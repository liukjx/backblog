<!DOCTYPE html><html lang="zh-CN" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="《Java8实战》读书笔记" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="第一部分 基础知识 第1章　为什么要关心Java 8　　 1.1　Java怎么还在变　　 1.1.1　Java在编程语言生态系统中的位置　　 1.1.2　流处理　　 1.1.3　用行为参数化把代码传递给方法　　 1.1.4　并行与共享的可变数据　　 1.1.5　Java需要演变　　 1.2　Java中的函数　　 1.2.1　方法和Lambda作为一等公民　　 1.2.2　传递代码：一个例子　　 1.2.3　从传递方法到Lambda　　 1.3　流　　 1.4　默认方法　　 1.5　来自函数式编程的其他好思想　　 1.6　小结　　 第2章　通过行为参数化传递代码　　 2.1　应对不断变化的需求　　 2.1.1　初试牛刀：筛选绿苹果　　 2.1.2　再展身手：把颜色作为参数　　 2.1.3　第三次尝试：对你能想到的每个属性做筛选　　 2.2　行为参数化　　 2.3　对付啰嗦　　 2.3.1　匿名类　　 2.3.2　第五次尝试：使用匿名类　　 2.3.3　第六次尝试：使用Lambda表达式　　 2.3.4　第七次尝试：将List类型抽象化　　 2.4　真实的例子　　 2.4.1　用Comparator来排序　　 2.4.2　用Runnable执行代码块　　 2.4.3　GUI事件处理　　 2.5　小结　　 第3章　Lambda表达式　　 3.1　Lambda管中窥豹　　 3.2　在哪里以及如何使用Lambda　　 3.2.1　函数式接口　　 3.2.2　函数描述符　　 3.3　把Lambda付诸实践：环绕执行模式　　 3.3.1　第1步记得行为参数化　　 3.3.2　第2步：使用函数式接口来传递行为　　 3.3.3　第3步：执行一个行为　　 3.3.4　第4步：传递Lambda　　 3.4　使用函数式接口　　 3.4.1　Predicate　　 3.4.2　Consumer　　 3.4.3　Function　　 3.5　类型检查、类型推断以及限制　　 3.5.1　类型检查　　 3.5.2　同样的Lambda，不同的函数式接口　　 3.5.3　类型推断　　 3.5.4　使用局部变量　　 3.6　方法引用　　 3.6.1　管中窥豹　　 3.6.2　构造函数引用　　 3.7　Lambda和方法引用实战　　 3.7.1　第1步：传递代码　　 3.7.2　第2步：使用匿名类　　 3.7.3　第3步：使用Lambda表达式　　 3.7.4　第4步：使用方法引用　　 3.8　复合Lambda表达式的有用方法　　 3.8.1　比较器复合　　 3.8.2　谓词复合　　 3.8.3　函数复合　　 3.9　数学中的类似思想　　 3.9.1　积分　　 3.9.2　与Java 8的Lambda联系起来　　 3.10　小结　　 第二部分 函数式数据处理 第4章　引入流　　 4.1　流是什么　　 4.2　流简介　　 4.3　流与集合　　 4.3.1　只能遍历一次　　 4.3.2　外部迭代与内部迭代　　 4.4　流操作　　 4.4.1　中间操作　　 4.4.2　终端操作　　 4.4.3　使用流　　 4.5　小结　　 第5章　使用流　　 5.1　筛选和切片　　 5.1.1　用谓词筛选　　 5.1.2　筛选各异的元素　　 5.1.3　截短流　　 5.1.4　跳过元素　　 5.2　映射　　 5.2.1　对流中每一个元素应用函数　　 5.2.2　流的扁平化　　 5.3　查找和匹配　　 5.3.1　检查谓词是否至少匹配一个元素　　 5.3.2　检查谓词是否匹配所有元素　　 5.3.3　查找元素　　 5.3.4　查找第一个元素　　 5.4　归约　　 5.4.1　元素求和　　 5.4.2　最大值和最小值　　 5.5　付诸实践　　 5.5.1　领域：交易员和交易　　 5.5.2　解答　　 5.6　数值流　　 5.6.1　原始类型流特化　　 5.6.2　数值范围　　 5.6.3　数值流应用：勾股数　　 5.7　构建流　　 5.7.1　由值创建流　　 5.7.2　由数组创建流　　 5.7.3　由文件生成流　　 5.7.4　由函数生成流：创建无限流　　 5.8　小结　　 第6章　用流收集数据　　 6.1　收集器简介　　 6.1.1　收集器用作高级归约　　 6.1.2　预定义收集器　　 6.2　归约和汇总　　 6.2.1　查找流中的最大值和最小值　　 6.2.2　汇总　　 6.2.3　连接字符串　　 6.2.4　广义的归约汇总　　 6.3　分组　　 6.3.1　多级分组　　 6.3.2　按子组收集数据　　 6.4　分区　　 6.4.1　分区的优势　　 6.4.2　将数字按质数和非质数分区　　 6.5　收集器接口　　 6.5.1　理解Collector接口声明的方法　　 6.5.2　全部融合到一起　　 6.6　开发你自己的收集器以获得更好的性能　　 6.6.1　仅用质数做除数　　 6.6.2　比较收集器的性能　　 6.7　小结　　 第7章　并行数据处理与性能　　 7.1　并行流　　 7.1.1　将顺序流转换为并行流　　 7.1.2　测量流性能　　 7.1.3　正确使用并行流　　 7.1.4　高效使用并行流　　 7.2　分支/合并框架　　 7.2.1　使用RecursiveTask　　 7.2.2　使用分支/合并框架的最佳做法　　 7.2.3　工作窃取　　 7.3　Spliterator　　 7.3.1　拆分过程　　 7.3.2　实现你自己的Spliterator　　 7.4　小结　　 第三部分 高效Java 8编程 第8章　重构、测试和调试　　 8.1　为改善可读性和灵活性重构代码　　 8.1.1　改善代码的可读性　　 8.1.2　从匿名类到Lambda表达式的转换　　 8.1.3　从Lambda表达式到方法引用的转换　　 8.1.4　从命令式的数据处理切换到Stream　　 8.1.5　增加代码的灵活性　　 8.2　使用Lambda重构面向对象的设计模式　　 8.2.1　策略模式　　 8.2.2　模板方法　　 8.2.3　观察者模式　　 8.2.4　责任链模式　　 8.2.5　工厂模式　　 8.3　测试Lambda表达式　　 8.3.1　测试可见Lambda函数的行为　　 8.3.2　测试使用Lambda的方法的行为　　 8.3.3　将复杂的Lambda表达式分到不同的方法　　 8.3.4　高阶函数的测试　　 8.4　调试　　 8.4.1　查看栈跟踪　　 8.4.2　使用日志调试　　 8.5　小结　　 第9章　默认方法　　 9.1　不断演进的API　　 9.1.1　初始版本的API　　 9.1.2　第二版API　　 9.2　概述默认方法　　 9.3　默认方法的使用模式　　 9.3.1　可选方法　　 9.3.2　行为的多继承　　 9.4　解决冲突的规则　　 9.4.1　解决问题的三条规则　　 9.4.2　选择提供了最具体实现的默认方法的接口　　 9.4.3　冲突及如何显式地消除歧义　　 9.4.4　菱形继承问题　　 9.5　小结　　 第10章　用Optional取代null　　 10.1　如何为缺失的值建模　　 10.1.1　采用防御式检查减少Null-PointerException　　 10.1.2　null带来的种种问题　　 10.1.3　其他语言中null的替代品　　 10.2　Optional类入门　　 10.3　应用Optional的几种模式　　 10.3.1　创建Optional对象　　 10.3.2　使用map从Optional对象中提取和转换值　　 10.3.3　使用flatMap链接Optional对象　　 10.3.4　默认行为及解引用Optional对象　　 10.3.5　两个Optional对象的组合　　 10.3.6　使用filter剔除特定的值　　 10.4　使用Optional的实战示例　　 10.4.1　用Optional封装可能为null的值　　 10.4.2　异常与Optional的对比　　 10.4.3　把所有内容整合起来　　 10.5　小结　　 第11章　CompletableFuture：组合式异步编程　　 11.1　Future接口　　 11.1.1　Future接口的局限性　　 11.1.2　使用CompletableFuture构建异步应用　　 11.2　实现异步API　　 11.2.1　将同步方法转换为异步方法　　 11.2.2　错误处理　　 11.3　让你的代码免受阻塞之苦　　 11.3.1　使用并行流对请求进行并行操作　　 11.3.2　使用CompletableFuture发起异步请求　　 11.3.3　寻找更好的方案　　 11.3.4　使用定制的执行器　　 11.4　对多个异步任务进行流水线操作　　 11.4.1　实现折扣服务　　 11.4.2　使用Discount服务　　 11.4.3　构造同步和异步操作　　 11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　 11.4.5　对Future和Completable-Future的回顾　　 11.5　响应CompletableFuture的completion事件　　 11.5.1　对最佳价格查询器应用的优化　　 11.5.2　付诸实践　　 11.6　小结　　 第12章　新的日期和时间API　　 12.1　LocalDate、LocalTime、Instant、Duration以及Period　　 12.1.1　使用LocalDate和LocalTime　　 12.1.2　合并日期和时间　　 12.1.3　机器的日期和时间格式　　 12.1.4　定义Duration或Period　　 12.2　操纵、解析和格式化日期　　 12.2.1　使用TemporalAdjuster　　 12.2.2　打印输出及解析日期－时间对象　　 12.3　处理不同的时区和历法　　 12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　 12.3.2　使用别的日历系统　　 12.4　小结　　 第四部分 超越Java 第13章　函数式的思考　　 13.1　实现和维护系统　　 13.1.1　共享的可变数据　　 13.1.2　声明式编程　　 13.1.3　为什么要采用函数式编程　　 13.2　什么是函数式编程　　 13.2.1　函数式Java编程　　 13.2.2　引用透明性　　 13.2.3　面向对象的编程和函数式编程的对比　　 13.2.4　函数式编程实战　　 13.3　递归和迭代　　 13.4　小结　　 第14章　函数式编程的技巧　　 14.1　无处不在的函数　　 14.1.1　高阶函数　　 14.1.2　科里化　　 14.2　持久化数据结构　　 14.2.1　破坏式更新和函数式更新的比较　　 14.2.2　另一个使用Tree的例子　　 14.2.3　采用函数式的方法　　 14.3　Stream的延迟计算　　 14.3.1　自定义的Stream　　 14.3.2　创建你自己的延迟列表　　 14.4　模式匹配　　 14.4.1　访问者设计模式　　 14.4.2　用模式匹配力挽狂澜　　 14.5　杂项　　 14.5.1　缓存或记忆表　　 14.5.2　“返回同样的对象”意味着什么　　 14.5.3　结合器　　 14.6　小结　　 第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　 15.1　Scala简介　　 15.1.1　你好，啤酒　　 15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　 15.2　函数　　 15.2.1　Scala中的一等函数　　 15.2.2　匿名函数和闭包　　 15.2.3　科里化　　 15.3　类和trait　　 15.3.1　更加简洁的Scala类　　 15.3.2　Scala的trait与Java 8的接口对比　　 15.4　小结　　 第16章　结论以及Java的未来　　 16.1　回顾Java 8的语言特性　　 16.1.1　行为参数化（Lambda 以及方法引用）　　 16.1.2　流　　 16.1.3　CompletableFuture　　 16.1.4　Optional　　 16.1.5　默认方法　　 16.2　Java 的未来　　 16.2.1　集合　　 16.2.2　类型系统的改进　　 16.2.3　模式匹配　　 16.2.4　更加丰富的泛型形式　　 16.2.5　对不变性的更深层支持　　 16.2.6　值类型　　 16.3　写在最后的话　　 附录A　其他语言特性的更新　　 附录B　类库的更新　　 附录C　如何以并发方式在同一个流上执行多种操作　　 附录D　Lambda表达式和JVM 字节码　　" /><meta property="og:description" content="第一部分 基础知识 第1章　为什么要关心Java 8　　 1.1　Java怎么还在变　　 1.1.1　Java在编程语言生态系统中的位置　　 1.1.2　流处理　　 1.1.3　用行为参数化把代码传递给方法　　 1.1.4　并行与共享的可变数据　　 1.1.5　Java需要演变　　 1.2　Java中的函数　　 1.2.1　方法和Lambda作为一等公民　　 1.2.2　传递代码：一个例子　　 1.2.3　从传递方法到Lambda　　 1.3　流　　 1.4　默认方法　　 1.5　来自函数式编程的其他好思想　　 1.6　小结　　 第2章　通过行为参数化传递代码　　 2.1　应对不断变化的需求　　 2.1.1　初试牛刀：筛选绿苹果　　 2.1.2　再展身手：把颜色作为参数　　 2.1.3　第三次尝试：对你能想到的每个属性做筛选　　 2.2　行为参数化　　 2.3　对付啰嗦　　 2.3.1　匿名类　　 2.3.2　第五次尝试：使用匿名类　　 2.3.3　第六次尝试：使用Lambda表达式　　 2.3.4　第七次尝试：将List类型抽象化　　 2.4　真实的例子　　 2.4.1　用Comparator来排序　　 2.4.2　用Runnable执行代码块　　 2.4.3　GUI事件处理　　 2.5　小结　　 第3章　Lambda表达式　　 3.1　Lambda管中窥豹　　 3.2　在哪里以及如何使用Lambda　　 3.2.1　函数式接口　　 3.2.2　函数描述符　　 3.3　把Lambda付诸实践：环绕执行模式　　 3.3.1　第1步记得行为参数化　　 3.3.2　第2步：使用函数式接口来传递行为　　 3.3.3　第3步：执行一个行为　　 3.3.4　第4步：传递Lambda　　 3.4　使用函数式接口　　 3.4.1　Predicate　　 3.4.2　Consumer　　 3.4.3　Function　　 3.5　类型检查、类型推断以及限制　　 3.5.1　类型检查　　 3.5.2　同样的Lambda，不同的函数式接口　　 3.5.3　类型推断　　 3.5.4　使用局部变量　　 3.6　方法引用　　 3.6.1　管中窥豹　　 3.6.2　构造函数引用　　 3.7　Lambda和方法引用实战　　 3.7.1　第1步：传递代码　　 3.7.2　第2步：使用匿名类　　 3.7.3　第3步：使用Lambda表达式　　 3.7.4　第4步：使用方法引用　　 3.8　复合Lambda表达式的有用方法　　 3.8.1　比较器复合　　 3.8.2　谓词复合　　 3.8.3　函数复合　　 3.9　数学中的类似思想　　 3.9.1　积分　　 3.9.2　与Java 8的Lambda联系起来　　 3.10　小结　　 第二部分 函数式数据处理 第4章　引入流　　 4.1　流是什么　　 4.2　流简介　　 4.3　流与集合　　 4.3.1　只能遍历一次　　 4.3.2　外部迭代与内部迭代　　 4.4　流操作　　 4.4.1　中间操作　　 4.4.2　终端操作　　 4.4.3　使用流　　 4.5　小结　　 第5章　使用流　　 5.1　筛选和切片　　 5.1.1　用谓词筛选　　 5.1.2　筛选各异的元素　　 5.1.3　截短流　　 5.1.4　跳过元素　　 5.2　映射　　 5.2.1　对流中每一个元素应用函数　　 5.2.2　流的扁平化　　 5.3　查找和匹配　　 5.3.1　检查谓词是否至少匹配一个元素　　 5.3.2　检查谓词是否匹配所有元素　　 5.3.3　查找元素　　 5.3.4　查找第一个元素　　 5.4　归约　　 5.4.1　元素求和　　 5.4.2　最大值和最小值　　 5.5　付诸实践　　 5.5.1　领域：交易员和交易　　 5.5.2　解答　　 5.6　数值流　　 5.6.1　原始类型流特化　　 5.6.2　数值范围　　 5.6.3　数值流应用：勾股数　　 5.7　构建流　　 5.7.1　由值创建流　　 5.7.2　由数组创建流　　 5.7.3　由文件生成流　　 5.7.4　由函数生成流：创建无限流　　 5.8　小结　　 第6章　用流收集数据　　 6.1　收集器简介　　 6.1.1　收集器用作高级归约　　 6.1.2　预定义收集器　　 6.2　归约和汇总　　 6.2.1　查找流中的最大值和最小值　　 6.2.2　汇总　　 6.2.3　连接字符串　　 6.2.4　广义的归约汇总　　 6.3　分组　　 6.3.1　多级分组　　 6.3.2　按子组收集数据　　 6.4　分区　　 6.4.1　分区的优势　　 6.4.2　将数字按质数和非质数分区　　 6.5　收集器接口　　 6.5.1　理解Collector接口声明的方法　　 6.5.2　全部融合到一起　　 6.6　开发你自己的收集器以获得更好的性能　　 6.6.1　仅用质数做除数　　 6.6.2　比较收集器的性能　　 6.7　小结　　 第7章　并行数据处理与性能　　 7.1　并行流　　 7.1.1　将顺序流转换为并行流　　 7.1.2　测量流性能　　 7.1.3　正确使用并行流　　 7.1.4　高效使用并行流　　 7.2　分支/合并框架　　 7.2.1　使用RecursiveTask　　 7.2.2　使用分支/合并框架的最佳做法　　 7.2.3　工作窃取　　 7.3　Spliterator　　 7.3.1　拆分过程　　 7.3.2　实现你自己的Spliterator　　 7.4　小结　　 第三部分 高效Java 8编程 第8章　重构、测试和调试　　 8.1　为改善可读性和灵活性重构代码　　 8.1.1　改善代码的可读性　　 8.1.2　从匿名类到Lambda表达式的转换　　 8.1.3　从Lambda表达式到方法引用的转换　　 8.1.4　从命令式的数据处理切换到Stream　　 8.1.5　增加代码的灵活性　　 8.2　使用Lambda重构面向对象的设计模式　　 8.2.1　策略模式　　 8.2.2　模板方法　　 8.2.3　观察者模式　　 8.2.4　责任链模式　　 8.2.5　工厂模式　　 8.3　测试Lambda表达式　　 8.3.1　测试可见Lambda函数的行为　　 8.3.2　测试使用Lambda的方法的行为　　 8.3.3　将复杂的Lambda表达式分到不同的方法　　 8.3.4　高阶函数的测试　　 8.4　调试　　 8.4.1　查看栈跟踪　　 8.4.2　使用日志调试　　 8.5　小结　　 第9章　默认方法　　 9.1　不断演进的API　　 9.1.1　初始版本的API　　 9.1.2　第二版API　　 9.2　概述默认方法　　 9.3　默认方法的使用模式　　 9.3.1　可选方法　　 9.3.2　行为的多继承　　 9.4　解决冲突的规则　　 9.4.1　解决问题的三条规则　　 9.4.2　选择提供了最具体实现的默认方法的接口　　 9.4.3　冲突及如何显式地消除歧义　　 9.4.4　菱形继承问题　　 9.5　小结　　 第10章　用Optional取代null　　 10.1　如何为缺失的值建模　　 10.1.1　采用防御式检查减少Null-PointerException　　 10.1.2　null带来的种种问题　　 10.1.3　其他语言中null的替代品　　 10.2　Optional类入门　　 10.3　应用Optional的几种模式　　 10.3.1　创建Optional对象　　 10.3.2　使用map从Optional对象中提取和转换值　　 10.3.3　使用flatMap链接Optional对象　　 10.3.4　默认行为及解引用Optional对象　　 10.3.5　两个Optional对象的组合　　 10.3.6　使用filter剔除特定的值　　 10.4　使用Optional的实战示例　　 10.4.1　用Optional封装可能为null的值　　 10.4.2　异常与Optional的对比　　 10.4.3　把所有内容整合起来　　 10.5　小结　　 第11章　CompletableFuture：组合式异步编程　　 11.1　Future接口　　 11.1.1　Future接口的局限性　　 11.1.2　使用CompletableFuture构建异步应用　　 11.2　实现异步API　　 11.2.1　将同步方法转换为异步方法　　 11.2.2　错误处理　　 11.3　让你的代码免受阻塞之苦　　 11.3.1　使用并行流对请求进行并行操作　　 11.3.2　使用CompletableFuture发起异步请求　　 11.3.3　寻找更好的方案　　 11.3.4　使用定制的执行器　　 11.4　对多个异步任务进行流水线操作　　 11.4.1　实现折扣服务　　 11.4.2　使用Discount服务　　 11.4.3　构造同步和异步操作　　 11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　 11.4.5　对Future和Completable-Future的回顾　　 11.5　响应CompletableFuture的completion事件　　 11.5.1　对最佳价格查询器应用的优化　　 11.5.2　付诸实践　　 11.6　小结　　 第12章　新的日期和时间API　　 12.1　LocalDate、LocalTime、Instant、Duration以及Period　　 12.1.1　使用LocalDate和LocalTime　　 12.1.2　合并日期和时间　　 12.1.3　机器的日期和时间格式　　 12.1.4　定义Duration或Period　　 12.2　操纵、解析和格式化日期　　 12.2.1　使用TemporalAdjuster　　 12.2.2　打印输出及解析日期－时间对象　　 12.3　处理不同的时区和历法　　 12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　 12.3.2　使用别的日历系统　　 12.4　小结　　 第四部分 超越Java 第13章　函数式的思考　　 13.1　实现和维护系统　　 13.1.1　共享的可变数据　　 13.1.2　声明式编程　　 13.1.3　为什么要采用函数式编程　　 13.2　什么是函数式编程　　 13.2.1　函数式Java编程　　 13.2.2　引用透明性　　 13.2.3　面向对象的编程和函数式编程的对比　　 13.2.4　函数式编程实战　　 13.3　递归和迭代　　 13.4　小结　　 第14章　函数式编程的技巧　　 14.1　无处不在的函数　　 14.1.1　高阶函数　　 14.1.2　科里化　　 14.2　持久化数据结构　　 14.2.1　破坏式更新和函数式更新的比较　　 14.2.2　另一个使用Tree的例子　　 14.2.3　采用函数式的方法　　 14.3　Stream的延迟计算　　 14.3.1　自定义的Stream　　 14.3.2　创建你自己的延迟列表　　 14.4　模式匹配　　 14.4.1　访问者设计模式　　 14.4.2　用模式匹配力挽狂澜　　 14.5　杂项　　 14.5.1　缓存或记忆表　　 14.5.2　“返回同样的对象”意味着什么　　 14.5.3　结合器　　 14.6　小结　　 第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　 15.1　Scala简介　　 15.1.1　你好，啤酒　　 15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　 15.2　函数　　 15.2.1　Scala中的一等函数　　 15.2.2　匿名函数和闭包　　 15.2.3　科里化　　 15.3　类和trait　　 15.3.1　更加简洁的Scala类　　 15.3.2　Scala的trait与Java 8的接口对比　　 15.4　小结　　 第16章　结论以及Java的未来　　 16.1　回顾Java 8的语言特性　　 16.1.1　行为参数化（Lambda 以及方法引用）　　 16.1.2　流　　 16.1.3　CompletableFuture　　 16.1.4　Optional　　 16.1.5　默认方法　　 16.2　Java 的未来　　 16.2.1　集合　　 16.2.2　类型系统的改进　　 16.2.3　模式匹配　　 16.2.4　更加丰富的泛型形式　　 16.2.5　对不变性的更深层支持　　 16.2.6　值类型　　 16.3　写在最后的话　　 附录A　其他语言特性的更新　　 附录B　类库的更新　　 附录C　如何以并发方式在同一个流上执行多种操作　　 附录D　Lambda表达式和JVM 字节码　　" /><link rel="canonical" href="https://liukjx.github.io/posts/java8%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" /><meta property="og:url" content="https://liukjx.github.io/posts/java8%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" /><meta property="og:site_name" content="栗少" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-31T19:13:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="《Java8实战》读书笔记" /><meta name="twitter:site" content="@liukjx" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-31T19:13:00+08:00","datePublished":"2022-08-31T19:13:00+08:00","description":"第一部分 基础知识 第1章　为什么要关心Java 8　　 1.1　Java怎么还在变　　 1.1.1　Java在编程语言生态系统中的位置　　 1.1.2　流处理　　 1.1.3　用行为参数化把代码传递给方法　　 1.1.4　并行与共享的可变数据　　 1.1.5　Java需要演变　　 1.2　Java中的函数　　 1.2.1　方法和Lambda作为一等公民　　 1.2.2　传递代码：一个例子　　 1.2.3　从传递方法到Lambda　　 1.3　流　　 1.4　默认方法　　 1.5　来自函数式编程的其他好思想　　 1.6　小结　　 第2章　通过行为参数化传递代码　　 2.1　应对不断变化的需求　　 2.1.1　初试牛刀：筛选绿苹果　　 2.1.2　再展身手：把颜色作为参数　　 2.1.3　第三次尝试：对你能想到的每个属性做筛选　　 2.2　行为参数化　　 2.3　对付啰嗦　　 2.3.1　匿名类　　 2.3.2　第五次尝试：使用匿名类　　 2.3.3　第六次尝试：使用Lambda表达式　　 2.3.4　第七次尝试：将List类型抽象化　　 2.4　真实的例子　　 2.4.1　用Comparator来排序　　 2.4.2　用Runnable执行代码块　　 2.4.3　GUI事件处理　　 2.5　小结　　 第3章　Lambda表达式　　 3.1　Lambda管中窥豹　　 3.2　在哪里以及如何使用Lambda　　 3.2.1　函数式接口　　 3.2.2　函数描述符　　 3.3　把Lambda付诸实践：环绕执行模式　　 3.3.1　第1步记得行为参数化　　 3.3.2　第2步：使用函数式接口来传递行为　　 3.3.3　第3步：执行一个行为　　 3.3.4　第4步：传递Lambda　　 3.4　使用函数式接口　　 3.4.1　Predicate　　 3.4.2　Consumer　　 3.4.3　Function　　 3.5　类型检查、类型推断以及限制　　 3.5.1　类型检查　　 3.5.2　同样的Lambda，不同的函数式接口　　 3.5.3　类型推断　　 3.5.4　使用局部变量　　 3.6　方法引用　　 3.6.1　管中窥豹　　 3.6.2　构造函数引用　　 3.7　Lambda和方法引用实战　　 3.7.1　第1步：传递代码　　 3.7.2　第2步：使用匿名类　　 3.7.3　第3步：使用Lambda表达式　　 3.7.4　第4步：使用方法引用　　 3.8　复合Lambda表达式的有用方法　　 3.8.1　比较器复合　　 3.8.2　谓词复合　　 3.8.3　函数复合　　 3.9　数学中的类似思想　　 3.9.1　积分　　 3.9.2　与Java 8的Lambda联系起来　　 3.10　小结　　 第二部分 函数式数据处理 第4章　引入流　　 4.1　流是什么　　 4.2　流简介　　 4.3　流与集合　　 4.3.1　只能遍历一次　　 4.3.2　外部迭代与内部迭代　　 4.4　流操作　　 4.4.1　中间操作　　 4.4.2　终端操作　　 4.4.3　使用流　　 4.5　小结　　 第5章　使用流　　 5.1　筛选和切片　　 5.1.1　用谓词筛选　　 5.1.2　筛选各异的元素　　 5.1.3　截短流　　 5.1.4　跳过元素　　 5.2　映射　　 5.2.1　对流中每一个元素应用函数　　 5.2.2　流的扁平化　　 5.3　查找和匹配　　 5.3.1　检查谓词是否至少匹配一个元素　　 5.3.2　检查谓词是否匹配所有元素　　 5.3.3　查找元素　　 5.3.4　查找第一个元素　　 5.4　归约　　 5.4.1　元素求和　　 5.4.2　最大值和最小值　　 5.5　付诸实践　　 5.5.1　领域：交易员和交易　　 5.5.2　解答　　 5.6　数值流　　 5.6.1　原始类型流特化　　 5.6.2　数值范围　　 5.6.3　数值流应用：勾股数　　 5.7　构建流　　 5.7.1　由值创建流　　 5.7.2　由数组创建流　　 5.7.3　由文件生成流　　 5.7.4　由函数生成流：创建无限流　　 5.8　小结　　 第6章　用流收集数据　　 6.1　收集器简介　　 6.1.1　收集器用作高级归约　　 6.1.2　预定义收集器　　 6.2　归约和汇总　　 6.2.1　查找流中的最大值和最小值　　 6.2.2　汇总　　 6.2.3　连接字符串　　 6.2.4　广义的归约汇总　　 6.3　分组　　 6.3.1　多级分组　　 6.3.2　按子组收集数据　　 6.4　分区　　 6.4.1　分区的优势　　 6.4.2　将数字按质数和非质数分区　　 6.5　收集器接口　　 6.5.1　理解Collector接口声明的方法　　 6.5.2　全部融合到一起　　 6.6　开发你自己的收集器以获得更好的性能　　 6.6.1　仅用质数做除数　　 6.6.2　比较收集器的性能　　 6.7　小结　　 第7章　并行数据处理与性能　　 7.1　并行流　　 7.1.1　将顺序流转换为并行流　　 7.1.2　测量流性能　　 7.1.3　正确使用并行流　　 7.1.4　高效使用并行流　　 7.2　分支/合并框架　　 7.2.1　使用RecursiveTask　　 7.2.2　使用分支/合并框架的最佳做法　　 7.2.3　工作窃取　　 7.3　Spliterator　　 7.3.1　拆分过程　　 7.3.2　实现你自己的Spliterator　　 7.4　小结　　 第三部分 高效Java 8编程 第8章　重构、测试和调试　　 8.1　为改善可读性和灵活性重构代码　　 8.1.1　改善代码的可读性　　 8.1.2　从匿名类到Lambda表达式的转换　　 8.1.3　从Lambda表达式到方法引用的转换　　 8.1.4　从命令式的数据处理切换到Stream　　 8.1.5　增加代码的灵活性　　 8.2　使用Lambda重构面向对象的设计模式　　 8.2.1　策略模式　　 8.2.2　模板方法　　 8.2.3　观察者模式　　 8.2.4　责任链模式　　 8.2.5　工厂模式　　 8.3　测试Lambda表达式　　 8.3.1　测试可见Lambda函数的行为　　 8.3.2　测试使用Lambda的方法的行为　　 8.3.3　将复杂的Lambda表达式分到不同的方法　　 8.3.4　高阶函数的测试　　 8.4　调试　　 8.4.1　查看栈跟踪　　 8.4.2　使用日志调试　　 8.5　小结　　 第9章　默认方法　　 9.1　不断演进的API　　 9.1.1　初始版本的API　　 9.1.2　第二版API　　 9.2　概述默认方法　　 9.3　默认方法的使用模式　　 9.3.1　可选方法　　 9.3.2　行为的多继承　　 9.4　解决冲突的规则　　 9.4.1　解决问题的三条规则　　 9.4.2　选择提供了最具体实现的默认方法的接口　　 9.4.3　冲突及如何显式地消除歧义　　 9.4.4　菱形继承问题　　 9.5　小结　　 第10章　用Optional取代null　　 10.1　如何为缺失的值建模　　 10.1.1　采用防御式检查减少Null-PointerException　　 10.1.2　null带来的种种问题　　 10.1.3　其他语言中null的替代品　　 10.2　Optional类入门　　 10.3　应用Optional的几种模式　　 10.3.1　创建Optional对象　　 10.3.2　使用map从Optional对象中提取和转换值　　 10.3.3　使用flatMap链接Optional对象　　 10.3.4　默认行为及解引用Optional对象　　 10.3.5　两个Optional对象的组合　　 10.3.6　使用filter剔除特定的值　　 10.4　使用Optional的实战示例　　 10.4.1　用Optional封装可能为null的值　　 10.4.2　异常与Optional的对比　　 10.4.3　把所有内容整合起来　　 10.5　小结　　 第11章　CompletableFuture：组合式异步编程　　 11.1　Future接口　　 11.1.1　Future接口的局限性　　 11.1.2　使用CompletableFuture构建异步应用　　 11.2　实现异步API　　 11.2.1　将同步方法转换为异步方法　　 11.2.2　错误处理　　 11.3　让你的代码免受阻塞之苦　　 11.3.1　使用并行流对请求进行并行操作　　 11.3.2　使用CompletableFuture发起异步请求　　 11.3.3　寻找更好的方案　　 11.3.4　使用定制的执行器　　 11.4　对多个异步任务进行流水线操作　　 11.4.1　实现折扣服务　　 11.4.2　使用Discount服务　　 11.4.3　构造同步和异步操作　　 11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　 11.4.5　对Future和Completable-Future的回顾　　 11.5　响应CompletableFuture的completion事件　　 11.5.1　对最佳价格查询器应用的优化　　 11.5.2　付诸实践　　 11.6　小结　　 第12章　新的日期和时间API　　 12.1　LocalDate、LocalTime、Instant、Duration以及Period　　 12.1.1　使用LocalDate和LocalTime　　 12.1.2　合并日期和时间　　 12.1.3　机器的日期和时间格式　　 12.1.4　定义Duration或Period　　 12.2　操纵、解析和格式化日期　　 12.2.1　使用TemporalAdjuster　　 12.2.2　打印输出及解析日期－时间对象　　 12.3　处理不同的时区和历法　　 12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　 12.3.2　使用别的日历系统　　 12.4　小结　　 第四部分 超越Java 第13章　函数式的思考　　 13.1　实现和维护系统　　 13.1.1　共享的可变数据　　 13.1.2　声明式编程　　 13.1.3　为什么要采用函数式编程　　 13.2　什么是函数式编程　　 13.2.1　函数式Java编程　　 13.2.2　引用透明性　　 13.2.3　面向对象的编程和函数式编程的对比　　 13.2.4　函数式编程实战　　 13.3　递归和迭代　　 13.4　小结　　 第14章　函数式编程的技巧　　 14.1　无处不在的函数　　 14.1.1　高阶函数　　 14.1.2　科里化　　 14.2　持久化数据结构　　 14.2.1　破坏式更新和函数式更新的比较　　 14.2.2　另一个使用Tree的例子　　 14.2.3　采用函数式的方法　　 14.3　Stream的延迟计算　　 14.3.1　自定义的Stream　　 14.3.2　创建你自己的延迟列表　　 14.4　模式匹配　　 14.4.1　访问者设计模式　　 14.4.2　用模式匹配力挽狂澜　　 14.5　杂项　　 14.5.1　缓存或记忆表　　 14.5.2　“返回同样的对象”意味着什么　　 14.5.3　结合器　　 14.6　小结　　 第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　 15.1　Scala简介　　 15.1.1　你好，啤酒　　 15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　 15.2　函数　　 15.2.1　Scala中的一等函数　　 15.2.2　匿名函数和闭包　　 15.2.3　科里化　　 15.3　类和trait　　 15.3.1　更加简洁的Scala类　　 15.3.2　Scala的trait与Java 8的接口对比　　 15.4　小结　　 第16章　结论以及Java的未来　　 16.1　回顾Java 8的语言特性　　 16.1.1　行为参数化（Lambda 以及方法引用）　　 16.1.2　流　　 16.1.3　CompletableFuture　　 16.1.4　Optional　　 16.1.5　默认方法　　 16.2　Java 的未来　　 16.2.1　集合　　 16.2.2　类型系统的改进　　 16.2.3　模式匹配　　 16.2.4　更加丰富的泛型形式　　 16.2.5　对不变性的更深层支持　　 16.2.6　值类型　　 16.3　写在最后的话　　 附录A　其他语言特性的更新　　 附录B　类库的更新　　 附录C　如何以并发方式在同一个流上执行多种操作　　 附录D　Lambda表达式和JVM 字节码　　","headline":"《Java8实战》读书笔记","mainEntityOfPage":{"@type":"WebPage","@id":"https://liukjx.github.io/posts/java8%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},"url":"https://liukjx.github.io/posts/java8%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}</script><title>《Java8实战》读书笔记 | 栗少</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="栗少"><meta name="application-name" content="栗少"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/static/B.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">栗少</a></div><div class="site-subtitle font-italic">记录成长</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/liukjx" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/liukjx" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['liukjx','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>《Java8实战》读书笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>《Java8实战》读书笔记</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1661944380" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/08/31 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://twitter.com/liukjx">栗少</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2681 字"> <em>14 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="第一部分-基础知识"><span class="mr-2">第一部分 基础知识</span><a href="#第一部分-基础知识" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="第1章为什么要关心java-8"><span class="mr-2">第1章　为什么要关心Java 8　　</span><a href="#第1章为什么要关心java-8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="11java怎么还在变"><span class="mr-2">1.1　Java怎么还在变　　</span><a href="#11java怎么还在变" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="111java在编程语言生态系统中的位置"><span class="mr-2">1.1.1　Java在编程语言生态系统中的位置　　</span><a href="#111java在编程语言生态系统中的位置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="112流处理"><span class="mr-2">1.1.2　流处理　　</span><a href="#112流处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="113用行为参数化把代码传递给方法"><span class="mr-2">1.1.3　用行为参数化把代码传递给方法　　</span><a href="#113用行为参数化把代码传递给方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="114并行与共享的可变数据"><span class="mr-2">1.1.4　并行与共享的可变数据　　</span><a href="#114并行与共享的可变数据" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="115java需要演变"><span class="mr-2">1.1.5　Java需要演变　　</span><a href="#115java需要演变" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="12java中的函数"><span class="mr-2">1.2　Java中的函数　　</span><a href="#12java中的函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="121方法和lambda作为一等公民"><span class="mr-2">1.2.1　方法和Lambda作为一等公民　　</span><a href="#121方法和lambda作为一等公民" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="122传递代码一个例子"><span class="mr-2">1.2.2　传递代码：一个例子　　</span><a href="#122传递代码一个例子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="123从传递方法到lambda"><span class="mr-2">1.2.3　从传递方法到Lambda　　</span><a href="#123从传递方法到lambda" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="13流"><span class="mr-2">1.3　流　　</span><a href="#13流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="14默认方法"><span class="mr-2">1.4　默认方法　　</span><a href="#14默认方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="15来自函数式编程的其他好思想"><span class="mr-2">1.5　来自函数式编程的其他好思想　　</span><a href="#15来自函数式编程的其他好思想" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="16小结"><span class="mr-2">1.6　小结　　</span><a href="#16小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第2章通过行为参数化传递代码"><span class="mr-2">第2章　通过行为参数化传递代码　　</span><a href="#第2章通过行为参数化传递代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="21应对不断变化的需求"><span class="mr-2">2.1　应对不断变化的需求　　</span><a href="#21应对不断变化的需求" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="211初试牛刀筛选绿苹果"><span class="mr-2">2.1.1　初试牛刀：筛选绿苹果　　</span><a href="#211初试牛刀筛选绿苹果" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="212再展身手把颜色作为参数"><span class="mr-2">2.1.2　再展身手：把颜色作为参数　　</span><a href="#212再展身手把颜色作为参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="213第三次尝试对你能想到的每个属性做筛选"><span class="mr-2">2.1.3　第三次尝试：对你能想到的每个属性做筛选　　</span><a href="#213第三次尝试对你能想到的每个属性做筛选" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="22行为参数化"><span class="mr-2">2.2　行为参数化　　</span><a href="#22行为参数化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="23对付啰嗦"><span class="mr-2">2.3　对付啰嗦　　</span><a href="#23对付啰嗦" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="231匿名类"><span class="mr-2">2.3.1　匿名类　　</span><a href="#231匿名类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="232第五次尝试使用匿名类"><span class="mr-2">2.3.2　第五次尝试：使用匿名类　　</span><a href="#232第五次尝试使用匿名类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="233第六次尝试使用lambda表达式"><span class="mr-2">2.3.3　第六次尝试：使用Lambda表达式　　</span><a href="#233第六次尝试使用lambda表达式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="234第七次尝试将list类型抽象化"><span class="mr-2">2.3.4　第七次尝试：将List类型抽象化　　</span><a href="#234第七次尝试将list类型抽象化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="24真实的例子"><span class="mr-2">2.4　真实的例子　　</span><a href="#24真实的例子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="241用comparator来排序"><span class="mr-2">2.4.1　用Comparator来排序　　</span><a href="#241用comparator来排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="242用runnable执行代码块"><span class="mr-2">2.4.2　用Runnable执行代码块　　</span><a href="#242用runnable执行代码块" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="243gui事件处理"><span class="mr-2">2.4.3　GUI事件处理　　</span><a href="#243gui事件处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="25小结"><span class="mr-2">2.5　小结　　</span><a href="#25小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第3章lambda表达式"><span class="mr-2">第3章　Lambda表达式　　</span><a href="#第3章lambda表达式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="31lambda管中窥豹"><span class="mr-2">3.1　Lambda管中窥豹　　</span><a href="#31lambda管中窥豹" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="32在哪里以及如何使用lambda"><span class="mr-2">3.2　在哪里以及如何使用Lambda　　</span><a href="#32在哪里以及如何使用lambda" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="321函数式接口"><span class="mr-2">3.2.1　函数式接口　　</span><a href="#321函数式接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="322函数描述符"><span class="mr-2">3.2.2　函数描述符　　</span><a href="#322函数描述符" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="33把lambda付诸实践环绕执行模式"><span class="mr-2">3.3　把Lambda付诸实践：环绕执行模式　　</span><a href="#33把lambda付诸实践环绕执行模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="331第1步记得行为参数化"><span class="mr-2">3.3.1　第1步记得行为参数化　　</span><a href="#331第1步记得行为参数化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="332第2步使用函数式接口来传递行为"><span class="mr-2">3.3.2　第2步：使用函数式接口来传递行为　　</span><a href="#332第2步使用函数式接口来传递行为" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="333第3步执行一个行为"><span class="mr-2">3.3.3　第3步：执行一个行为　　</span><a href="#333第3步执行一个行为" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="334第4步传递lambda"><span class="mr-2">3.3.4　第4步：传递Lambda　　</span><a href="#334第4步传递lambda" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="34使用函数式接口"><span class="mr-2">3.4　使用函数式接口　　</span><a href="#34使用函数式接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="341predicate"><span class="mr-2">3.4.1　Predicate　　</span><a href="#341predicate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="342consumer"><span class="mr-2">3.4.2　Consumer　　</span><a href="#342consumer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="343function"><span class="mr-2">3.4.3　Function　　</span><a href="#343function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="35类型检查类型推断以及限制"><span class="mr-2">3.5　类型检查、类型推断以及限制　　</span><a href="#35类型检查类型推断以及限制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="351类型检查"><span class="mr-2">3.5.1　类型检查　　</span><a href="#351类型检查" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="352同样的lambda不同的函数式接口"><span class="mr-2">3.5.2　同样的Lambda，不同的函数式接口　　</span><a href="#352同样的lambda不同的函数式接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="353类型推断"><span class="mr-2">3.5.3　类型推断　　</span><a href="#353类型推断" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="354使用局部变量"><span class="mr-2">3.5.4　使用局部变量　　</span><a href="#354使用局部变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="36方法引用"><span class="mr-2">3.6　方法引用　　</span><a href="#36方法引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="361管中窥豹"><span class="mr-2">3.6.1　管中窥豹　　</span><a href="#361管中窥豹" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="362构造函数引用"><span class="mr-2">3.6.2　构造函数引用　　</span><a href="#362构造函数引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="37lambda和方法引用实战"><span class="mr-2">3.7　Lambda和方法引用实战　　</span><a href="#37lambda和方法引用实战" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="371第1步传递代码"><span class="mr-2">3.7.1　第1步：传递代码　　</span><a href="#371第1步传递代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="372第2步使用匿名类"><span class="mr-2">3.7.2　第2步：使用匿名类　　</span><a href="#372第2步使用匿名类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="373第3步使用lambda表达式"><span class="mr-2">3.7.3　第3步：使用Lambda表达式　　</span><a href="#373第3步使用lambda表达式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="374第4步使用方法引用"><span class="mr-2">3.7.4　第4步：使用方法引用　　</span><a href="#374第4步使用方法引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="38复合lambda表达式的有用方法"><span class="mr-2">3.8　复合Lambda表达式的有用方法　　</span><a href="#38复合lambda表达式的有用方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="381比较器复合"><span class="mr-2">3.8.1　比较器复合　　</span><a href="#381比较器复合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="382谓词复合"><span class="mr-2">3.8.2　谓词复合　　</span><a href="#382谓词复合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="383函数复合"><span class="mr-2">3.8.3　函数复合　　</span><a href="#383函数复合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="39数学中的类似思想"><span class="mr-2">3.9　数学中的类似思想　　</span><a href="#39数学中的类似思想" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="391积分"><span class="mr-2">3.9.1　积分　　</span><a href="#391积分" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="392与java-8的lambda联系起来"><span class="mr-2">3.9.2　与Java 8的Lambda联系起来　　</span><a href="#392与java-8的lambda联系起来" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="310小结"><span class="mr-2">3.10　小结　　</span><a href="#310小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h2 id="第二部分-函数式数据处理"><span class="mr-2">第二部分 函数式数据处理</span><a href="#第二部分-函数式数据处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="第4章引入流"><span class="mr-2">第4章　引入流　　</span><a href="#第4章引入流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="41流是什么"><span class="mr-2">4.1　流是什么　　</span><a href="#41流是什么" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="42流简介"><span class="mr-2">4.2　流简介　　</span><a href="#42流简介" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="43流与集合"><span class="mr-2">4.3　流与集合　　</span><a href="#43流与集合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="431只能遍历一次"><span class="mr-2">4.3.1　只能遍历一次　　</span><a href="#431只能遍历一次" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="432外部迭代与内部迭代"><span class="mr-2">4.3.2　外部迭代与内部迭代　　</span><a href="#432外部迭代与内部迭代" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="44流操作"><span class="mr-2">4.4　流操作　　</span><a href="#44流操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="441中间操作"><span class="mr-2">4.4.1　中间操作　　</span><a href="#441中间操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="442终端操作"><span class="mr-2">4.4.2　终端操作　　</span><a href="#442终端操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="443使用流"><span class="mr-2">4.4.3　使用流　　</span><a href="#443使用流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="45小结"><span class="mr-2">4.5　小结　　</span><a href="#45小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第5章使用流"><span class="mr-2">第5章　使用流　　</span><a href="#第5章使用流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="51筛选和切片"><span class="mr-2">5.1　筛选和切片　　</span><a href="#51筛选和切片" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="511用谓词筛选"><span class="mr-2">5.1.1　用谓词筛选　　</span><a href="#511用谓词筛选" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="512筛选各异的元素"><span class="mr-2">5.1.2　筛选各异的元素　　</span><a href="#512筛选各异的元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="513截短流"><span class="mr-2">5.1.3　截短流　　</span><a href="#513截短流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="514跳过元素"><span class="mr-2">5.1.4　跳过元素　　</span><a href="#514跳过元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="52映射"><span class="mr-2">5.2　映射　　</span><a href="#52映射" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="521对流中每一个元素应用函数"><span class="mr-2">5.2.1　对流中每一个元素应用函数　　</span><a href="#521对流中每一个元素应用函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="522流的扁平化"><span class="mr-2">5.2.2　流的扁平化　　</span><a href="#522流的扁平化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="53查找和匹配"><span class="mr-2">5.3　查找和匹配　　</span><a href="#53查找和匹配" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="531检查谓词是否至少匹配一个元素"><span class="mr-2">5.3.1　检查谓词是否至少匹配一个元素　　</span><a href="#531检查谓词是否至少匹配一个元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="532检查谓词是否匹配所有元素"><span class="mr-2">5.3.2　检查谓词是否匹配所有元素　　</span><a href="#532检查谓词是否匹配所有元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="533查找元素"><span class="mr-2">5.3.3　查找元素　　</span><a href="#533查找元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="534查找第一个元素"><span class="mr-2">5.3.4　查找第一个元素　　</span><a href="#534查找第一个元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="54归约"><span class="mr-2">5.4　归约　　</span><a href="#54归约" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="541元素求和"><span class="mr-2">5.4.1　元素求和　　</span><a href="#541元素求和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="542最大值和最小值"><span class="mr-2">5.4.2　最大值和最小值　　</span><a href="#542最大值和最小值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="55付诸实践"><span class="mr-2">5.5　付诸实践　　</span><a href="#55付诸实践" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="551领域交易员和交易"><span class="mr-2">5.5.1　领域：交易员和交易　　</span><a href="#551领域交易员和交易" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="552解答"><span class="mr-2">5.5.2　解答　　</span><a href="#552解答" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="56数值流"><span class="mr-2">5.6　数值流　　</span><a href="#56数值流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="561原始类型流特化"><span class="mr-2">5.6.1　原始类型流特化　　</span><a href="#561原始类型流特化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="562数值范围"><span class="mr-2">5.6.2　数值范围　　</span><a href="#562数值范围" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="563数值流应用勾股数"><span class="mr-2">5.6.3　数值流应用：勾股数　　</span><a href="#563数值流应用勾股数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="57构建流"><span class="mr-2">5.7　构建流　　</span><a href="#57构建流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="571由值创建流"><span class="mr-2">5.7.1　由值创建流　　</span><a href="#571由值创建流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="572由数组创建流"><span class="mr-2">5.7.2　由数组创建流　　</span><a href="#572由数组创建流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="573由文件生成流"><span class="mr-2">5.7.3　由文件生成流　　</span><a href="#573由文件生成流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="574由函数生成流创建无限流"><span class="mr-2">5.7.4　由函数生成流：创建无限流　　</span><a href="#574由函数生成流创建无限流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="58小结"><span class="mr-2">5.8　小结　　</span><a href="#58小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第6章用流收集数据"><span class="mr-2">第6章　用流收集数据　　</span><a href="#第6章用流收集数据" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="61收集器简介"><span class="mr-2">6.1　收集器简介　　</span><a href="#61收集器简介" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="611收集器用作高级归约"><span class="mr-2">6.1.1　收集器用作高级归约　　</span><a href="#611收集器用作高级归约" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="612预定义收集器"><span class="mr-2">6.1.2　预定义收集器　　</span><a href="#612预定义收集器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="62归约和汇总"><span class="mr-2">6.2　归约和汇总　　</span><a href="#62归约和汇总" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="621查找流中的最大值和最小值"><span class="mr-2">6.2.1　查找流中的最大值和最小值　　</span><a href="#621查找流中的最大值和最小值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="622汇总"><span class="mr-2">6.2.2　汇总　　</span><a href="#622汇总" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="623连接字符串"><span class="mr-2">6.2.3　连接字符串　　</span><a href="#623连接字符串" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="624广义的归约汇总"><span class="mr-2">6.2.4　广义的归约汇总　　</span><a href="#624广义的归约汇总" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="63分组"><span class="mr-2">6.3　分组　　</span><a href="#63分组" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="631多级分组"><span class="mr-2">6.3.1　多级分组　　</span><a href="#631多级分组" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="632按子组收集数据"><span class="mr-2">6.3.2　按子组收集数据　　</span><a href="#632按子组收集数据" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="64分区"><span class="mr-2">6.4　分区　　</span><a href="#64分区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="641分区的优势"><span class="mr-2">6.4.1　分区的优势　　</span><a href="#641分区的优势" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="642将数字按质数和非质数分区"><span class="mr-2">6.4.2　将数字按质数和非质数分区　　</span><a href="#642将数字按质数和非质数分区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="65收集器接口"><span class="mr-2">6.5　收集器接口　　</span><a href="#65收集器接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="651理解collector接口声明的方法"><span class="mr-2">6.5.1　理解Collector接口声明的方法　　</span><a href="#651理解collector接口声明的方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="652全部融合到一起"><span class="mr-2">6.5.2　全部融合到一起　　</span><a href="#652全部融合到一起" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="66开发你自己的收集器以获得更好的性能"><span class="mr-2">6.6　开发你自己的收集器以获得更好的性能　　</span><a href="#66开发你自己的收集器以获得更好的性能" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="661仅用质数做除数"><span class="mr-2">6.6.1　仅用质数做除数　　</span><a href="#661仅用质数做除数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="662比较收集器的性能"><span class="mr-2">6.6.2　比较收集器的性能　　</span><a href="#662比较收集器的性能" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="67小结"><span class="mr-2">6.7　小结　　</span><a href="#67小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第7章并行数据处理与性能"><span class="mr-2">第7章　并行数据处理与性能　　</span><a href="#第7章并行数据处理与性能" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="71并行流"><span class="mr-2">7.1　并行流　　</span><a href="#71并行流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="711将顺序流转换为并行流"><span class="mr-2">7.1.1　将顺序流转换为并行流　　</span><a href="#711将顺序流转换为并行流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="712测量流性能"><span class="mr-2">7.1.2　测量流性能　　</span><a href="#712测量流性能" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="713正确使用并行流"><span class="mr-2">7.1.3　正确使用并行流　　</span><a href="#713正确使用并行流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="714高效使用并行流"><span class="mr-2">7.1.4　高效使用并行流　　</span><a href="#714高效使用并行流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="72分支合并框架"><span class="mr-2">7.2　分支/合并框架　　</span><a href="#72分支合并框架" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="721使用recursivetask"><span class="mr-2">7.2.1　使用RecursiveTask　　</span><a href="#721使用recursivetask" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="722使用分支合并框架的最佳做法"><span class="mr-2">7.2.2　使用分支/合并框架的最佳做法　　</span><a href="#722使用分支合并框架的最佳做法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="723工作窃取"><span class="mr-2">7.2.3　工作窃取　　</span><a href="#723工作窃取" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="73spliterator"><span class="mr-2">7.3　Spliterator　　</span><a href="#73spliterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="731拆分过程"><span class="mr-2">7.3.1　拆分过程　　</span><a href="#731拆分过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="732实现你自己的spliterator"><span class="mr-2">7.3.2　实现你自己的Spliterator　　</span><a href="#732实现你自己的spliterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="74小结"><span class="mr-2">7.4　小结　　</span><a href="#74小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h2 id="第三部分-高效java-8编程"><span class="mr-2">第三部分 高效Java 8编程</span><a href="#第三部分-高效java-8编程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="第8章重构测试和调试"><span class="mr-2">第8章　重构、测试和调试　　</span><a href="#第8章重构测试和调试" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="81为改善可读性和灵活性重构代码"><span class="mr-2">8.1　为改善可读性和灵活性重构代码　　</span><a href="#81为改善可读性和灵活性重构代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="811改善代码的可读性"><span class="mr-2">8.1.1　改善代码的可读性　　</span><a href="#811改善代码的可读性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="812从匿名类到lambda表达式的转换"><span class="mr-2">8.1.2　从匿名类到Lambda表达式的转换　　</span><a href="#812从匿名类到lambda表达式的转换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="813从lambda表达式到方法引用的转换"><span class="mr-2">8.1.3　从Lambda表达式到方法引用的转换　　</span><a href="#813从lambda表达式到方法引用的转换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="814从命令式的数据处理切换到stream"><span class="mr-2">8.1.4　从命令式的数据处理切换到Stream　　</span><a href="#814从命令式的数据处理切换到stream" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="815增加代码的灵活性"><span class="mr-2">8.1.5　增加代码的灵活性　　</span><a href="#815增加代码的灵活性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="82使用lambda重构面向对象的设计模式"><span class="mr-2">8.2　使用Lambda重构面向对象的设计模式　　</span><a href="#82使用lambda重构面向对象的设计模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="821策略模式"><span class="mr-2">8.2.1　策略模式　　</span><a href="#821策略模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="822模板方法"><span class="mr-2">8.2.2　模板方法　　</span><a href="#822模板方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="823观察者模式"><span class="mr-2">8.2.3　观察者模式　　</span><a href="#823观察者模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="824责任链模式"><span class="mr-2">8.2.4　责任链模式　　</span><a href="#824责任链模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="825工厂模式"><span class="mr-2">8.2.5　工厂模式　　</span><a href="#825工厂模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="83测试lambda表达式"><span class="mr-2">8.3　测试Lambda表达式　　</span><a href="#83测试lambda表达式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="831测试可见lambda函数的行为"><span class="mr-2">8.3.1　测试可见Lambda函数的行为　　</span><a href="#831测试可见lambda函数的行为" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="832测试使用lambda的方法的行为"><span class="mr-2">8.3.2　测试使用Lambda的方法的行为　　</span><a href="#832测试使用lambda的方法的行为" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="833将复杂的lambda表达式分到不同的方法"><span class="mr-2">8.3.3　将复杂的Lambda表达式分到不同的方法　　</span><a href="#833将复杂的lambda表达式分到不同的方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="834高阶函数的测试"><span class="mr-2">8.3.4　高阶函数的测试　　</span><a href="#834高阶函数的测试" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="84调试"><span class="mr-2">8.4　调试　　</span><a href="#84调试" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="841查看栈跟踪"><span class="mr-2">8.4.1　查看栈跟踪　　</span><a href="#841查看栈跟踪" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="842使用日志调试"><span class="mr-2">8.4.2　使用日志调试　　</span><a href="#842使用日志调试" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="85小结"><span class="mr-2">8.5　小结　　</span><a href="#85小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第9章默认方法"><span class="mr-2">第9章　默认方法　　</span><a href="#第9章默认方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="91不断演进的api"><span class="mr-2">9.1　不断演进的API　　</span><a href="#91不断演进的api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="911初始版本的api"><span class="mr-2">9.1.1　初始版本的API　　</span><a href="#911初始版本的api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="912第二版api"><span class="mr-2">9.1.2　第二版API　　</span><a href="#912第二版api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="92概述默认方法"><span class="mr-2">9.2　概述默认方法　　</span><a href="#92概述默认方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="93默认方法的使用模式"><span class="mr-2">9.3　默认方法的使用模式　　</span><a href="#93默认方法的使用模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="931可选方法"><span class="mr-2">9.3.1　可选方法　　</span><a href="#931可选方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="932行为的多继承"><span class="mr-2">9.3.2　行为的多继承　　</span><a href="#932行为的多继承" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="94解决冲突的规则"><span class="mr-2">9.4　解决冲突的规则　　</span><a href="#94解决冲突的规则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="941解决问题的三条规则"><span class="mr-2">9.4.1　解决问题的三条规则　　</span><a href="#941解决问题的三条规则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="942选择提供了最具体实现的默认方法的接口"><span class="mr-2">9.4.2　选择提供了最具体实现的默认方法的接口　　</span><a href="#942选择提供了最具体实现的默认方法的接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="943冲突及如何显式地消除歧义"><span class="mr-2">9.4.3　冲突及如何显式地消除歧义　　</span><a href="#943冲突及如何显式地消除歧义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="944菱形继承问题"><span class="mr-2">9.4.4　菱形继承问题　　</span><a href="#944菱形继承问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="95小结"><span class="mr-2">9.5　小结　　</span><a href="#95小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第10章用optional取代null"><span class="mr-2">第10章　用Optional取代null　　</span><a href="#第10章用optional取代null" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="101如何为缺失的值建模"><span class="mr-2">10.1　如何为缺失的值建模　　</span><a href="#101如何为缺失的值建模" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1011采用防御式检查减少null-pointerexception"><span class="mr-2">10.1.1　采用防御式检查减少Null-PointerException　　</span><a href="#1011采用防御式检查减少null-pointerexception" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1012null带来的种种问题"><span class="mr-2">10.1.2　null带来的种种问题　　</span><a href="#1012null带来的种种问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1013其他语言中null的替代品"><span class="mr-2">10.1.3　其他语言中null的替代品　　</span><a href="#1013其他语言中null的替代品" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="102optional类入门"><span class="mr-2">10.2　Optional类入门　　</span><a href="#102optional类入门" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="103应用optional的几种模式"><span class="mr-2">10.3　应用Optional的几种模式　　</span><a href="#103应用optional的几种模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1031创建optional对象"><span class="mr-2">10.3.1　创建Optional对象　　</span><a href="#1031创建optional对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1032使用map从optional对象中提取和转换值"><span class="mr-2">10.3.2　使用map从Optional对象中提取和转换值　　</span><a href="#1032使用map从optional对象中提取和转换值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1033使用flatmap链接optional对象"><span class="mr-2">10.3.3　使用flatMap链接Optional对象　　</span><a href="#1033使用flatmap链接optional对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1034默认行为及解引用optional对象"><span class="mr-2">10.3.4　默认行为及解引用Optional对象　　</span><a href="#1034默认行为及解引用optional对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1035两个optional对象的组合"><span class="mr-2">10.3.5　两个Optional对象的组合　　</span><a href="#1035两个optional对象的组合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1036使用filter剔除特定的值"><span class="mr-2">10.3.6　使用filter剔除特定的值　　</span><a href="#1036使用filter剔除特定的值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="104使用optional的实战示例"><span class="mr-2">10.4　使用Optional的实战示例　　</span><a href="#104使用optional的实战示例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1041用optional封装可能为null的值"><span class="mr-2">10.4.1　用Optional封装可能为null的值　　</span><a href="#1041用optional封装可能为null的值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1042异常与optional的对比"><span class="mr-2">10.4.2　异常与Optional的对比　　</span><a href="#1042异常与optional的对比" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1043把所有内容整合起来"><span class="mr-2">10.4.3　把所有内容整合起来　　</span><a href="#1043把所有内容整合起来" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="105小结"><span class="mr-2">10.5　小结　　</span><a href="#105小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第11章completablefuture组合式异步编程"><span class="mr-2">第11章　CompletableFuture：组合式异步编程　　</span><a href="#第11章completablefuture组合式异步编程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="111future接口"><span class="mr-2">11.1　Future接口　　</span><a href="#111future接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1111future接口的局限性"><span class="mr-2">11.1.1　Future接口的局限性　　</span><a href="#1111future接口的局限性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1112使用completablefuture构建异步应用"><span class="mr-2">11.1.2　使用CompletableFuture构建异步应用　　</span><a href="#1112使用completablefuture构建异步应用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="112实现异步api"><span class="mr-2">11.2　实现异步API　　</span><a href="#112实现异步api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1121将同步方法转换为异步方法"><span class="mr-2">11.2.1　将同步方法转换为异步方法　　</span><a href="#1121将同步方法转换为异步方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1122错误处理"><span class="mr-2">11.2.2　错误处理　　</span><a href="#1122错误处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="113让你的代码免受阻塞之苦"><span class="mr-2">11.3　让你的代码免受阻塞之苦　　</span><a href="#113让你的代码免受阻塞之苦" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1131使用并行流对请求进行并行操作"><span class="mr-2">11.3.1　使用并行流对请求进行并行操作　　</span><a href="#1131使用并行流对请求进行并行操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1132使用completablefuture发起异步请求"><span class="mr-2">11.3.2　使用CompletableFuture发起异步请求　　</span><a href="#1132使用completablefuture发起异步请求" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1133寻找更好的方案"><span class="mr-2">11.3.3　寻找更好的方案　　</span><a href="#1133寻找更好的方案" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1134使用定制的执行器"><span class="mr-2">11.3.4　使用定制的执行器　　</span><a href="#1134使用定制的执行器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="114对多个异步任务进行流水线操作"><span class="mr-2">11.4　对多个异步任务进行流水线操作　　</span><a href="#114对多个异步任务进行流水线操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1141实现折扣服务"><span class="mr-2">11.4.1　实现折扣服务　　</span><a href="#1141实现折扣服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1142使用discount服务"><span class="mr-2">11.4.2　使用Discount服务　　</span><a href="#1142使用discount服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1143构造同步和异步操作"><span class="mr-2">11.4.3　构造同步和异步操作　　</span><a href="#1143构造同步和异步操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1144将两个completable-future对象整合起来无论它们是否存在依赖"><span class="mr-2">11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　</span><a href="#1144将两个completable-future对象整合起来无论它们是否存在依赖" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1145对future和completable-future的回顾"><span class="mr-2">11.4.5　对Future和Completable-Future的回顾　　</span><a href="#1145对future和completable-future的回顾" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="115响应completablefuture的completion事件"><span class="mr-2">11.5　响应CompletableFuture的completion事件　　</span><a href="#115响应completablefuture的completion事件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1151对最佳价格查询器应用的优化"><span class="mr-2">11.5.1　对最佳价格查询器应用的优化　　</span><a href="#1151对最佳价格查询器应用的优化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1152付诸实践"><span class="mr-2">11.5.2　付诸实践　　</span><a href="#1152付诸实践" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="116小结"><span class="mr-2">11.6　小结　　</span><a href="#116小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第12章新的日期和时间api"><span class="mr-2">第12章　新的日期和时间API　　</span><a href="#第12章新的日期和时间api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="121localdatelocaltimeinstantduration以及period"><span class="mr-2">12.1　LocalDate、LocalTime、Instant、Duration以及Period　　</span><a href="#121localdatelocaltimeinstantduration以及period" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1211使用localdate和localtime"><span class="mr-2">12.1.1　使用LocalDate和LocalTime　　</span><a href="#1211使用localdate和localtime" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1212合并日期和时间"><span class="mr-2">12.1.2　合并日期和时间　　</span><a href="#1212合并日期和时间" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1213机器的日期和时间格式"><span class="mr-2">12.1.3　机器的日期和时间格式　　</span><a href="#1213机器的日期和时间格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1214定义duration或period"><span class="mr-2">12.1.4　定义Duration或Period　　</span><a href="#1214定义duration或period" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="122操纵解析和格式化日期"><span class="mr-2">12.2　操纵、解析和格式化日期　　</span><a href="#122操纵解析和格式化日期" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1221使用temporaladjuster"><span class="mr-2">12.2.1　使用TemporalAdjuster　　</span><a href="#1221使用temporaladjuster" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1222打印输出及解析日期时间对象"><span class="mr-2">12.2.2　打印输出及解析日期－时间对象　　</span><a href="#1222打印输出及解析日期时间对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="123处理不同的时区和历法"><span class="mr-2">12.3　处理不同的时区和历法　　</span><a href="#123处理不同的时区和历法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1231利用和utc格林尼治时间的固定偏差计算时区"><span class="mr-2">12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　</span><a href="#1231利用和utc格林尼治时间的固定偏差计算时区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1232使用别的日历系统"><span class="mr-2">12.3.2　使用别的日历系统　　</span><a href="#1232使用别的日历系统" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="124小结"><span class="mr-2">12.4　小结　　</span><a href="#124小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h2 id="第四部分-超越java"><span class="mr-2">第四部分 超越Java</span><a href="#第四部分-超越java" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="第13章函数式的思考"><span class="mr-2">第13章　函数式的思考　　</span><a href="#第13章函数式的思考" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="131实现和维护系统"><span class="mr-2">13.1　实现和维护系统　　</span><a href="#131实现和维护系统" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1311共享的可变数据"><span class="mr-2">13.1.1　共享的可变数据　　</span><a href="#1311共享的可变数据" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1312声明式编程"><span class="mr-2">13.1.2　声明式编程　　</span><a href="#1312声明式编程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1313为什么要采用函数式编程"><span class="mr-2">13.1.3　为什么要采用函数式编程　　</span><a href="#1313为什么要采用函数式编程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="132什么是函数式编程"><span class="mr-2">13.2　什么是函数式编程　　</span><a href="#132什么是函数式编程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1321函数式java编程"><span class="mr-2">13.2.1　函数式Java编程　　</span><a href="#1321函数式java编程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1322引用透明性"><span class="mr-2">13.2.2　引用透明性　　</span><a href="#1322引用透明性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1323面向对象的编程和函数式编程的对比"><span class="mr-2">13.2.3　面向对象的编程和函数式编程的对比　　</span><a href="#1323面向对象的编程和函数式编程的对比" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1324函数式编程实战"><span class="mr-2">13.2.4　函数式编程实战　　</span><a href="#1324函数式编程实战" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="133递归和迭代"><span class="mr-2">13.3　递归和迭代　　</span><a href="#133递归和迭代" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="134小结"><span class="mr-2">13.4　小结　　</span><a href="#134小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第14章函数式编程的技巧"><span class="mr-2">第14章　函数式编程的技巧　　</span><a href="#第14章函数式编程的技巧" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="141无处不在的函数"><span class="mr-2">14.1　无处不在的函数　　</span><a href="#141无处不在的函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1411高阶函数"><span class="mr-2">14.1.1　高阶函数　　</span><a href="#1411高阶函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1412科里化"><span class="mr-2">14.1.2　科里化　　</span><a href="#1412科里化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="142持久化数据结构"><span class="mr-2">14.2　持久化数据结构　　</span><a href="#142持久化数据结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1421破坏式更新和函数式更新的比较"><span class="mr-2">14.2.1　破坏式更新和函数式更新的比较　　</span><a href="#1421破坏式更新和函数式更新的比较" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1422另一个使用tree的例子"><span class="mr-2">14.2.2　另一个使用Tree的例子　　</span><a href="#1422另一个使用tree的例子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1423采用函数式的方法"><span class="mr-2">14.2.3　采用函数式的方法　　</span><a href="#1423采用函数式的方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="143stream的延迟计算"><span class="mr-2">14.3　Stream的延迟计算　　</span><a href="#143stream的延迟计算" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1431自定义的stream"><span class="mr-2">14.3.1　自定义的Stream　　</span><a href="#1431自定义的stream" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1432创建你自己的延迟列表"><span class="mr-2">14.3.2　创建你自己的延迟列表　　</span><a href="#1432创建你自己的延迟列表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="144模式匹配"><span class="mr-2">14.4　模式匹配　　</span><a href="#144模式匹配" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1441访问者设计模式"><span class="mr-2">14.4.1　访问者设计模式　　</span><a href="#1441访问者设计模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1442用模式匹配力挽狂澜"><span class="mr-2">14.4.2　用模式匹配力挽狂澜　　</span><a href="#1442用模式匹配力挽狂澜" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="145杂项"><span class="mr-2">14.5　杂项　　</span><a href="#145杂项" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1451缓存或记忆表"><span class="mr-2">14.5.1　缓存或记忆表　　</span><a href="#1451缓存或记忆表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1452返回同样的对象意味着什么"><span class="mr-2">14.5.2　“返回同样的对象”意味着什么　　</span><a href="#1452返回同样的对象意味着什么" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1453结合器"><span class="mr-2">14.5.3　结合器　　</span><a href="#1453结合器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="146小结"><span class="mr-2">14.6　小结　　</span><a href="#146小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第15章面向对象和函数式编程的混合java-8和scala的比较"><span class="mr-2">第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　</span><a href="#第15章面向对象和函数式编程的混合java-8和scala的比较" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="151scala简介"><span class="mr-2">15.1　Scala简介　　</span><a href="#151scala简介" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1511你好啤酒"><span class="mr-2">15.1.1　你好，啤酒　　</span><a href="#1511你好啤酒" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1512基础数据结构listsetmaptuplestream以及option"><span class="mr-2">15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　</span><a href="#1512基础数据结构listsetmaptuplestream以及option" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="152函数"><span class="mr-2">15.2　函数　　</span><a href="#152函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1521scala中的一等函数"><span class="mr-2">15.2.1　Scala中的一等函数　　</span><a href="#1521scala中的一等函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1522匿名函数和闭包"><span class="mr-2">15.2.2　匿名函数和闭包　　</span><a href="#1522匿名函数和闭包" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1523科里化"><span class="mr-2">15.2.3　科里化　　</span><a href="#1523科里化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="153类和trait"><span class="mr-2">15.3　类和trait　　</span><a href="#153类和trait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1531更加简洁的scala类"><span class="mr-2">15.3.1　更加简洁的Scala类　　</span><a href="#1531更加简洁的scala类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1532scala的trait与java-8的接口对比"><span class="mr-2">15.3.2　Scala的trait与Java 8的接口对比　　</span><a href="#1532scala的trait与java-8的接口对比" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="154小结"><span class="mr-2">15.4　小结　　</span><a href="#154小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="第16章结论以及java的未来"><span class="mr-2">第16章　结论以及Java的未来　　</span><a href="#第16章结论以及java的未来" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="161回顾java-8的语言特性"><span class="mr-2">16.1　回顾Java 8的语言特性　　</span><a href="#161回顾java-8的语言特性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1611行为参数化lambda-以及方法引用"><span class="mr-2">16.1.1　行为参数化（Lambda 以及方法引用）　　</span><a href="#1611行为参数化lambda-以及方法引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1612流"><span class="mr-2">16.1.2　流　　</span><a href="#1612流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1613completablefuture"><span class="mr-2">16.1.3　CompletableFuture　　</span><a href="#1613completablefuture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1614optional"><span class="mr-2">16.1.4　Optional　　</span><a href="#1614optional" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1615默认方法"><span class="mr-2">16.1.5　默认方法　　</span><a href="#1615默认方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="162java-的未来"><span class="mr-2">16.2　Java 的未来　　</span><a href="#162java-的未来" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1621集合"><span class="mr-2">16.2.1　集合　　</span><a href="#1621集合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1622类型系统的改进"><span class="mr-2">16.2.2　类型系统的改进　　</span><a href="#1622类型系统的改进" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1623模式匹配"><span class="mr-2">16.2.3　模式匹配　　</span><a href="#1623模式匹配" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1624更加丰富的泛型形式"><span class="mr-2">16.2.4　更加丰富的泛型形式　　</span><a href="#1624更加丰富的泛型形式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1625对不变性的更深层支持"><span class="mr-2">16.2.5　对不变性的更深层支持　　</span><a href="#1625对不变性的更深层支持" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="1626值类型"><span class="mr-2">16.2.6　值类型　　</span><a href="#1626值类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="163写在最后的话"><span class="mr-2">16.3　写在最后的话　　</span><a href="#163写在最后的话" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>附录A　其他语言特性的更新　　 附录B　类库的更新　　 附录C　如何以并发方式在同一个流上执行多种操作　　 附录D　Lambda表达式和JVM 字节码　　</p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-tag no-text-decoration" >读书笔记</a> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E3%80%8AJava8%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0+-+%E6%A0%97%E5%B0%91&url=https%3A%2F%2Fliukjx.github.io%2Fposts%2Fjava8%25E5%25AE%259E%25E6%2588%2598-%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E3%80%8AJava8%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0+-+%E6%A0%97%E5%B0%91&u=https%3A%2F%2Fliukjx.github.io%2Fposts%2Fjava8%25E5%25AE%259E%25E6%2588%2598-%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fliukjx.github.io%2Fposts%2Fjava8%25E5%25AE%259E%25E6%2588%2598-%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2F&text=%E3%80%8AJava8%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0+-+%E6%A0%97%E5%B0%91" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E8%8B%B1%E8%AF%AD%E9%9F%B3%E6%A0%87/">英语音标 英语</a><li><a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><li><a href="/posts/jvm-%E5%AD%A6%E4%B9%A0/">JVM 学习</a><li><a href="/posts/%E7%AC%AC5%E8%8A%82-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/">第5节 归并排序及其相关面试题</a><li><a href="/posts/%E7%AC%AC4%E8%8A%82-%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">第4节 一些基础的数据结构</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E5%B7%A6%E7%A5%9E/">左神</a> <a class="post-tag" href="/tags/%E4%BD%93%E7%B3%BB%E7%8F%AD/">体系班</a> <a class="post-tag" href="/tags/%E8%8B%B1%E8%AF%AD/">英语</a> <a class="post-tag" href="/tags/%E8%AF%AD%E6%B3%95/">语法</a> <a class="post-tag" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> <a class="post-tag" href="/tags/%E6%96%B0%E6%89%8B%E7%8F%AD/">新手班</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/juc/">JUC</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E5%A6%82%E4%BD%95%E8%BE%BE%E6%88%90%E7%9B%AE%E6%A0%87-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><div class="card-body"> <em class="small" data-ts="1663169700" data-df="YYYY/MM/DD" > 2022/09/14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《如何达成目标》读书笔记</h3><div class="text-muted small"><p> 引言 为什么大家设定的目标最后无法实现,大多数人找错根本原因,人人都能更加成功达成目标 成功者和自制力的悖论 每个人都有自制力,区别就是高低水平 最令自己感到自豪的成就,都不是轻松完成的,必须付出艰苦卓绝的能力,这就需要自制力 自制力到底是怎样的 自制力类似肌肉需要锻炼得到增强,过度压榨自制力,肯定会疲惫无法控制自己 你能做什么 刚开始控制抵抗点心,一根烟,烦人的任务,感觉煎...</p></div></div></a></div><div class="card"> <a href="/posts/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><div class="card-body"> <em class="small" data-ts="1663246080" data-df="YYYY/MM/DD" > 2022/09/15 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Effective Java 3th 》读书笔记</h3><div class="text-muted small"><p></p></div></div></a></div><div class="card"> <a href="/posts/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><div class="card-body"> <em class="small" data-ts="1660476660" data-df="YYYY/MM/DD" > 2022/08/14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>学习之道读书笔记</h3><div class="text-muted small"><p> 第1章 开启大门 第2章 放松点 专注思维和发散思维 当初读某个章节或部分,涉及数学概念时? 先宏观浏览一遍,不只是看表,公式或图片,还有小节标题,总结,甚至如果章节末尾有思考问题,最好也看看 用一两分钟预先翻阅,再深度思考,会创造小挂钩,把思维靠上去,把握概念变得更加轻松 专注模式：一台排布紧凑的弹球机 为什么数学和科学知识会更难对付 发散模式：一台间距松散的弹球机 为什么要有两...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E7%AC%AC3%E8%8A%82-%E4%BA%8C%E5%88%86-%E5%A4%8D%E6%9D%82%E5%BA%A6-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C%E8%A1%A8/" class="btn btn-outline-primary" prompt="上一篇"><p>第3节 二分、复杂度、动态数组、哈希表</p></a> <a href="/posts/redis-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/" class="btn btn-outline-primary" prompt="下一篇"><p>Redis 课程学习</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E5%B7%A6%E7%A5%9E/">左神</a> <a class="post-tag" href="/tags/%E4%BD%93%E7%B3%BB%E7%8F%AD/">体系班</a> <a class="post-tag" href="/tags/%E8%8B%B1%E8%AF%AD/">英语</a> <a class="post-tag" href="/tags/%E8%AF%AD%E6%B3%95/">语法</a> <a class="post-tag" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> <a class="post-tag" href="/tags/%E6%96%B0%E6%89%8B%E7%8F%AD/">新手班</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/juc/">JUC</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/liukjx">栗少</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
