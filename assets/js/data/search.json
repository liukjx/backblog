[ { "title": "第5节 归并排序及其相关面试题", "url": "/posts/%E7%AC%AC5%E8%8A%82-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/", "categories": "算法, 左神体系班", "tags": "左神, 算法, 体系班", "date": "2022-11-17 06:19:00 +0800", "snippet": "内容：归并排序题目：归并排序的递归和非递归实现在一个数组中，一个数左边比它小的数的总和，叫该数的小和所有数的小和累加起来，叫数组小和例子： [1,3,4,2,5] 1左边比1小的数：没有3左边比3小的数：14左边比4小的数：1、32左边比2小的数：15左边比5小的数：1、3、4、 2所以数组的小和为1+1+3+1+1+3+4+2=16 给定一个数组arr，求数组小和在一个数组中，任何一个前面...", "content": "内容：归并排序题目：归并排序的递归和非递归实现在一个数组中，一个数左边比它小的数的总和，叫该数的小和所有数的小和累加起来，叫数组小和例子： [1,3,4,2,5] 1左边比1小的数：没有3左边比3小的数：14左边比4小的数：1、32左边比2小的数：15左边比5小的数：1、3、4、 2所以数组的小和为1+1+3+1+1+3+4+2=16 给定一个数组arr，求数组小和在一个数组中，任何一个前面的数a，和任何一个后面的数b，如果(a,b)是降序的，就称为降序对给定一个数组arr，求数组的降序对总数量在一个数组中，对于任何一个数num，求有多少个(后面的数*2)依然&lt;num，返回总个数比如：[3,1,7,0,2]3的后面有：1，01的后面有：07的后面有：0，20的后面没有2的后面没有所以总共有5个归并排序$T(N)=2 * T(N/2) + O(N)$首先是把数据分成两部分,去进行递归,最后遍历存放根据Master公式,可知Master公式形如 $T ( N ) = a * T (\\frac{N}{b}) + O ( N ^ d )$ (abd都是常数)如果$log_ba &lt; d$复杂度为$O(N^d)$如果$log_ba &gt; d$复杂度为$O(N^{log_ba})$如果$log_ba == d$复杂度为$O(N^d * logN)$谁大谁作为N的系数a是分成几部分N^d 是除递归外,剩余所有行为的时间复杂度为什么$O(N^2)$的排序很挫?因为这种排序大量浪费比较而这种递归,每次排序好的结果都在传递给下次排序能看到递归的方法好,但不理解为什么能好到$O(logN)$可以看遍历写法的归并排序\t// 递归方法实现\tpublic static void mergeSort1(int[] arr) {\t\tif (arr == null || arr.length &lt; 2) {\t\t\treturn;\t\t}\t\tprocess(arr, 0, arr.length - 1);\t}\t// 请把arr[L..R]排有序\t// l...r N\t// T(N) = 2 * T(N / 2) + O(N)\t// O(N * logN)\tpublic static void process(int[] arr, int L, int R) {\t\tif (L == R) { // base case\t\t\treturn;\t\t}\t\tint mid = L + ((R - L) &gt;&gt; 1);\t\tprocess(arr, L, mid);\t\tprocess(arr, mid + 1, R);\t\tmerge(arr, L, mid, R);\t}\tpublic static void merge(int[] arr, int L, int M, int R) { // help是辅助数组\t\tint[] help = new int[R - L + 1]; // i是用于帮助help填满\t\tint i = 0; // P1是左部分的第一个数\t\tint p1 = L; // P2是右部分的第一个数\t\tint p2 = M + 1; // P1 &lt;= M 是左部分不越界,&gt;M是越界 // P2 ≤ R是不越界,&gt;R是越界\t\twhile (p1 &lt;= M &amp;&amp; p2 &lt;= R) { // 在都没越界的情况下,谁小拷贝谁\t\t\thelp[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];\t\t}\t\t// 要么p1越界了，要么p2越界了,两个越界只会发生一个\t\twhile (p1 &lt;= M) {\t\t\thelp[i++] = arr[p1++];\t\t}\t\twhile (p2 &lt;= R) {\t\t\thelp[i++] = arr[p2++];\t\t} // 从help拷贝回arr\t\tfor (i = 0; i &lt; help.length; i++) {\t\t\tarr[L + i] = help[i];\t\t}\t}\t// 非递归方法实现\tpublic static void mergeSort2(int[] arr) {\t\tif (arr == null || arr.length &lt; 2) {\t\t\treturn;\t\t}\t\tint N = arr.length;\t\t// 步长\t\tint mergeSize = 1;\t\twhile (mergeSize &lt; N) { // log N\t\t\t// 当前左组的，第一个位置\t\t\tint L = 0;\t\t\twhile (L &lt; N) {\t\t\t\tif (mergeSize &gt;= N - L) {\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tint M = L + mergeSize - 1;\t\t\t\tint R = M + Math.min(mergeSize, N - M - 1);\t\t\t\tmerge(arr, L, M, R);\t\t\t\tL = R + 1;\t\t\t}\t\t\t// 防止溢出\t\t\tif (mergeSize &gt; N / 2) {\t\t\t\tbreak;\t\t\t}\t\t\tmergeSize &lt;&lt;= 1;\t\t}\t}" }, { "title": "第4节 一些基础的数据结构", "url": "/posts/%E7%AC%AC4%E8%8A%82-%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/", "categories": "算法, 左神体系班", "tags": "左神, 算法, 体系班", "date": "2022-10-12 20:37:00 +0800", "snippet": "单链表、双链表栈、队列递归的物理实质评估递归复杂度的Master公式Master公式形如 $T ( N ) = a * T (\\frac{N}{b}) + O ( N ^ d )$ (abd都是常数)如果$log_ba &lt; d$复杂度为$O(N^d)$如果$log_ba &gt; d$复杂度为$O(N^{log_ba})$如果$log_ba == d$复杂度为$O(N^d * logN...", "content": "单链表、双链表栈、队列递归的物理实质评估递归复杂度的Master公式Master公式形如 $T ( N ) = a * T (\\frac{N}{b}) + O ( N ^ d )$ (abd都是常数)如果$log_ba &lt; d$复杂度为$O(N^d)$如果$log_ba &gt; d$复杂度为$O(N^{log_ba})$如果$log_ba == d$复杂度为$O(N^d * logN)$谁大谁作为N的系数a是分成几部分N^d 是除递归外,剩余所有行为的时间复杂度子问题规模是一致的,可以用Master公式哈希表的使用和性能如果是基础类型,会原样进入HashMap如果是自定义类型,只会存引用信息,八字节HashMap,有key和value,HashSet,理解为只有Key的HashMap原生的类型,包装类,存HashMap 都是按值传递自定义类型,按引用传递增删改查都是$O(1)$有序表的使用和性能TreeMap 有序表,接口名// 红黑树 avl sizeBalance树,跳表增删改查复杂度 $O(logn)$Java 中TreeMap是用红黑树实现的TreeMap如果没有定义比较规则会进入放入题目：反转单链表、反转双链表反转单链表展开\t// head\t// a -&gt; b -&gt; c -&gt; null\t// c -&gt; b -&gt; a -&gt; null\tpublic static Node reverseLinkedList(Node head) {\t\tNode pre = null;\t\tNode next = null;\t\twhile (head != null) { // head 记录\t\t\tnext = head.next;\t\t\thead.next = pre;\t\t\tpre = head;\t\t\thead = next;\t\t}\t\treturn pre;\t}反转双链表展开\tpublic static DoubleNode reverseDoubleList(DoubleNode head) {\t\tDoubleNode pre = null;\t\tDoubleNode next = null;\t\twhile (head != null) {\t\t\tnext = head.next;\t\t\thead.next = pre;\t\t\thead.last = next;\t\t\tpre = head;\t\t\thead = next;\t\t}\t\treturn pre;\t}练熟以上两道题在链表中删除指定值的所有节点展开\t// head = removeValue(head, 2);\tpublic static Node removeValue(Node head, int num) {\t\t// head来到第一个不需要删的位置\t\twhile (head != null) {\t\t\tif (head.value != num) {\t\t\t\tbreak;\t\t\t}\t\t\thead = head.next;\t\t}\t\t// 1 ) head == null 说明链表中全是num\t\t// 2 ) head != null\t\tNode pre = head;\t\tNode cur = head; // 后面挨个检查,非给定值的节点,往上一个非给定值节点上挂\t\twhile (cur != null) {\t\t\tif (cur.value == num) {\t\t\t\tpre.next = cur.next;\t\t\t} else {\t\t\t\tpre = cur;\t\t\t}\t\t\tcur = cur.next;\t\t}\t\treturn head;\t}用双链表实现栈和队列双链表基本定义展开\tpublic static class Node {\t\tpublic T value;\t\tpublic Node last;\t\tpublic Node next;\t\tpublic Node(T data) {\t\t\tvalue = data;\t\t}\t}&lt;/pre&gt;&lt;/details&gt; ## 双链表实现队列展开\tpublic static class DoubleEndsQueue {\t\tpublic Node head;\t\tpublic Node tail;\t\tpublic void addFromHead(T value) {\t\t\tNode cur = new Node(value);\t\t\tif (head == null) {\t\t\t\thead = cur;\t\t\t\ttail = cur;\t\t\t} else {\t\t\t\tcur.next = head;\t\t\t\thead.last = cur;\t\t\t\thead = cur;\t\t\t}\t\t}\t\tpublic void addFromBottom(T value) {\t\t\tNode cur = new Node(value);\t\t\tif (head == null) {\t\t\t\thead = cur;\t\t\t\ttail = cur;\t\t\t} else {\t\t\t\tcur.last = tail;\t\t\t\ttail.next = cur;\t\t\t\ttail = cur;\t\t\t}\t\t}\t\tpublic T popFromHead() {\t\t\tif (head == null) {\t\t\t\treturn null;\t\t\t}\t\t\tNode cur = head;\t\t\tif (head == tail) {\t\t\t\thead = null;\t\t\t\ttail = null;\t\t\t} else {\t\t\t\thead = head.next;\t\t\t\tcur.next = null;\t\t\t\thead.last = null;\t\t\t}\t\t\treturn cur.value;\t\t}\t\tpublic T popFromBottom() {\t\t\tif (head == null) {\t\t\t\treturn null;\t\t\t}\t\t\tNode cur = tail;\t\t\tif (head == tail) {\t\t\t\thead = null;\t\t\t\ttail = null;\t\t\t} else {\t\t\t\ttail = tail.last;\t\t\t\ttail.next = null;\t\t\t\tcur.last = null;\t\t\t}\t\t\treturn cur.value;\t\t}\t\tpublic boolean isEmpty() {\t\t\treturn head == null;\t\t}\t}&lt;/pre&gt;&lt;/details&gt; ## 双链表实现栈展开\tpublic static class MyStack {\t\tprivate DoubleEndsQueue queue;\t\tpublic MyStack() {\t\t\tqueue = new DoubleEndsQueue();\t\t}\t\tpublic void push(T value) {\t\t\tqueue.addFromHead(value);\t\t}\t\tpublic T pop() {\t\t\treturn queue.popFromHead();\t\t}\t\tpublic boolean isEmpty() {\t\t\treturn queue.isEmpty();\t\t}\t}&lt;/pre&gt;&lt;/details&gt; # 用环形数组实现栈和队列## 数组实现栈## 循环数组实现队列展开\tpublic static class MyQueue {\t\tprivate int[] arr;\t\tprivate int pushi;// end 进入的往哪放\t\tprivate int polli;// begin 弹出的从哪拿\t\tprivate int size; //size 管理能不能加,不能能减\t\tprivate final int limit;\t\tpublic MyQueue(int limit) {\t\t\tarr = new int[limit];\t\t\tpushi = 0;\t\t\tpolli = 0;\t\t\tsize = 0;\t\t\tthis.limit = limit;\t\t}\t\tpublic void push(int value) {\t\t\t//只要不等于limit限制,必能加\t\t\tif (size == limit) { \t\t\t\tthrow new RuntimeException(\"队列满了，不能再加了\");\t\t\t}\t\t\tsize++;\t\t\tarr[pushi] = value; //把值放在end位置\t\t\tpushi = nextIndex(pushi);\t\t}\t\tpublic int pop() {\t\t\t// 只要不等于0,必能取出\t\t\tif (size == 0) {\t\t\t\tthrow new RuntimeException(\"队列空了，不能再拿了\");\t\t\t}\t\t\tsize--;\t\t\t// 把begin位置的值取出\t\t\tint ans = arr[polli];\t\t\tpolli = nextIndex(polli);\t\t\treturn ans;\t\t}\t\tpublic boolean isEmpty() {\t\t\treturn size == 0;\t\t}\t\t// 如果现在的下标是i，返回下一个位置\t\t// 如果没到底就+1,如果到底了(i == limit -1)就返回0\t\tprivate int nextIndex(int i) {\t\t\treturn i &lt; limit - 1 ? i + 1 : 0;\t\t}\t} # 实现有getMin功能的栈实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能1)pop、push、getMin操作的时间复杂度都是O(1).2)设计的栈类型可以使用现成的栈结构。时间复杂度都是O(1)所以不能遍历最小栈是用两个栈实现的展开\tpublic static class MyStack1 {\t\tprivate Stack stackData; //数据栈\t\tprivate Stack stackMin; // 最小栈\t\tpublic MyStack1() {\t\t\tthis.stackData = new Stack();\t\t\tthis.stackMin = new Stack();\t\t}\t\tpublic void push(int newNum) {\t\t\t// 如果最小栈为空,直接放入\t\t\tif (this.stackMin.isEmpty()) {\t\t\t\tthis.stackMin.push(newNum);\t\t\t} else if (newNum &lt;= this.getmin()) {\t\t\t\t// 最小栈不为空,并且新元素的值小于等于当前最小栈的最小值,加入最小栈的值\t\t\t\tthis.stackMin.push(newNum);\t\t\t}\t\t\t// 将数据放入数据栈\t\t\tthis.stackData.push(newNum);\t\t}\t\tpublic int pop() {\t\t\tif (this.stackData.isEmpty()) {\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\t\t\t}\t\t\tint value = this.stackData.pop();\t\t\tif (value == this.getmin()) {\t\t\t\tthis.stackMin.pop();\t\t\t}\t\t\treturn value;\t\t}\t\tpublic int getmin() {\t\t\tif (this.stackMin.isEmpty()) {\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\t\t\t}\t\t\treturn this.stackMin.peek();\t\t}\t}\tpublic static class MyStack2 {\t\tprivate Stack stackData;\t\tprivate Stack stackMin;\t\tpublic MyStack2() {\t\t\tthis.stackData = new Stack();\t\t\tthis.stackMin = new Stack();\t\t}\t\tpublic void push(int newNum) {\t\t\tif (this.stackMin.isEmpty()) {\t\t\t\tthis.stackMin.push(newNum);\t\t\t} else if (newNum &lt; this.getmin()) {\t\t\t\tthis.stackMin.push(newNum);\t\t\t} else {\t\t\t\tint newMin = this.stackMin.peek();\t\t\t\tthis.stackMin.push(newMin);\t\t\t}\t\t\tthis.stackData.push(newNum);\t\t}\t\tpublic int pop() {\t\t\tif (this.stackData.isEmpty()) {\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\t\t\t}\t\t\tthis.stackMin.pop();\t\t\treturn this.stackData.pop();\t\t}\t\tpublic int getmin() {\t\t\tif (this.stackMin.isEmpty()) {\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\t\t\t}\t\t\treturn this.stackMin.peek();\t\t}\t}&lt;/details&gt;# 两个栈实现队列- 遵循两点原则,怎么导数据都对 - 一次性倒完 - pop栈空,再全部倒过去展开public static class TwoStacksQueue {\t// 准备两个栈,一个push栈一个pop栈\t\tpublic Stack stackPush;\t\tpublic Stack stackPop;\t\tpublic TwoStacksQueue() {\t\t\tstackPush = new Stack();\t\t\tstackPop = new Stack();\t\t}\t\t// 导数据\t\t// pop为空时,push不为空,push栈向pop栈循环倒入数据\t\tprivate void pushToPop() {\t\t\tif (stackPop.empty()) {\t\t\t\twhile (!stackPush.empty()) {\t\t\t\t\tstackPop.push(stackPush.pop());\t\t\t\t}\t\t\t}\t\t}\t\t// 每次放都是往push栈放入\t\tpublic void add(int pushInt) {\t\t\tstackPush.push(pushInt);\t\t\tpushToPop();\t\t}\t\tpublic int poll() {\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) {\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\t\t\t}\t\t\tpushToPop();\t\t\treturn stackPop.pop();\t\t}\t\tpublic int peek() {\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) {\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\t\t\t}\t\t\tpushToPop();\t\t\treturn stackPop.peek();\t\t}\t}&lt;/pre&gt;&lt;/details&gt; # 两个队列实现栈展开\t// 准备两个队列,queue和help互相导数据\t// poll一次后就需要两者引用互换\tpublic static class TwoQueueStack {\t\tpublic Queue queue;\t\tpublic Queue help;\t\tpublic TwoQueueStack() {\t\t\tqueue = new LinkedList&lt;&gt;();\t\t\thelp = new LinkedList&lt;&gt;();\t\t}\t\tpublic void push(T value) {\t\t\tqueue.offer(value);\t\t}\t\tpublic T poll() {\t\t\t// queue弹出到只剩一个\t\t\twhile (queue.size() &gt; 1) {\t\t\t\thelp.offer(queue.poll());\t\t\t}\t\t\tT ans = queue.poll();\t\t\tQueue tmp = queue;\t\t\tqueue = help;\t\t\thelp = tmp;\t\t\treturn ans;\t\t}\t\tpublic T peek() {\t\t\twhile (queue.size() &gt; 1) {\t\t\t\thelp.offer(queue.poll());\t\t\t}\t\t\t// 依旧弹出,但获取值以后,再进入help\t\t\tT ans = queue.poll();\t\t\thelp.offer(ans);\t\t\tQueue tmp = queue;\t\t\tqueue = help;\t\t\thelp = tmp;\t\t\treturn ans;\t\t}\t\tpublic boolean isEmpty() {\t\t\treturn queue.isEmpty();\t\t}\t}&lt;/pre&gt;&lt;/details&gt; # 用递归行为得到数组中的最大值，并用master公式来估计时间复杂度展开\t// 求arr中的最大值\tpublic static int getMax(int[] arr) {\t\treturn process(arr, 0, arr.length - 1);\t}\t// arr[L..R]范围上求最大值 L ... R N\tpublic static int process(int[] arr, int L, int R) {\t\t// arr[L..R]范围上只有一个数，直接返回，base case\t\tif (L == R) { \t\t\treturn arr[L];\t\t}\t\t// L...R 不只一个数\t\t// mid = (L + R) / 2\t\tint mid = L + ((R - L) &gt;&gt; 1); // 中点 \t1\t\tint leftMax = process(arr, L, mid);\t\tint rightMax = process(arr, mid + 1, R);\t\treturn Math.max(leftMax, rightMax);\t} # 哈希表和有序表使用的code展示" }, { "title": "第2节 认识复杂度、对数器、二分法", "url": "/posts/%E7%AC%AC2%E8%8A%82-%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6-%E5%AF%B9%E6%95%B0%E5%99%A8-%E4%BA%8C%E5%88%86%E6%B3%95/", "categories": "算法, 左神体系班", "tags": "左神, 算法, 体系班", "date": "2022-10-09 21:22:00 +0800", "snippet": "评估算法优劣的核心指标时间复杂度、空间复杂度、估算方式、意义常数时间的操作选择排序、冒泡排序、插入排序最优解对数器二分法题目：选择排序及其对数器验证冒泡排序及其对数器验证插入排序及其对数器验证有序数组中找到num有序数组中找到&gt;=num最左的位置有序数组中找到&lt;=num最右的位置局部最小值问题定义何为局部最小值：arr[0] &lt; arr[1]，0位置是局部最小；arr[N-...", "content": "评估算法优劣的核心指标时间复杂度、空间复杂度、估算方式、意义常数时间的操作选择排序、冒泡排序、插入排序最优解对数器二分法题目：选择排序及其对数器验证冒泡排序及其对数器验证插入排序及其对数器验证有序数组中找到num有序数组中找到&gt;=num最左的位置有序数组中找到&lt;=num最右的位置局部最小值问题定义何为局部最小值：arr[0] &lt; arr[1]，0位置是局部最小；arr[N-1] &lt; arr[N-2]，N-1位置是局部最小；arr[i-1] &gt; arr[i] &lt; arr[i+1]，i位置是局部最小；给定一个数组arr，已知任何两个相邻的数都不相等，找到随便一个局部最小位置返回" }, { "title": "第1节 算法和数据结构路线、注意点与常见问题", "url": "/posts/%E7%AC%AC1%E8%8A%82-%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%B7%AF%E7%BA%BF-%E6%B3%A8%E6%84%8F%E7%82%B9%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/", "categories": "算法, 左神体系班", "tags": "左神, 算法, 体系班", "date": "2022-10-09 21:22:00 +0800", "snippet": "算法和数据结构课程体系介绍算法和数据结构学习路线算法和数据结构学习方式推荐算法和数据结构面试软技巧同学们的各种答疑问题", "content": "算法和数据结构课程体系介绍算法和数据结构学习路线算法和数据结构学习方式推荐算法和数据结构面试软技巧同学们的各种答疑问题" }, { "title": "第3节 异或运算相关面试题", "url": "/posts/%E7%AC%AC3%E8%8A%82-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/", "categories": "算法, 左神体系班", "tags": "左神, 算法, 体系班", "date": "2022-10-09 21:06:00 +0800", "snippet": "内容：异或运算的性质异或运算的题目题目：不用额外变量交换两个数的值不用额外变量交换数组中两个数的值一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数怎么把一个int类型的数，提取出二进制中最右侧的1来一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数一个数组中有一种数出现K次，其他数都出现了M次，已知M &gt; 1，K &lt; M，找到出...", "content": "内容：异或运算的性质异或运算的题目题目：不用额外变量交换两个数的值不用额外变量交换数组中两个数的值一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数怎么把一个int类型的数，提取出二进制中最右侧的1来一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数一个数组中有一种数出现K次，其他数都出现了M次，已知M &gt; 1，K &lt; M，找到出现了K次的数要求额外空间复杂度O(1)，时间复杂度O(N)" }, { "title": "批判性思维—方法和实践", "url": "/posts/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4-%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E8%B7%B5/", "categories": "", "tags": "", "date": "2022-10-05 21:30:00 +0800", "snippet": "第一章 绪论1.1 导论（上）什么是批判性思维视频：什么是批判性思维练习1.2 导论（中）何时以及如何运用批判性思维？视频：何时以及如何运用批判性思维补充知识：一个被大多数人忽略、却该运用批判性思维的情况1.1投票题1点评1.1投票题2点评练习1.3 导论（下）哪些人和职业最需要批判性思维？视频：批判性思维可以帮我们做什么1.2投票题1点评1.2投票题2点评练习第二章 准确理解信息和知识的含...", "content": "第一章 绪论1.1 导论（上）什么是批判性思维视频：什么是批判性思维练习1.2 导论（中）何时以及如何运用批判性思维？视频：何时以及如何运用批判性思维补充知识：一个被大多数人忽略、却该运用批判性思维的情况1.1投票题1点评1.1投票题2点评练习1.3 导论（下）哪些人和职业最需要批判性思维？视频：批判性思维可以帮我们做什么1.2投票题1点评1.2投票题2点评练习第二章 准确理解信息和知识的含义2.1 准确理解的难点：识别下面观点里的模糊词语视频：准确理解的难点——识别模糊词语补充知识：补充几类模糊词语练习：识别下面观点里的模糊词语（连同它们的搭配词一起）2.2 模糊词语的意思，怎么才算搞清楚了？视频：模糊词语的意思，怎么才算搞清楚了？练习：识别外延很大的词语讨论：如何理解以下动词短语的外延？2.3 对模糊词语，为何以及如何“同情之理解”？视频：对模糊词语，为何以及如何“同情之理解”？练习：对下面观点里的关键词，该如何“同情之理解”第三章 恰当下定义方法、常见的概念谬误3.1 下定义的方法和规则是什么？视频：常用定义方法和规则补充知识1：下定义的两种不同情况下，怎么选“种差”补充知识2：”定义规则“对“澄清模糊词语含义”的启发、以及”定义“和“澄清模糊词语”的差别练习：下定义方法和规则3.2 概念相关的谬误视频：跟概念相关的谬误补充知识：“分解谬误”和“刻板印象”的关系练习：识别概念谬误上一章讨论和“投票题”点评“尊重科学”的外延“尊重他人劳动”的外延第二章 投票题点评第四章 全面深入地理解语句的含义——语句的预设分析4.1 语句的字面意思：语义预设视频：语句的字面意思：语义预设练习：分析以下句子中暗藏的“事实”（加载问题）4.2 语句的言外之意：语用预设视频A：语句的言外之意_语用预设(1)陈述句补充知识：陈述句的语用预设，对“传递信息类”写作的启示视频A里练习的答案练习：从以下陈述句的预设里，选出语用预设视频B：语句的言外之意_语用预设(2) 祈使句、疑问句补充说明：为啥“祈使句的语用预设3” 语音和画面有差异视频B里的练习答案练习：从以下祈使句的预设里，找出非语用预设的选项讨论：了解语用预设，对我们提高人际沟通技巧，有什么启发？4.3 观点里常用词语、句式的预设视频：表达观点时，常用词语的预设视频里的练习答案补充知识：“应该类”观点的预设中，哪些是脆弱的、容易受到攻击？投票题：以下“应该句”的预设里，哪个容易收到攻击投票题：判断以下观点的多个预设中，哪个容易受到攻击本小节投票题解析大家普遍认同的理念“应该独立思考/质疑”，其预设是什么？其中哪个预设是脆弱、易受攻击的呢？第五章 判断陈述的可靠性：事实-观点-谬误的区分5.1 判断信息类陈述的可靠性视频：判断信息的可靠性练习：判断以下陈述是哪类——事实、观点、谬误？5.2 判断信息类陈述的可靠性：复杂陈述句视频：信息类陈述的可靠性性-复杂陈述句练习1：以下陈述，哪个还需要继续分解、变成多个简单句练习2：以下陈述如果为事实，下面的哪个陈述也必须是事实？5.3 判断“知识”类陈述的可靠性视频：判断“知识”类陈述的可靠性练习：判断语段是否为事实第六章 如何判断事实类信息的可靠性-假新闻识别6.0-6.1虚假信息的外延和分类、来自媒体人的虚假信息视频：虚假信息的外延和分类-来自媒体人的虚假信息6.2 来自非媒体人的虚假信息视频：来自非媒体从业者的虚假信息6.3 来自专业媒体的失实报道视频：来自专业媒体的失实报道补充说明：识别假新闻范例第七章 归纳法及其相关谬误7.1-7.2 恰当归纳-改进归纳所得结论视频：恰当归纳-改进归纳所得结论练习1：对以下陈述背后的抽象原则，哪个概括是最恰当的？练习2：仔细阅读以下的故事，并作出选择7.3 归纳法的相关谬误视频：归纳法的相关谬误补充说明：视频最后思考题的参考答案练习：预测未来时避免机械概括的练习第八章 演绎推理的形式及其有效性8.1 条件命题及其推理的有效性视频：条件命题及其推理的有效性练习1：判断条件命题的关系是充分还是必要练习2：判断命题之间的关系、以及推理的有效性练习3：判断条件命题推理的有效性8.2 三段论推理及其有效形式视频：三段论推理及其有效性补充说明：视频里“补足推理环节练习”的答案练习1：补出三段论推理省略的前提练习2：视频里几个三段论推理，有效吗？第九章 演绎论证的方法和结构9.1 几种常用的论证方法视频：演绎论证的几种常用方法补充说明1：视频里“归谬法”练习题参考答案补充说明2：最后案例里的观点，用反证法如何证明9.2 论证结构分析法视频：演绎论证的结构分析补充案例：“市长选举”论证结构图练习：试试分析“篮子考古”的论证结构补充说明：“篮子考古”的论证结构图的解答第十章 演绎论证的改进方法10.1 改进演绎论证的图尔敏模型视频：改进演绎论证的图尔敏模型讨论：同学们遇到社科类小论文写作时，最大的烦恼是什么？10.2 用图尔敏模型改进复杂论证的方法视频：图尔敏模型改进复杂论证的方法补充说明：视频最后“新JAZZ俱乐部能赚钱”案例，运用图尔敏模型的改进过程补充知识1：“图尔敏模型”用于GRE Argument 写作补充知识2：“图尔敏模型”用于GRE Issues 写作第十一章 演绎推理和论证中的谬误11.0-11.1 演绎谬误的分类-理由或结论的相关谬误视频：演绎谬误的分类-演绎论证中理由或结论的相关谬误11.2 理由和结论间关系的谬误1视频：演绎论证中理由和结论关系的谬误补充：理由和结论不相干的谬误（”推不出“）GRE argument 案例补充：演绎相关谬误分类的思维导图练习：判断五毛言论里有哪类谬误第十二章 类比、比较、公正评价12.1 类比论证及相关谬误视频：类比推理和相关谬误练习：判断下面事物间的关系是否可以类比12.2 用类比沟通 说服，发现真相视频：用类比沟通说服、发现真相补充知识：用类比找到解决问题的思路练习：判断以下哪个类比更无懈可击12.3 比较和公正的评价视频：比较和公正的评价补充知识：比较对象不同，目标和价值不同练习：选择合适的比较对象第十三章 因果解释的相关概念、因果关系的谬误13.1 因果解释的相关概念视频：因果解释的相关概念练习1：判断以下问题是否要求“因果解释”练习2：判断以下原因是充分的、还是必要的13.2 相关性和因果关系的谬误视频：相关性和因果关系的谬误练习1：判断以下的因果解释中，可能有哪种错误练习2：判断以下因果推理可能有哪种谬误13.3 社会心理学对归因偏误的研究视频：社会心理学对归因偏误的研究补充说明：关于基本归因错误的文化差异练习：分析以下事件原因的时候，是否需要提醒自己不要陷入基本归因错误及其衍生谬误13.4 确认两变量间因果关系的方法视频：确认两变量间因果关系的方法练习：视频最后的思考题第十四章 因果解释的基本思路和研究方法14.1 因果解释的基本问题和思路视频：因果解释的基本问题和思路练习：判断以下因果解释问题，是否有隐含的对比问题(Y)14.2 对常识类现象，如何提出和筛选原因假设视频：对常识类现象，如何提出和筛选原因假设练习1：维纳总结出的“人类行为成败的因素”，按他的三维模型该如何归类？练习2：凯利的协变归因模型应用14.3 非常识领域，如何提出原因假设(上)视频：非常识领域，如何提出原因假设(上)补充说明1：“运用演绎法得出原因假设”时，什么是合格的因果解释理论补充说明2：筛选原因假设的基本方法(成为原因假设的必要条件)补充说明3：确定“某原因假设跟结果之间的有因果关系”的方法14.4 非常识领域，如何提出原因假设(下)视频：非常识领域，如何提出原因假设(下)补充说明： “穆勒五法”中的“剩余法”练习：判断下面哪个选题适合用穆勒法的求同法或综合法？讨论：穆勒法的应用实践题结束语视频：批判性思维的几个对手关于“独立思考”的适用范围和条件关于本课程的感受，请投票讨论：你对视频里讨论的主题，怎么看？" }, { "title": "《批判性思维教程》读书笔记", "url": "/posts/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E6%95%99%E7%A8%8B/", "categories": "", "tags": "", "date": "2022-10-05 09:39:00 +0800", "snippet": "第一章 理性的声音：批判性思维第一节 什么是批判性思维一、恰当的提问与合理的论证什么是世界观？人们对世界或对它的某些方面所形成的一系列信念和看法的总和graph LR;A[世界:信息源]--&gt;|过滤信息|B[问题和推理]--&gt;|提炼改善|C[世界观]世界观--&gt;|应用|问题和推理--&gt;|结果|决定和行动世界观和批判性思维的关系？由上图也已看出，世界观形成的核心是问题和...", "content": "第一章 理性的声音：批判性思维第一节 什么是批判性思维一、恰当的提问与合理的论证什么是世界观？人们对世界或对它的某些方面所形成的一系列信念和看法的总和graph LR;A[世界:信息源]--&gt;|过滤信息|B[问题和推理]--&gt;|提炼改善|C[世界观]世界观--&gt;|应用|问题和推理--&gt;|结果|决定和行动世界观和批判性思维的关系？由上图也已看出，世界观形成的核心是问题和推理批判性思维就是提出恰当问题和做出合理论证的能力批判性思维和好的思维品质的关系graph TD;A[/批判性思维\\]--&gt;B[/好的思维品质\\];B--&gt;清晰性;B--&gt;相关性;B--&gt;一致性;B--&gt;正当性;B--&gt;预见性;二、清晰性：澄清思维混乱 对一个问题可以拆成不同层次辨析在准备对一个问题做出回答之前，要思考这个问题是否假定了一些事实，这个事实如果是不成立的，就是一个不恰当的问题 思考要有条理,不要将事实问题,价值问题,情感问题同时混在一起讨论和思考 清晰性意味着清楚,准确地使用概念和语言.想清楚的事情未必表达清楚,没想清楚的事情肯定表达不清楚,概念不清和语词滥用也是导致思维混乱的根源。 三、相关性：摆脱感情纠葛围绕一个问题进行思考,搜集相关信息,做出针对回答或找出有针对性的解决方案,避免将不相关的问题牵扯进来 布什列举一大堆事实性陈述,没有回答是否逃逸服兵役的问题相关性意味着思考问题时,诉诸逻辑推理,而不是情感心理诉诸情感为什么有效?原因之一是由于人们在考虑问题难以切断感情的纠葛在承认问题和寻求答案的问题上,需要?理智的见解,深思熟虑和基于事实的分析与推理,如果不能摆脱情感依赖,就会陷入快捷廉价的选择判断之中,时过境迁之后,会为当初的选择后悔graph TD;清晰性--&gt;相关性;清晰性时批判性思维的第一标准,如果不清晰,则问题不知道是什么,相关性无从谈起满足清晰性,不等于满足相关性四、一致性：避免自相矛盾自相矛盾是最尖锐的不一致。自相矛盾的主张必有一个是不能成立的在相关性的基础上，才谈得上一致性。 我说：“青蛙会唱歌，总是过着快乐的生活。”你说：“歌星会唱歌，可他们有时并不快乐。”你我谈论的对象不同，因而谈不上一致或不一致。一致性总是针对同一个对象具有或不具有某种属性，或者针对同一个问题的不同回答而言的。graph TD;清晰性--&gt;相关性 --&gt;一致性满足了相关性的要求，不等于满足了一致性的要求五、正当性：消除不可靠的信念正当性意味着使用真实可信的理由为信念做出担保。信念和信仰的区别?一个人信仰什么可能不需要讲理由，但是，一个人相信什么却需要讲理由。应该基于什么相信?可靠的证据。基于个人的偏见、情感和愿望等，所获得的信念是不可靠的。什么是可靠证据?可靠的证据是在不受人为因素和不恰当的测量方法干扰的情况下，在不同的观察者面前能重复得到同样结论的实验结果。根据理由对信念的支持强弱来决定对信念的确信程度,对信念的确信程度超出了手中所掌握的证据的担保能力,这种确信就是不正当的六、预见性：拒绝盲目行动预见性意味着信念的实用性。如果你拥有的信念能帮助你对周围的世界做出较好的解释和理解，而且能够对周围世界所发生的事件做出较好的预测和控制，那么你的信念就是非常实用的。预见性意味着行动的主动性。了解事物的原因不只是为了满足好奇心和消除恐惧感，而是要引导我们的行动，知道要做些什么、什么时候去做以及如何去做，并为我们做决定提供依据。第二节 发展批判性思维能力一、正确的态度二、原则性知识三、勤奋的实践第三节 批判性思维课程的设计一、批判性思维课程的设计风格二、批判性思维教育的意义三、教程内容的组织安排第二章 主张与断言第一节 论证的概念一、什么是论证二、论证与解释三、论证与推理四、推理的有效性五、归谬与证伪六、论证的可靠性七、论证的谬误第二节 抓住断言一、语句与陈述二、陈述与断言三、断言与主张第三节 简单陈述一、直言陈述二、量化陈述三、矛盾陈述四、对当关系五、陈述的标准化第四节 复合陈述一、联言陈述及其否定二、选言陈述及其否定三、假言陈述及其否定第五节 避免自相矛盾一、自相矛盾的主张二、自相矛盾的论证三、悖论练习题第三章 问题与主张第一节 理解问题一、问题、回答和预设二、单一问题与多重问题三、责任性回答第二节 恰当提问的益处一、明确论证的主张二、辨析争议的焦点三、描述性问题与规范性问题第三节 问题的谬误一、误导性问题二、不一致的问题三、无视问题的谬误练习题第四章 理由与正当理由第一节 辨识理由一、理由的标志与面貌二、辨识理由的困难三、理由与原因四、前提与假设第二节 论证图解一、单一结构二、T型结构三、V型结构四、复合结构第三节 不正当的理由一、诉诸情感二、诉诸权威三、未确证的假设练习题第五章 澄清意义第一节 语言的意义一、意义理论二、语言的基本功用三、概念的内涵与外延四、歧义与模糊第二节 定义方法一、语词定义二、内涵定义三、内涵定义的规则第三节 划分方法一、划分的结构和方法二、划分的规则三、划分、分类与分解四、限制与概括第四节 苏格拉底方法一、逻辑推论与不一致的信念二、反例反驳与有纰漏的定义三、诘问式的益处练习题第六章 演绎论证第一节 直言三段论一、定义和结构二、主词与谓词的周延性三、判定有效式的规则四、评估直言三段论的有效性第二节 假言三段论一、假言推理的基本式二、纯假言推理的常用式三、归谬法和反证法四、评估假言推理的有效性第三节 选言三段论一、选言推理的基本式二、二难推理三、评估选言推理的有效性第四节 论证的可靠性一、关于真的理论二、经验性陈述与非经验性陈述三、评估演绎论证的可靠性练习题第七章 归纳论证第一节 枚举论证一、全称枚举推理二、特称枚举与单称枚举三、枚举论证的谬误第二节 类比论证与比喻论证一、类比推理二、比喻论证三、评估类比和比喻论证第三节 统计论证一、统计概括二、统计三段论三、统计推理的谬误四、评估统计数据第四节 因果解释与因果论证一、解释、假说和预测二、因果推论的术语三、时间关联与统计关联四、确立实质性因果主张五、确立统计性因果主张六、因果论证的谬误练习题第八章 批判性写作第一节 分析性写作与批判性准则一、批判性阅读与分析性写作二、宽容原则与中立原则三、阅读与写作的批判性准则第二节 分析性写作的步骤和方法第一步：如何发现分析性写作的分论点第二步：如何对评估的分论点进行论证第三步：如何组织文章结构、进行语言表达第三节 批判性写作赏析梁实秋：“资本家的走狗”鲁迅：“丧家的”“资本家的乏走狗”赏析：“丧家的”与“乏”练习题部分练习题参考答案" }, { "title": "写作课", "url": "/posts/%E5%86%99%E4%BD%9C%E8%AF%BE/", "categories": "写作课", "tags": "", "date": "2022-09-24 18:16:00 +0800", "snippet": "第01课 使用文字的本质文字的基本构成一篇文章由很多段落组成一个段落由一个或多个句子构成一个句子是由一个或多个词汇构成词汇是最基本的组成graph TD;O[文章]--&gt;A[段落];A --&gt; C[句子];C --&gt; E[词汇];词汇的分类 名词 做主语或宾语 动词 只能做谓语 形容词 通常...", "content": "第01课 使用文字的本质文字的基本构成一篇文章由很多段落组成一个段落由一个或多个句子构成一个句子是由一个或多个词汇构成词汇是最基本的组成graph TD;O[文章]--&gt;A[段落];A --&gt; C[句子];C --&gt; E[词汇];词汇的分类 名词 做主语或宾语 动词 只能做谓语 形容词 通常做定语 副词 做状语 用来修饰动词或形容词 甚至可以修饰另一个副词 graph LR;A[词汇分类]--&gt;B[名词];B --&gt; 做主语或宾语;A --&gt; C[动词];C --&gt; 只能做谓语;A --&gt; D[形容词];D --&gt; 通常做定语;A --&gt;F[副词]F --&gt;做状语;F --&gt; 修饰动词或形容词;F ---&gt; 修饰另一个副词名词 修饰 动词动词 修饰 名词形容词 修饰 名词副词 修饰 形容词副词 修饰 动词副词 修饰 副词词性的本质名词:用来描述能够感知的事物,不论抽象还是具体动词:描述能够感知的动作,不管抽象还是具体形容词:用来描述能够感知的那个事物的感知副词:在修饰动词时,作用和形容词修饰名词一样,描述对那个动作的感知副词修饰形容词时,作用是用来描述对感知的那个事物的感知的感知副词修饰副词时,作用描述你对感知的那个事物的感知的感知的感知到底应不应该弃用副词副词是用来描述一种深层的感知,用好比较困难,需要练习读者在理解副词的时候会遇到困难描述的本质在诚实的情况下，你根本无法描述你感知不到的事物如何钻入作者的脑子把一篇文章所有的名词拿出来,如果所有名词都是具体名词,没有抽象名词,说明这个人受教育程度非常低,因为没有理解任何抽象概念一个人受教育程度的高低就看能够理解多少清晰准确且必要的概念看完名词,把修饰这些名词的形容词找出来,如果没有任何形容词说明这个人感知能力非常差,如果有,但不准确,依旧说明非常差,有且很准说明不光感知能力强,表达能力也强写作的本质写作的本质就是记录感知进一步让读者通过我们的文字获得感知再进一步让读者通过我们的文字获得我们想要他们获得的感知作业1 标注文章词性每天拿出一篇文章,不管说理文还是小说,还是散文亦或是纪实文学,只要是文字拿出笔用圆圈画出名词,下划线画出名词前的形容词按照上课讲的方式思考这个作者抽象概念占比大概是多少,他的感知能力好坏两三年之后会发现看到的东西和别人看到的内容完全不一样,感知能力不断增强作业2 读文章反问几个问题读任何文章,问自己以下几个问题,认真用纸笔写下能够想到的答案 作者想要向我传达什么感知? 他做的成功么? 如果我是他,我会怎么做才更有效? 作业3 每天写小短文描述自己的感知每天做一次练习,用300-500词描写一个特定的感知,不管是视觉的还是听觉的,嗅觉的触觉的,还是脑子里的震撼,可能来自于路上遇到的人或事,也可能来自于读者或者听众,你的体验专注于某一个感知,用300-500词写清楚,还要自我分辨,自己的文字是否真的能够有效传递感知第02课 一切创作的前提都是选择创作的门槛到底高不高?伪专家强调天赋创作实际上是0门槛的发行渠道才是真正的门槛,过去出版商很少,很难出版你的书籍后去中心化时代的渠道?去中心化的意思并不是消灭所有的中心，而是当初唯且最大的中心”最终逐步被“多个相对较小的中心所替代”渠道成本降低到几近为零创作是零门槛的，过去真正门槛是渠道虽然创作是零门槛的，可是你的观众、你的听众你的读者究竟在哪里？没有受众的创作者最可怜你误以为你得先学会创作才能做其他的事情究竟写什么？写什么远比怎么写重要一万倍千万不要被李笑来限制住选择比努力重要一万倍人们误以为选择是属于当下的,事实上,选择属于未来做出了选择实际上生命中相当长一段时间会因为这个选择而变化非要讲道理怎么办？我写的东西到底对别人有没有用？我写的这些东西在十年后是否依然对读者有用？我写的这些东西在廿年、三十年后后是否依然对读者有用？为什么别人会觉得你写的东西有用,就是因为未知讲故事讲究新奇特,3个字你仔细研究一下就会发现都是关于未知的,最终这肯定是少数人的选择,只有这样极致的标准要求自己,你才有可能真正有出息,否则就算能够热闹一时也早晚泯然众人矣如何边进步边练习?因为在未知原则这个前提下向受众提供价值的方法除了提供新认知,还有加深旧认知最快最容易上手的方法就是做教程任何事的教程,分为以下内容最基础的 HOW再高级一点就是WHY当然最高级的是WHAT作业 1 回忆你遇到过的最好教程？作业 2 你需要的教程别人写的好不好？作业 3 如果你自己写，你能写成什么样？真正的作业作业 4 开始动手写100篇教程作业 5 不停搜集反馈。。反复揣摩修改教程建立渠道很重要,但这是写作课,具体的建立渠道可以看微信互联网平民创业随处可见如何创建渠道,如何维护渠道的方法论第03课 怎么写?所谓格式化创作是什么？如何定义？不是什么?之类似的是什么？怎么用？常见用法有哪些用的时候需要注意什么？怎么用是错的？常见错误都有哪些？练习“鸡尾酒效应”一切的教材都是非常格式化的教辅书籍的“模版 重点都有哪些？ 针对每一个重点最常见错误都有哪些？根源是什么？ HOW5W1H -&gt; 2W1HWho,Where,When ∈ WhatWhat/Why/How描述清楚任务描述清楚步骤)用的油比别人多一点；2)蛋也多几个；3)蛋并不全部搅匀；4)把蛋倒进锅里用筷子快速搅成丝；5)加盐（以前也用过方便面料）6)用冷饭，放进锅，调小火，翻炒直至颗粒分清1.细致完整2.新颖1)打两个鸡蛋；2)放一点葱花；3)撒一点咸盐；4)把剩饭放进去拌匀；5)在平底锅里放一点油：6)点火；7)油开之后把拌好的米饭鸡蛋糊倒进平底锅：8)细火，像煎葱花饼一样煎透，使米饭鸡蛋糊呈金黄色；9)放到盘子里，用刀切成长条；10)用手抓着吃。如何出彩？ 细致完整 新颖 神评论WHY现象/解释问题/解决分析/结论WHY的创作难度,并不在于文字本身,而是在于底层的逻辑严谨安慰剂双盲测试人至践则无敌逻辑差的人啥都干不好形式逻辑分类类别之间的排它性类别集合的完整性比较属于同一范畴拥有相同属性因果A是B的理由嘛？A是B唯一的理由嘛？A如果不是B的唯一理由那么，请问最重要的理由是什么？非形式逻辑政客大多是骗子川普是个政客那么川普在多大程度上是个骗子呢？第04课第05课第06课第07课第08课" }, { "title": "《Effective Java 3th 》读书笔记", "url": "/posts/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "读书笔记", "date": "2022-09-15 20:48:00 +0800", "snippet": "", "content": "" }, { "title": "《如何达成目标》读书笔记", "url": "/posts/%E5%A6%82%E4%BD%95%E8%BE%BE%E6%88%90%E7%9B%AE%E6%A0%87-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "读书笔记", "date": "2022-09-14 23:35:00 +0800", "snippet": "引言为什么大家设定的目标最后无法实现,大多数人找错根本原因,人人都能更加成功达成目标成功者和自制力的悖论每个人都有自制力,区别就是高低水平最令自己感到自豪的成就,都不是轻松完成的,必须付出艰苦卓绝的能力,这就需要自制力自制力到底是怎样的自制力类似肌肉需要锻炼得到增强,过度压榨自制力,肯定会疲惫无法控制自己你能做什么刚开始控制抵抗点心,一根烟,烦人的任务,感觉煎熬,过了一会,自制力恢复,变得没...", "content": "引言为什么大家设定的目标最后无法实现,大多数人找错根本原因,人人都能更加成功达成目标成功者和自制力的悖论每个人都有自制力,区别就是高低水平最令自己感到自豪的成就,都不是轻松完成的,必须付出艰苦卓绝的能力,这就需要自制力自制力到底是怎样的自制力类似肌肉需要锻炼得到增强,过度压榨自制力,肯定会疲惫无法控制自己你能做什么刚开始控制抵抗点心,一根烟,烦人的任务,感觉煎熬,过了一会,自制力恢复,变得没那么难熬以奖励的方法增强动机，可以弥补短时间内消耗的自制力。把目标以外的奖励方式作为实现目标的重要部分本书的主题在于描述如何实现目标,自制力是其中重要一环第一部分 准备就绪第1章 你明白自己去往哪里吗首先,要确定目标,其次,清楚如何实现目标别说“做到最好 ”“做到最好”这个目标一般用什么目标替代”做到最好”?明确而艰巨的目标为什么明确而艰难的目标比“做到最好”更能激发人们的动力呢？“明确”:明确期望值,免得告诉自己,已经做的足够好了,可以歇一歇,达成和未达成之前不存在中间地带“艰巨”:会使自己付出更大的努力,更加聚精会神,坚持的更久大局与细节每次行动或目标,有不同的方式进行理解注重”为什么”要做,习惯用抽象的方式理解行为 掌握代数注重”是什么”要做,习惯看重实际 题目做对什么时候要用”为什么”,什么时候要用”是什么”?“为什么”:更加抽象,让人充满激情,一件事与更大的意义联系在一起“是什么”:更加具体,在解决一件困难,生疏,复杂的事情更有帮助怎样从”为什么”的角度思考 写下一件你最近由于缺乏动力或者诱惑太多而无法完成的事。 现在，写下你“为什么”想做这件事。 你个人的目的是什么？这样做能帮助你实现什么？你怎样从中受益？ 等你下次再试着做这件事时，停下来想一想你刚刚总结的“为什么”。反反复复地这样做，直到它成为习惯为止。（它会成为习惯的。只要反复去做，任何简单的行为，都能变成习惯，做起来易如反掌，只要你肯坚持。）怎样从“是什么”的角度思考? 写出一件你想做却特别复杂、困难或者陌生的事。 现在，写下你第一步应当做什么。 为了开始追求那个目标，你需要采取的具体行动是什么？ 等你下次再尝试做这件事时，停下来想一想你刚刚总结的需要采取的下一个具体行动，并且聚精会神地做。这很快也会成为一个习惯。现在与将来一方面，我们偏向于用大而抽象的概念（强调“为什么”）来考虑较长时间以后才会执行的计划；另一方面，在考虑近期的计划时，我们往往更加具体，也就是更加专注于做好这件事需要做的“是什么”graph LR;A[远期的计划]--&gt;B[为什么] --&gt;E[合意度];C[近期的计划] --&gt; D[是什么] --&gt;F[可行度];合意度:关注这些事情有多有趣,多愉悦,多有益可行度:是不是真的能做好,有多大把握取得成功,有什么会阻碍你完成合意度和可行度在远期和近期计划上的错位,是一些人痛苦的根源关注合意度,不考虑可行度,就会安排些看起来不错,实际没有可能执行的计划关注可行度,不考录合意度,就会安排些较为简单的任务,忽视一些对提升自己更有价值的任务积极思考的利与弊积极思考有两种 相信自己能成功 想象自己能轻而易举地成功，并且抗拒诱惑和克服障碍有害的积极思考使得人们对完成计划盲目乐观,认为轻轻松松实现为什么相信成功道路艰险对实现目标那么重要?焦虑和担心,这种负面情绪能给人带来很强的动力树立并实现目标，而非陷入白日梦中，最好的方法是什么呢？设定目标时积极地思考你已经实现目标时的情景，同时切合实际地思考在实现目标的过程中需要做些什么,又称”心理对照”“心理对照”什么时候有用?当全心全意相信你确实能够完成的目标时有用成功率高时,增强实现目标的决心,成功率不高时,认清形势,放下包袱继续前行运用”心理对照”确定目标1.拿起笔记本或者一张纸，写下你最近产生的愿望或想法。 这可以是一件你想要做或是已经开始做的事情（例如去加勒比海度假、搬到洛杉矶去当一名编剧，或者减掉四五千克体重）。2.现在，想象一下愿望实现时的美好结局。 写下这个美好结局一个方面的好处（比如你可以不去查收电子邮件，惬意地躺在沙滩上放松身心，该是多么的美好）。3.接下来，想一想你现在的状况与这个美好结局之间还存在些什么障碍（比如，我现在有些胖，而我的美好结局是减掉四五千克体重，这两者之间的障碍是我格外喜欢吃奶酪）。4.现在再列出另一个方面的好处。5.接着列出另一个障碍。6.然后再列出一个方面的好处。7.再列举一个障碍。你觉得你取得成功的概率有多大？你应该追求这个目标吗？通过将你一定会获得的好处与妨碍你实现目标的障碍进行一番对比，你就能更清楚地知道自己成功的把握有多大，也知道自己有多大的决心去实现这个目标。第2章 你知道目标来自哪里吗搞清目标有什么不同,哪种目标适合自己,如何帮助自己改变目标首先要先理解,已经确定的目标来自于哪里,诚实而客观的评估他们,自由地做出不同的选择信念如何塑造成功对自己能力的信念影响着对可能发生事情的认知,还影响我们能创造的成就看待智力能否提高,把人分成实体论者和渐变论者实体论者:智力是或多或少与生俱来的、很大程度上是遗传的，或者是在儿童时期培育起来，但成年以后基本保持固定不变的渐变论者:相信智力是一种能够借助经验和学习来提升的品质，通过努力，你能够获得更多的智力导致后果实体论者:过于担心自己能不能获得别人的认可。只要有可能，他们希望别人确信他们聪明（或者，最起码不愚蠢）2他们想让自己给人感觉很聪明。他们想让自己看上去充满智慧。会避开那些过于艰难的目标，喜欢在更安全的赌局上下注。渐变论者:不会太过执拗地证明你很聪明，而是努力培育自己的智慧。挑战对你来说不是威胁，而是学习新技能的机会。犯错并不代表你很愚蠢，相反，你会觉得错误本身充满了有助于你学习和成长的东西。确实是江山易改、本性难移吗我们如何摆脱困境回想自己有没有逃避困难,谨小慎微,固守容易达到的目标,有没有一件事你很久以前就认定自己永远也不擅长的?有没有一些技能是你认定自己永远也掌握不了的,类似的事越多越说明自己是个实体论者实体理论并不正确,而且彻底错误,务必挣脱这套理论对自己成长的束缚,你，处在自动导航模式有意识思考的事情都是少数,越熟练的事会交给潜意识,大多数思考都是潜意识完成,潜意识根据周围的环境信息暗示,做出反应,甚至没有意识到自己在追求这个目标触发因素的神奇之处让潜意识思维为你所用第二部分 预备开始第3章 使人们不断前进的目标当你以展示才华为目标时当你以谋求进步为目标时哪种目标对我最有益解决困难大学医学预科班学生与毅力享受过程寻求帮助情绪低落也能催人奋起第4章 乐观者和悲观者的目标被爱与保持安全积极思考（或者，也许不必）保持动力乐观主义者与悲观主义者是如何形成的进取、防御与优先性你的焦点和你的感觉适合你目标焦点的策略运用合适的策略一个目标的优势是另一个目标的劣势第5章 让你幸福的目标我们真的需要什么我们真的不需要的目标这到底是谁的目标如何营造自主选择的感觉如何把别人规定的目标转化为自己的目标第6章 选择适合自己的目标当你觉得不费吹灰之力时当你需要鞭策时当前路十分坎坷时当你无法抗拒诱惑时当你本该昨天做完时当你需要完美地完成任务时当你需要创意像流水般动起来时当你想欣赏沿路景色时当你想要真正的快乐时第7章 帮助他人设立最佳目标直接方法运用提示信号图画在这里，请选框架目标感染第三部分 行动起来第8章 扫除障碍把握当前时机保护目标我做得怎么样你需要的太少了，不需要的太多了第9章 制订计划圣诞节的文章“如果……那就…… ”计划的力量这还不是全部……为什么简单的计划却能奏效第10章 增强自制力启动自制力恢复自制力面对消耗一空的自制力最后的警告：别去挑战命运第11章 切合实际的乐观总看到生活的光明一面但要警惕黑暗的一面……增强乐观精神第12章 懂得坚持怎样才能坚持不懈亚洲人不同的地方懂得何时放手第13章 给予反馈当表现不尽如人意时当表现令人满意时结语额外收获成功人士与众不同的9种做法目标故障诊断与解决" }, { "title": "CFA前导课", "url": "/posts/cfa%E5%89%8D%E5%AF%BC%E7%8F%AD/", "categories": "", "tags": "", "date": "2022-09-09 19:29:00 +0800", "snippet": "01-框架介绍+金融英语01-金融框架+金融英语CFA全称 charted financial analyst主流市场上有两类分析师第一类 sell side 卖方分析师 券商,投行研究院(不承诺业绩) 原则上卖方研究院通常不与业务挂钩,往往一些券商会让研究院的报告质量和经济业务挂钩 经济业务:大家拿钱去券商开户,券商帮你做投资,开一个资金账户一个证券账户,他会收取佣金 投行业务不能...", "content": "01-框架介绍+金融英语01-金融框架+金融英语CFA全称 charted financial analyst主流市场上有两类分析师第一类 sell side 卖方分析师 券商,投行研究院(不承诺业绩) 原则上卖方研究院通常不与业务挂钩,往往一些券商会让研究院的报告质量和经济业务挂钩 经济业务:大家拿钱去券商开户,券商帮你做投资,开一个资金账户一个证券账户,他会收取佣金 投行业务不能挂钩 投行业务是承销做IPO或者兼并收购业务 如果有内幕消息,偷偷告诉研究员,出了一个非常有价值的报告,对别的研究院不公平 劝说别的工资负责人把IPO业务放到我投行部门来做,研究部给一个买入建议,并不独立客观 第二类 bey side 买方分析师 基金经理(对业绩承诺)CFA一级,二级培养卖方分析师CFA三级 自负盈亏的基金经理一级和二级 三级主要的区别?一级的题干会比较的短一些二级考察的叫做case题,通常情况下是给你一页或者说两页A4纸,当中呢会描述一个场景,后面会跟着六道或者四道题目三级分为两部分,第一个部分写作题 essay 不需要完整的写出什么东西,只要达到对应的考点,关键字就能拿分,第二部分案例题,三级呢可能要两到三页A4一级基本上是以广度取胜的一个考试,以定性的概念题为主,计算量呢相对来说是比较低的二级主要培养的就是sell side,教研究员怎么样去写报告的,相关的一些理论知识,思维方法,涉及很多数学吗模型,对股票有一个估值三级主要培养的就是买方,写IPS, investment policy statement (投资策划建议书/投资政策声明)规定好我资金经理和客户两者之间的权利义务,了解客户相关的方方面面的基本情况七块内容 R R T T L L Uobjectives 目标 R : return 收益 R : risk 风险在给定了风险承受力下决定你的收益目标constrain 限制 T : time horizon 投资期限 T : tax 税务问题 L : liquid needs 流动性需求(大额的不定时的现金流出,某一个时间点一次性的这个支出) L : legal and regulatory 法律法规相关 个人投资者不能投资IPO 银行这种低风险承受力的机构不能去投资一些高风险的另类投资或者说衍生品 U : unique circumstances 客户的特殊要求分析师要分析一家公司好还是不好,两种分析思路 bottom-up 自下而上 小散户的思路,出了一个利好消息就去买,利空消息去卖 top-down 自上而下 从最最上层宏观经济进行分析,整体这个国家的经济表现,经济周期是属于哪一个阶段,第二步就是分析行业,经济好的时候投资一些周期性的行业, 经济不好的时候投资一些教育医疗这种防御性的行业,第三步在好的行业当中选择表现好的个股 IPS后就是执行第一步是做资产大类的配置(Asset Allocation)每一项大类资产要投资多少权重第二步细分的个体股票的配置呢 security selection第三步构建组合 PAFOLIO construction执行完就是反馈反馈就是跟踪,关注我整体组合的一个收益第一件事:计算业绩,收益多少,风险多少第二件事:评估一下基金经理的业绩,找到一个 benchmark(基准业绩) 和基金经理的真实业绩去进行比较用大盘股指的业绩作为 benchmark ,假设大盘股指的收益率是8%,基金经理给我带来的收益率呢是10%,投资组合的真实业绩,超过这个 benchmark 8%的部分就是我们所说的 $\\alpha$\\[\\mathop{\\alpha}\\limits_{abnormal\\ return} = \\mathop{R_p}\\limits_{10\\%} - \\mathop{R_B}\\limits_{8\\%}\\]中文称为超额收益基金经理的主要目的就是要怎么样获取超额收益,如果这个基因经理的业绩还不如这个指数表现的好肯定不会找他做投资啊,直接买指数基金就好只有当你真实的业绩超过这个基准业绩benchmark的时候才觉得你表现的比较好三级有50%的题目教你怎么样去构建组合CFA考试科目graph LR;A[Ethical &amp; Professional Standards]--&gt;B[Ethical &amp; Professional Standards];道德是CFA骄傲的部分,都是英文法律法规一级学完,二三只需要复习graph LR;A[Investment Tools投资工具]--&gt;B[\"Quantitative Methods数量(数学)\"];B --&gt;D[统计学];B --&gt;E[概率论];A --&gt; F[Economics];F --&gt; H[\"微观经济学(行业结构判断)\"]F --&gt; H1[宏观经济学]A --&gt; C[Financial Reporting Analysis];A --&gt; G[Corporate Finance];一级数学不难,稍微删除大学数学分析一家公司从两个角度来判断,1.从外部分析师,对公司不太了解的人认识公司就是看财报站在内部管理者角度, 第一 钱从哪里来,资金来源 从银行接的钱,是debt 从股东拿的钱是equity 公司希望尽可能低的融资成本,就会决定发债和发股的比例一级研究平均的融资成本是怎么计算的第二 钱怎么花?评价一个项目好坏的五个指标企业理财中详讲第三, 公司组织架构架构是否合理能不能使所有利益相关者利益最大化graph LR;A[Asset Classes -Valuation]--&gt;B[Equity Investments股票];A --&gt; C[Fixed Income固定收益,债券];B --&gt; F[traditional传统投资]C --&gt; F;A --&gt;D[Derivatives衍生品,期权期货];A --&gt;E[Alternative Investments其他类投资产品];graph LR;A[Portfolio Management]--&gt;B[Portfolio Management];确定各种投资品的权重道德和财务报表分析是重点CFA考试流程需要的时候再来查视频讲解02-科目框架道德的题目3分钟一道题道德 Framework of Ethics Code of Ethics 总纲性条款,高的要求,做不到也无法惩罚 Guidance for Standards I-VII 七条准则,最低要求 Ⅰ.Professionalism 职业精神 展开 Knowledge of the law;对法律法规了解 Independence and objectivity;独立客观 Misrepresentation;不当陈述 Misconduct欺诈行为 Ⅱ.Integrity of capital markets (天) 对资本市场正直诚信 展开 Material nonpublic information;非公开信息,内幕消息MNI Market manipulation操纵市场 Ⅲ.Duty To clients(地) 展开 Loyalty,prudence and care;忠诚, 审慎关心 Fair dealing;公平对待 Suitability;合适性 Performance presentation业绩诚实 Preservation of confidentiality保密义务 Ⅳ.Duty To employers(人) 展开 Loyalty; Additional compensation arrangements;额外收入兼职 Responsibility of supervisors保证手下员工合规 Ⅴ.Investment 展开 Diligence and reasonable basis;勤勉尽责 合理依据 Communication with clients; Record retention 记录保存 Ⅵ.Conflicts of interest 利益冲突interest1.利息,2.利益 展开 Disclosure of conflicts; 披露冲突 Priority of transaction;客户交易优先 Referral fees介绍费 Ⅶ.Responsibility as members 展开 Conduct as members and candidates; Reference to CFA institute,designation Global Investment Performance Standards(GIPS)全球业绩衡量标准 教基金经理怎么样去汇报业绩(自愿) Framework of Quantitative Methods The Time Value of Money 货币的时间价值 市面上各种利率 年金,时间间隔,方向,数量相同,称为年金 Application of Discounted Cash Flow Statistical Concepts and Market Returns Probability Concepts 概率论 Common Probability Distributions Sampling and Estimation 抽样 Hypothesis Testing 假设检验 Technical Analysis Framework of Economics Topics in Demand (需求) and Supply(供给) Analysis The Firm and Market Structures Aggregate Output,Price,and Economic Growth Understand Business Cycles Monetary and Fiscal Policy 货币和财政政策 International Trade and Capital Flows Currency Exchange Rates Framework of Financial Statement Analysis Introduction Introduction to Financial Statement Analysis Financial Reporting Standards ✔Three major financial statements 站在会计角度衡量 Income Statement 利润表(I/S)损益表 净赚多少钱 Balance Sheet 资产负债表(B/S) Cash Flow Statement 现金流量表 (CFS C/F) Financial Analysis Techniques 财务报表分析技术 ✔Specific categories in financial statements 站在分析师需要关注几个容易被操纵的点 Inventories 存货:代表的是公司生产出来要卖的这部分商品 Long–lived Assets 长期资产 一年以上的固定资产 Income Taxes Non-current Liabilities 长期负债 Financial Reporting Quality and Financial Statement Analysis应用 Framework of Corporate Finance 公司金融,企业理财 Introduction to Corporate Governance and Other ESG Considerations Capital Budgeting 资本预算 Working Capital Management 营运资本 对短期资产和短期负债的管理 Cost of Capital 融资成本 Measures of Leverage 杠杆 经营杠杆 财务杠杆 总杠杆 03-科目框架201 Framework of Equity 权益类投资 Equity Market Introduction 重点Market Organization and Structure 分类/资产/头寸/指令 Security Market Indices 市场指数 Market Efficiency Equity Analysis and Valuation Overview of Equity Securities Introduction to Industry and Company Analysis Equity Valuation:Concepts and Basic Tools Discounted cash flow models Multiplier models Asset-based models Framework of Fixed Income 各种债券 Basic Concepts Fixed-Income Securities:Defining Elements 定义元素 Fixed-Income Markets:Issuance,Trading,and Funding 发行,交易,融资 Introduction to Fixed-Income Valuation 估值 Introduction to Asset-Backed Securities 资产支持证券 Analysis of Risk Understanding Fixed-Income Risk and Return Duration 久期(一阶导)&amp; Convexity 凸性(二阶导) Fundamentals of Credit Analysis Framework of Derivatives 衍生品 Derivative Markets and Instruments Forward Futures Option Swap Other derivatives(credit derivatives,e.g.credit default swap) Basics of Derivative Pricing and Valuation Risk neutral approach 风险中性定价方法 Put call Parity 买卖权的一个评价理论 Framework of Alternative Investments 另类投资 Introduction to Alternative Investments Hedge funds 对冲基金 风险大 净资产千万以上 Funds of funds FOF 本质还是对冲基金,购买其他对冲基金 使用比较穷投资者, Fee structures 费率高 Private equity 私募PE 投资非上市公司 Venture capital 风投 投资相对初创企业,未来有了退出机制就可以赚很多,失败率高 LBO 杠杆收购 空手套白狼 相对成熟,风险小,收益较低 Real estate 房地产 REITs Performance,diversification Commodity 大宗商品 Investment vehicles Futures pricing Infrastructure 基建 Other alternative instruments Framework of Portfolio Management 组合管理 Portfolio Management:An Overview Classical Portfolio Theory Modern Portfolio Theory 现代组合管理理论 Capital Market Theory 资本市场理论 Basics of Portfolio Planning and Construction 教如何写IPS Portfolio Construction Procedure Investment Policy Statement Introduction to Risk Management 风控 分散风险 FRM更多研究风险发生该概率 Technical Analysis Fintech Investment Management 金融科技 03-科目框架202 03-科目框架203 04-金融英语 02-财务前导01-框架介绍02-资产负债表利润表03-现金流量表三大支柱04-RatioAnalysis0104-RatioAnalysis0204-RatioAnalysis0303-数量前导+金融计算01-利率的构成02-EAR0102-EAR0202-EAR0303-年金NPVIRR均值方差04-概率论推断性统计学0104-概率论推断性统计学0204-概率论推断性统计学0301-Calculator Guidance01-Introduction02-Setting Up the Calculator &amp; Memory Functions03-Time Value of Money04-Capital Budgeting05-Statistics(Standard Deviation)06-Linear Regression and Covariance07-Probabilities02-Time Value of Money01-Interest Rate（1）02-Interest Rate（2）03-Present Value and Future Value(1)04-Present Value and Future Value(2)05-Evaluation of Cash Flow Stream06-Return &amp; Yield Measurements03-Ethics01-Introduction02-I(B) Independence &amp; Objectivity03-I(C) Misrepresentation04-I(D) Misconduct05-II(A) Material Nonpublic Information06-III(B) Fair Dealing07-III(C) Suitability08-III(E) Preservation of Confidentiality09-IV(A) Loyalty10-V(A) Diligence and Reasonable Basis11-VI(A) Disclosure of Conflicts12-Responsibilities as a CFA member or candidate04-Quantitative Method01-Quantitative MethodsApplication02-Statistical Concept03-Central Tendency(1)04-Central Tendency(2)05-Dispersion06-Probability Concepts07-Bayes’Formula08-Discrete Distribution09-Continuous Distribution10-Sampling11-Point Estimate12-Confidence Interval13-Hypothesis tes05-Economics01-First Insight to Economics02-Demand and supply（1）03-Demand and supply（2）04-Consumer Demand05-Supply Analysis The Firm06-The Firm and Market Structures07-Aggregate output, price, And Economic Growth08-Understanding Business Cycles09-Monetary and Fiscal Policy10-International Trade06-Equity Investments01-First Insight into Equity Investments02-Financial System and Assets (1)03-Financial System and Assets (2)04-Positions and Buy on Margin05-Classification of Financial Markets06-Financial Intermediaries07-Security Market Indices08-Market Efficiency09-Overview of Equity Securities10-Introduction to Industry Analysis11-Equity valuation07-Portfolio Management01-Brief Introduction02-First insight to Portfolio management03-Investment Clients：Individual Clients04-Investment Clients：Institutional Clients05-Asset Allocation（1）06-Asset Allocation（2）07-Security Selection08-Fixed Income01-First Insight to Fixed Income02-Fix Income structure03-Bond Valuation-YTM04-Bond Valuation-Spot Rate05-Bond Valuation-Forward Rate06-Fixed Income Risk and Return（1）07-Fixed Income Risk and Return（2）08-Introduction of SecuritizationMBS09-Introduction of SecuritizationCMOs09-Derivatives01-First Insight to Derivatives02-Forward03-Futures04-Option05-Swap10-Financial Statement Analysis01-人生就是要折腾02-The Source of Financial Accounting03-The Importance of Financial Analysis04-Brief Introduction FRA in CFA Exam05-Accounting Standard and Regulation06-Accounting Elements07-Relationship Among Account Elements08-Accounting Equation09-Double-entry Accounting10-Overview of Income Statement11-Long-term contracts12-Bater Transaction ,gross or net reporting of revenue13-Inventory Valuation Method14-Depreciation Expense15-Current Asset16-None-Current Assets17-Financial Assets18-Current Liabilities19-None-Current Liabilities20-Format of Cash Flow Statement21-Classification of Cash Flow22-Cash Flow Classification &amp; Free Cash Flow23-Statement of Owner’s Equity24-Financial Report Footnote25-Management’s Discussion and Analysis26-Audit Report27-SEC Filings28-Techniques of Financial Analysis29-Financial Ratio and Limitation30-Profitiability Ratio31-Activity Ratios32-Liquidity Ratios33-Solvency Ratios34-Valuation Ratios36-Cash Conversion Cycle35-DuPont Analysis" }, { "title": "英语语法新思维-3-驾驭语法", "url": "/posts/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%96%B0%E6%80%9D%E7%BB%B4-3-%E9%A9%BE%E9%A9%AD%E8%AF%AD%E6%B3%95/", "categories": "语法, 新思维", "tags": "语法, 英语", "date": "2022-09-08 22:57:00 +0800", "snippet": "序言第一章 名词从句1.1 名词从句的本质1.1.1 名词从句的本质：三种句子充当四种成分1.1.2 引导名词从句的常用连词1.2 主语从句1.2.1 that引导的主语从句1.2.2 whether及连接代词或连接副词引导的主语从句1.2.3 because引导的主语从句1.3 宾语从句1.3.1 在及物动词后作宾语1.3.2 在双宾动词后作直接宾语1.3.3 在双宾动词后作间接宾语1.3...", "content": "序言第一章 名词从句1.1 名词从句的本质1.1.1 名词从句的本质：三种句子充当四种成分1.1.2 引导名词从句的常用连词1.2 主语从句1.2.1 that引导的主语从句1.2.2 whether及连接代词或连接副词引导的主语从句1.2.3 because引导的主语从句1.3 宾语从句1.3.1 在及物动词后作宾语1.3.2 在双宾动词后作直接宾语1.3.3 在双宾动词后作间接宾语1.3.4 在介词后作宾语1.3.5 宾语从句后置1.3.6 that在宾语从句中省略的问题1.4 表语从句1.5 同位语从句1.5.1 同位语从句句型（一）：名词+that+陈述句1.5.2 同位语从句句型（二）：名词+定语+that+陈述句1.5.3 同位语从句句型（三）：名词+谓语+that+陈述句1.6 从句的“嵌套结构”1.6.1 名词从句的“嵌套结构”1.6.2 连词与动词的配比原则第二章 定语从句2.1 先行词的结构特点2.1.1 先行词是一个词2.1.2 先行词是一个短语2.1.3 先行词是一个分句2.1.4 先行词是一个完整的句子2.2 先行词的位置特点2.2.1 先行词+其他定语+定语从句2.2.2 先行词+状语+定语从句2.2.3 作主语的先行词+谓语部分+定语从句2.3 如何判断先行词2.4 与先行词有关的考点2.4.1 先行词的选择2.4.2 关系词的翻译2.4.3 关系词的选择2.4.4 定语从句中的主谓一致问题2.5 关系代词which/that/who/whom2.6 关系代词whose2.7 介词+关系代词2.7.1 看从句选介词2.7.2 看先行词选介词2.7.3 看句义选介词2.7.4 表示所属关系或部分与整体的关系时用介词of2.7.5 固定的介宾结构2.7.6 定语从句的倒装结构2.7.7 “介词+关系代词+to do”结构2.8 关系代词as2.8.1 as引导非限定性定语从句2.8.2 as引导限定性定语从句2.9 关系代词than2.10 关系代词but2.11 缩合关系代词what2.11.1 使用关系词what的前提：what的前面不能有先行词2.11.2 what单独使用，即其后面可以不接名词2.11.3 what的后面可以接名词2.11.4 what用在一些固定结构中2.12 关系副词when2.12.1 用when引导定语从句，其先行词必须是表示时间的名词2.12.2 先行词表示时间时，不一定都用when引导定语从句2.12.3 如何区分when引导的定语从句与when引导的时间状语从句2.13 关系副词where2.13.1 用where引导定语从句，其先行词通常是表示地点的名词2.13.2 先行词表示地点，不一定都用where引导定语从句2.13.3 where引导定语从句，先行词可以是含有地点意义的其他各种名词2.13.4 如何区分where引导的地点状语从句和定语从句2.14 关系副词why2.15 关系副词有how吗?2.16 关系词后带有插入语的定语从句2.16.1 定语从句的关系词后面插入一个主谓结构2.16.2 定语从句的关系词后面插入一个其他成分2.17 并列定语从句2.18 双层定语从句第三章 状语从句3.1 状语从句的本质3.2 状语从句的省略3.3 时间状语从句3.3.1 时间连词when的用法特点3.3.2 时间连词while的用法特点3.3.3 时间连词as的用法特点3.3.4 时间连词before的用法特点3.3.5 时间连词after的用法特点3.3.6 时间连词since的用法特点3.3.7 时间连词until的用法特点3.3.8 表示“一……就……”的结构3.3.9 时间连词by the time的用法特点3.3.10 一些表示时间的名词短语引导的时间状语从句3.4 地点状语从句3.5 原因状语从句3.5.1 常见连词的用法3.5.2 用介词表示因果关系3.5.3 其他复合连词表示原因3.5.4 because的否定转移3.6 目的状语从句3.6.1 常见连词的用法3.6.2 目的状语从句的简化3.6.3 其他连词的用法3.7 结果状语从句3.7.1 常见连词的用法3.7.2 比较so与such的区别3.7.3 结果状语从句的简化3.7.4 结果状语从句的倒装3.7.5 其他短语连接的结果状语从句3.8 条件状语从句3.8.1 常见连词的用法3.8.2 only if与if only3.8.3 must/have to do…if…be to do结构3.8.4 其他条件从句的连词3.8.5 其他表示条件意味的句型3.9 让步状语从句3.9.1 常见连词的用法3.9.2 表示让步转折关系的介词和副词3.9.3 置于句首的while一般表示“尽管”3.9.4 no matter wh-3.9.5 as引导的倒装句表示让步3.9.6 as/so+形容词+as +主谓结构，放在句首表示让步3.9.7 句首用be的倒装句表示让步3.10 比较状语从句3.10.1 连词as 的基本用法3.10.2 as句型一：as much as结构3.10.3 as句型二：not so much…as结构3.10.4 as句型三：(just) as…, so结构3.10.5 连词than的基本用法3.10.6 no more…than结构3.10.7 表示倍数比较的三种句型结构3.10.8 the more…, the more结构3.10.9 A is to B what/as C is to D结构3.11 方式状语从句第四章 不定式4.1 非谓语动词概述4.2 不定式的作用（一）：作主语（It + to do）4.2.1 不定式放在句首作主语4.2.2 不定式放在句末作主语4.3 不定式的作用（二）：作宾语（动词+to do）4.3.1 结构一：动词+to do4.3.2 结构二：动词+疑问词+to do4.3.3 结构三：动词+it+宾语补足语+to do4.4 不定式的作用（三）：作宾语补足语（动词+宾语+to do）4.5 不定式的作用（四）：作定语（名词+ to do）4.5.1 宾语关系4.5.2 主语关系4.5.3 同位语关系4.5.4 状语关系4.5.5 补语关系4.6 不定式的作用（五）：形容词+to do4.6.1 宾语关系（一）：He is interesting to listen to.4.6.2 宾语关系（二）：The book is interesting to buy.4.6.3 主语关系（一）：He is kind to help us.4.6.4 主语关系（二）：He is glad to help us.4.6.5 主语关系（三）：He is slow to react.4.7 不定式的作用（六）：作状语4.7.1 目的状语4.7.2 结果状语4.7.3 条件状语4.7.4 原因状语4.8 不定式的作用（七）：独立使用的不定式4.8.1 不定式作独立成分4.8.2 不定式引导独立的句子4.9 不定式的逻辑主语4.9.1 何谓逻辑主语4.9.2 不定式逻辑主语的构成（一）：for+名词或代词+to do4.9.3 不定式逻辑主语的构成（二）：of sb. to do4.10 不定式的时态和语态（一）：被动式（to be done）4.10.1 不定式时态/语态简介4.10.2 被动不定式4.10.3 双重被动式4.11 不定式的时态和语态（二）：完成式（to have done）4.11.1 表示在谓语动作之前发生的动作4.11.2 表示“非真实的”过去4.11.3 偶尔表示将来的动作4.12 不定式的时态和语态（三）：进行式（to be doing）4.13 不定式的时态和语态（四）：完成进行式（to have been doing）4.14 省去to的不定式4.14.1 在某些动词的复合宾语中4.14.2 在特定的句型结构中第五章 动名词5.1 动名词的作用（一）：作主语5.1.1 动名词位于句首作主语5.1.2 动名词位于句末作主语5.2 动名词的作用（二）：作宾语5.2.1 在动词后面作宾语5.2.2 在介词后面作宾语5.2.3 在特定的句型中作宾语5.3 动名词的作用（三）：作表语5.4 动名词的作用（四）：作定语5.5 动名词的逻辑主语5.5.1 动名词复合结构的构成5.5.2 所有格还是普通格？5.5.3 动名词复合结构的用法5.6 动名词的时态和语态（一）：被动式（being done）5.6.1 动名词的时态和语态概述5.6.2 动名词的被动式5.6.3 主动形式表示被动意思5.7 动名词的时态和语态（二）：完成式（having done）5.7.1 动名词的完成主动式5.7.2 动名词的完成被动式5.8 there be 的不定式与动名词形式5.8.1 there be的动名词形式5.8.2 here be的不定式形式第六章 分词6.1 分词的意义6.1.1 引言：一个真实的故事6.1.2 现在分词的意义6.1.3 过去分词的意义6.2 分词的作用（一）：状语6.2.1 主语一致：单独的分词（短语）作状语6.2.2 独立分词结构（一）：“名词+分词”作状语6.2.3 独立分词结构（二）：“with+名词+分词”作状语6.2.4 固定结构6.2.5 分词作状语的意义6.3 分词的作用（二）：定语6.3.1 单个分词作定语要前置6.3.2 分词短语作定语要后置6.3.3 后置定语的三种被动结构6.4 分词的作用（三）：补足语6.4.1 分词在感觉动词后充当宾语补足语6.4.2 作补足语的分词与不定式的区别6.5 分词作成分要注意的问题6.5.1 定语还是状语？6.5.2 不能用作定语的分词结构6.5.3 不能用作状语的分词结构6.6 分词的完成式6.6.1 一般式还是完成式？6.6.2 何时该用完成式？6.7 分词的用法总结6.7.1 各种分词形式总结6.7.2 如何正确使用分词？6.8 分词构成的复合形容词6.8.1 外部关系与内部关系6.8.2 现在分词构成的复合形容词6.8.3 过去分词构成的复合形容词6.8.4 其他构成的复合形容词第七章 从句与非谓语7.1 名词从句的简化7.1.1 名词从句与动名词7.1.2 名词从句与不定式7.2 定语从句的简化7.2.1 定语从句如何才可能简化为短语7.2.2 定语从句与短语7.2.3 定语从句与分词7.2.4 定语从句与不定式7.3 状语从句的简化7.3.1 状语从句与分词7.3.2 状语从句与不定式" }, { "title": "英语语法新思维-2-通悟语法", "url": "/posts/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%96%B0%E6%80%9D%E7%BB%B4-2-%E9%80%9A%E6%82%9F%E8%AF%AD%E6%B3%95/", "categories": "语法, 新思维", "tags": "语法, 英语", "date": "2022-09-08 22:56:00 +0800", "snippet": "序言第一章 简单句与复合句1.1 引言一个完整的英文句子就是：“主语＋谓语”。意思往往还不完整，还需要在动词后面接其他成分。具体接什么由谓语动词决定的，动词决定了一个句子是否有宾语，或者有几个宾语，或者是否需要补足语以及状语。 分析长难句结构时，先找谓语 写句子时，知道谓语动词的用法和特点 动词后面是否能接宾语， ...", "content": "序言第一章 简单句与复合句1.1 引言一个完整的英文句子就是：“主语＋谓语”。意思往往还不完整，还需要在动词后面接其他成分。具体接什么由谓语动词决定的，动词决定了一个句子是否有宾语，或者有几个宾语，或者是否需要补足语以及状语。 分析长难句结构时，先找谓语 写句子时，知道谓语动词的用法和特点 动词后面是否能接宾语， 接什么形式的宾语， 接不定式作宾语还是动名词作宾语 1.2 句型一：主语＋系动词＋表语1.2.1 谓语动词的特点该句型的谓语动词是系动词（linking verb）这种动词并没有具体的动作，而只是起连接主语和后面成分的作用。作用：动词后面所接的成分是用来说明主语的特点，表明主语的性质特征的，因此被称之为主语补足语或表语（能表示主语特征的成分）作表语的形式 不定式（比如to run a lawnmower和to get to the root of the problem） 形容词（比如fine,time-consuming and painful, easy） 名词短语（比如a temporaryanswer） 副词（比如back）等。系动词分类一、单纯表示主语的特征、状态的 有feel, look, sound, taste, smell, seem和appear等二、表示主语由一种状态转变为另一种状态的 系动词有become, grow, get, turn, fall, go和come等 对于fall, go和come等词作为系动词时，这些系动词与形容词连用一般具有固定的搭配关系。 fall都是作为系动词，所以其后面不能接副词 go作为系动词时，一般用于贬义，即表示主语是朝着坏的或消极的一面改变。相反，come作为系动词，则是表示褒义的，即表示主语是朝着好的或积极的一面改变。三、表示主语保持某种状态的 系动词有continue, remain, stay, keep, hold, rest和prove等。四、近似于不及物动词的系动词近似于不及物动词的系动词有sit, act, arrive, blush, marry, die和be born等。有人将其称为“半系动词”，因为它们介于不及物动词和系动词之间。sitactarriveblushmarrydiebe born1.2.2 简单句叠加成复杂难句1.3 句型二：主语＋谓语1.3.1 谓语动词的特点1.3.2 简单句叠加成复杂难句1.4 句型三：主语＋谓语＋宾语1.4.1 谓语动词的特点1.4.2 简单句叠加成复杂难句1.5 句型四：主语＋谓语＋间接宾语＋直接宾语1.5.1 谓语动词的特点1.5.2 简单句叠加成复杂难句1.6 句型五：主语＋谓语＋宾语＋宾语补足语1.6.1 谓语动词的特点1.6.2 区分双宾语和复合宾语1.6.3 简单句叠加成复杂难句1.7 从简单句到复合句第二章 名词从句2.1 简单句与名词从句2.1.1 何谓名词从句？2.1.2 陈述句作句子成分2.1.3 一般疑问句作句子成分2.1.4 特殊疑问句作句子成分2.1.5 引导名词从句的连接词2.2 简单句与主语从句2.2.1 陈述句作主语2.2.2 一般疑问句作主语2.2.3 特殊疑问句作主语2.3 简单句与宾语从句2.3.1 陈述句作宾语2.3.2 一般疑问句作宾语2.3.3 特殊疑问句作宾语2.4 简单句与表语从句2.4.1 陈述句作表语2.4.2 一般疑问句作表语2.4.3 特殊疑问句作表语2.5 简单句与同位语从句2.5.1 陈述句作同位语2.5.2 一般疑问句作同位语2.5.3 特殊疑问句作同位语第三章 定语从句3.1 定语从句概述3.1.1 形容词作定语与从句作定语比较3.1.2 定语从句的两个重要概念：先行词和关系词3.2 关系词在定语从句充当的成分3.2.1 关系词用作从句的主语3.2.2 关系词用作从句中动词的宾语3.2.3 关系词用作从句中介词的宾语3.2.4 作宾语的关系词可以省去3.3 关系代词与先行词的搭配关系3.3.1 先行词指“人”，用关系代词who或whom3.3.2 表示人或物的所有关系，用whose3.3.3 先行词指“物”，用关系代词which3.3.4 that可以指代“人”，也可以指代“物”3.4 关系副词的用法3.4.1 when的用法3.4.2 where的用法3.4.3 why的用法3.5 限制性与非限制性定语从句3.5.1 限制性定语从句——不用逗号隔开3.5.2 非限制性定语从句——用逗号隔开3.5.3 用或不用逗号，句义有差别3.5.4 非限制性定语从句的翻译3.6 定语从句与同位语从句的区分3.6.1 从结构上区分：that是否作成分3.6.2 从意义上区分：that引导的从句的意义不同第四章 状语从句4.1 时间状语从句4.1.1 时间连词when的用法特点4.1.2 时间连词while的用法特点4.1.3 时间连词until的用法特点4.1.4 表示“一……就”的结构4.2 地点状语从句4.3 原因状语从句4.3.1 常见连词的用法4.3.2 用介词表示因果关系4.4 目的状语从句4.5 结果状语从句4.5.1 常见连词的用法4.5.2 结果状语从句的倒装4.6 条件状语从句4.6.1 常见连词的用法4.6.2 其他条件状语从句的连词4.7 让步状语从句4.7.1 常见连词的用法4.7.2 表示让步转折关系的介词4.7.3 置于句首的while一般表示“尽管”4.7.4 as引导的倒装句表示让步4.8 比较状语从句4.8.1 连词as的基本用法4.8.2 连词than的基本用法4.8.3 表示倍数比较的三种句型结构4.8.4 the more…, the more 句型结构4.9 方式状语从句第五章 完成时态5.1 完成时态的构成5.2 完成时态的意义5.3 “回顾”思维5.4 延续事件5.4.1 过去的事件“延续”到现在5.4.2 “延续事件”与时间状语的关系5.5 重复事件5.5.1 过去的事件“重复”到现在5.5.2 “重复事件”与时间状语的关系5.6 单一事件5.6.1 何谓“对现在有影响”？5.6.2 何谓“过去事件”？5.6.3 新闻热点（hot news）——近的过去5.6.4 过去经历（past experience）——远的过去5.6.5 “单一事件”与时间状语的关系5.7 “延续事件”、“重复事件”与“单一事件”之间的相互关系5.7.1 延续事件与单一事件5.7.2 延续事件与重复事件5.7.3 重复事件与单一事件5.7.4 “动作表达”的完成时态与“状态表达”的一般现在时态5.7.5 “动作表达”的完成时态与“状态表达”的完成时态5.8 完成时态用于最高级的句型5.9 时间连词since的特殊用法5.10 过去完成时态5.10.1 在“过去”回顾“更远的过去”5.10.2 延续事件、重复事件和单一事件的过去完成时5.10.3 过去完成时的其他意义和用法5.10.4 过去完成时与一般过去时的比较5.11 将来完成时5.11.1 将来完成动作的开始时间5.11.2 将来完成时的三种思维用法第六章 完成进行时态6.1 完成进行时态的构成6.2 完成进行时态的意义6.3 延续事件6.3.1 延续事件概述6.3.2 延续事件（一）：长期在延续的事件6.3.3 延续事件（二）：近期在延续的事件6.3.4 延续事件（三）：在说话时刻仍在延续的事件6.3.5 延续事件（四）：在说话时刻之前在延续的事件（即刚刚在延续的事件）6.4 延续事件比较：完成进行时与完成时6.4.1 比较（一）：完成进行时“刚刚在延续的事件”与完成时“单一事件”6.4.2 比较（二）：完成进行时的“延续”与完成时的“延续”6.5 重复事件6.5.1 重复事件（一）：短暂动词6.5.2 重复事件（二）：有限延续动词6.6 重复事件比较：完成进行时与完成时6.6.1 比较（三）：重复动作的分割性6.6.2 比较（四）：短暂动词用于完成进行时来表示重复活动6.6.3 完成进行时的“重复事件”与一般现在时的“重复事件”6.7 完成进行时与完成时对比总结6.7.1 比较（五）：完成进行时强调“延续过程”，完成时强调“成果”6.7.2 现在完成进行时与现在完成时的思维差异总结6.8 过去完成进行时6.8.1 过去时刻在延续的事件6.8.2 在过去时刻重复发生的事件6.9 将来完成进行时第七章 虚拟语气7.1 引言7.1.1 把U和I放在一起7.1.2 虚拟条件句：两类三时7.1.3 虚拟条件句的谓语变化7.2 将来虚拟（ZjCj）7.3 现在虚拟（ZxCx）7.4 过去虚拟（ZgCg）7.5 混合虚拟（一）：主句现在＋从句过去（ZxCg）7.6 混合虚拟（二）：主句过去＋从句现在（ZgCx）7.7 倒装虚拟7.8 跳层虚拟7.8.1 陈述句＋or＋虚拟主句7.8.2 虚拟主句＋but＋陈述句7.9 名词从句如何使用虚拟7.9.1 在下列词的宾语从句中7.9.2 在it is＋形容词或过去分词或特定的名词＋that的主语从句中7.9.3 在上述名词的表语从句和同位语从句中7.10 各种虚拟句型7.10.1 在wish后面的宾语从句中7.10.2 在if only感叹句中7.10.3 在as if / as though引导的从句中7.10.4 在it is (high) time (that)从句中7.10.5 在would rather，would (just) as soon，would sooner，would prefer等从句中第八章 情态动词8.1 引言：多情多义的情态动词8.1.1 情态动词的“全家福”8.1.2 情态动词的意义8.1.3 情态动词的结构搭配与意义关系8.2 推测用法（一）：现在推测（情态动词＋一般式）8.2.1 对现在的肯定推测8.2.2 对现在的否定推测8.2.3 对现在推测的其他情态动词8.3 推测用法（二）：将来预测（情态动词＋一般式）8.4 推测用法（三）：过去推测（情态动词＋完成式）8.5 推测用法（四）：情态动词＋（完成）进行式8.6 基本用法（一）：现在或将来的能力8.7 基本用法（二）：现实“可能”与理论“可能”8.8 基本用法（三）：过去的能力8.9 基本用法（四）：许可8.9.1 肯定句——给予许可8.9.2 否定句——拒绝许可，甚至禁止8.9.3 could一般不用来表示现在的许可，而表示过去的许可8.10 基本用法（五）：建议与忠告8.10.1 could表示建议8.10.2 Shall I…? Shall we…?8.10.3 may (just) as well, might (just) as well8.10.4 should和ought to表示忠告8.10.5 should表示“忠告”与could表示“建议”比较8.10.6 had better表示“忠告”8.11 基本用法（六）：意愿、意图与执意8.11.1 意图（intention）8.11.2 执意（insistence）8.12 基本用法（七）：请求8.13 基本用法（八）：过去习惯8.14 基本用法（九）：should的特殊用法8.14.1 should表示“竟然”8.14.2 should表示“万一”8.15 基本用法（十）：shall的特殊用法8.15.1 用于第一人称的疑问句中：Shall I/we…?8.15.2 用于第三人称的疑问句中8.15.3 用于第二、三人称的陈述句中8.16 基本用法（十一）：may的特殊用法8.17 情态动词的否定8.17.1 情态动词否定意义的深层结构——内部否定和外部否定8.17.2 内部否定和外部否定的使用规律8.18 总结：英文情态与中文情态的简单对比8.18.1 英文情态意义与中文情态意义的对应性8.18.2 英文情态动词的委婉表达在汉语中的缺失" }, { "title": "恶魔奶爸经验分享", "url": "/posts/%E6%81%B6%E9%AD%94%E5%A5%B6%E7%88%B8%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/", "categories": "", "tags": "", "date": "2022-09-05 20:03:00 +0800", "snippet": "机会来了该如何拼命把握奶爸您好。向您请教，本人现在职业是美资外企的财务分析，工作时间是4年。公司内部有个区域的分析岗位是更好的，负责招聘的财务经理很喜欢我，想让我过去她下面。但是她跟财务总监说了三次，都被拒绝了，理由都是我学校背景不够(本人是普通一本大学，领导都是名校北大复旦之类的)。现在外面有个机会是大宗商品的期货分析员，不知道是否应该去？如果去了那么财务分析的职业算是结束了。答：想去的岗...", "content": "机会来了该如何拼命把握奶爸您好。向您请教，本人现在职业是美资外企的财务分析，工作时间是4年。公司内部有个区域的分析岗位是更好的，负责招聘的财务经理很喜欢我，想让我过去她下面。但是她跟财务总监说了三次，都被拒绝了，理由都是我学校背景不够(本人是普通一本大学，领导都是名校北大复旦之类的)。现在外面有个机会是大宗商品的期货分析员，不知道是否应该去？如果去了那么财务分析的职业算是结束了。答：想去的岗位：岗位上司特别喜欢我，但是部门的老大总是拒绝，理由是学历背景不够。这说明有几种情况：1，其实上司并不喜欢你，所谓的喜欢，是你的错觉。不是人家主动喜欢你，而是你特别上心这个职位，积极争取，跟人聊了很多很多次，人家不好意思拒绝你，每次都笑盈盈很客气，然后搞缓兵之计，以大领导说你学历不够为由拒绝。这个可能性是最大的。2，确实是大领导拒绝，拒绝原因也确实是学历不够。但这种可能性是最小的。因为大领导太忙管不了这么鸡毛蒜皮的事，只要下属提交的事情，相对合理不那么重要的，都会直接签字。一个底层小卒，不至于让大领导这么上心，更不值大领导连着操心三次。这个概率可能性不到1%3，确实是大领导拒绝，但拒绝原因依然不是学历，而是他看你不顺眼。是的，这种情况确实是有可能的，大领导对于基层的作用主要不是负责批准，而是负责否决。也就是绝大部分基层提交的人和事，没问题他都会通过。极个别，他觉得看着不顺眼，不爽的，直接一票否决，以各种奇怪的理由否决掉。所以题主需要反思一下，自己是否平时得罪过大领导，留下不好印象，或者没得罪，但是给大领导的眼缘不好。4，大领导和岗位上司都没问题，但有一个人在作梗，就是自己现任的上司不肯放人，但是又要瞒着题主，不要上下不和，影响当前工作。5，大领导，题主学历，岗位上司，都没问题，但大领导和岗位上司不和，只要是岗位上司的申请，大领导都会否决，题主成了办公室斗争的牺牲品。以上这5种是可能性最大的，远比题主所想的什么学历问题，要靠谱。财务这种东西本身技术含量就不大，经验远比学历重要，尤其是美资公司，更不看重这个。所以题主应该怎么办？1，先排查岗位上司是不是客气客气，实际上压根不喜欢你不看重你。如果是，咱们也没必要自讨没趣给人添麻烦了——可以离职，但离职也可以找财务分析岗位，没必要非得转行。如果不是，那么往下看。2，排查下岗位上司和大领导之间关系的问题。如果真的是两者不和，那这题无解——可以离职，但离职也可以找财务分析岗位，没必要非得转行。如果查出来没有不和，那么继续往下看。3，排查自己上司的原因。看是否自己上司在从中作梗，如果是，那么非常好解决，上下班都跟着他，最多72小时，她就会主动跟大领导申请让你调岗了。如果也不是，那么继续往下看。4，上司，岗位上司，大领导，都没问题，那么剩下的就两个，眼缘看你不爽，或者你学历真的不够。这两种情况，解决方法都一样。毛遂自荐，用口才说服大领导。做一份精美的PPT，不用太长，10-15分钟的量。和大领导约时间，认真做一份自我的pitch，证明自己适合这个岗位，为什么自己是最好的选择，比从外面找的陌生人要放心。这个举措大约会有60%左右的成功率，失败率也很高。但做了，就有一半以上可能成功。不做，就板上钉钉的失败。而且口才格外优秀者，可以把胜率提升到8成，乃至9成。这就是我们反复强调，为什么说表达是是一切能力的重中之重。对于题主的这种局面，面对一个比较有含金量的岗位。这种机会呢，说实话，一辈子也就一次。抓住了，就抓住了，人生瓶颈就突破了。没抓住，可能以后也遇不到第二次机会了。那为什么绝大部分人都在抱怨自己的人生没有机会，没有贵人呢？因为他们往往意识不到机会到来时候的重要性，和所需要的能力。生活没有BGM和鼓点，没有旁白音提醒你这件事很重要。绝大部分人面对真正的机会，要么是畏惧畏缩，要么是嫌弃麻烦，要么是不加重视。机会本来就很少出现，出现时候又被彻底浪费，所以绝大部分人的事业工作，注定是失败的。读书时如何做好读书笔记？ 绝大部人读书，都有问题，就是追求读书效率，却不追求学习效率。奶爸你好。请问你平时读书会做笔记吗？我要是做笔记的话写着写着就成抄书了。想请教奶爸做笔记的方法，谢谢。奶老师答：做读书笔记不是一成不变的，没有标准的方法。做读书笔记的关键是，思考清楚你当前读到的内容对你有什么用。你在书中读到的内容，对你的作用和价值不一样，那自然对内容的吸收程度就应该不一样。对内容的吸收程度不一样，自然就应该选择不同的笔记方法。所以，在尚未打开一本书开始读之前，你不知道书中内容，你不知道书中内容对你有多重要，你肯定是不知道该用什么笔记方法的，以及，只用一个读书笔记方法，肯定是没用的，死板的，教条的。那怎么办呢？​​​​对书中的内容进行分层处理，区别对待。根据吸收程度，一般可以把书的内容分为四层：只需要看一遍，不需要看第二遍的，需要看第二遍及其以上的，需要背诵记忆的，需要运用实践的。这样分层后，就知道书中每部分内容，对应着哪个层次的吸收程度，也就对应上了该用的读书笔记方法。只需要看一遍，不需要看第二遍的——不需要任何笔记，直接过；需要看第二遍及其以上的——只需要下划线勾画标记一下就行了；需要背诵记忆的——需要画思维导图梳理知识框架；需要运用实践的——需要画思维导图推导运用场景。这样就有个问题，同一本书甚至同一页，有很多不同部分的内容，重要程度不一样，有的可能只需要过一遍，有的需要看第二遍，有的需要记忆背诵，有的需要运用实践，如果看书的时候，多个方法同时一起用，那不就非常麻烦吗？对，确实很麻烦，所以我要告诉你具体的操作技巧：1，书一般要看两遍，2，读第一遍的时候，把二三四层的内容，都在文字下方用下划线勾画出来，3，第二遍的时候，只读勾画过的内容，然后把三四层的内容，输出为思维导图，4，在第四层的内容输出为思维导图之后，要在每一个道理或方法后，写出具体的实操方法和运用场景。这样，在第一遍的时候快速阅读，划出重点内容，第二遍去除冗余重点吸收，既方便，学习效率高，又节省时间。你看，是不是比你手抄一遍好多了。可能你还有疑问：1，为什么需要背诵记忆的内容应该采用思维导图的方式来记忆？记忆并不是单纯的机械记忆，只管反复背反复看就行了。记忆最重要的是，把新知识与旧知识建立起联系，加深理解，以及，把知识间的联系给理顺，形成树状或者金字塔形的知识结构，好调用。当然，对于考试党最重要的，只背精华知识，思维导图可以大幅度减轻背诵压力。2，为什么需要运用实践的知识道理应该推导出具体的操作方法和运用场景？绝大部人读书，都有问题，就是追求读书效率，却不追求学习效率。只追求书读的多快，不追求学到多少东西能够切实的改变自己。之所以要在思维导图的基础上，还要求把学到的知识道理转化为具体的操作方法，以及推导出方法的运用场景，就是因为，只有这样逼迫自己思考，我们才能真正的实践起来，才能真正的提升学习效率。如果学了知识道理，只是单纯的记忆，根本就没法运用，除了觉得很有道理外只剩下道理很有道理。这也是为什么你懂得了很多道理却过不好这一生的原因。你从没把懂得的道理转化为具体的实操方法，你从没想过这个方法在什么情况下可以运用起来改善自己，你当然记不住书中的内容，更无法通过读书改变自己了。被欺负了，要么忍，要么狠！ 屌丝时期心志坚定，好好学习好好锻炼，别人说自己什么，躺平任骂，就当没听到。奶爸你好，我刚跳槽到一家新公司，第一个月明显感觉到公司里有很多人对我不爽，我工作非常认真都是加班加点在做，自认为问心无愧，我不知道我做错了什么，没想到却是这样，感觉很emo怎么办？奶老师答：有部漫画里说过，只要你踏踏实实努力上进，那么从一些人的视角出发，在他们的故事里，你就是反派，你让人家不舒服了，人家看见你就不爽，就想办法弄你。《浪客行》里宫本武藏老老实实种地，就被很多农民给排挤，讨厌，生怨，因为他干活太努力了，把这些懒农民比下去了，所以引发了诸多不满。在高层博弈，大人物大实体的人际关系上，也存在这种情况，最简单的：BAT​​​​这三家公司，一直是有团结有斗争的情况，而且五年河东五年河西，10年前后，贴吧流量最大，百度控制了舆论出口，所以马云天天被骂假货，腾讯天天被骂抄袭。现在，百度是草菅人命的恶贼，另外两家则是良心企业的代表。其实在10年，百度就已经进行大量的医疗广告推广了，但为什么那时候没人骂，现在骂的多，就是因为他的舆论力量变弱了。再比如刘强东，他当然是多行不义必自毙，但能被挂上一个多月的热搜头条，想想微博的老板是谁，其实不难看出，对头们都在等着丑闻倒霉，然后好好搞他一手，反正不费事，不搞白不搞。这些企业从发展期，到壮大期，很多操作手法都值得学习，这就叫人际交往中的防御和反制手段。1，在初创期，默默干活，2，在发展期，好好赚钱，讨投资人的欢心，至于什么黑粉抹黑，无所谓，躺平任骂。3，到了壮大期，买水军，买公关，进行舆论攻势，4，到了大成期，直接收购舆论平台，把报纸杂志媒体都买下来，或者投资布局，源源不断形成所谓的“自来水”，把十年前老对手的帐好好翻翻，弄死它。对于普通人可学习的点：1，屌丝时期心志坚定，好好学习好好锻炼，别人说自己什么，躺平任骂，就当没听到，2，有一点点的成绩之后，一定要开始寻找高层关系，找到愿意欣赏自己，可以罩着自己的人，依靠他不断上位，3，有了比较好的成绩和地位后，扶持自己的势力，栽培自己的党羽，收买人心，在公司内部发动舆论攻势，4，混到高层，清除异己，毫不手软。大部分人都死在屌丝时期心志坚定的第一层。因为让他们坚持看点书学个技能，他们就立刻觉得自己要升天了，就迫不及待认为身边人就应该认为自己优秀，欣赏自己，稍微被人说两句，立刻就觉得社会黑暗，人类虚伪，周围一切都是浑浊的，就自己干净。就这种drama queen的心态，能有个屁出息。年轻女性千万别去大城市，否则会变成大龄剩女？注意尽可能不要找富二代和有钱人家。​​今天在B乎看到一个帖子，建议年轻女性在小地方生活，不要去大城市，否则眼光高了嫁不出去。​​​​给出这种建议的人真的是非蠢即坏！对于年轻女性择偶的问题，恰恰相反，我建议女性尽可能不要在小地方生活，哪怕去不了大城市生活不得不沦落到小地方，找对象尽量也要找有正式工作的，体制内，教师，医生，国企员工等等。尤其要注意尽可能不要找富二代和有钱人家。因为在中国地级市和以下的城市，那是个完全不一样的文明和社会，完全不同的运转逻辑和社会关系，这方面建议大家多看看常书欣的小说，认真思考思考，当然要跳出框架来看待主角的那些言行。说的更直接一点，国内小地方的有钱人（县级年入超过30万，市级年入超过50万就算），基本都有非常严重的原罪。这些人少有不涉黑或者不违法的，江湖草莽气息极为严重，信奉的基本就是弱肉强食丛林社会那一套，不太可能搞什么文化修养，所以导致家风极为粗暴恶劣，有钱公公+废物儿子是标配，婚后生活富裕确实，但幸福罕见。如果是自己白手起家的呢？那恐怕要更为提防，废物不作恶还好点，野心勃勃能力高绝做最大的带恶人，这恐怕更加糟糕。传统印象中所谓的有知识有文化有修养，受过高等教育的文化富豪，多集中在省级城市和以上地区，市以下的规则和方法论，就完全改变，和大城市堪称平行宇宙。在一个不正常的变态的粪坑一样的社会里想出头，那么必然是最大最狠最恶心的那只苍蝇才可以。在一个正常的社会里想出头，那必然得能力卓绝足够优秀。这是两个完全不一样的概念。所以为什么网友会有很多矛盾的社会印象。比如富不过三代和富人的孩子都有优质的家庭教育。如果富人的孩子都有优质教育，那么富不过三代应该很难出现吧。再比如有人觉得这个社会不会好了，真的要做坏人才能成功吗？然后又觉得雷军马云等人能力卓绝，靠能力拼一拼还是有希望的。为啥会有两种完全冲突的富人印象？这是因为前者是小地方的有钱人，后者则是大城市的有钱人。衣食足则知荣辱，仓廪实则知礼节，这种情况只存在于大城市，小地方的有钱人就是靠狠起家，发家后要更狠，才能保住自己的地位。这里不是说大城市的富商就没有原罪，只是要干净很多，也不是盲目鼓吹公务员教师男的优质，这些人素质也未必高，但最起码要干净很多。总之，女孩子尽可能去大城市，不要留在小地方，对女性极度不友好。如果实在不愿意独立吃苦累，那么就先学会自保。上面就是最基本的自保方法。男人会珍惜一起共甘共苦过的女人？千万别信这种鬼话！私信提问，男人真的会珍惜和自己一起奋斗过来的女人吗？为什么很多男人取得成功后会出轨，作为女人该怎么办？其实所有的男人在口头上都会说喜欢门当户对，懂事知礼，一起共同奋斗的女人。你要是自诩所谓的“平权”，真心信这种话术，那你铁定掉沟里。真实情况：我们永远不会感激陪自己共过患难女人，永远也不会喜欢对自己好百般宠溺的女人，更不可能知恩图报不离不弃。我们不喜欢“对我好像妈一样照顾我们的”，只喜欢漂亮的性感的，这是基本人性——我自己就非常好色，并且从不讳言这点。所以正确的做法是：女孩子就应该七三开或者九一开，即7成以上的时间精力都打扮自己做自己的事，一两成的时间精力用来和你喜欢的男人互动，而且也绝对不要做牛做马当老妈子家务全包。男人绝对不可能会感激一个保姆。绝对不要亲自去浪费时间做事，你要明确告诉他个人独立的必要，自己的家务活自己干，自己的衣服自己洗，如果是两个人住一起，那最起码也得轮流做。同时还得学会说漂亮话，鼓励他，赞赏他，表扬他，让他去奋斗努力，伟大事业，在他失望难过彷徨的时候，鼓励他安慰他。但只是说话鼓励，情绪支持，而不是当老妈子，这讲究方法，不讲究卖力。男人对妈只会觉得厌烦，不会觉得喜欢。当然，做这件事的前提是看对人，垃圾人就早点分手远离比较好。以及，谈恋爱更重要的前提是做好自己。你是一个独立的，积极的，有自己事情可以做的人，那么你当然不会陷入当妈心态，100%所有期待希望生活热情都寄托在男人身上。你要是没正事干，那当然就会把所有事情都投入到男人身上，要么凄苦如祥林嫂，要么作闹如大傻逼。恋爱婚姻只能是随缘，变美变有钱才是正事。年轻人如何培养商业思维争取以后赚大钱？ 一般所谓的商业模式无非就是打广告，搞研发，登门拜访，开发经销商搞代理。奶爸您好，感谢奶爸一直以来的分享，想就商业模式这个话题延伸请教一下，如何提高商业嗅觉，用做生意的思维去培养嗅觉、经营自己的事业？如何跳出打工者思维？这个问题看两本吴晓波的大败局和激荡30年就够了。一般所谓的商业模式无非就是打广告，搞研发，登门拜访，开发经销商搞代理，说起来大家都懂，但是都抽象，不大容易理解。大败局里面有很多案例，结合案例看就容易理解了。比如健力宝的成功在于广告营销，但是死于股权不清，官商内斗，改成第五季后因为渠道做的烂，经销商拒绝发货，同时巨额投央视广告，导致回款不及时崩盘。再比如爱多VCD，死于急速扩张招代理，被媒体造谣代理催收账务，公司出现财务危机，资金链断裂，创始人最后坐牢。吴晓波表面是个财经作家，其实是个历史作家，看政治历史最起码你知道王朝政治制度基本是怎么回事，看商业历史，你能获得最多的商业运作是怎么回事。当然吴搜集的案例在真实性上存在一定的争议，写的东西未必是史实，比如科龙的老板出狱后就跟他打过笔战，质疑他写作的意图和对事实调查的严谨性，简单说就是，老子失败是因为被人陷害，你丫xjb写还抹黑我，几个意思？但是吴晓波作为国内新崛起阶层的发言人，对于自由经济和自由市场的描写不可谓不细致，不可谓不精彩，可读性非常强，他的每一篇文章都做到了非常符合逻辑，最基本的商业逻辑，所以对于培养最基本的所谓“生意思维”，是有帮助的。不给方法论的干货，都是伪知识，真鸡汤，忽悠傻子！底层考虑什么战略模式问题，建议直接送精神病院。​​作为职场博主，我发现，分享具体的细节的关乎大家升职加薪的知识，开始越来越不受人欢迎，数据越来越差。远不如现在网络上流行的什么思维、格局、认知和战略这类知识，远不如它们受欢迎数据好。我很疑惑：整天讨论什么宏观战略，未来前景，到底有没有意义？各种课程，整天讲这个格局，那个思维，对大家现实里的生活真的有用么？我个人认为没啥屁用。思维或者说商业模式这东西不是很推荐花费太多时间琢磨。做生意也好，升职加薪也罢，最重要就是关系背景钱，其次就是客源，搞这些都是有系统的方法论的，不是啥思维战略糊弄下就能过去的。细节才是魔鬼。比如产品销量不好要打广告，谁都知道，但真给你个300万预算，你去打，怎么规划，怎么花，花出去了怎么保证效果，万一效果差怎么承担责任，一般人根本就不知道。甚至都不敢去做，压根都不敢想。华为的底层员工，写信给任正非，谈华为未来十年的战略，说要做手机，任正非回复以后再有底层考虑什么战略模式问题，直接送精神病院。你要我做手机，我当然知道该做这个，问题是怎么做，花多少钱，多大团队，怎么运作，我需要的是这个，而不是什么宏观方向。后来还有个博士也写信给任正非，他就高升了，因为他写的全是细节，科研团队的管理制度有哪些问题，奖金激励哪里不合理，怎么设计最好，科研体系和流程上出现哪些问题，怎么改最合适，全是实实在在的工作方法。这个世界并不缺什么商业模式，或者战略思维，绿皮车厢里对中南海指手画脚的人都多了去了，最缺的是实际的工作方法，和工作成果。知道如何做，比做什么，永远都更宝贵。这个诀窍不单单是对做大事，做大生意有用。对个人的职业规划，也有用。只自己喜欢什么，不喜欢什么，想要什么，对什么感兴趣，这些统统都不重要。如何把眼前的事情做好，你个人能力如何，知道怎么做事，这更重要。重要的多。如果不知道如何把事做好，只知道聊什么喜好，兴趣，战略，那就是标准的loser talk为了逃避眼前繁重工作寻找借口而已，根本不是什么好的才能。别人给你画大饼不可怕，自己给自己画大饼最可怕。打工人最适合看哪些书？ 名气大过经历的话，那么出的书基本都是纸上谈兵，可参考性非常差。普通人尽量不要看大佬写的书，李开复，马斯克，乔布斯，向前一步，还有桥水基金写创始人写的那本原则，看着是挺美，但是实际上对自己只有启发，却没有帮助。这些人写的书，属于典型的“富贵限制了他们对生活的感知力”，所以给出的建议和方法对普通人没什么操作性，自己的故事更没有什么参考性。尤其是向前一步，全是鸡汤，告诉你该做什么，但绝对不会告诉你该怎么做。比较适合看的书，就是非大佬，不是创始人，也不是联合创始人，而是经理人写的书，比如吴军老师当年就谷歌的经理人，他的书就非常好。这类经理人中，混的比我们稍微好那么一丢丢，出的书是最有意义，也是实践价值最大的。比如杜拉拉升职记，她就是个外企的HR经理，能出书还能火，说明书里是有真干货的，比如《销售就是要搞定人》，作者本人就是个销售大手，把整个销售攻坚过程和具体细节都讲透了，不论是外行小白还是行家里手，都是很好的学习体验，再比如《参谋助手论》，两位作者写书时候都只是小秘书而已，能在大学开授课程，说明确实有两把刷子。据说某位已经落马的著名中将曾把此书翻阅千遍，每页里的每一段都留下了细密的笔记和感受补充，可惜读书笔记被中纪委没收了，不然能出版一定是职场界技巧的一次飞跃。但是在这类作者里，如果是本身职场经历不突出，甚至很少，教师或者传媒的经历比较多，名气大过经历的话，那么出的书基本都是纸上谈兵，可参考性非常差，甚至有误导的毒害可能，尽可能不要看，比如新东方系出身的老师出版的非英语类的书——这种就属于贫穷限制了他们对工作的想象力。如何判断一本书是不是好书？ 人的鉴赏水平，和自己个人的知识水平，是直接相关的。奶爸，如何判断一本书的内容是否可靠，内容能否当做方法论去实践，作者是瞎编乱写还是确有依据？讲两个小故事。溥仪，曾经的皇上，下台后去故宫游玩，看到宫殿里摆的照片不对，找来专家反映，专家很不屑，说自己是历史大能经过多方考证这张照片就是xx王爷的，溥仪轻轻说了一句，这人是我爸，我确信照片里的不是我爸。后来又有朋友拉他去看古董，他基本一眼就能看出真假和质量好坏，朋友就问怎么看的有没有什么方法，他说说不出来，因为从小自己就用这些东西，看多了摸多了，再看假的就总觉得怪怪的，哪里差点东西。好东西看多了，自然鉴赏能力就提高了。然后是第二个故事：爱因斯坦出了相对论之后，几乎每年都被提名诺贝尔奖，但是每次评选委员会都心怀疑虑，觉得相对论这玩意儿就是个玄学没法验证，不该获奖吧，比如1911年的生理学奖得主阿尔瓦古尔斯特兰德就专门写了份报告，公开反对相对论，抗议把奖颁发给爱因斯坦。到了1922年，整整10年过去了，诺奖评选会这群智障，仍然认为爱因斯坦不该得奖——要记住，评选会里的人，可都是当时有头有脸的大科学家。普朗克当时非常着急，甚至直接说，爱因斯坦得到诺贝尔奖可绝对不是爱因斯坦的荣誉，而是我们这个破奖有幸给爱因斯坦颁奖，是咱们这个奖项集体的荣誉，否则会被千古耻笑的（大意如此，非字字对应）一直到物理学家奥新提出来，爱因斯坦的相对论没法证实，但是光电效应被证实了，仅这个就可以拿奖了吧。这个时候诺奖才有些不情愿的把奖发给了爱因斯坦。为什么同样都是大科学家，普朗克极力推崇爱因斯坦，不断推广相对论，而类似阿尔瓦古尔斯特兰德就极力反对？他是个生理学家门外汉光也正常，但是之后的诺奖评选会一帮科学家都不认同？因为人的鉴赏水平，和自己个人的知识水平，是直接相关的。从溥仪和爱因斯坦的两个例子里我们可以得知：想去鉴别一本书，首先你得是个厉害的人。那如果你不厉害，应该怎么办？内心至诚，最为重要。就是不要听别人盲目瞎推荐，只要你自己认为可以学到东西的书，对当下的你来说，就是好书。比如我买过一本口才书，是金话筒奖的教材，这本书在豆瓣被批的很惨，得分5.5左右，但是我自己很喜欢，我认为干货十足，里面的技巧我每天都用，写文章，做视频，去演讲，效果非常不错。豆瓣的读者绝大部分人演讲经验不可能有我丰富，演讲场次也不可能有我经历的多，但这不能说明我比他们厉害，或者我不如他们。我的意思就是说，适合自己当下水平，只要你觉得有用的，就是好的。而不是在乎外界的口碑或者评价。这一点对于方法类书籍尤为重要。别人找你借钱，该如何巧妙拒绝？ 人情的前提是，你得搞清楚，这个人是否值得投资。奶爸，您好。请问你在工作场合里，怎么拒绝别人的借钱呢？这次问我借钱的，是一个经常给我介绍客户资源的讲师，每次成了一单我都会给他一些20%的提成。合作了一年多了，昨天人家问我借钱，说是投资一个可靠的餐饮项目，自己已有20万，还需要10万。我委婉表示因为借钱很伤和气，我至今不再借钱给任何人了。但是对方不依不饶，说可以立一个合同，十万一年半之内还给我。也没提利息这回事。想问奶爸的是，面对职场的这种借钱怎样处理才好？还有，这种并没有好到那个程度的男的问我这种女生借钱，他妈的算不算不要脸呢？奶老师答：原则上当然不鼓励任何人给任何人借钱。但是这里有一个问题，就是这个人是你的财源之一，他经常给你介绍客户。你得衡量一下，未来给你介绍客户赚的钱，有没有这十万的价值。​​​​如果没有，那就算球，非常有礼貌的说对不起啊真抱歉最近困难。如果有这个价值，那也尽量不要全部满足。自己给自己设置条门槛，比如我给自己设置的借钱门槛就不会超过一万块。普通人刚毕业，借钱门槛尽量不要超过一千，有了积蓄的人，借钱门槛不要超过三千或者五千。对方跟你借十万，你立刻转五千或者三千又或者是一千过去，说真抱歉哥们，我手头也紧，刚才计算了很久东拼西凑，才这几千块钱，你先拿着用，不着急还。这个钱就当给出去了，别指望再还回来了，为的是个人情，而不是真的有借有还。但人情的前提是，你得搞清楚，这个人是否值得投资。不值就算，值的话，就按照自己的门槛给，又维护人情，又降低了未来可能的风险。最后提醒下，网络借钱一定要注意，让他录个视频，手拿当天的报纸，亲口说出当天的日期和找你有什么事，发给你看下，否则很可能是骗子。电话，录音，文字聊天都不可信。如果对方生气不理解，那说明这人要么是骗子要么是智障，不要理睬。最后的最后，额外提醒一句，进入社会最好不要以“我一个女生”这种角度或者方式来思考问题，对自己很不好。以利益角度看待利益关系，是最好的。家长如何帮孩子树立三观？孩子愿意开口交谈，家长才有机会去“树立”孩子的三观。​​最近微博后台来咨询亲子教育问题的V+会员，都有一个问题，那就是把孩子当成一个静态的整体，而不是一个动态变化，不同阶段不同方法，这是一个很大的误区。都说老朋友如果3年以上没联系，下次接触就要留个心眼了，因为你不知道他这么多年接触了什么变成什么样。养小孩就更是如此了，尤其是孩子进了初中后，一天怎么着也有12个小时以上在学校，个别地区类似苏北，6点到10点都在学校，那都是16个小时了。这时候你压根也不知道孩子每天经历了什么遭遇了什么新接触到了什么样的人，如果孩子对你不信任不沟通，你能保证小时候辛苦打好的基础，不变坏变歪？想做到这点，最重要的是小学四年级以前。​​​​在小学四年级也就是10周岁前的孩童，以当代儿童心理学教育学的理论来看，就属于心智的发展区，对外界其实没有什么善恶标准。只有亲疏标准。这个时候的家长如果自以为是，圣母附身，过于严厉，对孩子绝对不是好事。孩子太小时候，家庭对于孩子的整体态度，只能有一个：帮亲不帮理。这里所谓的帮亲不帮理，并不是过度溺爱，而是必须旗帜鲜明的站在孩子这边，让孩子知道，家长是绝对可靠的，任何事情都可以来找家长。哪怕是孩子的错，你也不能当众打骂孩子，对外的态度要摆足了架势，这是我家孩子我罩着，对内关起门来细细教育。这种建立孩子和家长的初步信任感，非常极端的重要。因为只有这样做，到了13-16岁这三年的青春叛逆期，孩子在外遇到的困惑事件，疑惑想法，遭遇见闻，才敢放心大胆的和家长说。孩子愿意开口交谈，家长才有机会去“树立”孩子的三观。如果拒绝沟通，冷漠处之，那么孩子在这个时候就有很大可能学坏。所谓棍棒底下出孝子，是最滑稽的说法，家庭暴力的受害者，在青春期缺乏判断力的时候，极度容易学坏，也不信任家长无法得到良好指导，轻松松就会变成混混流氓太妹，导致一生误入歧途，万劫不复。如果你在10周岁前，都过于严厉，家庭环境冷冰冰缺少爱，那么从现在开始就很棘手，你至少需要花费10倍百倍的精力，才能让孩子重新信任你。如果孩子对你没有信任，就谈不上什么教育和树立三观。我很奇怪谈育儿的那么多，都谈教育和培养，却很少谈沟通和信任建立。要知道，亲子间的信任，是1，教育培养成才都是后面的0.没有1，0再多也没有基础，无从谈起。让小孩赢在起跑线？别用你的焦虑害了小孩！ 给孩子一个快乐的童年，哪怕将来孩子过得很平凡，至少可以平凡的很快乐。奶爸你好，家里小孩儿该上小学了，请问怎么选小学比较好？奶老师答：在教育学上，按照皮亚杰的成长理论，一般我们把孩子的成长过程，分为四个阶段：感知运动阶段（0-2岁）、前运算阶段（2-7岁）、具体运算阶段（7-12岁）形式运算阶段（12岁以后）。我国的小学阶段，正好对应的就是具体运算阶段和形式运算阶段。简单来说，就是只有感性思维，以及抽象思维形成的两个阶段。最经典的案例就是，小学的数学课有一道题，问一公斤的铁和一公斤的棉花，到底哪个更重。​​​​有的孩子会觉得铁本来就比棉花重，所以铁更重。有的则会觉得一公斤棉花是非常大的一团，远比同等重量的铁大，所以是棉花重。这都是具体运算阶段的表现，孩子只能根据自己的亲身经验和想象来思考问题。只有非常少的孩子，能够根据抽象思考，发现二者都是一公斤，因此无论具体是什么实物，都应该一样重。这种孩子，就能不再根据个人感受和经验，而是根据逻辑来推理，这就是进入形式运算阶段的标志。俗称“开窍”。具体运算阶段和形式运算阶段的不同，是因为孩子的脑部发育的不同。因此，处在不同阶段的孩子，教育目标和手段是非常不同的。处在具体运算阶段的孩子，应该让孩子更多的去发现世界，感受世界。因为处在这阶段的孩子，最应该培养的是洞察力，和敏锐度。让孩子们能够快速的发现事情的重点，他可以不理解这些都是为什么，但是一定要能快速的感知到这些变化。这种训练会为孩子进入下一个阶段，打下坚实的基础。观察的具体实物多了，孩子自然而然的就能，通过在不同当中寻找到相同，在相同当中发现不同，从而完成从具体思考，到抽象思考的过渡。处在形式运算阶段的孩子，重点培养的则是，推理纠错能力。这阶段的孩子，刚刚开始学会抽象思考，运用的并不熟练，很多时候想着想着，就又开始回到凭借个人感受，而不是逻辑推理规则上面来。所以，需要有人不断的去纠正他的推理错误，并告诉他其中奥妙，还要进行强化训练，充分做到知道，是什么、为什么、怎么做。由于处在不同阶段的孩子，教育的目标不一样，因此采用的具体教育手法也不一样。这些都是普遍存在的教育规律，谁若违反，谁的孩子必定受到相应惩罚。因此，在考虑孩子到底上什么小学的时候，不能单凭这是重点小学、升学率高，就盲目下结论。有些东西，是一定要调查清楚的。比如学校是不是对成绩要求很高。如果是，那尽量不要去。因为对成绩要求高的学校，往往从孩子进校门起，就会不断的进行重复训练，让孩子死记硬背各种题型，从而保持高成绩。这种教学手法，短期成绩效果显著，但会给孩子造成非常大的伤害。很多孩子小学时代成绩优秀，典型的乖乖女。但是到了初中成绩就一泻千里，怎么都提不起来。本质原因，就是孩子处在具体运算阶段时，没有充分感受其中变化，而是死记硬背各种运算法则，从而导致孩子的理解能力有问题，无法进行复杂抽象思考。比如学校所处街区是不是龙蛇混杂。如果是，那也不要去。至少在形式运算阶段以前，孩子交友，基本上就是谁离的近，谁就是好朋友。科学研究表明，孩子的同龄人对孩子的影响，远超其他人。所以孩子如果从小处在问题儿童当中，十有八九也会成为问题儿童。很多家长不惜斥重资买学区房，并不是为了让孩子有多么好的起跑线，纯粹是怕孩子跑到烂学校跟着学坏，一辈子就完蛋了。至于孩子是不是要参加各种素质培训。如果家庭负担得起，那就听孩子的意见，爱去就去，不愿意也不强求。如果舍不得随便扔那么多冤枉钱，那就不用去了。让孩子开开心心的玩耍，比什么都重要。给孩子一个快乐的童年，哪怕将来孩子过得很平凡，至少可以平凡的很快乐。女人就不应该太辛苦，反正都有男人养？？？ 婚前就意外怀孕，婚后就失去自由，主观放弃独立，一生被人操纵和掠夺压迫。​​6月的时候写了《如何教育女儿，避免长大后成为恋爱脑？》 这篇V+文章，然后每个月都有V+会员私信问我相关的问题，这里我就再补充一下。从我这么多年微博接到的私信来看，女生恋爱脑偏多，非常依赖另一半，好似没断奶一样。​​​​家长一般会认为女儿最坏的结果是嫁不出去，所以一直都在给闺女灌输在家靠父母，出门靠男友，小时靠亲戚，长大靠老公的思想，从小一直就这么潜意识的教导。如果家长主动这么教育，那是家长的错，可如果家长太忙，精进工作，只是树立一个优秀榜样，和女儿缺乏沟通和耐心讲解，会怎样。那就更糟糕了。思维想法的高地你不占领，别人就会来帮你占领，你闺女接触的朋友，长辈，看的书籍各种娱乐文化和社交网站，到最后基本仍然还都是在家靠父母，出门靠男友，小时靠亲戚，长大靠老公。尽管这类思想会以各种不同的面貌出现，但内核不变，区别仅仅是要把自己卖的贵一点而已。而且因为外部舆论是你不可控的，你在灌输落后思想的时候，好歹还会想办法培养美德素质和能力，如果你对女儿疏于沟通教育，她自然会从外部得到信息，至于她吸收的同时，得到的还有没有其它毒素，这就不好说了。这是非常极度极其危险的家庭教育方式和思想。按照这种方式养育出来的闺女，下场绝对要比嫁不出去糟糕的多。婚前就意外怀孕，婚后就失去自由，主观放弃独立，一生被人操纵和掠夺压迫。帮闺女找到个好人家我就心满意足了，这种想法是朴素又美好的，也是可以理解的。但老一辈人可能不会想到：做任何事情都要有风险意识，以及风险概率多大。这件事如果做成了，那闺女这辈子都很幸福，可如果这件事做不成呢？那基本就是半生被毁。这件事的风险概率有多大呢？每年再持续上升。所以最重要的是什么？规避风险。也就是说，从小就要教会孩子，怎么规避风险。你可以一遍遍教育她婚姻很重要，成家很好，老公很重要，没有问题，可以理解，但这类教导最多占30%更多的70%以上的内容，你一定得告诉她，爸妈会老去，会变无力，亲戚和朋友不一定是真心为你好，男友老公也会出事，人生最后的一切结果，都得你来承担。如果你缺乏承担的能力，你就会陷入到更可怕的生活里，比你孤单一人面对难事要可怕的太多了。所以培养孩子的独立性，单纯的独立性，而不是甘于奉献或者依赖，是抗风险的最基础，也是尤为重要的一部分 。这是养闺女最难的部分，因为外部的环境氛围太差，太容易被侵蚀。男孩养育很少会有这个忧虑，因为社会的舆论从小给他们的潜意识就是要拼要努力要独立。所以穷养儿子富养女儿是绝对不对的，正确的说法是：闲养女儿，耐心养女儿，认真仔细正确的引导女儿，这非常重要。对于儿子来说这方面的要求没那么高，儿子最重要的是榜样激励，正面引导，鼓励支持，对于时间，耐心，解释的需求没那么大。女儿也需要这些，但女儿更需要时间，家长多花时间陪伴，极为重要。对于别人的不开心，认真你就输了！对于日常的抱怨，是不能当真的，就默默听听，让人发泄发泄，就好了。​​来自V+会员“打不过就跑”的提问：奶爸，关注您很久了，斗胆问一个问题，跟一个朋友在同一个公司工作，不同部门。但是朋友啥事都很消极，觉得他的上司在搞她。每次只要是跟她在一起她就是在吐槽说这事。一起入职差不多两个月，她吐槽到两个月，一开始自己还有心情开导她说不要想太多，上司没那么有空搞你。后面听她说她跟她父亲聊天。她父母也被她搞烦了。我不是不想开导她，而是她真的太自我为中心了，整天觉得上司有事没事就搞她。可是，我觉得进入一个公司，遇上什么样的人就只能用什么样招去拆她，一味地只是跟所有身边人吐槽这个很多自以为的事情，我觉得真的没必要，发现她自己也没有解决问题，开导自己的能力，只是一味向身边所有人吐槽。 两个月了，真的很烦，搞得我都不想跟她一起吃饭，上下班了。奶爸，请问我应该怎么做？奶老师答：我爸就这个性格。我一开始也想着给他解决方法，毕竟我30多了，又都是一直在一线城市工作，解决过的问题比他遇到过的还要多的多。后来不仅给建议方法，还直接给钱，随便花。但我发现老头还是满腹牢骚抱怨。​​​​后来我发现这是人家的缓压方式，骂骂咧咧的表面之下才是对生活的热爱。而对于日常的抱怨，是不能当真的，就默默听听，让人发泄发泄，就好了。所以对于大部分的来信投稿，我都是不回的，他们也就是选择了一个渠道发泄，发泄完毕了还是那样。不要对身边人的事情太认真，太上心，默默听就行了。因为你认真给意见的样子，会反差到自己的问题没解决，自己的事情没做好，这样就很滑稽。为什么你会被负能量给感染？因为你对别人的事太认真，太上心了。认真你就输了，指的是对别人的事认真。认真你就赢了，指的是对自己的事认真。所以别人吐槽抱怨时候，就听听，然后说同情你，理解你，心疼。就够了。如果他要问你“建议”，你就说我能力也一般，不懂，所以只能陪你一会，没法给建议呢。放心别人不会怪你的。你出个耳朵听听，很快就忘了，然后就不会有问题了。这是最好的社交方法。谈恋爱让男生多花钱就是占便宜的坏女孩吗？你心疼男人没钱，这他妈不是负面激励让自己男人当窝囊废么。​​来自读者朋友“橙子”的提问：奶爸，请教~和男朋友两人目前都是在医院实习（都无收入），你觉得谈恋爱的一些花费是两人aa还是男生多出一些？想知道你是如何做的呢？因为我大概也出了一半的钱，我妈说我太傻，应该男生多出一些。奶老师答：恋爱花费统一规则：确定关系后谈恋爱，女生绝对不可以一分钱不花，但也最好不要为约会消费买单或者AA女生的花费应该重点在两方面，一是主动邀约，二是主动为男友生活上的当家作主。比如，主动说最近xx电影很好看，出来看。比如，你上次的衣服不好看，周末出来我带你去优衣库。具体花费的数量和次数，和男生的花费在1比3比较好——比如你给他买一次衣服，可以抵上一个季度，但是他吃饭请客可能每周都有。总结，确定关系后女生花多少钱是次要的，女生主动，主动表达出对男友生活上的关心才是重要的。AA或者你一顿我一顿很不好，因为这是在表达我很懂事我很靠谱我不欠你的，一种冷漠界限感强的社交礼貌，而不是我喜欢你我关心你我们的感情甜美如蜜。以上说法仅限于确定关系后，没确定关系，处于勾搭期，暧昧期，社交期，普通交往期，那么社交守则永远只有一条：谁邀约，谁买单。多人组局，AA刻意讨好关系，主动送礼。说到这里，很多“懂事”女孩百分百会来抬杠，说不AA就觉得欠对方之类的云云。我觉得这些人很“懂事”，但就是不懂谈恋爱。​​​​谈恋爱要花钱，是因为约会本身有支出，两人相处本身有支出，但是这些支出不是目的，约会本身也不是目的。促进感情，才是目的。“懂事”女孩各种意见和论调的本质，不是为了促进两人的感情关系，而是为了通过这个行为，来彰显：自己有多么的懂事，自己有多么的靠谱，自己有多么的优质。这本身已经脱离了恋爱的真意，是为魔道。如果真的心疼男友没钱，没办法约会，那就精打细算好好过日子。但这就叫做婚姻，而不叫感情和浪漫。恋爱和浪漫本身就是需要最基础的金钱来支撑的，否则就是搭伙过日子，不要谈什么浪漫和感受。这也是我反复强调恋爱花费女男比例1比3的根本原因。你可以心疼男友工作累，你可以心疼男友过劳肥，你可以心疼男友生活粗心大意，你可以心疼男友不懂打扮收拾自己，你可以心疼男友孤单寂寞冷。但是你唯独不能心疼男友没有钱！这是恋爱的大忌，更是找男人的大忌！因为男人的使命就是去远征，去冒险，去开天辟地。你心疼男人没钱，这他妈不是负面激励让自己男人当窝囊废么。男友给你最好的，请你去最好的餐厅约会，你就大方接受，别觉得自己亏欠了，转头你送他个领带或者袖扣啥的，说你工作肯定需要，好好加油，业绩一定能翻倍，这才是正途。要有情感慰藉和正面激励，而不是彰显自己懂事靠谱优秀。这种所谓的懂事靠谱优秀，说白了就是思维狭小导致眼瞎，对男人的品味低下，不会有啥好下场。如何教育女儿，避免长大后成为恋爱脑？ 教育女儿，意味着你必须得坚定的和整个社会作对。​​有个妈妈网友问我，如何教育女儿，避免长大后成为恋爱脑。​​​​在国内，教育闺女的难度永远要远大于教育儿子，这是因为哪怕你不奢求女儿长大后成名成家杰出成就，哪怕你只是想要女儿独立生活不吃亏就好，哪怕是这个很微小的目标。教育女儿，也意味着你必须得坚定的和整个社会作对。而这场战争，往往以父母的失败而告终。这就涉及到一个客观事实：社会风气不好，甚至可以说很差。按照社会的通用标准，不额外的努力，自然而然的养育儿子，长大后他会成为一个掠夺者，不论他给别人造成了多么大的苦痛，但是最起码他自己的人生不会吃亏，作为家长可以完全放心。按照社会的通用标准，自然而然的养育女儿，长大后她必定会成为一个被掠夺者，不论她身边人有多么大的幸福，最基本的她自己的人生一定会吃亏而且吃大亏，作为家长怎么可能会放心。当你想养育女儿的时候，你会惊恐的发现你身边的一切都在跟你的养育作对。你在家谆谆教导，言行模范，女儿认同，可是女儿出门，遇到的亲戚，长辈，朋友，同学，乃至老师，看的玛丽苏小说，玛丽苏电视剧，大女主小说，大女主电视剧，网络，电视，书籍，各种文化制品，无一不在毒害你女儿。家长教育千万句，两集电视剧全都霍霍完了。所以对女儿的养育，格外的困难，格外的需要投入心血和注意方法。最基本的第一点，一定要想办法从小就建立和女儿的信任理解，无话不谈，绝对不可以有任何威压逼迫。和父母哪怕只有一方，朋友相处无话不谈关系密切的女孩，长大后都过的不会太差，很难养成依恋型人格和讨好型人格。而很多家长自以为是的做着光鲜的一切，淡淡的保持着父母的极大权威和所有一切的规矩，认为自己对孩子的管教到位把孩子弄的非常优秀，这样的家庭女孩长大是最总容易出事的。这就是为什么教师和公务员家庭，以及很多高学历家庭的父母，养女儿经常有惨痛结局的根本原因。只有规矩，正确和知识，唯独没有亲密和彻底的信任。有人会担心，亲密和信任，是不是就溺爱闺女，让她长大后太软弱？这个完全不用担心，因为还有一招极好的方法：带着她多从事各种体育活动，并且鼓励她面对困难不放松，不气馁。挫折教育不是说家长觉得孩子生活水平太好了，刻意的去骂ta打ta，给ta点打击，这不叫教育，这叫爹妈有神经病，应该尽快去杨永信教授那里电击治疗，挫折教育的意思是，家庭应该鼓励孩子多从事感兴趣的体育或者文化或者科学项目，并且在孩子遇到挫折的时候，鼓励孩子坚定的走下去。练习长跑，游泳，跆拳道，柔术，拳击，足球，篮球等运动的时候，天然就会吃很多苦，遇到很多挫折，这时候爹妈带着孩子一块练习，鼓励ta咬牙坚持，既能培养亲子友谊，又能培养孩子坚毅的品格，还能培养坚韧的体质，一举三得。当然，前提是得挑孩子感兴趣的运动，不过兴趣也是可以引导的，比如我小时候爱打乒乓球就是受家里人影响，并不是天生的。做到这两点基本以足够，超越绝大部分家庭了，如果还有什么要注意的，就是从小就应该鼓励孩子志向远大，培养极强的事业心。女孩们的事业心不被鼓励，从小就被打击，长大后身边不断有人劝说她要放弃，这就是恶劣的社会风气。作为父母，你不力挺，就真的没人力挺了。局限于当螺丝钉，时间一久人就废了！你就是颗螺丝钉，啥也学不到，来了就是卖苦力的，想啥成长，想啥人才呢。​​最近一个刚创业不久的朋友，问了我一个问题：公司辛苦把员工培训好，怕人学成跑了怎么办？我说这个其实无所谓。一家真正成熟的大公司，在建立之初，肯定是一超多强。即创始人为超人，加几个巨头，不能理解的就看刘邦和朱元璋造反时候的班底。有这几个人在，开始慢慢培养新人成长，不一定要求独当一面，但是有做事能力就挺好。​​​​员工培训好跑了也无所谓，只要巨头不跑就行，巨头也不会跑，因为是合伙人，去别的地方找不到这么好的待遇，公司就是人自己开的，自己有份。公司最需要的担心的，是遇到强技术难题或者商业困境，该怎么办，这时候需要的压根也不是应届生，而是找厉害的人，高薪利诱，分成分股。刘邦团队遇到的问题是困守关中，他需要找到韩信帮他解决这个难题，IBM当年陷入绝境，它们找的是郭士纳，扭亏为盈，增长数倍，通用陷入低谷，寻找的解决方案是内部提拔，把十多年工厂生产和运营资深老专家韦尔奇选出来带领大家一起干。这些人和以前的巨头超人，才是公司最重要的核心资产，最为重要。当年创业的核心团队里，当然会有人能力不行，没法持续进步，那就慢慢架空，只有名头，没有实权，但大抵多为精英。有这些精英在，随便招个小朋友进来，沾沾仙气，都能快速成长。到了公司做大，第一件事就是SOP细化公司的业务线和培训线，能够做到源源不断地培训员工，量产人才。老中青三代，人才济济，根本不用担心有人跑。人可以跑，但是培训系统，业务系统，没办法跑，创造个系统的人，也不会跑（公司就人家自己的，跑哪去），公司再大一点，进入成熟期后，就会彻底分拆细化，把业务精细到每一个模块，你进来后不需要了解公司太多，只需要明白这一个最小的点，把事做好就行了，没人在乎你能不能学到东西。这时候就从根本上杜绝了人才出逃的情况——你就是颗螺丝钉，啥也学不到，来了就是卖苦力的，想啥成长，想啥人才呢。那么倒推过来，这时候螺丝钉硬想要成长，怎么办？倒推流程，而不是满足于分拆的点，在公司工作，尽可能弄清楚所有流程。通过访谈，打听，聊天，跨部门沟通，不到几个月你就能弄明白公司流程，放心这些都是公开的，不会有人藏着掖着，只是你没想过要打听拼图而已。这时候恭喜你，你具备了第一步的巨头思维。懂得经营高层关系，你的努力才能事半功倍！一切围绕着高层关系去进行建设，思考你未来可能遇到的高层都有哪些。​​来自V+会员“甜辣炸鸡”的提问:奶爸，你好。我是个即将大二的学生，大学一年了，我还交不到知心的朋友，经常一个人，总觉得孤单。请问怎样去提高自己的社交能力呢？奶老师答：学生时代属于典型的奋斗时代，奋斗时代需要考虑的不是社交能力，而是高层关系的能力。​​​​啥叫高层关系能力，指的是，有一天，遇到身份地位比你高那么一点的人，你可以施加影响力，得到他的帮助，或者进入他的资源圈沾光。稍微思考下你就会明白，对自己来说以后最大可能的高层，就是面试时候的面试官，和工作时候的上司。再稍微分析下，你就会知道这些人的需求和要求是什么。面试官的第一需求，就是有个匹配度比较高的人，给他省事，降低招聘成本，如何满足需求？多看看招聘网站JD，现在开始着手准备，上司的第一需求，就是得力下属通力合作减轻自己的工作负担，有哪些点属于得力下属，自己试着分析分析，对应需要哪些能力。而面对这些高层关系的时候，你需要有表达自己的能力，推销自己的能力，也就是所谓的elevator pitch如何练习？自己对着镜子练，拿着话题练，参加演讲比赛和辩论比赛，参加口才和演讲辩论的兴趣社团，甚至自己组织一个。如何与高层有共同语言？看看CEO们看哪些书，自己也看那些书。搜搜“大佬爱看的书”，就行了。一切围绕着高层关系去进行建设，思考你未来可能遇到的高层都有哪些，处理高层接触时候需要哪些能力，深入交流又需要哪些能力。这样你就会不亦乐乎。至于说孤独，在庸众群体里，优秀的人一定会觉得孤独的。能撑过去，你的优秀才能开花结果，撑不过去，优秀就会慢慢黯淡，最后沦为平庸。读经管类专业，毕业出来真的很容易当上高管吗？认清现在不是工业时代，而是商品经济时代，金融信息时代，需要的不是螺丝钉。​​今天在知乎上看到一个网友说，技术专业上升空间小，经管专业上升空间大，经管专业可以做管理，然后下面纷纷有很多人表示认同，给他点赞。这种其实是典型的蠢材想法，是应试教育下培养出来的愚蠢和懒惰。​​​​在技术公司内部做管理的人，几乎不可能是经管专业的，必须有相关专业背景，有人喜欢拿郭士纳举例，说他掌管IBM是专业不对口，但人家是电子工程专业的，非常对口。非技术背景，却成了科技行业大佬的情况有没有？有，甚至很常见，马云英语专业，刘强东思想社会学专业，程维行政管理专业。但这些人是创业者，而不是“管理者”，是创始人，而不是总经理，马云很早以前就不做CEO了，刘强东曾经一直把持着CEO的位置，但他公司的CTO绝对不可能会找一个社会学专业的人来做，必定是名校对口专业技术过硬多年资深经验的老专家，来管理几百上千人的技术团队——曾经的CTO张晨就是如此。而非技术公司，主要以商贸为主的，比如化妆品，快消，服装，食品这些公司，技术的同质化现象很严重，主要靠的就是营销，类似宝洁和卡夫这样的公司，他们的管理人员背景五花八门什么都有，学中文的学英语的学会计的学化工的学食品的都有。因为市场营销讲究的是创意和经验，这玩意儿学校教不了，主要靠毕业后自己的学习和积累，工作的门槛壁垒不在于专业知识，而在于时间和资源。从这个角度来说，其实经管专业的优势并不是很大。那么为什么外界总是有这种经管专业出路＞技术专业的错觉？1，有出路的经管专业大部分都毕业于名校，这是因为名校好，而不是因为专业好。2，名校的经管专业培养体系和质量，相对来说要好于工科专业，经管专业学生的口才，表达，交际，情商，抗压能力，普遍要好于工科生。工科专业的培养偏向于狭窄化，螺丝钉化，继而脑残化，又自大又自卑，性格和心理行为都古怪戾气重的工科生不在少数——这是普鲁士和苏联教育培养模式滞后于现在商业社会发展需求的怪胎结果。工科宅男如何破处这个困境，方法也很简单：1，认清现在不是工业时代，而是商品经济时代，金融信息时代，需要的不是螺丝钉，而是懂技术懂交际懂手腕的多面手。2，目标应该由混吃等死的底层技术员，转为技术支持，技术销售，项目经理，产品经理，技术团队经理等等，继而放大野心，做CTO，CEO，项目总监，创业大佬。3，有意识的锻炼口才，表达，交际，情商和抗压能力，工科这么苦都能毕业，这些玩意儿比高数简单太多了。为什么你的努力总是注定没结果？努力的难点不在于时间精力不够，而在于，你连怎么努力，如何入手都压根不知道。​​来自V+会员“张粒子”的提问：奶爸你好，请教一个问题，为什么我都这么努力了，怎么还没有回报？自从转行加入互联网公司后，我每天都很努力地学习，新媒体、爆款文案、社群运营都学。只要当前互联网火的，我都去买课学习，笔记都好几本了。两年过去了，花出去的学费一点也不少，工资却不见涨。我很想知道：自己都这么努力了，为什么依旧得不到相应的回报？奶老师答：这个问题的关键点显然在于努力学和努力干的区别。​​​​学习努力和工作努力是两个维度的事情。努力学习爆款文案的课程，和写出几篇十万加这是两个完全不同的事情，完全两个次元，不可同日而语。放在简历里。学习过爆款文案的课程。和写作经验丰富，曾写出过xx篇十万加。前者可能直接被拒，后者真的就有可能月薪几万了。凡是涉及到改变命运财富增长的，一切事情到最后，真的就只和一个要素有关。努力。努力的难点不在于时间精力不够，而在于，你连怎么努力，如何入手都压根不知道。当个前台，怎么努力表现让总监对你有好印象，从而把你招到销售团队里去？做社群运营，怎么提高下一期的续费率？做自媒体运营，怎么涨粉？光是学点什么认知折叠。这不叫努力，叫没屁用。努力是直接作用在相关项目上，并起到效果的手段措施。比如19年，我写公众号，写微博。不管我怎么写，就是涨不了粉，甚至每天还掉粉。那时候我真的慌乱，觉得到此为止了，完蛋了，不可能再继续了。那时候我很长时间没更新，就是因为这个。于是我研究了很久的同行，看了很多文章，和很多人交流，学习，跟一线的人深入学习。后来这个局面被我一举扭转，每天涨粉至少过千。我没有报名参加任何所谓的新媒体培训课程——我当这些讲师的老师都绰绰有余，有这种徒弟我都嫌丢人，丢份。这一段经历异常宝贵，算是我创业以来的第一个坎。现在回头看，凡事就只拼一个点：就是努力。努力动脑，努力思考，努力分析，努力交流，努力实践，努力总结。没别的好方法。这套方法你可以套用在任何其它行业上，都成立。到底怎样做，才能尽可能让孩子未来有出息？身边缺少了一位雄性的榜样和模板的存在，对未来的成长非常不利。​​来自V+会员“何静静”的提问：请教一下奶爸如何教育男孩？如何建立亲密的关系，挫折教育，鼓励他有事业心？还有没有其他的特别针对男孩的方法呢？奶老师答：有个词叫“男孩危机”，前几年很热门的，由此还衍生出一大堆的各种畅销书，有时间可以看看。没时间就看这一条博文即可。如何破除男孩危机，如何建立亲密的关系，挫折教育，鼓励他有事业心？​​​​方法非常简单。多增加他和爸爸相处的时间即可。或者更直白点。让孩子他爸对儿子的教育多上心就好。你看比如这个问题，就是身为当妈你来问的。这就非常非常非常极度的不妥当了。互联网舆论场上，喜欢钻研和讨论教育方法的，宝爸和宝妈的比例，大概不到1比10，这是个非常不妙的现象。不仅仅是网上如此，线下也是，喜欢讨论并且钻研家庭教育方法的父亲，非常少，而且这个数量随着受学历文化程度的降低而骤减。所以其实不是“男孩危机”，而是“父辈危机”，或者说“丧偶式育儿危机”。在孩童2-5岁这个阶段，叫做前运算阶段，孩子是没有什么逻辑推理能力的，你跟他说要懂事，爸爸忙着工作没办法回家，他根本无有法理解。他只能理解一点，那就是谁对他好，谁就是他的亲人，谁对他冷漠，谁就不是亲人。而在这个关键阶段，身边缺少了一位雄性的榜样和模板的存在，对未来的成长非常不利。所以最好的办法，就是让爸爸多带带孩子，要让他发自内心的喜欢和儿子一块玩，并且多找一些好玩的项目。英文里有个词，叫quality time，直译就是品质时光，高质量时间。在大部分语境下，特指父母或者长辈专门拿出来和孩子一起相处的时间。很多家庭还会认真预约，就像是男女约会一样，充满仪式感。比如：儿子啊，周六下午你别出门了，要专门拿出来和你爹一块游泳，父子过点quality time儿子啊，明天晚上别看电视了，跟你爹一块去修车，过点quality time儿子啊，周末回来一会，你爸想你了，跟你爸唠唠嗑，过点quality time这个时间不用很频繁，不用很多，不用每天都来，但一定要有，一周至少一两次。杜绝丧偶式育儿，让父亲好好陪陪儿子，认真普及quality time，就能把孩子教好。哦对了，如果父亲和母亲都对挫折就处理不好，就没有事业心，工作就没有责任心的话，这个基本就培养不出具有这类品质的孩子，不论儿子还是女儿。如何判断老板是真牛还是草包？虚幻的软就是也讲所谓的方法，智慧，经验，但是讲完等于没讲，几乎等于放屁。​​来自V+会员“彤彤”的提问：奶爸你好，以自己浅薄的阅历判断不出来老板到底是吹牛还是真有料，请问奶爸要怎么判断？奶老师答：面试交流时候看他说话的内容，是硬的多，还是软的多。​​​​硬的就是成绩，头衔，数字，人脉。比如我管200人团队，公司两万人我排第三，我跟马云吃饭，跟马化腾搓麻，我身家千万，世界500强企业的高管我认识至少一半，我的公司上市了，我开兰博基尼。一般和人交流时候，硬性的东西大过软的，那说明他有资源，没能力。软的就是方法论，诀窍。比如：你需要哪些准备可以把工作做好，应该怎么做才能融入团队，如何迅速上手工作，工作时候遇到的常见问题有哪几类，如何解决它们。一般和他交流时候，软性的东西居多，说明他肯定有能力，是否有资源另说。除了软和硬之外，还要提防虚幻的硬和虚幻的软。虚幻的硬就是把吹牛逼当现实，把未来当现在。比如：虽然我们公司现在只有3个人，但是未来我有信心一定能扩展到200人！我们公司迟早是要上市的，到时候人人有车有房！我的理想是颠覆整个行业！这点小钱我真不放在眼里。我们要做至少1000亿规模的企业！我认识很多朋友，各个都身价百万，其实赚钱并不难的。虚幻的软就是也讲所谓的方法，智慧，经验，但是讲完等于没讲，几乎等于放屁。故弄玄虚，基本没法落地，没有任何可操作性和可行性。比如：存量搏杀，全球衰退，大逆行，认知折叠，跃迁，财富自由，认知升级，超级个体，灰色认知等等。举几个例子：午餐肉的出现不是因为工业化大生产精细后诞生，而是因为美国人把认知折叠了。淘宝店做不好不是因为涨粉不够，而是因为你缺乏供应链思维，工作手忙脚乱不是因为你的日程管理记事本等有问题，而是因为你不懂第一性原理，采购能升职加薪不是因为研发了一套供应商管理系统，而是因为懂得底层思维，CEO能成为CEO不是因为第一桶金，而是因为格局，眼光，宏大。以上的方法论总结基本等于胡B瞎扯淡。如果一个上司，虚幻软性内容多，说明这人的脑子有问题，智商过低，虚幻的硬性内容多，说明这人的人品有极大问题，以上就是看人识人，尤其是在处理高层关系，判断比你强那么一点的人到底有没有真水平的一个判断技巧。在领导拉胯的情况下，同事就是你宝贵的财富刚入职场，你没有任何可以交换的才能和价值，就只能靠态度和诚意取胜。​​来自V+会员“惠惠子的奋斗记”的提问：奶爸您好，我即将毕业，根据您的面试分享，很幸运在疫情期间拿到一个offer，所以想问下，在不知道部门和领导的情况下，如何尽可能的避免坑？请问有什么好的方法吗？非常感谢~瑞思拜~奶老师答：公司尤其是大公司最大的优点不是什么工资高平台好前景广，这些都是董事长的，跟你关系不大。​​​​大公司最大的优点是资源丰富，这里的资源就是人，随便找个人都有可能是高手，愿意给你一招，100个高手告诉你一招，你就是绝顶高手。但前提是你得会挖掘，很多人不主动，整天一副死妈脸见谁都没笑，不找招呼不社交还觉得自己这样很好很优秀，这就不行，去黑心作坊和去BATJ没啥区别，都是螺丝钉的命。所以拿到了offer后不知道部门和领导，最重要的就是启动预备方案，从别的人身上学东西。比如我的第一份工作，领导是个傻逼，屁也不懂啥也不会，于是我天天跟别的组的Dean混在一起，向他请教问题学习。我的第二份工作，我不抽烟但也买包中华揣着散烟，大家看我态度都友好，于是告诉了我不少八卦和工作窍门，同时分享了不少资源。这些偏门方法在我升职当了经理以后就再也没有过了，因为那时候我就不是锻炼能力积累资源，而是发挥能力，使用资源了——这个时候人际关系会非常简单。至于现在就更简单了，任何一个地方我只要说一句话“我是微博好几届的十大影响力大V，就会有一堆人过来跟我交流，我教他们怎么涨粉，他们告诉我各行各业自己的各种信息和方法论——不需要忍受烟味，不需要拍马屁，不需要看人脸色。但是在锻炼和积累的新人入门期，这是个非常艰难的时刻，就得拍马屁看人脸色。否则你的才能没办法经过漫长的孵化，积累，增长，达不到开花结果。那就只能当底层。所以把公司当个宝库，和同事们多走动走动，多请教请教问题，善意相待，别人也会待你。刚入职场，你没有任何可以交换的才能和价值，就只能靠态度和诚意取胜。但态度和诚意不是自以为是的善良或者真诚，你觉得自己是个什么样的人没屁用。你做了什么样的行为，让别人觉得你是个什么样的人，这才很重要。所以罗永浩郭德纲自认为自己很内向社恐，但他们的言行让外人觉得能言善辩。自我感觉，和自身言行给外界的印象是两码事。前者不重要，重要的是后者。好好加油。只学习不思考的人就是在荼毒自己！公司的利益诉求点就是你能否把工作做好，给公司提供价值帮助公司赚钱。​​大家平时看了我很多微博分享的职场内容，今天我要特别强调一下活学活用的事情。如何把学到的职场和沟通技巧灵活运用？最基础的原则就是不要偷懒，要仔细阅读，深入理解消化之后再用。实践和使用 的时候始终记住这四个字：换位思考。举例说明：有一个网友，看了我的微博原话：“找工作最重要的不是公司大小，而是line manager如何，因为他决定了你能不能学到东西，未来事业是否顺利。”​​​​于是他找了一份工作，和HR沟通，直接就问：这份工作的line manager是谁？换位思考：一般小公司不会用这么装逼的词，通常都是说：请问我上司是谁，向谁汇报呀。HR没直接回答，反过来问，你为什么要问这个呀？然后就tm精彩了，这个网友直接复制了我的原话，真的是原话：“因为工作最重要的就是line manager如何，因为他决定了我能不能学到东西，未来事业是否顺利。”HR发了一串迷惑问号，没理睬。这个网友还觉得自己特别有道理，特别理直气壮，还生气为什么HR不理他，不专业。因此他截图发我提问，暗示我的东西不管用。同时他还截图发给别的职场博主提问。我简直惊掉了下巴。换位思考下：公司不是大学，压根不在乎你能不能学到东西——甚至大学都不在乎你能不能学到东西。公司的利益诉求点就是你能否把工作做好，给公司提供价值帮助公司赚钱。你想得到自己想要的内容，那么当然就要从这个角度出发去提问：因为我想了解下未来上司的风格，性格，或者说喜好，提前做好功课，想马上跟他合作更高效更顺畅，更好更快的做好业绩完成工作呀。所以想多跟您了解了解他是个怎样的人呀。你这么一说，不仅给HR印象好，也能打开话匣子，达到自己的目的。职场沟通的话术，其实基本和情场100%一致，尤其是在泡妞勾男这个阶段。都是先了解对方的诉求，满足对方的诉求，然后巧妙的让对方实现自己的诉求。你不可能直接上来赤裸裸的就说：你长的美，我想肏你，越快越好。或者你长的帅/有钱，我想占有你，越快越好。扪心自问，其实恋爱的深处就是欲望，而欲望的本质就是这么赤裸裸的。这个和你找工作的诉求是一样的，也是因为欲望，欲望也是赤裸裸的：自私自利，想要钱，想学到东西，想积累资历，想找到平台，想骑驴找马。可对方不是这么想的，对方想的只有两个：你是不是真的爱他——你是否真的值得ta爱。所以你必须懂得换位思考，懂得最基本的沟通技巧和说服技巧。这并不虚伪，而是人和人交际中最基本的利益平衡，失去了这种平衡直接赤裸，社会就会陷入到无序的混乱灾难中——我们不需要证明自己爱对方和值得被爱，而是看到的人直接强上就行，那整个社会都会崩溃。把你琢磨泡妞或者琢磨爱人的精力，拿过来琢磨社交，琢磨朋友，琢磨公司的诉求——这个，就叫换位思考。仔细读完文章，深入细致的了解清楚，不要偷懒，不要原文直接复制粘贴，这是最基本的一步，不是智障都能做到。换位思考则是个高级技能，要求相对较高，但是这个更类似于篮球中的运球，本身没有什么技巧，只有一个字：多练习，自然就会越来越精通。无它，唯手熟尔。所以时时刻刻多换位思考，总是好的。当然很多人总误认为换位思考就是要当包子，怂比，被人占便宜，敢怒不敢言，就是要退让容忍别人，就是吃亏被占便宜不说话，就是要按照别人的要求去做，按照别人的利益去行事，去委屈牺牲自己。这些二傻子怎么说呢，治疗他们是医院的事情，我就不掺和了。千万不要在领导面前卖弄自己，否则卷铺盖走人比谁都快！老大赚的比你多，经验比你丰富，吃过的盐比你吃过的米还多。​​这几个月因为疫情的原因，到处都在疯狂裁员，所以接下来几天我会重点分享求职的文章，争取帮大家找到新工作。​​​​今天讲第一个求职技巧，面试的时候，老大突然问自己宏观的行业分析问题怎么答？比如：你对拼夕西和X音怎么看？这个问题有很大陷阱，因为老大赚的比你多，经验比你丰富，吃过的盐比你吃过的米还多。你夸夸其谈，就容易被任正非话术一下（华为某底层员工谏言谈公司战略，被任正非批示立刻开除，送精神病院），这里一定要注意忌讳：千万不要做预言。预言没有任何的衡量标准，属于无意义对谈，而且显得很滑稽，尤其是对高层来说。我觉得拼夕西肯定不行，这种话只要你说出来，不管怎么分析，都是在吹牛逼。写微博时候讲这个可以，吸粉，传播快，因为傻逼们就爱看这个，什么中美大势，什么什么战。但是面试不行。所以，绝对不要下预言和定论。最好的方法，是结合自己工作来谈。比如我的工作，勉强算文案，那么我就只能老老实实回答：我的工作是文案，所以我们就谈谈拼嘻嘻和x音这两年的广告语和他们做的这些投放吧。我认为他们的文案优点有哪些，和自己的哪方面特质匹配，可以学到的东西是，总体来说我更倾向于xx，因为它如何如何。你这么一说，就显得你无时无刻不在观察自己工作素材，在了解行业。搞数据的，搞产品的，搞设计的，一样可以按照这个模板来说。保证老大听的连连点头。什么叫行业大势，并不是让你去做预言家和策略者。而是让你去学习优秀的工作方法和经验，升华你自己的工作。这不仅是面试套路，而且是工作的思考方法，是你平时在商业社会里接触到的信息的分析方法。越早培养这个特长，孩子长大越可能有出息不论是孩子的能力问题，智力开发问题，亲子的关系问题，还是孩子未来的成才问题，都可以解决。​​来自V+会员“ 停不下来”的提问：奶爸好！就是想咨询您一下普通家庭应该培养小孩哪方面的兴趣爱好啊？我想在运动才艺上给孩子培养一到三个就可以了，可是不知道怎么选择？奶老师答：​​​​运动和才艺的选择非常简单，看孩子自己喜欢哪个就选哪个即可，家长千万不能越俎代庖。这是家庭教育的小事，完全不重要。体育也好艺术也罢，长大后能发挥的也就极少数场合，但是我们的脑子和口才，却是一天十几个小时无时无刻不在发挥作用。这是家长反而经常容易忽略掉的大事，也就是真正的特长。对人生有重要作用。这一点恰恰最容易被人忽略。而这恰恰是最好的特长。在这里我强烈呼吁所有家庭都采用洛克菲勒家族以及肯尼迪家族的教育方法。这个家族传统和教育方法，顺利保障了他们的传承历经两三百年不变，源源不断的有人才涌现，律师，法官，学者，议员，教授，大学校长等等。这个方法的好处还在于，对家长的文化修养要求不高，只是对心胸和耐心有点要求而已。任何平民都可以采纳，而且非常简单易懂，极具可操作性。那就是餐桌谈话，鼓励小辈多谈话。谈什么？谈最近看过什么书，什么电影/动画片，学到什么东西等等。你不需要参与讨论，只需要认真倾听，并且自己有听不懂的地方，请教孩子即可。家里所有大人都这么做，满足孩子的荣誉感。从孩子两岁会说话开始，就保持这个传统，一直到孩子去远方上大学。当然，平时也要鼓励孩子多看书，给他办张图书证，现在都很方便。但光看书不行，一定要保持沟通。这个家族传统传承下去，不论是孩子的能力问题，智力开发问题，亲子的关系问题，孩子未来的成才问题，都可以解决。这是最好的方法，没有之一。垃圾领导毁你青春这句话不假！不同的职业时期，对好老板的评价标准不同。​​微博私信里隔段时间就有人投稿问，什么样的领导才算是好领导。为了解答这个月经问题，我再给大家说一下，如何判断自己需要什么样的领导。我们可以按照能力和资源这两个维度来划分领导的类型。资源，一般来说指的就是人脉关系，钱财，权力等等，决定了此人吃不吃得开。能力，一般来说就指实际工作，把活做好的能力。（姑且把搞人脉搞钱财的事情不算能力之内，因为这些东西可以父母辈传承）。以这两个坐标判断，一般公司里的领导，可以分为四类：​​​​有资源，有能力——李世民，朱元璋，刘秀，跟这种大佬不需要费心思，老老实实跟着他们干就行，有资源，没能力——刘邦，刘备，这种普通人跟着也没用，对他帮助也不大，他们最需要的就是能力卓绝的人，比如韩信和诸葛亮，有能力，没资源——曾国藩创业早期，就有能力，但没资源，到了他创业大成也没资源，权力都被清皇室没收了，但是他培养了大批的优秀人才，李鸿章袁世凯严格来说都算他的门生后辈，没能力，没资源——最常见的傻逼领导。按照这个坐标系，你要懂得判断。有的老板，看似傻逼，但不一定傻逼，他可能运气好，是大老板的心腹，资源非常丰富，大老板极度信任，但跟这种老板就别指望学东西，得到什么培训了，你最重要的是要自己有能力，发挥能力，老板给你平台。有的老板，看似很牛逼，确实也很牛逼，但一直郁闷不得志，得不到重用，部门没发展。对于普通的毕业生来说，最重要的是要找到有能力的上司，尽量不要那种资源能力兼具的老板，这类老板非常牛逼，标准工作狂，未必适合你。对于工作经验丰富，或者优秀的毕业生来说，这时候想的就不该是学习，而是发挥能力了，这时候判断老板最重要的就是资源，只要有资源，能够提供平台，不论自己能力强不强，都是好老板，都应该心怀感激。不同的职业时期，对好老板的评价标准不同。又能教自己东西，又能提供机会栽培自己的，当然是好老板，但打着灯笼也难找，刚毕业时候，最重要是要找能教自己东西的老板，有没有机会栽培自己前途如何画大饼好不好，无所谓。毕业两三年后，最重要的就不是继续学习了，而是有机会，有平台，得到栽培的机遇最重要。可悲！你像猪一样懒，但却无法像猪一样懒得心安理得焦虑就像流沙，你越挣扎，下陷的越深。​​来自读者朋友“拉莫达的烤串儿”的提问：为什么无所事事会让人情绪低落，一点也不轻松。奶爸你好，我是个很懒的人，经常会拖延和无所事事，但为什么每次这么做的时候以及事后，都会觉得很难受，一点都不轻松呢？比如打游戏吧，明明很好玩，可是完全得不到什么快乐，感觉时间就这么一天天过去了，但是自己一事无成，想开始动手做事吧，也不知道从何入手。奶老师答：无所事事的时候却还是情绪低落，原因很简单，因为你在焦虑呗，而且你可能会误以为，只要忙起来就不会焦虑，不会低落了，所以干脆就不忙了，因为你害怕万一忙起来，情绪还是低落，唯一的靠山救命保护伞没了，那难受死了。但事实是：你在很繁忙的时候一样会情绪低落，这个看看广大社畜现状就明白了。忙，并不能像你想象的那样，解决一切问题。那持续造成广大焦虑心理这种现象的具体原因是什么呢？​​​​1，没成绩，没正面刺激，长时间做下去仍然进展一般，成绩平平，身体自然会因为缺乏多巴胺而显得情绪低落。2，社会舆论和应试教育营造的氛围，你必须要努力，你必须要拿第一，如果不努力，不拿第一，你就完了。所以全社会大部分人的潜意识会担心自己的未来。当我们停止工作休息与身体潜意识里的“竞争惯性”相冲突时，你便会开始焦虑，即使无所事事，也会感觉情绪低落，一点也不轻松。3，焦虑就像流沙，你越挣扎，下陷的越深，想逃避，那也只是稍微晚一点而已，一样下陷，不论是挣扎还是逃避，都会越来越糟糕。那么应该怎么解决呢？最彻底的解决方法当然是现实中做出成绩，正面激励，让自己信心满满，但这个做不到。因为正面情绪和正面成绩互为因果，想要成绩就必须在长期得不到激励的情况下持续付出努力，所以正确的做法是，从情绪入手。英国焦虑专家克莱尔.威克斯博士在《精神焦虑症的自救》中结合几十年的从何经历，他对于焦虑问题提出的第一个词便是：“面对”。那如何面对？如何在无所事事的情况下，可以轻松些呢？你可以采取正念冥想的办法：第一步：尽可能舒服的躺在座位上，背部可以靠着椅子，双手放在腿上第二步：闭上眼睛，紧接着把你的注意力集中在你的呼吸上，深深的吸进腹部，然后慢慢的呼出，重复20次。第三步：在整个过程中，如果你的呼吸分散了，则要慢慢的将呼吸转移到你的身体上，你的脚、小腿、手腕、胸膛、脖子、头。第四步：无论你观察到你身体的感受是什么，你只需要观察它就可以，感受它。最后再回到你的呼吸上，用你的呼吸贯穿你的身体灵魂。第五步：从下到上，一直到你的头。每次呼吸，平静加深了，存在加深了，体验感受着般轻松感。音接受而带来的轻松，再深吸一口气、慢慢的呼出来，呼完气，再睁开眼睛。每次正念冥想20~30分钟，坚持3个月，你将有不同的体验。慢慢的，你在工作和日常生活中，也会发挥的更好。怎样才可以改掉眼高手低这个坏毛病？历史上也存在很多郁闷不得志的天才，成功了就是非池中物，失败了就是眼高手低。​​微博后台私信我的网友以及不少V+会员，都有一个普遍的问题，眼高手低，且不自知，自以为自己有很大的抱负，只是暂时不得志而已。​​​​历史上也存在很多郁闷不得志的天才，成功了就是非池中物，失败了就是眼高手低。比如韩信，给项羽看门无精打采没意思，给刘邦管仓库也表现消极，各项职业都做的非常一般，考评都在C-以下。很多人面对工作的时候，都是韩信的态度，觉得眼前的工作没价值，没意义，没前途，渴望着未来的大成就，大事业，挥洒大青春。但是这些人可能忽略了一点，没有韩信的才能，却有韩信的心志，这是件非常可怕的事情。史记记载，韩信在项羽那里当个小兵，献计不被采纳，就投奔刘邦，结果还是当个小兵管仓库，管仓库的时候也心不在焉，应该是陷入了贪污丑闻，要被连坐砍头，排在韩信前面的已经连续砍了13个人，到了韩信了，他说了一句，主上不是说有雄心壮志征服天下吗？为什么要斩杀人才？一般人这时候无非是喊什么冤枉啥的，只有韩信喊的我是人才你杀我就可惜了，当时监斩的大官是夏侯婴，看到这个小兵有点意思，就给了他几分钟跟自己聊聊。这几分钟，可能是韩信这辈子最重要的几分钟。我们在讲职场技能时候，非常强调elevator pitch这句话，就是你在电梯这么短的时间里，可以跟老板说清楚一件事或者一个项目，或者献计献策。韩信完美的做到了这点，夏侯婴说的军国策略，兵法战术，他侃侃而谈，而且见识比夏侯婴还要厉害。韩信，战略问题解决专家的名号，就是从那个时候开始传播出去，并且不断奠定巩固地位的。这里就涉及到一个面对问题时非常重要的区别：不想解决，和不能解决。是两个完全不一样的事情。以社交举例，罗永浩说他也内向，也不擅长社交，也不喜欢社交，你就信了，自比罗永浩。他是不愿意解决社交问题，还是没能力解决社交问题？据我所知，罗永浩去任何地方，可都是八面威风，人人拥戴的，他的社交圈极其庞大且质量极高。可普通人呢？回到工作问题上来说。你觉得眼前的工作没前途没意思，无精打采。总渴望的大的，渴望光鲜和长久未来。那请问：你是不愿意把工作做好，还是没能力把工作做好？哪怕你有能力把眼前工作做好了，解决更庞大，更复杂，更光鲜的项目问题的能力，你有没有？面对大老板简介扼要，落到实处，侃侃而谈的能力有没有？你是战略问题解决专家吗？不是你干嘛要有韩信的心态？三国演义里有个案例，大概情况如下，非严格对照，我记得不是很清楚了：庞统被诸葛亮推荐去刘备那就职，但是庞统这人喜欢开玩笑，故意不把推荐信给拿出来，刘备就打发他做了个县令，当了县官他天天就吃喝玩乐啥也不干，底下人就去告状，上头来了个大官问他咋回事，他说你想要考我能力，那我现在就给你展示一下。于是当天就让属下把公文拿出来自己批注，一边批一边点评给出解决方法，一个上午时间，所有工作全部完成。搞定后他说，工作太简单了，我一个上午就能完成一个月的，剩下的我干嘛不吃喝玩乐睡懒觉呢。惊得大官目瞪口呆。所以，不妨问问自己，你有伟人心态了。但到底是你没能力做好，还是不愿意做好？职场底层永无出路，起码做个主管才会有一丢丢希望做底层，干小公司，也可以，成为业务骨干核心即可。​​刚刚我在一个往期沟通训练营的付费群里说到工作的事情，这里同步给各位V+会员，其中提到一点：被猎头有规律的联系挖，是一个职场人的基本日常。​​​​我刚从有道离职的时候，手机电话基本没停过，有朋友推荐有猎头联系，哪怕到了现在都好几年了，仍然每个月都会有猎头打我电话，问我所谓的“职业规划”，给我推荐职位或者让我推荐合适的人。群里的同学觉得很厉害，但我自己其实当过猎头，我知道这一点都不厉害，反而是职场非常非常常见的普通日常。然而哪怕是普通日常，我发现至少8成以上的人，完全没有感觉，甚至毫无意识。这些人甚至可能不是什么小公司的，就是大公司的，却完全没接触过这样的信息。而我以前的同事，几乎每天，无时无刻不在接触这些基本信息。这就仿佛是一个平行世界。我们每个人都好像在工作，在努力事业，在认真奋斗。我们所处的几乎是完全的两个不同的世界，完全平行，毫无交叉。我平时偶尔会参加一下线下聚会，有时候要求介绍自己工作，我说自己是猎头，立刻一堆人涌上来，来咨询各种职业问题，其中问的最多的是怎么被猎头找到，怎么有一份好事业。这还是在猎头这份工作已经像养兔子一样一窝一窝的随处可见的现在。这愈发让我感觉自己穿梭在平行世界中。想要被猎头找到，其实非常简单：1，在业内一家叫得出名的公司，不用太大，三线以上即可，2，担任主管级别或以上的职位，有业绩或者成绩支撑。达到这两点，就会被猎头骚扰烦死。但哪怕是同时达到这两点，对于相当一大部分人来说，几乎都是遥不可及的。进大公司，不少人能进去，但是升职到主管级别以上，基本没戏。这些人就去小公司能否升职都是个问题。大部分人都在焦虑自己能否赚大钱，但是对于自己眼前的工作业绩能否升职，都很少看重，这是我认为很奇怪的一件事。当然，成功有两条路，靠公司发挥，和靠个人发挥的路，其实都行。做底层，干小公司，也可以，成为业务骨干核心即可——比如很多电商公司的人，一个人扛业绩，撑起一家公司，之后跳槽创业，财务自由，这是每天都在广州深圳上演的一个又一个案例。这一条路和职业经理人无缘，但是说不定能赚的更多。可问题是，对于相当一大部分升不了职的人来说，走这条路就更难了。所以我们的职场，就仿佛被切割成了两个完全不交叉的平行世界。如何打破这个次元壁，恐怕才是大部分人最应该思考的问题。这比什么阶级跃升，要实际的多。如何成为一个坚毅不屈的狠人？所谓玻璃心，就是心像玻璃一样，一碰就碎，没有任何弹性，而反脆弱，就是要提高心理弹性。​​来自V+会员“蒙小小”的提问：奶爸 ～ 怎么应对人生中的各种打击？奶老师答：你的这个提问太宽泛太抽象，没有举例，我没法给你具体问题具体分析，就只能说一下应对这类问题的思维模型。我们人生中必然会遭遇各种大大小小意外的和不意外的打击，我们该怎么应对呢？​​​​1、相信你自己，任何打击，你都扛得住，天不会塌下来。当我们遭受到打击的时候，都会觉得这个糟透了，感觉天要塌下来了一样，难以接受。可是，你现在去回顾以前遭受的打击，那会儿要死要活，觉得要完蛋了，可现在，你不是好好的，挺过来了嘛。无论任何时候，我们遭遇任何打击，我们都能承受得住，即便我们不愿意承受，或悲伤、或痛苦、或一蹶不振，但随着时间，我们一定能够自然而然的克服，就如同尼采所说的——杀不死你的，必使你强大。我们害怕遭受打击，打击来临时候，觉得天下塌下来了，要完蛋了，这辈子不活了，其实是我们高估了打击会对我们造成的伤害。比如高考失败、失恋、考研失败、求职失败、创业失败、炒股失败等等，遭遇这些打击的时候，当时你会很难受，但是只要你活着，不自杀，你就一定能够挺过来，我们的抗打击能力远比我们的想象的要厉害的多。我们高估了打击对我们的伤害，也低谷了我们的抗打击能力。所以，你遇到任何似乎天要塌下来的事情，都不必害怕，后果都不会你想的那么严重，只要活着，你就能扛得住。只要我们内心不奔溃，天就不会真的塌下来。2，不要过分自责，要学会自我怜悯。我们遭受打击的时候，不仅觉得事情的后果很严重，而且还会觉得自己糟透了，就是个垃圾、loser、悲剧，太差劲了。我们会不断的否定和攻击自己，我们会非常自责。这个时候，我们学会自我怜悯。当朋友遭受打击遇到变故的时候，我们不会在身旁讲大道理，也不会批评他们是垃圾、loser、一无是处，而是会鼓励他们，理解他们，关心他们的情绪和感受，寻找积极的原因来引导他们从悲伤中走出来。可是，我们自己遭受打击的时候，为什么就不能像对待朋友一样对待自己呢？我们自己就是自己最好的朋友啊，没有人比你更懂自己了。你要做自己的朋友，去照顾好你自己，安慰好你自己，帮助你自己走出来。这就是自我怜悯。我们也要学会可怜自己，心疼自己，而不是一味的责怪自己，否定自己。你想想，从小父母就责怪我们不够乖巧，上学时老师责怪我们成绩不好，毕业工作领导责怪我们能力不行，全世界都在责怪我们。难道我们还不够可怜吗？为什么还要自己责怪自己呢，我们对自己心善一点不好吗。所谓爱自己，就是自己做自己的朋友，对自己好一点。不要自责，要关爱自己，要积极，才能避免习得性无助。3，用认知行为疗法，理性分析挫折、打击和困境，避免情绪化。当遭遇挫折，当遭受打击，当深处困境，我们很容易悲观、消极、习得性无助。觉得天塌下来了，没救了，完蛋了，感觉承受不住压力了，不想努力了，毁灭吧。有一种想躺平，自暴自弃，摆烂的冲动。这是非常典型的低逆商表现。低逆商，抗压能力弱，玻璃心，很大程度上是非理性思维导致的。这个非理性思维体现在三个方面：a，全面化比如在公司被领导骂，觉得遭受了打击，心情特别不好，然后回家看到老婆没把孩子带好，就朝着老婆发脾气，你天天待在家里，为什么连个孩子都带不好。这就是全面化，一个事情的负面影响，会蔓延至另一个不相干事情上，持续这样不断的蔓延，就会让自己人生的方方面面都受到影响。为什么很多人喜欢破罐子破摔，从此一蹶不振，就是因为这个原因，一个事情的负面影响扩散到方方面面，觉得整个人生都废了，没动力改变了。那么明智之举，就是把事情的负面影响控制在单个事情的范围内，不要让他蔓延出去影响其他事情。这需要我们独立的看待事与事之间的关系。比如：你语文没考好，你认了，然后专心复习准备数学，把数学考好，而不是，语文没考好，就很受打击，然后接下来的几科都摆烂。你感情不顺，你认了，然后专心把事业搞好，而不是感情不顺，事业也没心情搞了，躺平得了。你哑巴了，你认了，然后认真学手语，而不是觉得自己残疾，不如死了算了。当你遭遇打击，感觉自己人生糟透了的时候，一定要注意控制负面事情的蔓延。可以问问自己，这个挫折这个打击这个逆境，真的会对我生活的其他方面产生影响吗？当你这样问问自己，就会知道，未必——就只是这个事情不好而已，对我生活的其他方面没有影响，我依然可以过得很好。既然不影响我生活的其他方面，那我还害怕个啥呢，还伤心个啥呢，这也太矫情了吧。b，永久化。当你遭受打击的时候，你觉得这个是永久的，那你就会很难受，很绝望。比如阶层固化，当你觉得你永远都不可能买得起一套房的时候，你就充满戾气，痛骂内卷，鼓吹躺平。比如创业失败，当你觉得自己永远都不可能东山再起的时候，你就充满绝望，成为老赖，东躲西藏。比如恋爱失败，当你觉得永远都不可能找到心仪对象的时候，你就充满悲观，挑拨对立，不婚不育。当你遭受打击，把事情的负面影响，看成是永久的后，你就会绝望，无奈，想要摆烂。其实，当你负面情绪来临时，多想想，我遇到的挫折，遭受的打击，所处的困境，真的会持续很久吗？你就会发现，也未必——那些打击带来的伤害，其实过几天就好了，再不济，过几个月就好了，反正总会好的。既然打击带来的伤害是暂时的，那我还真的有必要沉溺在消极失落悲伤中太久吗？不会显得自己矫情吗？c，不可控。当我们觉得一个事情不可控的时候，再小的事情，我们也会觉得这个事很恐怖，很无奈，后果很严重。相反，当我们觉得可控的时候，天大的事情，也就那样，该咋办咋办。有没有控制感，主要在于心态，是一个主观感受。即便你胜卷在握，你也可没有控制感，选择放弃到手的好处。即便你无力回天，你也可以有控制感，做好自己的心态建设。我们在遇到挫折，遭受打击，深处逆境的时候，最重要的一个动作，就是找回自己的掌控感。我们可以告诉自己：无论遇到任何事情，我都可以力所能及的做到最好，我永远都有选择——能改变的，我力所能及做到最好，不能改变的，我努力做好心态建设。我做好自己就行了。当你努力找回掌控感的时候，你的抗挫折能力就提高了，你就变得强大了。4，每次打击都是成长的养料，我们要学会反脆弱。只要人活着，就不可能不遇到挫折，遭受打击，困于逆境，痛苦难受。人与人之间遇到的挫折和打击，只有时间的早晚和数量上多少的区别。既然每个人都必然会遇到挫折打击，那早遇到总比晚遇到要好，不仅犯错要趁早，遇到挫折遭受打击也要趁早。从这一点来说，我们遇到挫折遭受打击其实不是一件坏事。更为重要的是，我们对逆境的反应，比当前遇到什么样的逆境，重要一万倍，就如同我们赚钱的能力，比当前赚到多少钱，重要一万倍一样。所以，遭遇打击，我们不应该沉溺于逆境的情绪之中，我们要学会正确应对逆境的方式，也就是建立反脆弱系统。经不起打击的人，就是玻璃心，所谓玻璃心，就是心像玻璃一样，一碰就碎，没有任何弹性，而反脆弱，就是要提高自己的心理弹性。弹性分为两个方面，一是能够承受压力，前文说的3个方法都是，二是能够反弹，从压力中获得成长。也就是说，我们不要吃打不吃记，而是要吃一堑长一智。那怎么做呢？记录、总结、复盘、行动优化。具体的方法就不说了，重要的是有这个意识。5，找到榜样激励自己。你遇到了挫折，遭受了打击，在困境中无法翻身，抑郁不得志，很痛苦很难受，对吧。你可以找一个，同样遇到了挫折，遭受了打击，曾经也深处过逆境，然后成功翻身的榜样，来激励自己。比如“中国橙王”褚时健，原红塔集团董事长，亚洲烟王，后因经济问题坐牢，他的人生大起大落，可比你的精彩多了，人家在73岁的时候出来，还在进行第二次创业，还在折腾，你那点不如意，又算啥呢？多找积极正面的榜样来激励自己，你就会发现自己其实很矫情，你也会发现自己慢慢会变得有力量。这可以帮助你调节心态，不自怨自艾，积蓄心理力量，然后留出时间、精力、情绪和注意力去解决问题，摆脱困境。说了这么多，遇到打击，还是得靠你自己，但希望我的这些建议，对你有帮助，祝好。人脉比学历重要一万倍！只要认识合适的人，商业公司的职位，很容易就进去的。​​来自V+会员“妙妙”的提问：奶爸您好，我26，双非二本毕业，目前在一个广东三线城市当小律师，执业未满一年，年薪大概12-15万左右。最近希望换个更好的平台，如果只是在本市换个律所的话，即使收入有所提高，但其实平台差不多，能学的或者能接触的案子质量有限（现在的所算是市里前几）。大城市的大所很多都招985、211的，还要研究生以上学历，而且现在粤港澳大湾区很热，相关部门也经常发文要收集有涉外经历律师的数据，觉得以后需要这方面的人才。想请问：读个研镀金换平台是否可行？因为偏向读全日制的，需要辞职，但未来收获不确定。想请奶爸分析一下性价比。谢谢。奶老师答：中外所有的职业规划师，都会认同一个基本常识：学历作为门槛的确很重要，能力作为支柱也非常重要，但是所有的学历和能力，都不如一个因素重要：​​​​合适的人脉。合适的人脉，会提供给你一个好的机会。因为商业工作和学术研发不同。学术研发一定要硬干货，一定要强能力，是就是，不是就不是，没有余地。高考录取也是，少一分就是不行。但是别的领域就不是这样了。你学法律，肯定知道一句话：法不外人情。法律这么严谨条理清晰的事情都如此。所谓的招聘需求，就真的那么严格？只要认识合适的人，商业公司的职位，很容易就进去的。大部分人认为，一定要去读研，是为了满足门槛。这个想法大错特错。尤其是法律这种领域。你想读研，无非是为了找对合适的人脉，有好的老师和校友资源，可以推荐自己进去。可惜大部分人不懂，他们就傻傻的认为满足门槛就好了，进了大学也不会主动和老师搞关系，不会到处拜访师兄，白白浪费资源，最后也没啥用。如果能找到积累人脉，合适人脉的方法，不需要读研也可以。等你实在找不到，积累不到了，再考虑成本极大的读书这个途径。现在太穷如何结识有效人脉？社交的开支问题，一定要精心计算。​​来自读者朋友“许公子”的提问：奶爸好～ 我想咨询下，如果朋友邀约你参加饭局，局里刚好有我现在的同事（没见过面），大家可以相互交流。但同事选择了很贵的餐厅，是自己平时消费的3倍，是否需要参加呢？如果感觉信息量不足以支撑消费，会不会显得自己太势利，太在乎钱呢？感谢。奶老师答：这个同学问了个好问题了。这个问题就非常不错。现实问题，社交需要钱，大量的钱。所以到底要不要去呢？​​​​答，不应该，量力而为。办公室的同事不需要这么高的代价去结识，办公室里遇到了微笑打招呼就好。除此以外，社交的开支问题，一定要精心计算，两个基本原则：1，一定要大方的坦诚自己的穷，如果不能对外平常心态的坦诚，就没办法交到真正为你考虑的朋友。也就是说，约局可以没问题，但是要直接说这家店人均太贵了，自己承担不起，在平时也大大方方承认自己的家境。这是个筛选问题，能够有效筛选出势利小人，加以拉黑，这么做能够交到的朋友很少，但愿意帮忙的朋友本来就应该是很少的，不需要那么多，这个方法能够让你交到的朋友，都是愿意体谅你的真朋友。2，不要跨服聊天，可以接触阶层比自己高太多的人，但不要妄图保持亲密接触。举个例子，我在有道打工时候，机缘巧合人带人遇到一集团公司的公子哥，这种富二代一般脾气都很温顺很容易相处，自然就成了朋友，但是我基本一年跟他也不见两次面，因为没法处，出来过两次，吃饭酒吧都是人掏钱，我掏不起，不好意思再占人便宜，而且他那时候说的东西我也用不着，还不如我在公司10块钱食堂跟同事聊聊互联网项目执行。后来我自己做生意赚到钱了，才跟公子哥交往密切起来，吃饭都是他请一顿我请一顿，我也请得起了，他说的什么投资跟管理等方法我也有需要，我说的打造公司私域流量如何看创业公司等内容他也需要，这样才能交往起来。所以要去和自己同级，或者稍微高那么一点的人多交流，才能学到东西。比自己高太多，对你没啥好处。所以，社交场合的花费，是自己平时花费的1.5到2倍即可，3倍太高了。当然，这里说的是交流，不是接触，接触人的话，多多益善，什么样的人都友善对待就好。只是很多人容易把认识和深入交流的关系搞混了，尤其是在性资源匮乏性压力巨大的当代社会，以前留几手博士讲过一个段子，说他身边很多女孩说自己被富二代追，被富二代追，他感觉有点不可思议，为啥那么多富二代把他圈子的女孩都包圆啦，按道理也不应该啊，后来问了富二代，答说派对认识一姑娘，刚接触很热情，喝了点就转场去别的地方吃了点东西，然后送回家，不让操，挺装逼的，拉黑了。他说这跟被富二代追也差了十万八千里啊，咋都这么形容。类似的案例我见过不少，年轻人的虚荣心导致对人际交往的边界认知不清楚，上次我在一大V群里也遇到一个年轻人，说现在赚钱很容易，他身边都是年入千万的人，我说你处在这个圈子自己肯定也很有钱，您年入千万了吗？对方就开始骂我势利，短浅，没格局，不懂友情，没有长远眼光。所以，很多人对朋友的认知，是听说过一人存在=很熟悉=朋友=交往过密=铁瓷。所以很多人的朋友，可能都不记得有这么个人。希望大家都能接触到各种有趣的人，都能结交到真朋友，也都能把握好边界感。打死也不要进入梦游类公司不论哪种情况对你的工作都非常致命，很难搞。​​之前我问过大家一个问题，为什么同样都是小兵，同样都是工作。你拼死拼活累的半死，他啥也不做，你也没办法。为什么他什么事也不做，就什么后果也没有，为什么你一不做事，就会被骂？​​​​这类职场贱人的出现，100%根源是在于大企业的弊病，官僚机制发生。不单单是所谓体制内，私企和外企同样会有。官僚机制发生的最大原因在于，权力阶层的意志无法渗透到第一线，利益的监管负责人不够明确。比如腾讯某部门之前爆出丑闻，主管让男员工双腿夹着矿泉水瓶，让女员工蹲下来用嘴咬开瓶盖。马化腾张小龙本人肯定是没有这样的特殊癖好，也不太可能有这样的审美和行事作风。但这件事就是的的确确发生在了腾讯，为什么会这样，原因非常简单：因为公司太大层级太多，掌权者的个人意志和喜好已经无法渗透到基层了，对基层的掌控力也不够。这就是为什么，大部分创业者，只要是相对比较正经有点能力的，过的都比较俭朴，更不太可能会睡女下属女同事，而职业经理人，非常多的贪污腐败铺张浪费随意挥霍，跟女下属女同事不三不四搞不正经关系的核心原因：不是花自己的钱，不是自己的公司，糟践起来一点都不心疼。创业者的公司，倒闭了就完了，但是职业经理人把公司弄黄了，跳槽换下家照样风生水起。这是我在上海职场见到的每天日常，不稀奇了。时间较短的公司类似腾讯万达，创始人都还在，都身体健康精力充沛，且都励精图治，高层的权力集中且有效监管，仍然不可避免的出现官僚和腐化现象。很多老牌公司，比如福特，飞利浦等等，实际的创始人都去世了，股份权力都被大大稀释了，哪怕是现任CEO都不算是老板直接负责人。反正公司不是我自己的，那我还干嘛要爱惜？这就叫有便宜不占王八蛋，薅公家的羊毛不薅白不薅。所以目前外资公司或者机构里的合法贪腐现象非常严重，上海的那些什么总监副总什么的很多都这样，甚至包括联合国的慈善机构科教文之类的组织都爆出过丑闻，合理的利用报税走账，援助非洲的基金会官员，都配专车，司机，出门都是头等舱，最顶尖的星级酒店，米其林三星大厨上门服务，酷爱高档慈善晚宴，顶级红酒。合法合理的利用规则来进行个人享受。你能指望这群人还认真工作干活？怎可能。当高层出现官僚化，腐化堕落的情况时候，基层就不可能幸免。贱人们存在是无非是两个原因：领导朋友亲戚，领导不想干活，懒得管。不论哪种情况对你的工作都非常致命，很难搞。在这种体制下，你做什么都是错的，基本上没有什么解决方法。梦游类公司，指的就是这种。对别人指指点点，你不知道你自己有多恶心吗？在没有产出，没有拿到人生结果之前，任何人都没有资格去评价他人。​​来自V+会员“小川”的提问：奶爸你好，和女朋友在一起总觉得她肤浅，蠢，没内涵，不求上进，怎么办？奶老师答：这个事吧，得看你对上进的定义是什么？上进的定义是伟大的科学发现，卓越的学术成就，诺贝尔和菲尔兹共舞，那我们都没资格谈什么上进，大家都是草履虫的存在。但如果只把上进狭窄定义为“赚钱”，或者说“赚钱能力”，那么一般直男自以为的上进和能力，其实很可能要比他们瞧不起的肤浅女生要低，低很多。​​​​我大学刚毕业就做了猎头，当时非常不幸分进了一个非常时髦的组，广告组，这个行业的从业人员，99%以上都是女生，而且是非常漂亮的女生。当然这跟我没关系，因为一个男生长的秃肥穷丑的时候，就算掉进了饥渴的女人堆里，也不会有人看得上他的。不过这点倒是并不困扰我，因为工作是工作，不是泡妞，为了工作配合有所业绩产出，我非常认真专业的试图和这些女生沟通，但最后发现这是一种低效无产出无结果的徒劳。因为我们行业组的女生们在一起聊天的时候，讲的都是你今天的头发好好看呀，用的什么牌子的洗发水，感觉怎么样呀，哪里买得到呀，你的指甲油好好看呀，哪里做的呀，下次带着我一起去吧。好呀好呀，我有优惠券可以打7折呵呵呵呵呵。一向能言善辩口才极佳的我，坐在这群女人堆里，默如一默，沉默是金，沉默是今晚的康桥，沉默是那天的上海职场，沉默是枯坐在新天地百无聊赖的我。在这个行业待了几年，后来我就跳槽去了互联网行业，那时候我给我的好朋友eno介绍了个美貌的女网友，当然是他主动要求认识的，说是我一女粉丝，我匆匆说了句提防照骗就把微信给了他然后下线了。他们两人确定关系后，经常一起出来朋友聚会，小姑娘真人确实非常漂亮，但是在一群大男人的聚会里，她也是保持沉默，从不插话。第一直觉我觉得这姑娘知识储备挺低的，人也太内向，没意思，那时候我和普通直男一样的想法狭隘。但是突然我灵光一现，想到了刚毕业时候的上海新天地和南京西路，眼前的小姑娘的此情此景，何尝不是和当时的我一模一样呢，最起码人家还很有礼貌，在一堆臭男人吹牛逼的国家大势特朗普美帝局势等无聊无用无趣的讨论中，非常耐心的倾听，并且加以微笑和温柔的表情示意鼓励你说下去， 完全不像我当年的一张臭脸和自闭表情。我认为在这个场合下的小姑娘肤浅，而当年的上司和同事们，又何尝不是一样的认为我愚笨粗浅呢？再后来我做起了新媒体，接触到了深夜徐老师等账号，这些是我们同行的大手，收入可谓盆满钵满，论上进态度和赚钱能力，比我们这些屌丝直男不知道高到哪里去了。但是她们平时分享的内容，其实和我在上海的女同事们每天聊的关心的，没多大区别。所以你说什么口红头发润肤露，跟美帝经济特朗普，真的有什么高下之分，真的可以随意的去评价别人是不是肤浅和不上进吗？我不这么认为。在没有产出，没有拿到人生结果之前，任何人都没有资格去评价他人，而拿到了人生成果后，对他人的态度会更接近于包容和保护，而不是嫌弃，这是做人的格局和修养问题。相比较这些，我反而认为，在社交场合中，哪怕自己不感冒的话题，也保持礼貌，耐心倾听，予以回应和鼓励，让对方侃侃而谈，如沐春风，才是最重要的。要求造原子弹的工作，实际上比做茶叶蛋还简单仔细沉下心多阅读各个工作的职位描述，把这些要求和工作给具象化。​​接了大量的投稿，我发现，绝大部分人职场上混的不好，主要是缺乏职业精神和职场常识而导致的。​​​​职业精神和职场常识很多人不懂，一方面固然有家庭和教育的问题，但我个人认为至少有百分之五十的原因是职场商界刻意的在和普通人生活之间制造隔绝，明明非常简单的事，非要弄的特别装逼，装逼到了就连对口大学专业的学生都看不懂的程度。以项目经理举例，很多人不说人话，一开口就连直接对口的工科学生都不明白，那么自然很多工科生就天然觉得自己只能当技术，不能当项目经理。我觉得这是一个很不好的现象。我们这的办公室文化和工作方法，基本和别的国家差不多，但是在美帝，职业文化不是个什么装逼的东西，每个小学都有profession day，一群当白领的坐办公室的爸爸妈妈去小学课堂细致的讲讲自己平时做什么事，接触什么人。这种良好氛围的普及性导致，哪怕一个接头小贩，路人，都知道交易员是干啥的，都知道啥叫pitch，都知道坐办公室的工作思路大致方法是个什么样。但是你说国内的很多所谓的高级白领，去小学里讲工作，能让小孩听懂？他们这些人既没能力也不愿意让自己容易接受被小孩听懂，非得高高在上端着。尤其是JD让人看不懂，比如这种：1、跟踪研究市场、行业、公司及新产品品种。2、解读市场资讯和公司研究报告，配合公司进行产品策略的制定和开发工作；3、定期对公司现有的策略执行和表现进行总结评估、分析改进；4、分析客户行为与客户的日常沟通并维护客户档案的真实有效；这谁能看得懂呢？但说白了，无非就是做表格、看数据、做PPT、发邮件、打电话罢了。当然，现在还要加一项，聊微信。所谓的什么跟踪、研究、总结、分析、评估，解读，特别高大上，无非就是收集数据，做表格，看表格，看数字，注意地域，产品，项目种类，客户喜好，然后得出结论罢了。这是任何一个没有生理性脑残疾病retarded的智人，都能完成的工作，甚至经过一段时间的训练后，都会完成的非常好。这一块的工作，其实就是research，而这种所谓的research，和美帝从小到大的教育系统里的research，查阅资料，翻书，找数据，提出自己观点，大胆假设，小心求证，从各种案例数据中提出自己的观点，是完全一脉相承，甚至可以说是一模一样的。但这种职场工作的方法，工具和分析思路，在我们这里是完全隔绝的。而真的去实习了，上司同事也未必有耐心跟你好好说话，好好讲，而是冲上来就各种术语装的你晕头转向，录入半天数据了，不知道自己在干啥，为什么要这么做，这么做有什么意义。所以大家在实习或工作中，很重要的一点就是，仔细沉下心多阅读各个工作的职位描述，把这些要求和工作给具象化，具体把每天做什么工作都搞清楚，这样你们才能针对性的精进工作，积累职场常识不犯错，恪守职业精神不犯规，从而在公司内部有一个好的职业发展前途。节日聚会上如何变得嘴甜？一个人口才不行，是因为不会看氛围，也就是所谓的KY​​我妈妈从小就一直教导我一项技能，几乎每天都说，耳提面命。这项技能就叫“漂亮话”技能。​​​​有时候她用这个词作为贬义来骂我，比如：你净会说些漂亮话，实际行动吧看不到！有时候她有用这个词作为中性来教育我，比如：出门在外，和领导朋友相处，一定要多说些漂亮话，让对方听了心里舒坦，不要学不会说话。上了中学，她还拿着一些余世维曾仕强的鸡汤来教育我，会不会说话，就看这几招，云云。家族里有几个有出息的表哥，成了教授，学者，企业高管什么的，回来我家拜年，看见我妈就亲切握手，说主要感谢三姑从小的教育和关怀，全都仰仗跟你学习说话。妈妈每次都以此为荣洋洋得意，有一次我忍不住揭穿，说人家其实就是拿漂亮话的话术来套路你，拍你马屁给你戴高帽而已，可能他对家里的三姑六婆全都这么说，一模一样，你还真信啦？但说归说，妈妈也经常拿漂亮话套路晚辈，那一套套夸人的词汇量，丰富多彩，层次递进，外人听了尴尬，本人听了舒坦。目前从我接到的各个年龄段的网友投稿和提问来看，我发现这项技能在他们的人生中还是非常欠缺的。热衷当舔狗，对喜欢的人拍彩虹屁。但是对长辈对朋友对领导对同事却说不出一句漂亮话。灵能百分百说一个人口才不行，是因为不会看氛围，也就是所谓的KY其实不止这个，我觉得更重要的是词汇量太缺乏了。哪怕读懂了氛围，也说不出恰当的话。所谓的真诚，真实，真情实感，其实是词汇量缺乏带来的不知所措和自我封闭而已。那怎么办呢？大家可以看一下之前一个同学的提问：奶老师您好，在一个饭局上，大家都说了漂亮话，想到的词都被用光了，然后不知道该说什么了，请问怎么办？答：漂亮话需要积累，你的人生体验太少，当然就不行了。像我的很多漂亮话，一方面是我自己慢慢积累的，另外一方面是我现编的，看见老年人就祝他身体健康。如果别人都已经说完了身体健康，那你可以说什么呢？你可以变化着来，说幸福安康，或者说和和美美，身体硬朗。所以这是一个词汇量的问题，你需要的是积累词汇量。怎么积累词汇量呢？如果你的天赋比较好，你不需要刻意的去记，你就可以直接实践学会的漂亮话。如果你的天赋不好，你就需要准备一个笔记本，在平时看电视，看小说，看到寒暄的场景，把里面的词记下来。或者在平时你跟人社交的时候，吃瘪了，别人把漂亮话抢先说完了，你可以记一下，然后百度一下，查一查近义词。甚至你当场偷偷的用手机查近义词，身体健康的近义词是什么，然后直接说近义词这不行了吗？词汇量是最简单的事情。过年推荐看一本拍马屁的书绝对会让你茅塞顿开，大大提高的你的政治敏感性。​​最近在付费群里一直和大家讨论体制内的工作还有升迁问题，不可避免的要提到“拍马屁”的相关事宜。有关拍马屁这个问题，之前针对商业公司里我们讨论过，具体见如何做好年终总结，拍好马屁之类的博文。那严格来说那不是拍马屁，其实是一些场面话，漂亮话而已，而且很多人并非自以为是的真诚善良，更多时候是不知好歹惹人讨厌，工作做出成绩了就自高自大。我当时写的那些方法，本质上来说，还是告诉他们，做出成绩，要正式的学会感激领导和同事。不论如何，当时我们讨论的重点前提都是：在一家做实事，重视业绩和工作表现的商业公司里，怎么说些漂亮话，搞好和领导以及同事的人际关系。问题就在于，目前国内70%以上的公司和单位是不重视做实事，不重视业绩的，你干的好还是不好都没关系，公司和单位也不靠着你吃饭的。只要混到及格线，就可以安稳混完大半辈子的工作。在这种环境下，如何生存，如何存活，甚至如何晋升呢？因此祭出神书：《参谋助手轮：为首长服务的艺术》看看这个标题，看看这个目录:协助首长决策领会首长意图维护首长尊严探究首长情绪否定首长错误意见向首长传递假话整理首长讲话精神帮助首长圆场等等看看，这是不是马屁功夫已臻化境？不贬低不嘲讽，本书对于拍领导马屁这个话题，充满干货，细细解说，绝对不是一些含糊其辞大而化之的垃圾畅销书可以比的。绝对会让你茅塞顿开，大大提高的你的政治敏感性。严格来说，我不推崇在这类工作环境里奋斗进取，没多大意义，更不推荐你真的采用这种工作方法。推荐这本书不代表我认同这样的奋斗方法。但是怎么说呢，正所谓世事洞明皆学问，这属于一场坏人学，对坏人的学问了如指掌，最起码有一天你堂堂正正通过能力当上首长的时候，可以识别出底下哪些人是有真材实料，哪些人是拍马屁。过年必看的两部职场美剧不存在什么work life balance，工作就是生活，生活就是工作。​​马上要过年了，大家回家也别只想着玩，推荐大家看一下职场相关的美剧。最贴近真实职场，尤其是外企办公室的工作节奏和生活的美剧，我认为是两部。​​​​一部是《白宫风云》，这部剧的节奏快到什么程度？看惯了国产剧的人看这部剧，第一时间会感觉脑袋要爆炸了，连中文字幕都跟不上。仔细观察里面人的语速和作息，不存在什么work life balance，工作就是生活，生活就是工作，一睁眼就是要开始不停的工作工作工作，所有的朋友都是工作里结交的，很难有什么个人隐私，经常通宵或者深夜还在办公室是家常便饭。而其中的各种语速，文件报告，开会，更是超快。当然不用被吓的这么惨，烈度没有电视剧这么可怕，现实没这么可怕，把这个烈度，调整到7-8成，跟现实就很像。请不要害怕，时间长了你就麻木了。另一部是《丑女贝蒂》，表面看很光鲜，其实和白宫风云一样节奏超快，事情超多，贝蒂工作极为努力，但决胜的不是努力，而是专业度，她非常懂公关，创意，市场宣传，活动策划这一套，整部剧集就是看着她从助理慢慢成长为独当一面的高管。原版是哥伦比亚版，我小时候跟我姐看的，剧集节奏很缓慢，没那么快节奏，美国人翻拍后更接近真实的职场，事务繁多节奏超快几乎连轴转。哥伦比亚版最后贝蒂取掉了牙套，减了肥，变成了美女贝蒂，我不知道美国版最后有没有这么安排，希望最好没有，职场和人生的幸福，走到最后，决定因素不是你长的有多美，而是你的才能有多强，地位有多高，资源有多丰富。另外大陆翻拍了这个，好像叫什么丑女无敌，一如既往的在职场和爱情上胡逼瞎扯淡，工作节奏慢的要死，中国人如果说在职场上节奏这么慢这么悠闲事情这么少，绝对不可能这么快就成为世界第二大经济体。如何判断一个行业有没有前途？从经验和学习中来，时间越长，人越厉害，越难以取代，越受欢迎。​​付费群有同学极度执着的问我，虽然他知道旅游业没前途，他也工作两年了工资低的一笔，但是他就是想不清楚问题到底出在哪。问题出在哪？问题出在供需呗。供需分为两个：​​​​一个行业，消费者多，商家少，那么商家就能卖高价，赚钱就舒服，消费者少，商家多，商家就很痛苦。除此以外，就是人力资源市场，人才的供给，远远大于行业每年需要的人数，你作为人才，当然就很痛苦了。国内经历过很多次不同阶段的社会浪潮和专业热门。下海热，房地产热，计算机热，机械热，生物热，环境热，英语热，旅游管理热，工商管理热，市场营销热，以及现在又回到了，计算机热。这其中除了计算机行业较为特殊外，其它所有的所谓的热门，要么就是假的，从来就没热过，比如生物环境农学食品等等，要么就是特殊国情导致的市场空缺。下海热在1996年，因为一方面经过开个开放快20年，老百姓收入高了，消费意愿强了，需求旺盛，一方面是因为国家建立了社会主义市场经济，开公司方便自由，在万物俱废，等待复述，从零开始的时代，当然做生意容易发财，现在就不容易了。旅游管理和英语热大约是在03年左右，因为中国加入了世贸，居民人均收入大幅提高，对外交流意愿空前发达，旅游和国际贸易人才极度空缺，那时候也基本是从零开始，需求不断，当然好做。问题是现在，行业稳定了。除此以外，为什么服务业的平均工资都非常低？因为门槛低。以技术销售举例，比如卖挖掘机的，卖工程设备的，卖磁核共振机器的，这些都是高科技，高科技产品招人门槛很高，基本都要求对口经验+综合素质强。但是服务业，没有高科技，不需要研发，所以门槛极低。门槛高，意味着下限也高，门槛低，意味着下限也低。下限都低，那就得看上限了。我现在工资低，没关系，我要看看未来发展前途如何，这是奋斗者的基本思维。很不幸，酒店旅游业，和其它下限低的行业，比如财务类，广告类，营销类相比。上限也非常非常低。整体的行业基本最高薪水两万，这还是多年资深经验才能达到的。有人说两万也不错，那我问你，你要是博万分之一概率的两万，还是要博百分之一概率的两万？这又是为什么？这是服务业本身的特点决定的：市场营销，有很多点子，创意，渠道，和资源。这些创意和资源，从什么地方来？从经验和学习中来，时间越长，人越厉害，越难以取代，越受欢迎。所以起薪4000，很可能变成薪水4万。但是旅游和酒店不是，你招待客人，再牛逼，再厉害，你不可能自我增值。就像捏寿司一样，你捏30年寿司，不可能捏成啥样。这行的纵深太浅。浅，就意味着，你不可能越老越吃香。你只会越老越不值钱。因为永远是体力更好，要价更低，更年轻貌美的小年轻，比你有优势。所以你看。。。如何提升口才解决说话语无伦次的问题？想要说话不语无伦次，关键是随机应变，这是有方法技巧的。​​来自读者朋友“月婉婉”的提问：奶爸您好，我是V+会员，向您咨询一个问题，请问说话总是语无伦次怎么办？针对这个情况应该如何提升自己的口才呢？奶老师答：说话语无伦次这个问题，在不同场合情景下有不同的应对方法。这些场合大体可以分为两类：1，可以提前准备的场合，比如：面试、汇报、开会、述职、演讲、获奖感言等场合。2，只能即时反应的场合，比如：突然被抽起来回答问题、突然需要解释某个东西、突然要求你发表对某个事情的看法等等。对于可以提前准备的场合，应对方法有三点：1，缓解紧张。说话语无伦次，不一定是思维没有逻辑和思维混乱，很大一部分原因可能是因为过于紧张而导致的。想要缓解紧张，一方面平时就要进行大量刻意的脱敏练习，另一方面就是在上台之前多深呼吸，让自己冷静下来，多思考所要表达的内容，少思考表现的不好怎么办等恐吓自己的事情。克服了紧张的问题，你的其他准备才会产生效果。2，提前准备好逐字稿。准备逐字稿非常重要，记住是逐字稿，而不是思维导图，不是框架。只有逐字稿才能过让你在紧张气氛下还能够记住自己要表达的内容。那为什么我们会在台上记不住逐字稿呢？是因为你没有背诵，或者背的次数不够。背逐字稿，20遍都不算多，一定要背的非常之熟才行。如果你希望表现的好一点，很紧张，那么一定要把逐字稿背透。背不透，忘记了内容，磕磕巴巴，语无伦次就很正常。那么就只能怪自己懒了。如果你不知道怎么写逐字稿，可以看这篇文章《如何有效提升自己的表达能力》3，提前准备别人可能会问到你的问题。如果你只是准备了逐字稿，那么别人提问的时候，你没有准备，可能你当场直接就懵逼了。没有思路和头绪，不知道该怎么回答，不知道该怎么组织语言，那么你说话就会语无伦次重复啰嗦没有逻辑和重点。所以，不要只准备逐字稿，还要准备面试官、领导、同事、观众等人可能对你的提问。他们大概率会问哪些问题要提前研究清楚。然后针对这些问题该怎么回答，也要研究清楚，并准备逐字稿和背诵。4，提前进行大量的模拟练习。在背透逐字稿之后，还要进行大量的现场模拟练习，越逼真越好。可以录视频或者录音，然后录完看回放，找出自己可以改进的地方，针对性的进行优化，再进行模拟练习，一遍一遍的这样迭代改进优化。在时间允许的情况下，多练习几次，多多益善。说完这四个方法，你会发现，对于可以提前准备的场合，想要表现好，说话不语无伦次，关键不在台上，而在平时的台下，在平时就要进行大量的练习和准备。而对于只能即时反应的场合，想要说话不语无伦次，关键就是随机应变了。当然，随机应变且是有方法的。在需要即时反应的场合，大致有三类情况需要我们应对：1，回答非常熟悉或擅长的问题。回答这类问题，一般不需要花时间思考，直接就能想好怎么回答。那么避免语无伦次就很简单，方法就是结论先行和分点论述。先说结论是什么，然后说原因，第一第二第三，分点说出来就好。2，回答完全没有头绪和思路的问题。回答这类问题，就只能碰运气了。因为短时间内你根本没有时间把一个复杂陌生的问题思考清楚。要么你承认自己不知道，要么你就想到什么说什么，不要在乎自己说得有没有道理。想到什么说什么，想要避免语无伦次，我们要有条理，看似有逻辑的讲出来。可以直接进行分点论述，针对XXX这个问题，我认为有以下几点，第一XXX，第二XXX，第三XXX……在你没思考清楚答案的时候，你开头就不要说有以下3点或者具体的几点，而是直接说“有以下几点”。这样你后面才可以想到几个点就说几个点。你想到几个点，你就依次说出来就好，第一第二第三第N，不用在意这几个点之间的联系和逻辑。因为你根本没有时间去思考清楚他们的逻辑关系。你把几个没有逻辑关系的点，按照第一第二第三第N的格式说出来，实际上没有逻辑，听众也会感觉有逻辑。你的目的就达成了，答案不一定对，但听起来至少是有条理的，不是语无伦次的。3，回答一知半解的问题。面对这类问题，你既有答案，但是思考的答案又不完整，是最容易变得语无伦次逻辑混乱的。因为你没有时间去完全思考清楚所有答案，更没有时间去整理组织语言答案。所以，想要避免语无伦次的话，回答的时候应该针对已经思考好的答案进行重点论述。重点论述就是着重详细的说一个点，因为说多了你也说不清。这时候推荐两个表达结构：1）问题+原因+解决方案2）问题\\现象+原因+本质+建议+结果这两个结构只是参照，你可以具体根据自己的情况进行修改。而且你临场反应可能想不起这两个表达结构。那么重点就是：着重详细的说一个点，说清楚，保证结论先行就行了。这样可以避免语无伦次的问题。对于必须及时反应的场合，你记住这三个技巧就够了。因为这种需要马上反应的场合，复杂的技巧是很难用出来的，你把我说的这三个简单技巧记住就可以了。简单的技巧，能用出来的技巧，才是好的技巧。但以上的技巧不过是临时的应急之法。语言是思维的载体，你回答不好，磕磕巴巴，语无伦次，是因为没有思考清楚。没有思考清楚，是因为你缺乏相关的知识背景。所以，真正重要的还是平时的积累，持续的读书学习，对业务专精，对问题的深度思考才是根本。最终，功夫还是在平时，希望你重视起来，加油！普通人做销售就是去当炮灰！普通人误解的所谓销售，往往是2C销售。​​我之前写过多篇2C和2B区别的文章，很多人还是不懂。所以再给大家补充一点，方便大家好理解。2C和2B的业务，除了跟产品有关系，跟业务也有关系。拿我个人最崇拜的公司3M举例。​​​​3M这家公司，实际运营时间至少得有150年，开发的专利产品一共有3万多个，也就是现在在卖的产品种类，多到了恐怖的程度。以2元钱一副的耳塞为例，这玩意儿肯定是标准的2C的，普通消费者购买。但是，如果耳塞不是卖给普通消费者，而是卖给施工队，射击队之类的地方呢？施工队统一采购，采购之后发给工人，射击队统一采购，采购之后发给队员。这个时候，就是非常典型的2B了，因为是签合同，定期供货的。当然3M的真实商业模式是否如此不太确定，我说的只是一个假设的案例分析。耳塞这玩意儿技术含量是不高，不需要专业背景就能卖出去，问题是，如果你做2B渠道，你接触的对象是什么？施工队的队长，工程项目公司的采购经理，项目经理，体育局的官员等等。这些人是社会的中坚阶层，有头有脸，有款有范。一个刚毕业的大学生过去，啥也不懂，说错话做错事得罪人，怎么开展业务？所以2B渠道对销售新人招聘的要求极高，并不是大家想象中的那种油腻，喝酒，吃喝招嫖的黑暗。恰好相反，反而是谈笑风生，如沐春风，令人愉快的交谈方式。你身边最优秀的同学，那种让你也有这种感觉，人际交往极为擅长的人，他们毕业就可能做这种你瞧不起的工作。而你瞧不起，一定会被排除在外，根本入行都没机会。这还是耳塞这么个简单玩意儿。拿3M的通信耗材举例。所有的光纤都需要一种特殊的纸垫。这款纸垫的专利就在3M手里。不论是华为，中兴，还是思科，又或者是移动联通，想给你村通网，就必须采购这款产品。这玩意儿看着好像很简单不复杂没技术含量，但是3M的销售出门，面对的客户都是什么人？华为中兴等大公司的技术经理，采购经理。必须要回答很多技术问题，尤其是光纤的维护和定期维修等等。没学过这方面技术的人，你再怎么请客吃饭招嫖也没用，答不出来就是答不出来，就是卖不出去。懂技术，但是口才不好，不擅表达的人，没法说服客户，一样做不好，卖不出去。那种通信专业里，模样好，机灵，八面玲珑，口才流利，让你感觉非常优秀的同学，人家毕业了，就干这种工作。是的，你身边最优秀的专业人才，才有资格做这种工作。各大2B业务线对销售的招聘，就这个要求。至于普通人误解的所谓销售，往往就是2C销售。啥叫2C销售。就是一丁点技术含量都没有，接触的人群也很low的，比如洗发水化妆品的推销，电话销售，保险，房产中介，卖场推销。等等等等。2C的销售，最重要的不是单对单去说服，去做项目。最重要的是营销转化。是通过大规模的宣传和营销，让品牌深入人心，实现转化才行。但是2C的营销市场部，门槛又很高，所以。。。对待不怀好意的同事就该狠心打击报复在利益交错的场合，那么当然就是政治家心态，没有个人情绪，只看利益得失。​​来自V+会员“舒薯”的提问：奶爸你好，我自己的工作能力不错，公司的领导上司都很喜欢我，但是总有部分同事不喜欢我，而且不是因为我做人有问题，而是第一次见面就表现出敌意。请问到底是因为可能我什么原因，才导致工作人际关系不好？我应该怎么做才能缓和这些关系呢？奶老师答：这个题主是个美女，看样貌应该在30-35岁左右，刚好是在事业的黄金时期。女生在人际交往方面，确实会比男生更介意，更在乎，更容易投入不必要的时间和精力。这是中国社会从小就对女生刻意进行的“淑女教育”导致的，鼓励男生去志在四方，理想远大，要求女生文静善良不要太有事业心等等。​​​​所以男的很少会思考纠结，为什么我身边人喜不喜欢我。他们的逻辑多在于，有没有钱？有钱了我要不要拉拢对方，或者对方有钱，我要不要巴结对方。所以对于男性来说，尤其是事业心比较强的男性来说，人际关系不是一个状态，感情，或者说一种烦恼。而是一个可以解决的问题，或者说需要努力干的事业。可以解决的问题，可以奋斗的事业。职场的人际关系，就是这样。交朋友，交心，那肯定是两三个死党足矣，但是在利益交错的场合，那么当然就是政治家心态，没有个人情绪，只看利益得失。能拉拢的，就拉拢，不能拉拢的，就和平相处，刻意侵犯自己利益的，那就当机立断的弄死。在职场上要拉拢谁？领导，永远是领导对自己的利益裁决权力最大，要跟谁和平相处？对所有人都和平相处。要弄死谁？侵犯自己利益的人。对于不喜欢自己，表达敌意的人，看他是否真的使坏，没有，那么就哈哈一笑，展现出政治家的胸怀，等待机会拉拢。对于真的给你使坏的人，那么就当机立断，弄死。弄死的方法有很多种，在得到领导赞赏的情况下，不需要担心这个问题。好好加油干吧。年龄大的底层员工，下场会越来越惨能力，指的就是管理能力，一个人，打造团队，团结队员，指挥团队去攻城略地的能力。​​职场的基本规则是up or out不升职，就出局。我微博分享的内容方法都是按这个逻辑来的。人类的工作都只有两条标准：1，让自己不被淘汰，不变坏，2，飞黄腾达。我教的大部分技巧，外人看来以为是成功学，是铜臭，也就是所谓的2，但其实我重点集中的，是11，也就是所谓的要求稳定。稳定分为三种：​​​​1，制度型稳定，把自己和国家捆绑，2，能力型稳定，铁饭碗不是一辈子在一个地方吃饭，而是去哪都有饭吃，3，产业型稳定，自己开个店，开个产业，掌握了一定的生产资料。最稳定的当然是1，因为我们国家真的很不错，不会像欧洲或者美国某些城市的政府那样破产，公务员老师发不出工资甚至裁员的情况，基本在未来很难发生。当然不要指望一张报纸一杯茶可以混一天的轻松了，国家深化改革的意思就是让所有公务员都忙起来，撅着腚干活，而不是轻松。之后稳定的就是3，但是3的要求也是最高的，不要小看能在你们小区门口开杂货店开了三年以上还没事的人，这些人都有一些地方是普通人没有的。最后稳定的就是2，能力型稳定，而能力型稳定，很多人仍然误以为是类似考试读书应试教育的那些能力，自己一个人，一支笔，可以搞定所有。商业社会里压根不存在的。能力，指的就是管理能力，一个人，打造团队，团结队员，指挥团队去攻城略地的能力。这个和带兵打仗是一个道理，小兵就是炮灰，随便找，随时可以替代，年纪大了踢掉换一个。这还有哪门子稳定。但是基层的连长，营长，乃至团长，就是非常重要，无比宝贵了，是每个军队的重要财产，轻易不会替代。这些人才叫稳定。如果你家里没产业，考不上公务员老师等等，真的要混职场，就不要还抱着应试教育那一套死读书想法，天真的认为靠个人能力也好，靠技术专精也罢，就能混得好。不可能的。最基本的职业觉悟认知：请想方设法混到连长。在职场混日子，不想升职？最后只有一个下场。up or out忍不住和别人比较怎么办？想要避免焦虑，不和别人比较，就是要有自己的目标，要有自己的人生规划，要有自己的想法。​​有很多V+会员的读者朋友问到，总是忍不住喜欢和人比较怎么办？这个问题说严重不严重，说不严重也挺严重的。因为有比较心态的人，喜欢嫉妒别人，会过得很不幸福。严重的话，可能做出伤害别人的事情，或者伤害自己把自己搞得焦虑抑郁得心理疾病。我接到类似的来信，不在少数，所以还是有必要认真说清楚。1、为什么我们喜欢比较别人？这个问题不知道你有没有认真想过。一般来说，低自尊且好胜心强的人，喜欢和别人比较。就是自己觉得自己很差，看到别人比自己优秀，自己就觉得自己更差，而且看到别人很优秀自己心里会非常不舒服。总喜欢关注别人的一举一动，尤其是别人取得的成绩。别人有什么好消息了，自己心里就开始酸了。为什么低自尊的人会喜欢和人比较，还好胜心很强，喜欢嫉妒？因为低自尊的人从小缺爱，缺少”我很好，我很棒，我很不错”的感觉，长大了，就会极其渴求这种感觉，来弥补内心的空缺。因为太缺太需要这种”我很好”的感觉了，所以他们无时无刻不在追求”优越感”。只有优越感，才会让他们感觉心里很舒服，才能暂时弥补内心的空缺和难受。优越感从哪里来呢？就从和别人的比较中来。自己在某一个方面比别人更好，才会得到优越感，自己和自己比是获得不了什么优越感的。所以这类人，喜欢拜高踩低打压别人，喜欢买奢侈品，喜欢发朋友圈装B。他要展现自己比别人更优秀，更强，生活更幸福。如果不展现出来让别人知道，那么变优秀，变有钱，生活变很好，就没有什么意义了。追求优越感，让人忍不住和别人比较，和别人比较，让人时刻关注别人而不是自己，这就会出现一个严重的问题：他对自己没有什么目标，没有什么规划，没有想过怎么过好自己的生活，做好自己的事情。只想着和别人比较，注意力都放在别人身上了，除了想超越对方，没想过怎样提升自己。这样的人，很难有出息。一个没有目标，没有规划，没有自己想法的人，就说明这个人没什么坚定的信念和理想，没什么固定的价值观，只会人云亦云，以及相互攀比，不大可能会有什么成就。他们的人生可能就是：1，读大学就天天盯着谁拿奖学金了谁保研谁发论文了，2，工作后就开始攀比穿着品味吃喝玩乐消费，3，到了一定年龄就开始攀比自己的另一半多有钱了，4，婚后就攀比谁的房子位置更好车子更贵了，5，生娃后就开始攀比孩子取得的成绩和兴趣班了。反正就是没完没了，一辈子都在比较和攀比。在比自己差的人面前，就充满优越感和鄙视的目光，在比自己好的人面前，就充满自卑感和焦虑心酸的神态。既充满优越感又充满焦虑，两股情绪来回倒腾，让外人看着觉得十分恶心。那么如何避免与他人比较呢？很简单，改变对比较的认知。2，优越感没有用。优越感不能让你成长，不能让你赚钱，不能让你获得异性的欣赏，只会让你变得不人不鬼，十分恶心让人生厌。优越感太多的人，是没有友谊和爱情的。所以，你要警惕自己的优越感。多想想你的优越感，多少来自你的实力，多少来自别人的加持，多少来自打压别人，多少来自和别人攀比获得的。反思一下，你真的有资格有优越感吗？3，和别人比较这个行为本身就是不合理的。人的家庭环境、经济实力、资源背景、性格脾气、目标规划都是不一样的，每个人都是独特的，根本就没有可比性。都说人和人的差距，大过人和猪的差距，那么，你和别人比较，与你和猪一起比较，有什么区别呢？你为什么不去和猪一起比较，而要和周边的人比较，难道是猪不愿意吗？人与人之间的差距大过猪，真没有比较的意义。而且和人别比较吧，很多人也不会正确的比较。总是把自己的弱势和别人的长处一起比较，这个脑回路有问题，这不就是自找罪受，求打击么。你说你忍不住比较，那你反过来，把自己的长处和别人的弱势来比较，找找自信也比找总打击要好呀。还有，别人其实根本没有你想的那么完美，你看到的只是别人的高光时刻，别人付出的努力，别人表面背后的痛苦，你是不清楚的。别人并没有你想象的那么轻而易举的就变得完美优秀获得成功。想要变得优秀就自己努力，没必要比较和嫉妒。4，和别人比较阻碍自己的成长。每个人的情况不一样，每个人都有自己的路要走。你和别人比较，就是去走别人的路，但对你自己来说，路就是走偏了。和别人比较会迷失自己。相反，我么应该多和自己比较。和以前的自己比较，每天都超越昨天的自己，才能成长，才能在自己的路越走越远，才有意义。只有自己是最重要的，多关注自己，多做好自己的事情，比什么都重要。别人对我们来说，说的好听点就是过客，说的难听点就是个屁，没必要和他们比较。5、屏蔽让你焦虑和忍不住比较的人。谁让你焦虑和忍不住比较，你就屏蔽谁。别人发朋友圈让你很不爽，就不看他们的动态。最好整个朋友圈都别看，除了带来焦虑，没什么用。现实生活中，谁让你焦虑和忍不住比较，你就离他远点，眼不见心不烦。最重要的，想要避免焦虑，不和别人比较，就是要有自己的目标，要有自己的人生规划，要有自己的想法。专注去实现自己的目标，别人什么东西再好，只要与自己目标无关，也不关注。因为目标外的东西不重要，目标内的东西才重要。你要学会区分，什么东西对你重要，什么东西对你不重要。重要的东西才关注，不重要的东西不关注，多关注一点都是浪费时间生命。比如，你对大学的规划就是毕业出来拿到一份高薪工作，那么你就应该多实习。而室友同学朋友拿奖学金多少多少，保研到了什么名牌大学，你就少酸少在意少关注。别人怎么样和你没有关系。你只需要关注你规划和目标内的事情就行了。还有，人与人之间不只是有你死我活的零和博弈，还有更多的正向博弈。人与人之间不仅需要比较和竞争，还需要更多的共同合作和成长。所以与其想着怎么和别人比较，不如多想着请教别人，自己怎么改善提高。要敢于承认和认可别人比自己厉害，然后和他们成为朋友。对于别人的厉害的地方，多鼓励，多请教。如何有效克服精神内耗变得成熟强大？弱者觉得很痛苦的事情，强者不一定觉得很痛苦，甚至觉得很轻松平常。​​成功学不是科学。但很多人对它的迷信超过了科学。最经典的一句话，只有经历了痛苦才能成长。乍一听好像没毛病，但是细想就有问题。真的只有经历痛苦才能成长吗？经历痛苦才能成长，所以我们要挫折教育吗？要搞清楚是否必须经历痛苦才能成长的问题，那最重要的，是如何定义“成长”这个词。成长，是自己和自己比较？还是自己和别人比较？还有一个与之相似的，大家容易混淆的概念——成就。你觉得成就，是自己和自己比较？还是自己和别人比较？成长和成就这两个词的区别，搞清楚了，才不会南辕北辙。​​​​成就，是自己和别人比，要战胜别人，把别人比下去，成长，是自己和自己比较，不断的战胜昨天的自己，不断的进步。我们的目的是成长，而不是成就，不要把目的搞错了。而且，要先成长，我们才好后有成就。当自己成长到一定阶段的时候，才有资格去和别人比较，和别人比较成就。所以，当我们讨论成长的时候，是和自己比较，讨论的是如何战胜自己，而不是战胜他人。很多人喜欢去攀比，其实不是在成长，而是在散发人性的恶臭，去嫉妒甚至坑害别人，很难有自己真正的提升。想要成长，和别人比较是没有意义的。确定了定义，那么是否必须经历痛苦才能战胜自己呢？不一定。这就是一个强者心态和弱者心态的区别了。弱者觉得很痛苦的事情，强者不一定觉得很痛苦，甚至觉得很轻松平常。痛苦很大程度上是精神上的，情绪上，而不是肉体上的痛苦，这种痛苦是主观的，同样的事情，你觉得痛苦，别人可能却觉得没什么感觉。你懦弱，很小的，屁大一件事，你都会小题大做，精神内耗，动不动就痛苦难受，抑郁不想活了，人间不值得。你强大，哪怕天真的塌下来了，你也会沉着冷静，情绪稳定，该怎么办就怎么办，能改变的就积极想办法，不能改变的就坦然接受，危机之下还有心思嗅下悬崖边的鲜花。所以，强者心态与弱者心态的区别就在：强者，积极主动，学会调节认知，专注于解决问题和行动。弱者，消极被动，不会调节认知，沉溺于消极情绪和逃避。对于一个人正常人来说，本该痛苦的事情，对强者来说，没什么感觉，但对弱者来说，可能就会要了他的老命。是否必须经历痛苦才能成长呢？答案很明显了。对于弱者来说，经历了痛苦也不能成长，什么都让他很痛苦。对于强者来说，不经历痛苦也能成长，没有什么能让他痛苦。这里的强者与弱者，不是实力的强弱，而是心态上的区别：拥有强者心态的就是强者，拥有弱者心态的就是弱者。痛不痛苦，与成长无关，只与你的心态和精神力有关。你觉得痛苦，可能只是因为你太弱鸡了。所以，不要去强行让自己痛苦，去自虐，而是要改变认知和心态，提升精神力，成为强者。那么如何才可以的变得精神强大，锻炼自己的强者心态呢？强大精神的人，只不过是更能真实的认识这个世界和这个世界的人罢了。他们懂得如何调节自己的认知——当认知失调，自己的内在想象和外在现实不一致时，他们愿意尊重外在现实，主动的改变自己不合理的内在想象，让内在想象和外在现实变得一致。认清这个世界和这个世界的人，见怪不怪，自然内心就强大了。有两个思维方式可以锻炼下：1是换位思考，学会去站在对方的角度思考，你会更理解别人，更能理解别人眼中的你。举个例子，你总是在意别人对你的看法和评价，你换位思考一下，你平时都不在意别人，都不多看别人一眼，都不关心对方过得好不好，那为什么别人平时就会在意你呢？你是多长一只舌头还是多长一只眼睛呢？别人平时不仅不会对你有什么看和评价，别人根本就看不到你。以及每个人真正在意的只有自己。别人对你说三道四，只不过是你侵犯了人家的利益，而不是你这个人真的有什么问题。你懂得这样换位思考，就更能理解这个世界上的人了，也不会为此而担惊受怕了。2是现实思考，坚持唯物角度的去思考这个世界，你会更尊重现实，更能理解自我的发展。这个推荐你去学一下概率论或者统计学，你就会对现实思考会有更深的理解。你的成功和失败，其实都是存在概率的，而不是主观的——你努力了就更容易成功，你不努力就不容易成功。真实的世界不是这样的。真实的世界是复杂多变模糊不清的，不以为你的意志为转移的，成功与失败，大都可以用概率大致估算一下。你做了件小概率才会成功的事情，没有成功，你觉得失败了，无法接受自己，活在人生阴影里，那就是SB绝大部分创业者就是这个调性，觉得自己创业就应该理所当然的成功，一旦失败，就颓废堕落，自暴自弃，走上天台，不活了。真正尊重现实的，是尽可能不做小概率风险的事情，比如创业，赌博，炒股这些事情。或者说要做，也要做好风险管理，而不是一把梭哈。这时候，即便也失败了，也会坦然接受，知道概率在这儿，本来概率比较小，没什么好可惜好后悔好自责的，更不会觉得活不下去。所以，痛苦并不能让我们成长，相反，我们应该避开痛苦，以及尽可能让自己变得强大。职场上应该怎样表现自己很优秀？口才和社交技巧，不是用来表现的，是用来不犯错的。​​刚毕业进入职场的新人，普遍有一个问题比较严重，就是学生思维。学生思维的成因，主要是实习少导致的。缺乏职场基本常识，拿着学校的那一套认知和思维来应对全新的职场，所以显得会比较自我和理想化。比较典型的就是如何在职场上表现自己。如何表现自己，新人想到的是口若悬河的高谈论阔，是妙语连珠的左右逢源，是通过口才和见识展现自己优秀的一面。似乎无论是出行办事，还是团建聚餐，都应该勇敢且自信的展现自己，才能脱颖而出让老板高看一眼。实际上，学校是这样，但职场不是。在学校，无论是课堂发言，辩论，演讲，还是酒桌聚餐，能够夸夸其谈的人，确实会被认为是会来事儿的，擅交际的，受欢迎的。大家容易被你的口才、见识和自信所唬住。大家都半斤八两，你会装逼，当然你厉害一些。​​​​但在职场上就不一样，你是新人，你是职场底层，你再怎么表现也唬不住任何人，在其他人看来，你的表现就是装逼出风头，愚蠢。哪怕是迎新晚会这种看似你是主角的活动，实际就只是一个形式，老板才是主角，还轮不到新人。强行出风头，段子滔滔不绝，客套话滴水不漏，实际上同事看你是小丑，老板看你是傻逼。夸夸其谈，左右逢源，自我表现，抢走了本该打在老板身上的聚光灯，忽略了老板，是巨大的错误。表现的舞台，小职员的仅限于汇报、述职、年终总结和答辩等正式场合，除此以外都是老板。老板在身旁，老板就是C位，职场新人不要出风头表现自己抢聚光灯。在汇报、述职和答辩等正式场合，你就应该认真表现，拿出200%的精力准备，写好逐字稿，多练几遍，结论先行，STAR原则，数据支撑，详略得当，这才是属于你的时刻。而在其他的各种场合，就别太把自己太当回事儿，低调才能不惹人厌。不必在路上或餐桌上妙语连珠，不必把漂亮话说得滴水不漏，这没什么用。真正有用的是，在业务能力较强的基础上，最好还有秘书助理般的觉悟和服务意识：关注老板的情绪和需求，给老板捧哽、多提问、多感恩、多夸奖，注意维护老板的权威和尊严，老板走前面、站C位、拍板、不公开顶嘴，把注意力多放在老板身上，而不是自我意识过剩，老板是不是不喜欢我，我是不是什么没做好，然后从各种细节中去做好向上支持，像秘书助理一样，有眼力见儿，考虑周全。很多新人经常投稿问，和老板一起出差见客户，该怎么在领导前表现自己，该怎么在客户面前表现自己？有没有什么话术？职场新人不需要表现，认认真真服务好客户和老板，像个服务员一样，端茶倒水有眼见力儿，能做这样就及格了。新人不用担心自己口才不好，不擅长表现。与其妙语连珠，言多必失更为严重。口才和社交技巧，不是用来表现的，是用来不犯错的。先不犯错，再谈改善。平时多注重培养秘书助理般的服务意识，有眼见力儿，在汇报时结论先行，在述职时准备好逐字稿反复练习，对新人来说这就够了。如何快速改变自己怂逼懦弱的性格？归根结底，他们害怕别人不喜欢自己，害怕别人离去抛弃。​​如何快速改变自己怂怂的懦弱的性格和气质？这是很多V+会员朋友经常私信问到我的问题，今天就来全面的说说。改变自己的懦弱性格或者气质，至少需要从心理、认知和身体三方面来改变。缺少任何一方面，都是片面的，效果不会太好。那具体怎么办呢？1，心理方面，认清懦弱的根源。懦弱和自卑缺爱一般是紧密相关的。或者说，因为自卑和缺爱，所以才懦弱。虽然我很不愿扯到原生家庭，但确实有这方面的因果关系。小时候被父母打压多了、PUA多了、否定多了、忽略多了、挫折教育多了，会让我们感受不到爱，缺爱，觉得自己很差劲，很垃圾，不配被爱。这些小时候的痛苦感受内化后，就会形成类似真理一样的信念，支配我们的人生，使得我们自卑，低自尊。而且，小时候缺爱，一直没有被满足，长大了，就会更加渴望爱，比如异常渴望被接纳，渴望被认同，渴望被理解，渴望被喜欢等等。​​​​然后，这就会导致一个严重的问题——非常害怕与人起冲突，非常害怕破坏与任何人的关系。对于他们来说，破坏关系意味着，会再次面临被打压，被骂，被否定，被人不喜欢，被人抛弃等糟糕的感受，他们无法承受。一方面是自己自卑，觉得自己很差劲，对方不会爱自己，一方面是缺爱，渴望关系，恐惧关系破裂，就导致他们会通过“讨好”的方式来维护人际关系。而讨好别人，就会导致三个问题：1，没有攻击性，不敢表达不满，不敢发脾气，不敢骂人，不敢怼人，2，过度在意别人的看法和评价以及认可，十分情绪化，3，不敢拒绝别人的任何请求，会自责内疚。归根结底，他们害怕别人不喜欢自己，害怕别人离去抛弃。所以，畏手畏脚的，非常懦弱，看起来像个怂包，让人很好拿捏。现在发现了问题，实际上也没什么用，那怎么办呢？2，改变认知，别人喜欢你与否，与讨好无关。人，根本上只在意自己。别人喜欢你与否，取决于你给别人的价值，而非你这个人怎么样。这个价值包括情绪价值、工具价值、利益价值等其它价值。你越能够给别人提供这些价值，别人越喜欢你，你越受欢迎。而别人不喜欢你，其实不是因为你做错了什么，而是他们从你这里没得到什么好处，他们不喜欢你才叫正常。你长得美，无时无刻不给人提供情绪价值，大家当然喜欢你。你长得丑，无时无刻不让人心理膈应，大家当然不喜欢你。那么是不是长得丑就完蛋了呢？不是，提供不了情绪价值，可以提供工具价值，利益价值等其他价值，也能让人喜欢你。而且，长得丑，也不能说就不能提供情绪价值了，因为你可以变得幽默有趣温暖懂人心，也能提供情绪价值，让别人喜欢你。可是，这里就有个根本性的问题了——让别人喜欢我有什么用？为什么要让别人喜欢我？讨好同事，帮同事干活，又不给你发工资，让同事喜欢你有什么用？讨好同学，帮同学做笔记拿外卖，又不帮你拿，让同学喜欢你有什么用？讨好父母，听父母的住家里把工资都给父母，但父母又不给你买房，让父母喜欢你有什么用？我们不仅不可能讨好所有人，我们也没必要去讨好所有人。所以，讨好人，必须要有目的，要自己受益。讨好异性，是为了恋爱结婚，讨好老师，是为了学到知识，讨好老板，是为了升职加薪。讨好重要的人才有意义，讨好不重要的人是浪费生命。不必讨好不重要的人，甚至很有必要去得罪不重要的人。请记住：不要过度在意不重要的人的感受，不需要得到不重要的人的喜欢，不要害怕不重要的人讨厌你，不要害怕和不重要的人发生冲突，不要害怕破坏与不重要的人的关系。要有攻击性，敢于表达不满，敢于发脾气，该怼怼，该骂骂，该打打。别人惹你了，只要得罪的起，就不要怕以牙还牙。否则，别人欺负你了，你无动于衷甚至哭鼻子，别人就会得寸进尺拿捏你。人善别人欺，马善别人骑，就是这个道理。所以，不要怕得罪人，得罪不起的可以不得罪，得罪得起的，一定要反咬一口。暂时做不到怎么办？去玩狼人杀，去和游戏队友对喷，去看广场的大妈吵架。如果这都做不到，那就早点洗洗睡，别在意这个事情了。3，身体锻炼，从根本上改善性格和气质。人的身体是生活生存的根本，更是情绪的根本。体内激素可以让你更有力量，更加快乐更自信。想要不懦弱不怂，最重要的还是身体要健康、精力水平要高，精神状态要好。头脑再灵活，体力精力跟不上，也没用。所以要锻炼身体，甚至可以健身练练肌肉。你肌肉发达，抬头挺胸，活力满满，直接就远离了怂和猥琐的气质，没人敢欺负你。再注意下穿搭，改善下体态，能够很明显的提升自信，性格和气质会很不一样。看到这里，我想该你应该知道怎么做了，相信这一系列的组合拳打下来，能够很好的帮你改变自己。能帮你直接赚钱的商业知识，人人必学很多人对此熟视无睹或者毫无概念，所以一直是底层，赚不到钱，也很正常。​​来自V+会员“婷婷觉觉子”的提问：打扰了！奶爸的微博里经常提商业知识，那到底什么才是商业知识？可以具体说说吗？谢谢！奶老师答：商业知识这个范围太广了。要学商业知识，不是学什么上市、股权、期权、ABCDE轮、IPO怎么怎么样，学这些，除了吹牛逼，没什么卵用。你都有能力把公司搞上市了，你也不会问我这个问题了。普通人学习商业知识，最重要的是学习自己能用得上的，而不是听起来高大上学了之后没屁用的。那么你学习商业知识，目的就不是帮助老板把公司搞上市，而是为自己做好职业规划和升职加薪，或者赚更多钱的。我们来具体说说：​​​​想赚更多钱，做职业规划，就涉及到，城市、行业、城市、公司、部门、岗位、业务的选择，以及跳槽和转行的抉择了。这些都是很必要的商业知识。你想赚更多的钱，当然就得选择热门行业、该行业发达的城市、该行业内的头部公司、业务部门、业务岗，做发展好的业务啦。很多人根本就不去想这些，活该赚不到钱。就拿互联网行业来说吧，如果你能在BAT做个产品或者运营，就算是符合上面例举的大部分条件了，因此你能得到的薪资可以高出其他行业公司一大截。相反，你去经济落后城市的传统行业濒临倒闭的小公司做行政人力会计等支持岗，不仅不赚钱，甚至随时都有失业的风险。那么想赚钱，想去热门行业头部公司做业务方面的工作，专业不对口怎么办？转行啦，除了还能怎么办？这就涉及到搜索、cold call、写简历、面试、求职、内推、背调、实习等知识了，这些也属于商业知识。很多人从来不学习和自己息息相关影响自己赚钱的商业知识，就喜欢研究瑞兴咖啡是如何去外国割资本韭菜的，侃侃而谈，怎么可能让你赚到钱？以上就是职业规划大致需要学习的商业知识。此外与升职加薪相关的商业知识对普通人来说也很重要。升职最重要的是有空缺。那就需要了解企业的性质、企业组织架构、企业扩张情况、企业文化、实权领导、更新换届的节奏等商业知识了。举个例子：私企，层级结构少，快速扩张中，业绩导向，领导即老板，没有人员流动，你作为元老员工或前期加入公司的员工，就有更大的机会做管理层，甚至拿到股票期权，比如阿里的十八罗汉。国企，层级结构多且复杂，裁员，官僚文化，领导无实权，更新换届慢，那你想升管理层就很难，如果是没资源没背景没学历，那升职就是难上加难。没有新增扩张，又缺少更新换届和人员流动，就没有空缺，而没有空缺，下面的人就没法升职，你就没机会了。想升职，这些商业知识有必要去学习一下。然后是加薪。加薪，主要就是靠业务，靠项目提成，靠涨底薪，靠福利，靠跳槽，靠股票期权等来实现。那么研究清楚你工作的薪资结构，以及了解清楚，公司内部的涨薪幅度，你上级甚至上上级的薪资，公司外市场上跳槽的涨薪幅度，大致是多少，绘制出这份工作未来的收入曲线，也很重要。这样你就知道这份工作赚不赚钱，以及如何把握好内部升职加薪和外部跳槽的性价比了。上面我提到过的商业知识，才是真正值得学习的，帮助你赚钱的，深深影响着你的命运的。很多人对此熟视无睹或者毫无概念，所以一直是底层，赚不到钱，也很正常。我希望你看到这，就能够提高重视，尽早的，脚踏实地的学起来，少吹牛逼，好好的改变自己。以及少被各种拽着高大上你听不懂新创造的商业名词的“大师”给割韭菜。发财致富，从好好工作做起，加油~打工人准点下班会得罪领导吗？打工人要学会平衡好自己与公司的利益。​​来自V+会员“塔塔”的提问：奶爸你好，我是今年的毕业新人，才刚过试用期不久，对公司其他方面都很满意，除了加班。我从工作以来，都不敢准点下班，因为领导不下班，同事们也都不下班，我自己一个人下班觉得很奇怪，害怕枪打出头鸟，我也不敢下班，就在工位上耗着，等着大家一起下班。但是我最近换了地方租房子，离公司更远了，想早点下班，不知道该怎么办。想问下奶爸，有必要和领导说带电脑回家加班吗？或则拒绝加班到点就走？我害怕领导看我不加班对我印象不好，不知道怎么办，希望奶爸指教。奶老师答：不用主动给领导说带电脑回家加班，更可以到点就走。但是要把电脑带回家，甚至晚上发下工作信息。把电脑带回家，目的是装作要回家加班的样子给领导看，哄哄领导，给领导一个好的印象。而不是真的让你回家哼哧哼哧的加班。为什么要装加班的样子给领导看？​​​​1，领导自己都加班，看到员工不加班，心理不平衡，觉得给你分配的工作太少太轻松了，接下来要加重你的任务。2，领导看到其他同事都带电脑回家，就你不带，就你不加班，觉得你工作积极性很差，给你打低绩效。3，领导看到你不带电脑回家，下班后临时有工作需要，你无法处理，觉得你不靠谱，斤斤计较不愿为公司付出，有好机会不敢留给你。4，你带电脑回家，装作回家加班，你在领导之前下班，或者到点走，领导的意见也不会太大。5，你带电脑加班，是一种服从，是一种“听话”的人设，可以减少与领导的摩擦。那么具体回到家要不要工作呢？这就不一定了，甚至完全可以不工作。出于业务需要，接到领导合适的紧急的任务需要处理，也可以加班一下，但是不紧急的，就可以搪塞过去，说自己在回家地铁上，人太挤不方便工作，或者在加班做其他任务，你这个任务明天做哈。这就是态度上积极表现，行动上消极抵抗，做做样子，平衡好了自己与公司的利益。我当然也不希望大家下班了还要工作，也不希望大家要迎合领导，装样子给领导看，也觉得加班不给工资，下班了不能走要等领导下班，要必须带电脑回去不合理。但是，我们在处于弱势的时候，面对实权掌握者，面对decision maker ，我们只能迎合、讨好、听话。听话吧，我们又不能完全听话，无偿996，损害自己的身体。所以我们要取折中方法，表面迎合、讨好、听话，表现的很愿意工作，但实际这是我们装出来的，在下班的时候想着办法摸鱼，推诿，搪塞，不干活。而不是说，绝对不能接受加班，领导叫我加班，我就要骂领导SB，要和资本家斗争到底。不能这样。加班严重，要么是公司太吝啬白嫖，要么是领导不会分配工作和偏心，要么是管理能力太差。明明是公司和领导的问题，很不合理，为什么我们还要加班，装作在加班？原因在于背后是自身代价和收益的考量。很多时候，不合理的事情就是存在，我们无法改变，我们只能计算利益，做出利益最大化的选择。当顺从加班有机会升职加薪的收益，大于被边缘化甚至辞退的代价，就应该加班。但顺从加班有机会升职加薪的收益，小于被边缘化甚至辞退的代价，就不必加班。关键看代价和收益，而不是死磕合不合理，领导讲不讲道理。举个例子：你在私企，你暂时没跳槽的实力，你想升职加薪，加班文化严重，你就不大可能拒绝得了加班，拒绝的后果很严重，只能服从。但你在体制内，你不追求高升，只想安稳一点，那你就可以拒绝领导安排的分外之事，只要脸皮厚，其他人就拿你没办法。所以要不要接受公司和领导的无理要求，关键是看代价和收益怎样。也因此，每次微博私信有人问我职场人际关系太恶劣，或者加班太严重该怎么办？我都会回答，先骑驴找马出去投个简历试试。当新工作比原工作，薪资更高，环境更好，也就是收益更大，那就果断跳。多考虑收益和代价，少考虑情绪和道理，可以让我们做出更正确的决策。如何有效戒掉手机上瘾？我们失去对生活的控制，对自我的控制，往往就是从上瘾开始的。​​来自读者朋友“东方斯斯”的提问：奶爸，我想问下该如何戒掉手机呀，已经沉迷于玩手机了 ，一天不玩游戏和追剧就难受，一玩就玩半天。。。奶老师答：明知道做这件事情会带来什么不好的后果，但还是忍不住去做，而且一做就停不下来，就是真正的上瘾了。题主正好符合。​​​​你玩游戏，追剧，刷短视频是不是也是这样？手机上瘾这件事情，其实不能只怪我们自己，主要还是各种互联网公司的锅，他们的梦想就是做出让用户上瘾的产品，让我们欲罢不能，尽可能的榨干我们的时间、精力与钱包。对于他们来说，做出堪比毒品的产品才是好产品，但对我们来说，越是上瘾，越是自控失败后的懊悔、内疚与自责，时间精力金钱健康没了，对生活的掌控，对生活的信心也没了。很多让人上瘾的产品，和毒品没什么区别，只不过一种是电子，一种是化学罢了。我们失去对生活的控制，对自我的控制，往往就是从上瘾开始的。如果我们连自己都控制不了，何来我的人生我做主一说？你的人生，你希望自己做主，那最基本的，就是避免上瘾，避免被操控。那么已经上瘾了，该如何戒瘾呢？戒瘾，或许大家想到的第一件事情就是，自律。实际上，这根本没用。戒掉上瘾行为，并不是简单地禁止去做一件事就行了。你不每次都告诉自己不要再玩游戏，再刷短视频，再追剧，然后都失败了嘛。这次你要吸取教训，别指望通过毅力、意志力、和自律来戒瘾，要是有这么简单就好了。上瘾与否，和你的意志力没关系，主要和你的心理需求与不良的习惯有关系。举个例子：你是不是每次无聊、空虚、疲惫、孤独的时候都想刷短视频？刷短视频，确实能暂时能够压制你的孤独感、空虚感、无意义感，对不对？这就是上瘾的原因，因为短视频等让你上瘾的应用，能够暂时的让你忘记痛苦，让你马上觉得很爽。一难受，就想爽一下，一爽，就停不下来，这样次数多了，这种行为在大脑里形成牢固的神经回路了，就养成习惯了，也就是上瘾了。上瘾说白了就是一种坏习惯。既然是习惯，那就好解决了，我们可以用克服坏习惯的思路来戒瘾。而改变坏习惯的关键，就是换一种更健康更积极的方式，来满足同样的心理需求，即用新的好习惯去代替旧的坏习惯。比如同样孤独无聊空虚，你可以把刷短视频的动作换成看电子书。这里说的电子书，不是小说，而是对你工作和成长有帮助的任何知识内容。具体做法，可以参考 if then 格式：if 我无聊，then 打开手机看电子书，if 我孤独，then 打开微信找朋友聊一聊，if 我空虚，then 打开微博特别关注看恶魔奶爸微博。或者换成：if 我想刷抖音，then 打开手机看电子书，if 我想玩游戏，then 找朋友打乒乓篮球羽毛球，if 我想追剧，then 打开电脑看豆瓣电影TOP250然后每次做完了 if then 这个动作，都可以奖励自己一下，戒瘾又前进了一步。这样做多了，养成了新习惯，自然之前的坏习惯或者上瘾问题就解决了。但是，理论很丰满，现实很骨感，你也有可能忍不住诱惑，想要继续刷短视频。那怎么办？增加上瘾行为的难度！同样以刷短视频为例，可以增加一系列刷短视频的难度，变得很费时间，很麻烦，来阻碍想刷短视频的冲动：卸载所有的短视频应用，注销所有短视频软件的账号，保持断掉WIFI只使用4G网络，4G网络流量套餐买少一点，只够日常其他软件使用，等等……当你想刷短视频的时候，想的不是很爽而是很麻烦，那你这个方法就奏效了，你抵抗刷短视频的能力就提升了。一方面用新的积极的行为代替上瘾行为，并奖励自己，一方面增加操作上瘾行为的难度，克服冲动，这样两个方面同时坚持，可以有效戒掉上瘾行为，帮助我们从各种电子产品和软件手中夺回对自我的控制权。戒瘾，让我们自由！希望大家都能拥有克服上瘾的能力，你的人生你做主，加油。职场上总有同事来阴阳怪气怎么办？​​来自V+会员“潇潇”的提问：奶爸你好，我做彩妆行业，最近新来了个同事，大公司背景，她有一次突然说小公司女生就是土气一些。听的我很不舒服，再后来隔了两周看见我，突然问我是不是胖了？每次遇到这种阴阳怪气，但又不是直接恶意的情况，就不知道怎么应付。请问类似场合怎么处理比较好？奶老师答：职场社交一般来说分为两个类型，上下级，以及同级。同级之间的别人对你阴阳怪气当面打压，ta在潜意识里，是有一个期待值链条的：先说你这里做的不好，或者哪里不行。如果你不回应，不理睬，忍气吞声，那么就坐实了你确实不行，ta就可以继续告诉别的人，继而摧毁你的个人品牌。如果你很生气，开始回怼，发火。这时候ta一定会采用的策略，就是圣母高地策略：我是关心你，为你好，你这人怎么这样对待别人的善意？这么不接受好心的建议？或者就是：开个玩笑，你怎么心眼这么小？这么经不住说笑？这时候如果你继续发火，就真显得你心眼小。如果你不说话，还是显得你心眼小。如果你解释你不是心眼小不接受别人意见，这时候也没用，别人不会听。这种情况我经常会在微博中遇到。作为职场工作和自媒体工作都算有点成绩的人，我写了条有关自媒体的微博。底下立刻有人评论：你说的不对，自媒体需要天赋，普通人做不了，还是得做普通工作。我说哥们你对普通工作和自媒体都一窍不通完全没经验啊。他回是啊我是没经验完全不懂，也没做过自媒体。我说你没做过自媒体，在这下什么定论呢？他说我没有下定论啊，我就表达一下自己的个人看法不行吗？我说表达个人看法也得自己先懂，明白了才能表达 ，不然不就是放屁？他说我连表达个人看法的权利都没有？你这个大V这么不允许不同意见？这么独裁？这通对话到这里，就纯属浪费时间瞎扯淡。而且它造成的后果就是，之后又冒出来好几个网友SB，纯路人，也出来指责我，说对啊人家就表达下不同意见不行啊？非要别人都认同你？你就是绝对正确？这个属于谈话中典型的逻辑谬误，从讨论事实，变为讨论道德。一个很简单的事实：对工作不了解的人就不要胡说八道，想要表达意见必须有足够的认识和成绩。但被他们扭曲为了：个人自由，言论自由，表达自由，你心眼小，独裁。类似的案例还有很多，我几乎每天都能遇到。这就足够说明，这样的小人，在现实中也存在不少。他们主动打压你，阴阳怪气。你反驳。他们就占据道德高地。对于这些小人，在网络上没必要搞什么策略，直接爆粗，NMSL，然后删除拉黑就行了。但是现实中不行，现实中没有办法这么做。在现实中需要做的，是占据主动，逻辑反制。​​​​他们的期待是这样：主动挑事，你生气，然后站道德高地，让你更生气和形象不好。那么你应该打破这种逻辑链条，应该自己占据主动。别人挑事，你不生气，你反过来对他阴阳怪气，他生气，你站道德高地，让他更生气和形象不好。具体怎么做？举例说明：假设一个大公司有优越感的同事过来，突然冒出一句：大公司女孩子就比较靓丽精明，能工作生活平衡，像你在咱们公司就比较土，还是缺乏锻炼。如果是普通行业说这种话没事，但在时尚，彩妆，护肤行业，说从业者土，其实就是在质疑你的专业水平。这时候应该反过来 ，以关心的口吻对他进行阴阳怪气。你可以这么说：是的呀，你说的没错，我们公司的女孩子就比较踏实努力，专注工作。不像某些人在大公司锻炼好几年了，除了打扮什么都不会，空有外表内心草包，白白浪费了在大公司学的机会呢。诶你来找我是不是也是因为工作不太懂呀，我可以教你呀~对方这时候肯定很生气，肯定会问你阴阳怪气什么意思？这时候你就应该站道德高地：我是在关心你呀，主动提出要给你工作帮忙。你工作不行很差是有目共睹的事实呀，咋还能掩耳盗铃不承认呢？我主动提出帮忙你还这样，你这人就是这么对待外界的善意和好心的呀？这时候对方就更加生气，而且说不出什么有效的反驳。哪怕他撂狠话，恶话，损害的也是他自己的个人形象。再举个例子，同事聚会，旁边突然有人说，小X，你最近找了个很有钱的男朋友吧。这种就是酸，你应该怎么回答？正确的回答还是，用关心帮忙的口吻，打回去：我男朋友就普通人啦，一般般。不过我确实认识不少有钱的男生诶，听大家说你一直都很想傍大款，我给你介绍啦，保证质量优秀。你有男朋友/结婚啦，没关系的啦，有男朋友可以分手，结婚了也可以离婚的嘛，反正你这么关心这种事，我成人之美，保证帮你介绍一个有钱的。对方这时候如果生气，或者指责你。你还是占道德高地：我关心你，主动提出来帮忙还不行啊？你就这么对待自己身边的善意啊？你想傍大款是事实啊，不然干嘛专门特地提出来，显然平时就日日想夜夜想，我成人之美有什么问题啦？以关心的口吻反击，依旧是一个循环：对方不管怎么反击，你都坐实了你是在关心他。而每重复一次，都会强化这个人的缺点，降低他的个人形象，而对你形象无损。他一开始主动挑事想贬低你形象的目的就落空了。知识付费行业一直有一个课程，叫个人品牌，个人IP打造什么的，我看过不少，但是看来看去，都没什么有用实用的东西。个人品牌和IP最重要的不是社交媒体的粉丝量，什么升职加薪。而是你的言谈举止，坐立行走，日常的一切，都是你的个人形象，个人口碑。职场就是丛林社会，你可以不挑事，但一定会有人来主动搞你。搞你的原因，其实都是想贬低你的个人口碑和形象。但我没见过任何一个这类课程，教人如何在这些小事中防守反击的。日常生活中，亲戚朋友什么的，你可以不理，因为亲戚无法选择，朋友可以远离，没必要浪费时间和这些人置气。但是同事短时间无法选择，一个屋檐下抬头不见低头见的，更无法远离。如果他经常过来阴阳怪气，从工作能力，外表，乃至私德（找有前男友）方面来打压你，长期以往，你的个人形象会越来越糟糕，会成为办公室里的软柿子，是人都敢来拿捏你。对付这种小人，就不要有任何顾忌，直接打回去，让他知道你的厉害，气到他说不出话。而且不用担心什么后果，如果你真的牙尖嘴利，让人气到说不出话，他以后绝对不敢报复你，反而会畏惧你，尊重你。如何在职场上与人完美撕B？甩锅是门艺术，推锅更是​​昨天见了一个朋友，最近很苦恼，他升职也加薪了，产品一级棒，蒸蒸日上，大好前途。就是遇到点小麻烦，不知道如何反击。主要是一个情况。其它部门的人看他年纪轻轻就当上了部门经理，觉得他不够格好欺负，觉得他的部门应该听自己的，所以总是在群里搞事。具体的搞事，就是动不动就在群里指责他XX事情没做好。大公司的工作流程一般是这么一回事：首先上头觉得某个项目，或者某个任务不错，可以做。于是开始分拆，进入流程，各个流程阶段分拆到不同部门。于是不同部门之间开始协作。在协作中当然就会发生争利的情况。谁来主导？谁最重要？谁最关键？谁的功劳最大？谁最得重用？这些就是避不开的勾心斗角。而其它部门经理，就总是在群里指责他，试图造成一种印象：你的工作总是犯错，我们部门这里都好好的，别的部门流程推进也都很顺利，唯独到你这里就出错，卡住了。你是我们流程的最大的包袱和障碍。话说到这个份上，就是很严重的指责。如果老板看到这些话，你又没有很好的给出回应，那么老板对你的印象就会变差，长期以来你就会被边缘化。于是我问他每次他是怎么回应的。他说一般是这个流程（为了让各位同学有身临其境的办公室代入感，以下我用第二人称）：对方指责你有错，你工作留痕，用实据，用数据证明你没错，然后对方立刻开始说你另一个地方也有错，你再用实据用数据证明你没错。即兵来将挡，不断防御。这个其实就是职场甩锅推锅的一个错误策略。职场甩锅推锅的第一大策略，当然很重要，就是工作要留痕，要有STAR法则深入内心，处处养成习惯，别人甩锅时候你证据打脸很爽。但这只是职场的初级技巧，仅仅做到这点是不够的，并不能很好的胜出，最多让别人搞不动你。但绝对无法让别人不敢搞你。他这次没搞动，下次继续搞你。只有千日做贼，哪有千日防贼的道理。如果我们把职场撕逼看作回合制游戏的话，那么第一回合：他进攻，你用实据来防御。第二回合：他找别的理由进攻，你继续用实据防御。这种回合制游戏，显然你就玩错了。这里就涉及到第二大技巧：防御反击。不要永远只有防御，而是要明白主动进攻。所以第二回合的策略应该是主动进攻：第一回合：他进攻，你用实据来防御。第二回合：他找别的理由进攻，你：等一下，还请不要转移话题，刚才的还没有结束。你上来就指责我做错了，可我明明没错，并且我已经给出了充分的证据证明了我没有错，所以请问为什么您上来就要无端的指责我？这个时候你就变被动为主动了。主动进攻之后的策略怎么打，下面涉及到第三大策略：3，定性错误。​​​​他觉得你工作不好，是巨大的失误和犯错。这是他对你的定性。同样，这个时候你要对他进行反定性，即：你指责我，可实际上我没错。你指责我就是错的。无端指责冤枉同事，就是巨大的错误。因此第三回合：你：我明明没做错，你却上来就无端的指责我，冤枉好人，请问您这种行为是不是工作的严重过错和失误？是不是欠我一句道歉呢？对方这时候无非就两种反应。一种恼羞成怒，胡搅蛮缠，开始胡说八道，胡言乱语。另一种就是圣母道德，开始大讲自己只是关心公司，关心工作，看你有问题，好心提醒，年轻人怎么这么咄咄逼人，一点都不谦虚，听不进批评，有则改之无则加勉。这两种反应都无所谓，都可以用同一个策略击破：4，应承对方过激和无耻情绪心理。直接承认了对方的情绪，并加以小嘲讽因此第四回合：你：（对方恼羞成怒）消消气，这么愤怒生气能解决问题吗？还是我说对了您心虚了？（对方圣母道德）哦，那多谢您的关心呢，当然如果您的这份关心有真凭实据，不是无中生有，血口喷人，冤枉好人，那就更好啦。到了这里，不要等对方回应，直接继续攻击。这时候涉及第五个策略，也是本文的核心重点：5，创造两难陷阱即故意制造两个都很糟糕的选择，让他必须二选一，不论选哪个都是错。因此第五回合：你：我能理解您对工作的上心。但是上心不代表能力强工作到位。如果能力差不到位，越是努力上心，工作会做的越差，公司的业绩会被您拖垮的越是严重。您看，这么一件小事，我明明做对了，您却认定我做错了，可实际上有足够多的实际证明我就是做对了，您的看法是错误的。那我们应该可以这么理解：1，我做对了，您却不知道，说明您工作中存在疏忽，也就是您的工作能力比较差。2，我做对了，您也知道，但您还是要在群里无端指责我犯错，说明您撒谎了。好了到此为止。只要两难陷阱被掘开，此时不管对方说什么，他都已经进入了。接下来不管对方回什么，他都是裤裆沾黄泥，不是屎也是屎。6，以关心和高姿态收尾。你：如果是能力太差，那没什么关系，我们公司，at xx大总裁大总监，各位同事，包括我自己，我们对你都有足够的耐心，更有信心，会慢慢培养你，给你时间，给你空间，让你慢慢成长起来，直到以后不会犯这种低级错误。但如果你撒谎，这个就真的不太好了，这就是严重的职业精神，和个人的道德人品有问题，我希望最好不是撒谎，毕竟咱们俩也没仇没怨，您犯不着这么来整我，是不是？ok，就这样。接下来不管他怎么狂怒，怎么胡搅蛮缠，你只需要咬住了这几个关键词就行了：1，无端指责他人是错误，是您工作上的巨大疏忽，2，这个疏忽要么说明你工作能力差，要么说明你撒谎了。如果你觉得还不够，可以上纲上线一点，搞所谓的滑坡谬误，即：3，你今天可以冤枉我，明天就可以冤枉其他同事，我们群里的任何一位都可能会被您冤枉，因为您工作能力低下，容易产生疏忽，甚至有一天，您就可能会冤枉at出XX大总。长此以往，团队氛围会变成什么样？同事关系会变成什么样？公司到底是XX大总的，还是您的？这样的人，在团队中这样的存在，我称您一句害群之马，团队毒瘤，是标准的实话实说吧。一般到这个程度，职场小人基本没什么能力有什么好的措辞，顶多就是复读机一样，那你就把上面的三个点也复读即可。他只能在你的圈内打转。。当然更大的可能是，他丢下一句，你这人不讲理，我不想说话了！一般对话是不可能说服对方了，对方认输也不可能说我输了，只会说我不想说话了！只需要这么一次，他以后就绝不敢再来惹你了。这个就叫：人不犯我，我不犯人，人若烦我，我弄死他。总结：职场撕B我觉得关键点就是三个：首先工作要留痕，当然这只是基本及格线，仅做到这个是不够的。更重要的两点：1，定性对方的错误2，制造两难陷阱这种吵架策略就是把对方拖入自己的逻辑框架中打转。接下来不论是你，还是对方就只有简单复读了。而每次复读，都是在不断的削弱对方的能力形象，强化你的能力。和领导出去见客户该注意什么？自我意识不要过剩，存在感不要太强，默默吃饭无人搭理你才是正事。​​来自读者朋友“人间豆豆”的提问：奶爸，我是实习生，这周领导要带着和客户一起去聚餐，有啥需要注意的吗，比如说我该不该敬酒什么的？奶老师答：和领导一起出去，主要是做好工具人的角色，当好老板的助理。需要注意的有以下三个方面：​​​​1，提前用心准备。提前问领导是什么样的客户，人数多少，谈什么业务，自己应该注意说什么不应该说什么，要带上哪些资料，提前问好领导怎么打扮比较合适，提前问好领导怎么称呼客户，把就餐和敬酒的礼仪提前搞清楚，如果可以的话，提前问好客户的饮食偏好，确定菜单和预算……2，有眼见力儿，照顾好客户和领导。路上注意给领导拎包指路，注意走在领导的后面，注意握手的礼节，吃饭时候记得帮人拉座位和倒水，领导和客户先入座，你最后入座，坐在离门近但是紧挨领导的地方,菜跟不上要注意催菜，端茶倒酒递纸盛饭让菜要看准，敬酒要跟上领导的节奏，提前帮忙结账买单，结束后打车或者代驾…3，不要插话没事找事主动找领导和客户闲聊。没找你说话就不要主动找客户和领导聊，领导和客户说话的时候认真听并在旁边点头小声回应甚至做好笔记，让你接话你再接话多拍拍客户的马屁…此外，最好随身携带饮用水、纸巾、充电宝、雨伞、晕车药和醒酒药，领导和客户可能会用得到。以上是大体需要注意的方面，具体情况自己补充。当然如果你觉得这么做让你没尊严，像个卑鄙小人，那么你可以不这么做。你只需要记住两件事即可。吃饭时候记得帮人拉座位和倒水，这个不是拍马屁，而是最基本的餐桌礼仪。尤其是领导招待客户主动端茶倒水的时候，你却无动于衷，这会显得极为难看，客户会觉得你作为小弟跟班非常不懂事。其次，自我意识不要过剩，存在感不要太强，默默吃饭无人搭理你才是正事，也根本没人在乎你，不要觉得尴尬。如何保持长期、持续、稳定的努力？如果没有明确的目标，那么空努力就是神经病。​​来自读者朋友“小荔子”的提问：奶爸您好，请问“记吃不记打”的人，如何长期维持好自己的工作（学习）状态?我反思自己的人生轨迹，发现无论是短期还是长期范围内，有一个明显的起伏规律：每次都是在跌落谷底时被激发求生欲，然后垂死挣扎，化险为夷之后就自满放纵，对自身放松警惕，日积月累再次把自己作死，然后开始新一轮恶性循环。所以想请教您，如何才能改掉这种“记吃不记打”的属性呢？我很想维持住那种摆脱低谷后“走在上坡路”的状态，但事实却是一直“好了伤疤忘了疼”。奶老师答：如何才能改掉这种“记吃不记打”的属性呢？换句话说，就是如何长期保持努力而不堕落颓废。能思考这个问题并提出来，你已经很不错了。想要改变间歇性踌躇满志持续性混吃等死，想要变得动力满满，一直努力，达成目标，取得成绩，其实并不难。简单的分享几个小方法：​​​​1，确定明确的目标。如果没有明确的目标，那么空努力就是神经病。为了努力而努力，为了自律而自律，往往只是自我安慰，用虚假努力来迷惑自我，企图得到自我良好的感觉来克服当前的焦虑，是一种内源性思考。它脱离了现实的物理层面的改变，就像原地游泳，挥舞了一阵子，累了，没有任何改变，继续焦虑，周而复始，永远得不到答案，不会有任何改善。所以，第一步必须确立明确的目标，不能因为焦虑而没有方向的空努力。2，选择认同的目标。你对确立的目标是否认同，你是否真正觉得这个目标很重要，你要优先去做当前你觉得最重要的一件事情。不认同的目标，觉得不够重要的目标，没法开始行动和坚持，就像戒烟戒酒，除非医生给出诊断报告亲口告诉你再吃烟酒就会挂掉，体会到了严重性，否则很难有结果。所以，你要优先做你觉得真正重要的事情，你才能下定决心，有动力和紧迫性，坚持的更久。3，抓住当前阶段的主要矛盾。如果第2个方法没用，仍然没有找到合适的目标，很迷茫，那么我建议你接地气点。思考当前的主要矛盾，大学生就不用思考乱七八糟的太多，多考虑未来就业的问题，打工人也不要思考太多，就多考虑买车买房升职加薪的问题，已婚已育的话，就多考虑还贷和孩子教育的问题。把当前阶段的主要矛盾解决了，能够明显的改变人生改善生活。解决主要矛盾，永远是无比正确且性价高的事情，不会出错。感觉迷茫，没有目标，那就先把当前的主要矛盾解决了再说。4，制定针对目标的短中期计划。计划中的目标要拆解和量化，可参考SMART原则（自行百度），拆解任务要遵循MECE原则（自行百度），形成任务树，这样大致的拆解和规划一下，你大概知道何时何地应该做些什么做到什么程度。那么一有空，想做点什么就不会不知所措，不至于不知道该如何着手，而被迫躺平。5，做好精力管理。精力是身体最珍贵的能源。精力管理搞不定，计划再好也没屁用，执行不下去。可以先从吃、睡、运动、冥想、休息入手。吃方面，按时就餐，少吃糖，多吃水果蔬菜营养健康，睡方面，睡足8小时，定时上下床，午休不超过25分钟，动方面，每周有氧运动150分钟以上，冥想方面，思绪紊乱及时冥想，休息方面，每工作50分钟，休息10分钟，不要上网，多走动，喝水，聊天，看看窗外。6，改善学习环境。戒掉容易让你失控上瘾的东西，比如游戏、短视频、社交软件，否则你始终处于失控状态，容易破罐子破摔，长期形成习得性无助就很难自救了，不要在睡觉的地方学习，工作和学习尽量拥有一个专门的区域和空间，远离诱惑源，卸载娱乐以及影响学习的软件，零食不要放在身边等，避免受外界影响，准备好耳塞或者降噪耳机，不要刻意追求时长，累了就休息，学不进去就转移注意力，劳逸结合，张弛有度。7，多鼓励少自责。不要轻易自责，不为小失败而垂头丧气，只为小成功而鼓励奖赏自己，不要过度追求效率，始终保持自己专注学习的状态即可，再没效率但有耐心恒心的乌龟，也比效率高一口气想吃成胖子的兔子要靠谱的多。慢慢来，放弃的少，进步会更快。这些只是些最基本的小技巧，先做到这些吧，应该对你有帮助，你要加油。如何有效的提升自己的表达能力？你的“只言片语”是因为你的知识太碎片化了。​​来自读者朋友“赏心悦目的木木”的提问：奶爸您好，有幸从大一认识您到现在已经大三了，学到了很多有用的东西，想询问奶爸一个问题：自己的思维很散，比较片段和碎片化该怎么办？以至于表达自己的观点时也是只言片语，没有逻辑条理。这个问题一直困扰着自己，跪求奶爸指点。奶老师答：思考与表达缺乏逻辑性，主要是因为没有结构化思维。语言是思维的传声筒，只有想清楚了才能表达清楚。只要思维上有了逻辑，那么表达的时候自然会有条理很多。所以我们重点要解决的是思维混乱缺乏逻辑的问题。思维混乱缺乏逻辑性主要有两个原因：​​​​1，学习的知识本身过于碎片化，零散，缺乏结构。之所以你感觉自己的思维很混乱，有一点想法总是零零碎碎的，难以快速把它们有逻辑性的整理起来，是因为你学习的知识本身就很零碎，缺乏逻辑结构把它们给提前连接起来形成完整的一个体系。就好比你买好了衣服也不提前分类整理，随手就丢进了衣柜，等到要穿的的时候，才在混乱的衣柜中寻找不知散落在各处的零星的几件衣服，很难迅速的搭配好所需的一套衣服。结构化思维就承担着类似整理衣服的作用，可以在知识点之间建立起金字塔形状的逻辑结构。现在大家都习惯于在手机上学习，刷X乎X书X博等，学习往往只是记住了结论，会不自觉的忽视或者忘记推导出这个结论的多个论点。当时你的脑子会欺骗你说你掌握了这个知识点，但过后，除了结论，你可能什么都记不得了。这样只记住结论而记不住论点的学习方式，无法搭建起结构，就无法将知识体系化结构化。如同你买了各种不同类型的衣服，无法对它们进行归类一样。无法归类，我们就难以迅速调用。学习的知识是零零散散的结论，它们之间是孤立的，没有联系，散落在你的脑海各处。那么在临时需要表达的时候，就难以迅速将这些知识点有逻辑的整理的起来，所以你说话只能只言片语。因此，在学习的时候，不要止于结论表面，而是既要知其然还要知其所以然：搞清楚知识间的相互联系，学习和积累这个知识点的金字塔结构的知识体系，而不是偷懒单纯的记住某个结论。思维混乱是因为没有想清楚，提前学习成体系的知识，能够有效避免思维混乱的问题。也就是说，除了要记住结论，至少还要记住结论下面的的几点论据。比如，我经常说女性在职场上没有性别优势，越漂亮越有劣势。有的人就只记住了这一句话，别人问他为什么？他说不出来，或者只能讲出一个点，太漂亮会被同事嘲讽惦记以及被女领导嫉妒打压，这就是你说的只言片语的情况。而那些学会了整个知识点所在的金字塔体系的人，就知道还有三点,：1，靠谱的男领导会对漂亮女下属避嫌，2，不靠谱的男领导会潜规则，3，靠谱的女领导相对来说比较少。所以你的“只言片语”是因为你的知识太碎片化了，你记住的只是结论，而不是金字塔结构的知识体系。2，没有结构化的思考习惯。讲话兜兜转转讲了大半天，每一句话都听得懂，但凑在一起就让别人懵逼，显得异常啰嗦，没有重点和逻辑，这就是在表达时候缺乏结构化思维的表现。前面说了，学习现成的结构化的体系知识，应对熟悉的话题，能够有逻辑条理的快速讲出来，可是遇到陌生的话题就不一样了，仍然需要我们大量的临时的思考。一边思考一边回答，那么这时候该如何避免啰嗦没有逻辑和重点呢？还是得依靠结构化思维，即结构化表达。表达的时候有意识的进行逻辑整理，比如结论先行，论据归类，二八陈述。我们写论文的时候就是严格按照三个逻辑来写的，还有印象吧。其中最重要的是结论先行。首先给出结论，点明重点，把结论放第一句说，然后再去解释或者分点论述。既然给出了结论，要告知内容的目的达到了，重点也点明了，那么后面对结论的解释仍然啰嗦和缺少逻辑也没有太大关系。这样不至于你说了一大堆，一群人不知道你在说什么。所以，要提升表达能力，第一步也是最重要的一步就是结论先行，这个在汇报中尤其重要。提升表达能力一定要提前养成这个思维习惯。其次是，论据归类。论据归类，上一级的结论由多个下一级的论点推导而出，共同推导出某一结论的多个论据形成一个小组，就是归类，这会形成一个大主干或者小分支。众多分支根据自上而下的顺序连接起来就是一个金字塔结构。论据归类的目的是为了分点论述。论述的时候，要分点，可以用上第一第二第三或者首先其次再次最后等表明分点的词语，强行加上分点分段逻辑。论述的几个点之间的顺序，可以按照重要性，时间，空间等顺序来论述。结论先行并且论点后面阐述对应的论据，就会显得非常有条理逻辑性。最后是二八陈述，指的是20%的结论和80%对结论的解释，二八比例可以让结论更加精练简洁，解释更为详细完整，全文更为详略得当。当然也不一定是严格的二八比例，更为常见的是一九比例。以本文为例，结构化思维表达就是这样的：结论先行，首先给出结论：思考与表达缺乏逻辑性，主要是因为没有结构化思维。论据归类，分点论述：论点一，学习的知识本身过于碎片化，零散，缺乏结构：论据1，只记结论忘记论点的学习方式，过于零碎，缺乏结构化，无法调用。论据2，结构化思维具有整理知识间逻辑关系的作用。论点二，没有结构化的思维习惯：论据1，没有结论先行，说话非常啰嗦没有条理和重点。论据2，论据归类和分点论述可以让表达更有条理和逻辑。论据3，二八陈述可以让表达的内容详略得当。只要你按照三个表达的思维习惯来讲话，就不会出现没有条理逻辑的情况。如果一开始不适应，尤其无法在脑子里快速的进行论据分类的时候，可以先在纸上画一张金字塔结构的逻辑树，然后结论先行，分点论述。但结论先行的思维习惯，必须时时刻刻有意识的保持，汇报的时候提醒自己一定要结论先行。这会快速提升你的表达与汇报能力。如何说话有体系有逻辑，已经讲清楚了，希望大家都能够针对性提升，加油。多说一句，结构化思维不仅使思考与表达更有逻辑性，实际上对于大家思考与解决问题更有帮助，因此在这里推荐一本书《金字塔原理》，对结构化思维感兴趣的同学可以去买来学习。如何一招收买领导人心？刻意谦虚会让人觉得虚伪。​​来自读者朋友“橘子精本人”的提问：奶爸，您好，想请教一下，被评为先进个人，作为获奖者要在大领导和全体部门人员面前发言，发言的内容要怎么说比较合适？谢谢~奶老师答：当然是把领导和部门同事全夸一遍啦。这种个人的高光时刻是拍领导马匹的好机会。句式：​​​​我很荣幸被评为先进个人，但我认为这主要都是我们部门领导和同事的功劳，多亏了他们。都靠我们部门的XX主管/经理（带头的）的帮助，多亏了他的殷切鼓励和手把手的辅导，我才取得了XX成绩，还有我们部门的XX前辈（资历最深的那个），他工作认真刻苦，给我树立了非常好的榜样，每次累了，都会想到他，备受鼓舞，这才能XXX我们公司的XX，有什么优点，对我有过什么帮助。以此类推。2-3分钟把整个部门拍完。以后在部门混要顺利的多。虽然这是在拍大家的马屁，实际上这是我讲过的一种感恩套路。我们人嘛，本质上在意的都只是自己。在个人的高光时刻，在被夸奖的时候，有意识的进行回夸，把光环递给对方，聚光灯打到对方身上，让对方感受到被在意，感觉舒服，是一种很好的眼力见儿。因为刻意谦虚会让人觉得虚伪，而通过回夸表达感恩，恰恰相反，大家会认为你十分谦虚，反而更厉害。既不虚伪，也不骄傲自大，懂得感恩更不私自揽功还想着大家，形象这不就在大家心中树立起来了吗。看一看奥斯卡的颁奖典礼，大家就知道这是一种套路。需要注意的是，在日常较为轻松简单的生活中，不在正式场合也没有高光时刻，也会有突如其来小的夸奖，可能不注意，随口就应付过去了。比如老板说一声干得好，非常不错，该怎么回复？你不能只说声谢谢搪塞过去，就没有感恩意识了。依然需要回夸来表达感恩：老板，你不能这么说，主要是您教的好，更重要的是我们团队战斗力强，大家都很支持我的工作，我个人的努力其实是微不足道的。你这样回夸，大家都沾光，才是好的感恩套路。不仅如此，同时伺候大老板和上司的时候，该怎么办？在大老板面前，凡事多表达对上司的感恩。餐桌点菜，点大老板爱吃的，一定要说：这些都是上司XXX平时说的，他教导我们要注意您的喜好。被大老板们夸奖，一定要说：没有没有，都是上司XXX教导有方，主要是他特别厉害，我只是跟着学而已，学的还不是特别好，各位领导请多担待啊。你表现的越谦虚，越是把所有功劳都推到上司头上，大老板们对你的印象就越好，未来的职场路就越顺利。真诚的赞美同事上级，时刻注意带着自己的导师或者上司，是职场的基本教养。所以任何被夸奖的时刻都要及时表达感恩，学会推功，让人觉得你这个人的人品不错，长此以往，你的人际关系会融洽很多。如何成为一个内心强大的人？避免内源性思考，跨越到外源性思考才是正解。​​来自读者朋友“月儿”的提问：奶爸，怎么成长成一个内心强大的人？奶老师答：怎么成为一个内心强大的人？一般人都不会思考这种过于空泛和抽象的问题，都忙着赚钱，思考这种问题的一般都是吃饱了撑着了没事干的。但是你既然问了，那我也回答一下。如何变得内心强大，确实是有方法的，以我的个人经验来看，主要有三个：1，从内源性思考跨越到外源性思考。什么是内源性思考？​​​​思考自己要成为一个什么样的人，就是内源性思考。比如题主说自己想成为一个内心强大的人，这就是典型的内源性思考。内源性思考的问题在于，用标签来评判个人，片面割裂的去认识自我的价值，使人变得情绪不稳定。被别人贴上诸如能力强、积极乐观、热情、自信等积极的标签，就会得意开心，被别人贴上诸如自以为是，不思进取，愚蠢懒惰等消极的标签，就会沮丧失落，开心与否，主要与别人贴的标签是积极还是消极有关，说白了，就是被别人给操纵了。这还不是最严重的，最为严重的在于，自己给自己贴上诸如垃圾、一无是处、loser等消极标签，而感觉自己差透了，烂透了，连一张侧纸都不如，毫无价值，别人怎么夸怎么劝也没用，陷入自卑无法自拔。这类人内心极其脆弱。因此，避免内源性思考，跨越到外源性思考才是正解。什么是外源性思考？与思考我要成为什么样的人相反，思考我要做成什么样的事，就是外源性思考。这样思考有一个最大的好处，从关注自我，转向关注做事，会变得理性很多。变得理性，自然情绪就会稳定很多。举个例子，被领导批评了，有的人情绪低落甚至当场就哭出来，有的人却能沉着冷静细耳聆听，区别就在于，是关注自我，还是关注做事。关注自我的人，会情绪低落，因为她满脑子显得都是，我是个怎么样的人，领导批评我了，说明我是个垃圾，我人太差了，好伤心难过，而能保持沉着冷静，是因为关注成事，领导批评我，是为了给我指出问题，我应该认真听，哪些有道理，哪些没有道理，接下来我该如何解决问题，以后该如何规避不再犯第二次。你看，关注自我就容易情绪化，关注成事则会理性冷静很多。所以，想要内心强大，就别把自己太当回事儿，多做外源性思考，多关注做成事。2，培养自我效能感。从关注自我到关注成事，避免内源性思考，只能说是内心强大的第一步，还是不够完美，因为关注成事，会遇到挫折，容易丧失信心，形成习得性无助。这个时候，最重要的就是自我效能感了。什么是自我效能感？所谓的自我效能，就是我知道我可以通过努力把一件事情做好，即“我能行”的感觉。内心不强大，常常焦虑和恐慌，其实就是不自信，缺乏自我效能感的表现。我们应该怎样去培养自我效能感呢？其关键就在于要不断获得成功。成功了才有自信，有自我效能感，没成功只有挫败感，是没有的自我效能感的，也就是说，成功是成功之母，而非失败是成功之母。想要获得成功，那么最好是选择优先去做一些挑战小的事情，然后一步步的提高难度，做挑战更高的事情，循序渐进，不断积累小成功，收获自我效能感。当你能够做好第一件第二件第三件事的时候，你慢慢也会有信心做好第四件甚至第N件事情，自我效能感越来越强，在面对挫折的时候，内心也会强大很多。3，培养批判性思维。为什么批判性思维对于内心强大来说非常重要？这个就涉及别人对你的评价，你是否认同的问题了。别人说你是个loser，你不加以批判，直接认同了，哎，我就是个loser，我好垃圾，感觉自己一无是处，不想活了。而有批判性思维的人，是这样想的：你凭什么说我是个loser？就因为你是权威是大咖经验比我丰富更有话语权么，你有什么具体的证据来证明我是个loser？你得把具体的证据拿出来，你的这些证据真的能够证明我就是个loser吗？有强因果联系么，你对loser的定义是什么？你得说清楚你对loser的定义是什么……如果这些你都做不到，你凭什么说我是个loser，你这就是在乱说，恶心人。所以你看，有批判性思维的人，面对他人的评价，不会轻易认同，别人说啥就是啥，而是认真考究，别人说的是否有道理，有道理自己就改，没道理就放之脑后，毫不在意。拥有批判性思维，能明辨是非，不会轻易受伤，让你更坚定从容，会使你内心强大很多。掌握以上三个方法，能够很好的让内心变得强大，希望你加油，祝好。读垃圾畅销书会让人智商变低如果没人教，只是自学看书，最后看完了，要么啥也记不住，要么只能够记住一句话。​​如何去选择适合自己的好书？如何判断适合自己的书？什么样的书才是好书？想要明白这个，你就必须知道，读者的层次区别。读者的智商分三层：​​​​底层，大部分都是傻逼，如果没人教，只是自学看书，最后看完了，要么啥也记不住，要么只能够记住一句话，一句核心的东西。不要觉得不舒服，我也是底层的傻逼，我天资就非常差。中层，除了记住最重要的那一句，还能记得相关引申出来的方法，时刻提醒自己，但是他做不到活学活用。做到这个层次，基本你就能考211 985了，不开玩笑，当然，不是每个211 985的学生都具备这个能力。高层，聪明人，除了记住核心，方法，同时能够自己构建出系统，灵活化用，也就是所谓的庖丁解牛。做到这个，你考个清北和哈耶普的商学院就不是啥大问题了。当然同样也不是每个清北哈耶普的人都具备这个能力。那么反过来，当一本畅销书作家，在试图写书的时候，一个基本及格的职业素养就是：他必须明确考虑到高中低三层的读者理解和运用的能力问题。当一个作者在写书的时候，他就应该想到，自己面对的读者群，肯定是底层最多，中层一般，极少数高层。所以他就必须要想出办法，一定要满足最低要求：让读者记住最核心最关键的那一句话。这个最低要求，就是评价书的标准：看完一本书，以你的智商，能不能留下印象最深刻的那一点核心？能，说明这就是本好书。不能，说明就是故弄玄虚的垃圾。其实大部分所谓的方法论书，以这个标准来评价，都是不及格的。以《如何阅读一本书》举例，无数的人都看过这本书，但是他们的话术只有，我推荐你看看这本书。而不是，《如何XX》这本书里的几大原则，教我们看书这个方法最好用。看完了全书，大部分读者一句话都记不住，只记得装逼和书名，说明这本书是彻底失败的，说垃圾也不为过。而反观《金字塔原理》就不是，看完了全书，读者最起码能记住一句话：说话要先说最重要的核心，放第一句，然后再组织语言。如果你读完一本书，这本书让你有一个强烈的印象，你就记得这一句话。那么这本书是当之无愧的好书。以你的低弱智商，都能够被点化启发，这本书你就应该留着，找身边的高人，请他作为教材，教你。帮你拆解出方法论，同时帮你构建系统，灵活运用。这类书很少的，其实没多少本，这也是为什么我一直认为卡耐基是大师，而不是骗子的原因。因为看完他的书，再弱智的人，也能记住一句核心思想。年轻人做销售到底还能不能赚到钱？个人能力强，说实话在销售行业，能力这玩意儿算是个玄学。​​有个美女咨询我销售类求职工作的事情，说她之前在小地方小公司，来到了深圳，还想找销售工作，发现找不到，最多的只有电话销售，没别的了。有这种烦恼，其实是对销售工作的职业分布规则不太熟悉导致的。销售是不是一份好工作？不是。只有某一种类型的销售才是好工作。​​​​大部分销售都是炮灰，干电池。比如电话销售，上门推销员——凡是2C卖给普通消费者的销售岗位，基本都是陪衬。什么样的销售才是好工作？1，产品特别强的，销路不担心，2，公司特别大的，品牌特别好的，销路不担心，3，个人能力特别强的，资源特别丰富，销路不担心。产品，公司，能力，这三个满足一个就可以，但这三点任何一点都只意味着一件事：门槛特别高。产品好的职位，肯定要求懂技术，一定要专业对口，这一条就卡的死死的，公司大的职位，肯定对学历有要求，一定要高学历，最好还要英语流利，这一条也卡的死死的，个人能力强，说实话在销售行业，能力这玩意儿算是个玄学，没法细细深入讨论。综上，如果想要靠销售实现殷实收入不断增值，前提是得进入好的行业好的公司好的产品，这种人跟普通人的世界基本是完全隔绝的。比如华为的销售，三一重工的销售，都是在985院校的工科专业内，优中选优，选外形好口才好性格好能力特别强的人才行。如果是普通人的话，我反而不太建议从销售入手，虽然电话销售，上门推销，卖场促销等等门槛特别低，但门槛低就意味着炮灰。我反而建议从电商，外贸，互联网运营入手，这些门槛也低，但是纵深很广。就是电销和促销，往上走，就没了，但是运营和外贸，起薪差不多，只是往上走，能达到COO，还有理论可能。关注职位的纵深，这点很重要。工作中最重要的能力一定要学会一个人做事的底线，不是完美完成，而是不坏事，不耽误事。​​刚进入职场，最体现工作能力的，就是沟通协作，即向领导汇报请示工作。能够跟进任务进度，并及时向领导反馈和请示，把事情做成，不坏事儿，就是靠谱的表现。汇报沟通这件事，很重要，但并不难，很多人却总是做不好。​​​​老板让你去技术团队提需求，或者让你去供应商催货，你去催了，对方说忙，不好意思，你等等。然后你等了两天了，一直催，一直说忙，没办法，只能等。等到两天后，老板问你事情搞定没有，你说没有，老板一脸愤怒，想骂你，但是想想又算了，无奈的重重叹了口气，然后带着你，自己去刷脸，把这事解决了。这是在无数办公室里每天都会发生的事情，而这个案例，真实发生在我以前公司，事情的当事人，还是清华毕业的。这就是应试教育对人才最大的戕害所在。应试教育的环境下，老师和家长不问过程，只问结果。如果结果是好的，那就表扬，如果结果是不好的，那你惨了。不要听老师家长说什么结果不重要，最重要的是你的态度和和努力，这些都是狗屁。还有一点，应试教育考试的分数是恒定的，不是按照百分比来计算的。在商业场合里，一件事情达到70%的目标，就已经是超完美推进了，今年打算赚1个亿，赚到7000万了，开香槟！但是你考试，100分就是100分，70分就是70分，无法更改，不可能因为完成度而欣喜，考70分就是要被打屁股。在这种长期的制度化培养下，年轻人就成了巴甫洛夫的狗，大家都习惯了一点：隐瞒，报喜不报忧，不敢反映真实情况。看看多少家长辅导孩子做功课，孩子做错一道题，家长就摔笔拍桌子发脾气的视频，在这种长期的精神虐待下。孩子敢及时沟通吗？孩子敢及时反馈吗？孩子敢及时汇报吗？不敢，我们都隐瞒着问题，自己自学，独自解决。解决得了，那就是优等生，解决不了，那就是差生，无所谓，破罐子破摔得了，算了。这一套，放在职场上，就会坏大事。一个人的能力有限，不可能靠自己独立的解决问题，一个人做事的底线，不是完美完成，而是不坏事，不耽误事。不坏事，不耽误事的基本方法，就是12个字：及时沟通，及时反馈，及时汇报。所以老板交代你做事，第一件事就是要问，这件事是否非常优先，要在几天内得到结果？如果优先级高，那么就应该迅速反馈，尤其是反馈问题和难题。对方说忙，忙有很多原因，这个你不管，你也不要想着自己独自解决，而是应该立刻找老板，说遇到问题了，对方不给办，说忙，需要老板支持。然后老板立刻就去刷脸，事情解决。不至于耽误两天时间，有的时候，这两天就很致命。当然，以上是针对合格的老板，良好的职场氛围。有的老板不是这样。如果有的老板不喜欢你及时沟通，及时汇报，及时反馈。说明他不是个好老板，他是官僚思维，老师思维，家长思维。这时候你就应该远离他，考虑跳槽，而不是质疑我这套到底对不对。35岁以后工作，最重要还是得靠朋友社会关系丰富的人，不可替代，社会关系薄弱的人，就很好替代。互联网上很流行中年危机这个说法，招聘广告上已经不要35岁以上的人了，他们不好找工作，职场上超过35岁就会被裁员优化，他们很容易失业，那么是不是说，在35岁之前没升到管理层或者没年薪百万就完蛋了？在职场超过35岁还没做到管理层没达到年薪百万怎么办？其实不需要做到管理层，也不需要年薪百万。你只需要做到不可替代就可以了。​​​​​​这里的不可替代，一般人会误解为特殊的才能，成绩和能力。这是错误的看法。尤其是对35岁后的人来说，拼能力，拼技术，拼脑力，拼精力，拼加班，是不可能拼得过年轻人的。那为什么高管都是年纪大的，几乎没有年纪轻的？马克思说过一句话，人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和。所以为什么年纪大的人能够当高管？因为他本人所汇聚的社会关系，不可取代。社会关系丰富的人，不可替代，社会关系薄弱的人，就很好替代。电视剧《我的前半生》里，商场里有个采购部员工，老金，勤勤恳恳工作20年了，论学历，能力，资历，精力，任何一个大专生都可以取代他。但现实是，永远不可能有大专生甚至本科生可以取代他。因为，供应商只信任老金，不会信任新人。难搞的供应商只会希望和老金合作。所以老黄无可替代。波士顿法律里的保罗也是，全律师行里，最不会打官司的合伙人就他。老大丹尼看他不爽，想整他，就让他退休了。结果第二天公司乱套了：物业不开空调，因为保罗没打招呼，他们在早上和下班后就停空调，电梯不运营，因为接替保罗工作的布拉德不懂怎么跟电梯工人打交道，给的钱少了，害大家爬楼梯，清洁工罢工，甚至就连纯净水都不供应。这一切，就是因为保罗背后的社会关系，离开了这家公司，造成的大混乱。所以，什么叫稳定，稳定不是说你在一个地方吃一辈子饭，也不是说你可以一辈子保持健康一直拼命。而是说，你积累起丰厚的社会关系。这对于不喜欢跟人打交道的人来说，可能确实困难，但想在人类社会生存下去，就必须如此。打骂孩子往往没有任何作用非常可惜的是大部分人在看家庭养育的时候，只看到打骂二字。​​来自读者朋友“自在的花露”的提问：奶爸你好，有一个问题一直想要请教你，希望能够得到你的解答，请问打骂孩子真的一点作用也没有吗？温柔的说话教导，孩子总是不听，把厨房的面粉和厨具三番五次的扔在地上玩，厨房被搞得一团糟，看到心里就来气，冷静下来后温声细语说了几遍也没有用，这时候还不应该打孩子让他知道什么不该做吗？别人家同龄的小孩很规矩，明显比我家熊孩子听话懂事多了，打骂也多，为什么他们教育孩子就很有效果？奶老师答：家庭养育里的打骂体罚，类似《射雕英雄传》里的江南七怪教郭靖，对郭靖恩重如山，但是一样正常打骂，死去活来。很多人觉得郭靖的人品好三观正能力强，跟江南七怪的管教关系非常大。其实说白了，根本原因还是：1，江南七怪跟郭靖寸步不离，生活在一起，有充分的时间耳提面命，2，江南七怪自身的人品极好，对郭靖潜移默化的影响极大，3，江南七怪和郭靖朝夕相处的感情极为深厚，彼此间为了对方付出生命也不犹豫。上面这三点才是最重要的。而打骂到底有没有用，看郭靖自己就知道了：​​​​长大后最害怕的是大师父柯镇恶，因为最严厉最爱打骂他，最喜欢的是韩小莹，因为对他严厉管教的同时又最慈爱。非常可惜的是大部分人在看家庭养育的时候，只看到打骂二字。看不到以身作则，看不到朝夕相处，看不到感情深厚。我爸妈经常给我讲一个中学教员前辈的故事，他对三个子女打骂都狠，最后都考上大学了。但是了解故事全貌就知道了，这位教员人品极好，助人无数，面冷心热，帮助无数学生解决学杂费问题，工作极为刻苦努力，经常挑灯批改作业，对自己本职工作极为敬业。在这种父亲的鼓励下，子女怎么可能不刻苦，不敬业。然而大部分人，其实都是人品不好，不敬业，偷奸耍滑，贪小便宜的小市民，却总是望子成龙望女成凤，总想着子女有大出息。怎么可能。以身作则，人格教养，亲密相处，严加管教是很重要，假设为A但是打骂绝对是巨大的恶习减分，假设为BA多B无，是上上等A多B有，是中等，A少B多，是下下等。大部分人只能看到B，看不到A，因为成年人不愿意承认自己的猥琐龌龊和阴暗，更不愿意改。所以大部分人只能当下下流的父母。如何高情商的抚慰他人？对情绪的安抚，采用建议和方法的策略，属于典型情商低的表现。​​来自读者朋友“斯斯”的提问：奶爸你好，咨询一个情感问题。男朋友看了一篇关于原生家庭决定论的营销号文章，然后发给我看，给我描述他的童年阴影。我非常激动的骂了造成心理阴影的人，且给他提出了我能想到的解决的办法，让他往前看好好生活，不要想这些以前的事情了。但他说我冷漠，没有和他产生共情。我提出完全共情是不可能的。他就生我的气。我想知道如何才能达到他说的共情和关心？奶老师答：共情与其说是一种能力，不如说是一种话术和肢体语言。​​​​其中最基本的策略就是：少说两句，让对方多说，自己负责偶尔惊叹即可：天哪、太过分了、他怎么可以这样、真心疼你、当时挺难过的吧。惊叹的次数不宜过多，否则别人会觉得你不耐烦敷衍，想赶紧结束这段谈话。在这过程中绝对不要表现的比他还激动，这非常假，更不要说的比他还多，这显得非常自私和傲慢不礼貌。应该听他说，并且鼓励他不断的说下去，然后呢，后来呢，那你当时是怎么做的呢。最后，千万不要提出任何解决方法，只要提出解决方法，那就是好为人师。这是非常傻逼的行为，因为你没经历过那种情况，就不可能自信处理的比他更好。正确的方法是在说完后，继续询问他的感受，直接问他：宝贝，那你现在怎么想的呢，那你现在打算怎么做呢。而所谓的“让他往前看好好生活，不要想这些以前的事情了”——这些其实都很容易让对方产生你居高临下，好为人师，傲慢自大的感觉，用上面的话术诱导他说出自己现在的想法，让他不断倾诉，你默默倾听，然后听他自己现在做的决定，你负责表达同情，支持，和鼓励就行。往事是不可追忆，不可弥补，更是没有什么完美方法的，我们能做的只有对现在受伤害后情绪的一种平息，安抚，而对情绪的安抚，采用建议和方法的策略，属于典型情商低的表现。以及，在至爱亲朋倾诉心理阴影，并且明确表示出对你的态度回应不满的时候，还说出“完全共情是不可能”的这种话，属于非常过分，是一种很恶劣的言行，应该可以归结在差不多这人可以分手绝交了的范畴里的。最后的最后，作为倾听者，一定要注意自己的身份：如果是你关系非常密切的朋友，亲人，伴侣，你是有义务倾听什么童年阴影之类隐私的，如果是普通同学，同事，没交流过几次的陌生人，如果他对你的倾诉你避无可避，听完后千万不要多说话，少说话，就说一句I’m sorry，或者我为你感到难过，用英文说就是I feel for you, 然后双唇紧闭保持沉默，不要开任何腔找任何别的话题，等TA自己开口转移话题。千万不要多说哪怕一句话，更不要自作主张的建议方法什么的。交浅言深不仅仅对于说话者有危险，对于倾听者更有危险，尤其是说话者如果身份地位社会能量远远高于你的话，更加糟糕。为什么说面试的本质是推销？面试本质来说更像是宣讲，推销。​​来自沟通训练营学员“一场白”的提问：奶爸你好，我这周去一家公司面试，二面是由公司总经理进行的，看起来是一个很干练的女人。我把简历递给她后，她也没怎么看，然后气氛很尴尬，她没什么要问我的，我就主动问了她一些问题，主要关于工作内容，培训机制，考核方式，加班补贴。可是这位总经理也没有很明确的给我解答，基本上都是泛泛而谈，我处于一知半解的状态。我想问奶爸，在面试时如果面试者不主动对应聘者进行询问和说明，如何处理尴尬的情况以及作为应聘者在面试时应该如何提问？谢谢。奶老师答：这里要明白两个常识：1，总经理面试是不可能跟你讨论工作内容，培训机制，考核方式，加班补贴的。因为总经理不负责管这些。你问这些总经理可能会有不错的印象，但是他泛泛而谈也正常，人家可能未必记得那么清。​​​​2，面试不是考试，也不是考验和考核。面试本质来说更像是宣讲，推销。目的就是把你推销出去。所以真正优秀的职场人，是不可能在面试的时候被动的，而是直接抢占主动。面试时如果面试者不主动对应聘者进行询问和说明，如何处理尴尬的情况——这种尴尬，优秀的职场人不可能遇到。举个例子：一条的老哥们找我见面喝茶聊天，谈合作。问，对一条了解么？了解一点点，不太多，又问，知道我们的业务和商业模式么？知道一点点，不太多。再问，那对一条感兴趣么？我也不太清楚。一问三不知，这时候非常尴尬，请问咋办？老哥们飞快的掏出了笔记本电脑，打开了PPT，然后说我来给你详细介绍下我们的情况吧！然后接下来的30分钟里他口若悬河，眉飞色舞，把我彻底侃蒙了，然后稀里糊涂就签了合同。面试也是一个道理啊。如果是在会议室面试，最佳选项是，直接把笔记本连上他们的投影仪，开始讲。如果没有投影仪，那就电脑打开ppt，开始讲。如果不让用电脑，那就用手持PPT啊，微微一笑，进门第一句就是：您好，XX总吧？很高兴认识您。为了节省您的工作时间，加快面试效率，我先详细介绍下我自己，重点谈谈我对这份工作的了解和匹配情况。然后你就开始口若悬河的说啊，说到关键部位，拿出手头的纸质PPT，闪过去啊。说完了，她如果没问题，或者说到一半不让你说了，说明她可能对你不感兴趣，那也不用尴尬，这很好，节省时间了。但是大部分情况下说完了，就没问题了。面试，不是考核，不是考试，更不是考验。面试就是推销，推销自我。迷茫绝不是你不思进取的借口只要你有了这种不浪费时间，用心做事的习惯，不论未来如何，你都会有一个不错的收获。​​来自读者朋友“yase yyds”的提问：奶爸，你好，最近关注你，特别喜欢你的内容，也购买了V+会员。现在想要请教个问题，希望可以得到你的解答。进入到大学后我就感觉好迷茫，都不知道自己一整天干了些什么。别人都会很多东西，我好像什么也不会，每天就上课，玩会游戏，不知不觉一天就过去了，慢慢的就感觉一天天过得好空虚，好没意义。虽然才大一，但是感觉这样下去，毕业了可能也找不到好的工作，家里也不是富裕人家，看着一天天流逝，心里就感到紧迫烦燥。现在暑假也天天在家里待着没事干，很焦虑，我真的好害怕一直这样下去，一无是处，我不知道该怎么办。可能是我没什么理想，没什么太大的目标，也没什么兴趣爱好，不知道做什么才有价值。希望奶老师能够指点一下，大学迷茫该怎么办？奶老师答：2005年乔布斯在斯坦福大学做了一次演讲，主题是stay hungry, stay foolish，求知若饥，虚心若愚。那一年《读者》杂志刊登了他演讲的全部中译，我只注意到这句话，后来看了英文原版，发现有一个细节更重要。就是第一个故事：如何把生命中的点点滴滴串连起来，这个翻译的不太好，英文原名叫：connecting the dots在第一部分的结尾，还有一大段鸡汤：你在向前展望的时候不可能将这些片断串连起来；你只能在回顾的时候将点点滴滴串连起来。所以你必须相信这些片断会在你未来的某一天串连起来。你必须要相信某些东西：你的勇气、目的、生命、因缘。在我刚开始看这段话的时候，内心充满了不屑，觉得不过就是鸡汤而已，没什么具体的方法论，虚头巴脑的。那时候我在清华大学隔壁上班，经常去大学里蹭讲座，清华经常会邀请国际顶级公司的高管来讲东西，什么微软苹果高盛的CXO，合伙人等等，听多了也都觉得虚头巴脑的全是鸡汤，一说讲成长，没啥屁用。我问在清华读书的小学弟们，也都纷纷表示不屑，浪费时间，只能当是练英语听力了。后来我读了很多商业巨子的传记，并且把乔布斯传翻来覆去看了好几遍才发现，这些前辈们说的都很正确，只是我当时还太年轻，并不明白。​​​​在创业发达这个领域，有极少数的位面之子的存在，比如比尔盖茨和扎克伯格，他们非常幸运，几乎是一落地生下来就知道自己要做什么，更厉害的是童年开始他们就知道怎么做，怎么去实现达成，从小就开始搞各种电子科技。然而大部分成功者都没这么的幸运，甚至包括苹果的联合创始人Wozniak，智商高达190的他虽然也是从小就搞电子科技，但是他的性格腼腆内向，不够自信，并不能确定自己想要的到底是什么，根据乔布斯传的记载，成年后的他也仅仅满足于做个惠普公司的普通工程师就可以了。乔布斯也并非命运之子，他对于创新的兴趣，恐怕还没有灵修来的大，他也并不像盖茨，沃兹，扎克伯格那样从小就顶着神童天才的名号，有一个多姿多彩的灿烂童年。他很清楚自己想要出人头地，想要发家致富，但是具体做什么事，从事什么行业事业，恐怕他并没有感受到命运的征召。仔细想想，其实去清华演讲的那些成功人士大部分都是这样。乔布斯从事电子行业，可以说完全是机缘巧合，遇到了一些朋友一些人，凑巧打听到了电子产品的价格和市场潜力，觉得可以试试，于是就去试了，试了刚好发现自己特别擅长，于是就开始持续做了起来。这非常像电影《当幸福来敲门》的桥段，主角也只是凑巧打听到了证券公司的收入，所以就努力追求，仅此而已。他们在年轻时候，恐怕都不能确定自己真正要做什么事情。换言之，也就是迷茫。这就是connecting the dots的核心意义所在。商业巨子的年轻时代，不能确定自己要具体做什么事可以飞黄腾达，具体要怎么做才能发家致富。所以他们无一例外都选择了，在自己的年纪，去做自己现实条件允许，力所能及的事情。并且立刻去做。这其实是一种止损措施。知道自己想做什么，怎么去做，这非常幸运，但是自己没有这样的机缘，所以退而求其次，立刻去着手开始做自己力所能及的事情，这也不错。最糟糕的，是不知道自己想做什么，同时忽略了眼前自己能做的事情，陷入空想和自我麻痹，浪费时间。这是三种层次的状态。大家会以为成功人士的年轻时代离自己很远很传奇，但其实命运之子还是很少的。乔布斯年轻时候并没有感悟到命运的征召，他甚至完全不知道自己想要什么，在这样的前提下就盲目退学了。但是他并不像给我投稿的同学们那样，吃喝玩乐，浪费时间，自我荒废，没有任何技能和才能。他抓住了眼前最感兴趣的事情，上书法课，冥想，灵修（虽然我不知道他跟上师修行那么久为什么还是那么情绪化）。他读遍了图书馆里感兴趣的书，自由的蹭课，喜欢就去，不喜欢就不去，他随意的交友，认识了各种各样的朋友。终于命运的齿轮推动着他接触到了硅谷，接触到了电子科技工程师们，接触到了电子行业，他大感兴趣，立刻开始大干特干。所以connecting the dots的真正含义，恐怕是这样的：未来其实是无法预测的，你不论想多少，都不能准确的规划出真实世界的走向，所以你只能抓住眼前的这一分一秒，全身心投入到自己力所能及或者感兴趣的事情中去，只要你有了这种不浪费时间，用心做事的习惯，不论未来如何，你都会有一个不错的收获。这个恐怕才是商业高管们成长鸡汤的真实含义。所以我不断强调大学里不要胡思乱想，不要去做什么规划自以为是还要发给所有老师同学大V，拼命问对方自己的规划可不可行。这一切都没意义。从自己力所能及的小事开始做，立刻就去做。学习编写简历，一周时间搞定，锻炼自己的口才，表达，沟通，多参加演讲比赛辩论比赛，多出门社交，不局限在宿舍小圈子，多读自己感兴趣的书，找些实习做做。这些都是小事，但确实门槛不高，立刻就能开始的，做这些，比你头疼选哪条路，要有意义的多。想找对象，朋友圈应该怎么发？不要展现别人对自己的好，要多展现自己对别人的好。​​来自沟通训练营学员“楚琪”的提问：奶爸你好，请问怎么发朋友圈才能展现出高价值啊？我发的太随意了，感觉这样不太好，希望奶爸可以指点一下。奶老师答：我特别有经验，跟你分享一下。朋友圈展示高价值主要在两个领域，一个是婚恋，一个是工作。工作的领域应该发什么？发自己加班。偶尔发一发，不要天天发，天天发显得像奋斗逼。​​​​当然也不一定是发自己加班，也可以编造发一些加班的心情感受，比较积极向上的那种。反正我加班的时候，我的想法就一个，我想把老板一脚从楼上踹下来，没有别的想法了。但是发朋友圈的时候，我一般这么说：一转眼已经11点半，又是坐着最后一班地铁回家。在上海冬天静谧的月光之中，走在安静的小路上，有一种别致的浪漫感。像我这样发，就显得不像奋斗逼，别人会感觉我在很认真的工作，很积极，很上进。如果你总是写自己的心情，那你就要像我一样，写一些环境风景，然后加一些感受。除了发自己的加班外，第二个就是发自己的成绩，但千万不能发自己赚钱很多。因为赚钱多不是什么高价值，而是可利用。赚钱多就相当于长得漂亮。大家不会尊敬你，大家只想来你这里得到好处。长得漂亮别人想性侵，你赚钱多，别人想跟你借钱或者想骗你的钱。所以不能说自己赚钱多。你要说自己升职了，你要说自己拿奖了。但是拿奖的时候依然不能炫耀，不能凡尔赛。这时候你得加上一个“可模仿性”。什么叫可模仿性？可模仿性就是你在发朋友圈的时候，你要证明你得到的成绩，都是通过你努力得来的，然后别人通过努力也可以达到。我举个例子：刚进入公司也就才两年，没想到被提升了三个级别。我自己其实是受之有愧的。我特别感激某某，他总是耐心的、反复的、一遍又一遍的教我。我也特别感激同事们，平时对我的配合，以及对我刚入职时候的不懂事不成熟的包容。又或者，我的CPA证书到了，你不能说CPA证书收到了，我很牛逼。而是，CPA证书收到了，突然觉得为之奋斗的120多个日日夜夜都是值得的，或者说，突然觉得为此而奋斗的120多个日日夜夜都是有意义的。我再举个例子吧，像我们这一行：比如说你买法拉利，你不能说我买法拉利了，我牛逼得不行。你要说我刚来广州的时候，一辆法拉利从我身边开过，把水溅到我身上，我当时气的大骂，开法拉利有什么了不起？一转眼我在广州已经度过10年了，苦也吃过，没想到我今天也能买得起法拉利。或者你说，我刚来广州的时候，饭也吃不上，住的也不好，那个时候楼下停着一辆法拉利，我特别羡慕，觉得我跟那完全就是两个世界的人。我来广州10年了，没想到今天我也终于拥有了自己的一辆法拉利。重点不是说我有钱，我牛逼，重点是我通过不懈的努力，我实现了当初我想都不敢想的目标，这个叫可模仿。因为看到的人不会反感，他会觉得这个小伙子挺实在，挺上进，挺努力的，很正能量。接下来讲讲谈恋爱找对象的领域。在这个领域，很多人都喜欢秀恩爱，喜欢秀我的对象对自己有多么的好，对象给我买这个，对象关心我，对象给我送吃的。我就在想这些人，像这种秀恩爱的人，都是脑子有问题。为什么脑子有问题？因为他们这样秀恩爱，别人不会觉得很甜蜜，别人只会觉得这哪来的傻逼，就凭他也配吗？垃圾也配被人爱吗？或者凭什么他也配有这么好的爱情。但如果把秀恩爱的方式换过来，别人的感受就不一样了。不说我对象给我买了什么东西，对我有多关心，给我做饭，而是换过来。我给我对象送了什么，我对他多关心，我给他买了什么，要这样说才行。不要展现别人对自己的好，要多展现自己对别人的好。一般人互相称另一半为小某，比如说你的男朋友叫小刘。发个朋友圈截图，你说，小刘最近工作很不开心，整天加班，日渐消瘦，所以中午多买了几个鸡腿给他炖了一锅鸡汤，然后发一个鸡汤的照片出来。这样显得你太好了，厨艺很棒，又很关心人。如果你跟小刘分手，你下一个就可以无缝衔接，排队追你的人一堆。如果你整天讲的是小刘整天给我做饭，小刘对我特别好，小刘肯给我买礼物。如果你跟小刘分手了，以后没有人敢追你。因为大家都会觉得你这个人很难伺候，需要给你做牛做马，当爹当妈，还要花钱给你买很多东西，给你这样那样才能和你在一起。男生也是，男生找女朋友，也不要秀女朋友对自己怎么好，你要多秀一秀自己，自己怎么喜欢女生的。你就说，小姑娘这个工作压力太大了，在我面前哭的梨花带雨的，我赶紧请她吃了一顿大餐，然后发一个红包，安慰她，一切有我不用担心，然后把红包的数字亮出来，比如说520或者说666，然后发朋友圈出来。千万不要秀别人的，一定要秀自己对别人的，偶尔秀一下。也不要发你们两个人出去玩的。你们两个人去哪玩，拍了什么照片，没什么意义。为什么大多数人宁愿吃生活的苦，也不愿吃学习的苦？社会的不同领域是不同舞台，在学习的舞台上你不是主角，换一个工作领域，可能你就是重要角色了​​来自读者朋友“钢铁之躯”的提问：奶爸你好，我去年考研一战失败，初试没过，看到别人都上岸了，心很酸。现在马上毕业了，正在纠结要不要二战，因为我不想这么早工作，没什么混社会的经验，不懂人际关系，害怕出社会工作会太艰难，学历不高也害怕以后没有什么好的发展，还有就是我感觉二战只要我努力的话还是有机会考上的，如果放弃的话，过去一年的努力就白费了。我一直都想去一个更高的平台提升自己，想要再搏一搏。但是我家里比较穷，他们更希望我早点工作，所以我很纠结，不知道要不要二战，希望奶爸能够指点一下。奶老师答：人的智力分两种。一种叫book smart，一种叫street smart也就是学院聪明，和社会聪明。学院聪明有天赋和极限所在，社会聪明不是如此，主要靠巴甫洛夫，哪怕是条狗，多历练历练，也能学会在酒桌上推心置腹。这两种智慧有联系相通的地方，也有不能联系相通的地方。比如金融大佬，就两者兼具，都很厉害，名校毕业，智商高，可以研究超弦理论，也能在酒桌上推心置腹。但是也有很多科学家，举止怪异，比如谢尔顿，只能研究超弦理论，绝对不可能擅长推心置腹。除此以外，不同事情的客观难度是有绝对的高下之分的。​​​​比如说核聚变技术，统一场理论，火星移民，人类最杰出的大脑研究了上百年，进展也不大，但是做个外贸，跑跑单子，只要你不是个傻逼，吃得了苦，肯下功夫琢磨钻研模仿，总能成单是不是？运气好点的，成为金牌业务员也不是问题。前者就是book smart的应用，后者就是street smart说的再简单点，考试能不能考高分，其实就是book smart的典型运用，这玩意儿是有极限有先天界限的。不是说你注重训练方法，学习方法，就能提高的。但是类似外贸跑单，待人接物，street smart，是绝对有大幅提升空间，且没有极限，注重训练方法就一定能提升的。所以做人最重要的就是要心里有点数，明白自己到底是不是book smart那块料。没过线，要不要再战，总的来说，得要看你是不是这块料。从这几个角度来判断：1，差了多少分，差几分可以弥补，那不妨二战，差太多了，就打消这个痴心妄想，2，考研准备时候的状态。有的人认为自己考试分数少，是因为自己不认真，只要认真了，就一定能上，那么我告诉你，这种状态就不适合二战，很难考上，这是典型的不是这块料。集中力不足，毅力不足的人，可能压根没思考过。读书求学时候，精心规划按期完成任务的人，始终是极少数。但是毕业后，在富士康工程吃苦受累的人，就是批量化，极大多数。为什么？这其实就是天赋的问题，因为学习带来的心智要求，集中力，理解力，不是每个人都具备的，而因为生产和工作带来的压力要求艰难困苦，大部分人都能撑得住。所以，请认真从这两方面来评估自己，不是这块料就放弃。有的人说自己不是这块料，不想放弃怎么办？这是个心态问题：1，社会如果是个舞台，可能你就不是主角，你只能负责给主角鼓掌，接受这种落差，2，社会的不同领域是不同舞台，在学习的舞台上你不是主角，换一个工作领域，可能你就是重要角色了，就好比陈奕迅看麦当娜演唱会是路人甲观众，自己的演唱会就是天皇巨星。所以不要在别人的舞台死磕，想办法找到属于自己的舞台。3，street smart是绝对可以提升的，先从写好简历，对着镜子说话练眼神接触和说话条理开始。以及最最最最最最重要的，不要死磕。知道法学红牌专业不好找工作，就不考了，知道金融咨询工资高，但是自己死活考不上，就放弃，转行，知道医生辛苦贼难受，那就别考了。趁年轻赶紧转行，是条良道。成功人士一定是高智商人群吗？子女后代的天赋和家庭的财力决定他进入到什么样的圈层。​​来自沟通训练营学员“不朽”的提问：奶爸你好，我是一个天资平平的人，学习起来经常容易觉得劳累和困苦，虽然也算是一所知名985毕业也在所谓的名企工作，但在面对新知识新工作的时候，始终都没有别人来的那么反应迅速敏捷灵光，很顺畅的就能处理好。通过刻苦努力我一般最后的学习成绩工作成绩也不会比别人差，这个月还拿到了季度优秀员工奖，但总是自我怀疑，似乎我生下来就比别人慢半拍，天资就不是很足，因此对未来也充满了不自信，甚至有点畏惧畏难心态。您常说您自己就是普通人，可在我眼里您非常厉害，文思敏捷反应迅速经验丰富，比我见过的绝大部分名校生都要好太多了。不讨论学术科学还有文学这类领域，仅讨论经商赚钱的话，您认为天资在这方面占多大比重呢？真的有天赋平平的人能够功成名就么？奶老师答：其实很多时候你以为的天赋，天资，大概率都源自家庭环境。这种家庭环境不是父母对你的爱，亲子感情，而是你生下来那一刻，父母给你展示，你在这个家庭里逐渐内化养成的本能习惯。天资指的是你在你妈妈肚子里，而只要你生下来了，那以后的一切习惯，严格来说都不能叫天赋或者基因，都算是后天环境。只是很多人容易误认为这个属于天赋基因。​​​​比如医学上有一种遗传性疾病，和基因天赋没有任何关系，纯粹的和生活习惯有关。举个例子，我妈那边就家族性遗传高血压，她的兄弟姐妹几乎都有高血压，唯独她没有，去医院检查发现身体上都没啥问题，最后排查出原因：我们家口淡，吃盐少。别人家口重，吃盐多。就这么个生活上的小习惯，导致身体健康上的巨大差异。国内很多地方都有特色疾病，本质上也都和基因天赋无关，纯粹和生活习惯有关。比如苏北一带的人食道癌的患病率非常大，主要是因为普遍没有暖气冬天又特别冷零下好几度，整个中国地区生活最难熬的就这片地方，冬天饭端上来必须趁热吃，而且又特别喜欢喝粥，滚烫的开水非常致癌，长期以往自然就会容易得这种病。广东一带的人肾出毛病的几率比其它地区高，和他们的饮食习惯也有关系。在肉体健康上，家族性遗传的生活习惯影响是如此的剧烈，都经常会让人觉得这是家族遗传病，是家族基因的问题了。那么在精神，思想，实干，学业，事业，人生成就方面，家族性遗传的生活习惯，会不会也有这样的影响？有的，非常有。所谓的龙生龙凤生凤老鼠的孩子会打洞，并不是因为基因和先天的智力因素，而是因为家族的生活习惯。看美国的黑人街区纪录片，普通黑人少女的生活仿佛被人下了诅咒，都未婚先孕，十五六岁就怀孕了，然后爸爸跑没了，接着生了女儿，女儿接着继续未婚先孕，世世代代形成诅咒，永远无法从贫困的生活里摆脱出来。奥巴马也是未婚先孕的私生子，他能成为美国总统显然不是因为他天赋异禀，而是因为他的死鬼老爸虽然是个黑人，但他老妈外公外婆都是白人，且都是白人抚养的他。所以他虽然肤色是黑人，但其实是出生在白人家庭，受的教育都是白人文化，思想观念上就热爱读书，渴望学习，尊重文化。传统黑人的生活习惯是啥？枪支匪帮毒品性。而且整个族裔没有任何反思和自我批判，反而特别引以为豪，形成了文化自信，通过rap传唱世界各地，洋洋得意，丝毫不觉有何不妥。中国也有类似的现象。左宗棠的后代诞生了不少院士，江南钱氏家族更是了不得，钱穆钱伟长钱钟书钱学森钱三强都是这个家族出来的，到了现在，这个家族也还在不断的出产院士。而反观一些普通家庭，父母自己的生活习惯就是吃喝玩乐，以前是打麻将，现在是刷手机，平时的交谈从来就没有过洞见思考，全是鸡毛蒜皮普通八卦，这样的家庭望子成龙，怎么可能？之前有一个教育学教授对自己的女儿一筹莫展，女儿说自己就不想努力不想奋斗不想做大事业也没什么理想，网友听了哈哈大笑觉得是段子很有趣，但现实来说这一点都不有趣一点都不自由。这说明这位教授的家庭习惯培养彻底失败，家庭传承被彻底打破了。造成这种情况无非两个原因，一个是教授自己忙于工作很少介入家庭，和家里的子女没什么交流，从小没在身边受影响，长大了再想教育，为时晚矣，另一个就是教授的老婆没找好，素质不高，教授自己作为父亲失职，母亲也失职，从小没有给孩子做好楷模和榜样，没有和孩子交流沟通这方面的事情。导致孩子大了懂事了，脑子里只有享乐，只有躺平，没有半点的奋起之心。家门不幸莫过于此。在小孩三四岁的阶段，父母的一言一行他其实都会记在心里，比如我爸是乡村教师，我家住教职工宿舍，我妈经常让我去喊我爸吃晚饭，那时候都七八点天都全黑了，我爸拿着蜡烛给学生们讲题，殷切期望他们都能考上好的高中，继而考上大学有不一样的人生。我家里也经常放着书，我爸无聊会拿着书来看消遣。曾经我以为这种家庭习惯是基本配置，等我去了别的同学家，发现他们家上上下下一本书都没有，全家人最大的乐趣就是看电视窝在沙发里一动也不动的时候，才发现真的不一样。父母这种言行对子女的影响是根深蒂固深入骨髓，一辈子都没法改掉的，这就导致我和我姐不管做什么工作都力求做到最好，都认真负责到底，而且闲暇时间无聊就看书而不是别的消遣，继而出现了问题也会习惯性的从书本和搜索中寻找答案。子女后代的天赋和家庭的财力决定他进入到什么样的圈层，是大城市还是小城市，但家庭中潜移默化的习惯决定了ta在各自的圈层中达到什么样的位置。家庭习惯好，子女就能在自己的圈层里勇夺第一，并且把这种习惯传承下去，后代中总会出现天资好的，打破圈层上升。家庭习惯差的，子女就在自己的层圈不思进取，随便混混，甚至还可能跌破圈层，以后有了孩子大概率就是一代不如一代。就题主这个情况来看，题主经常觉得自己脑力枯竭，殚精竭虑，这种感觉我也常有，代价就是失去了所有的头发。但脑力枯竭，觉得自己天资不足的人，仍然能够考上名校，进入一流大公司，那么显然，你的家庭习惯远优于别人，让你一普通天资，达成了高天资才有的成就。换言之，你已经进入了名校名企的这个圈层，只需要保持住流传下来的好习惯，那么你必然会在这个圈层里成为最顶尖的存在。因此完全不用担心，不用觉得畏惧，大胆自信起来，你的家庭习惯，就是你最好的天赋。而对于普通人来说，不论你有没有好的天赋，不论你有没有好的家庭习惯，不论你能不能大富大贵，尊重知识，理性，热衷深度讨论，这永远是个好习惯，是个值得你传下去的好习惯。为什么鸡娃没有任何屁用，只是在浪费钱？在促进孩子心理发展方面，人为加速孩子的发展，会对孩子心理的健康发展产生危害。​​来自读者朋友“星晴”的提问：奶爸，很想你能帮我也指点一下，万分感谢。我的孩子快6岁了，我一直比较注意尊重他，爱他，引导他，也比较注意规矩的树立。可是现在发现，他对外交往依然不够自信，学习的兴趣也没有激发出来，礼貌素养也不够好。我都有教啊，不知道为什么还会这样。之前我不赞同身边打骂教育孩子的孩子方式，但通过吼或者恐吓孩子的方式教育出来的孩子似乎学习得更好，做事更好，更礼貌大方。孩子马上要上小学了。他的性格、能力、社交、学习等方面面临的考验更多。我很担心我在教育中出了错，却自己没有发现。奶爸，希望你能指点一下，万分感谢！奶老师答：最近收到不少鸡娃和家长焦虑的投稿。这让我想起了我的小时候。小时候我最害怕的其中一项经历，就是学自行车。人小个子矮，所以学自行车一定要学上车跟下车，我这个人又怕痛，怕摔，所以一直不敢学。我爹妈就对我又是打又是骂，喋喋不休，逼着我上，最后我终于能上下车了，他们对此觉得还挺自豪。后来等到了我初中了，人长高了，根本就不需要学上下车，直接跨上去，腿一支，就保持平衡了。然后再回想起小时候学自行车的经历，感觉挨的打骂全白挨了，都是无用功，越想越生气。而且我这辈子的身高都不可能缩回去，所以根本不需要学习所谓的上车和下车的技巧，这些所谓的技巧，统统都无用。现在微博里很多视频，小孩很小年纪，发育完全没开始，就学汉语拼音，学各种运算，死活不开窍，被父母冷嘲热讽发脾气。不知道他们长大了，会不会也跟我一样面露苦色，觉得自己从小经历的打骂，都白挨了。顺便附上著名的双生子爬梯试验：​​​​美国心理学家格塞尔曾经做过一个著名的实验：被试者是一对出生46周的同卵双生子A和B。格赛尔先让A每天进行10分钟的爬梯实验，B则不进行此种训练。6周后，A爬5级梯只需26秒，而B却需45秒。从第7周开始，格赛尔对B连续进行两周爬梯训练，结果B反而超过了A，只要10秒就爬上了5级梯。格塞尔分析说，其实46周就开始练习爬楼梯，为时尚早，孩子的身体没有发育成熟，所以训练只能取得事倍功半的效果；52周开始爬楼梯，这个时间就非常恰当，孩子身体发育了，所以训练就能达到事半功倍的效果。这个实验给我们的启示是：教育要尊重孩子的实际水平，在孩子尚未成熟之前，要耐心地等待，不要违背孩子发展的自然规律，不要违背孩子发展的内在“时间表”人为地通过训练加速孩子的发展。在促进孩子心理发展方面，人为加速孩子的发展，同样会对孩子心理的健康发展产生危害。幼儿期的孩子正处在“游戏期”，这个时期的教育应以游戏为主，在游戏中发展孩子的感官，激发孩子的心智，培养孩子的社会能力。不少的家长却认为游戏浪费了孩子的时间，因而提前教导孩子学习知识（如读、写、算）或才艺（如绘画、弹琴、舞蹈），将孩子提前置于不成功便失败的压力之下，会使孩子养成以后遇事退缩与事后内疚的不良个性。按照儿童和少年的生长发育以及大脑发育的成熟，高中和大学其实才是最重要的，才是学习知识的黄金时期。我往常对家长的回答都说的很清楚了，皮亚杰儿童认知发展理论，2-6岁不管怎么教都没屁用，儿童的大脑根本就理解不了什么叫礼貌什么叫规矩。这时候最重要的不是儿童的素质是否优秀，而是和家长的关系是否亲密，是否喜欢家长，是否在家里有安全感。6-12岁才是管教的重点。至于说打孩子吼孩子的方式教育出来的小孩表现更好，那不叫教育，而叫驯化，这种孩子基本上已经被毁了。小时候很优秀，高中就开始变差的人，主要根源就在这里。另外小孩仅仅是上个小学而已就对他在性格、能力、社交、学习这么多方面有期待和要求，不太合适吧，这个妈妈也太让人窒息了。从这个投稿看得出来，可能对孩子平时不是热暴力，但冷暴力是绝对少不了的，小孩没有被打骂，但是从小到大的压抑和窒息气氛肯定少不了。鸡娃的SB家长越来越多，为这个时代的小孩默哀。。。哦对了，国内还有一套更牛逼的大杀器，跟早教互相配套的，长期以来毁人不倦，那就是：“小时候努力刻苦好好学，上了大学就轻松了。”对小孩来说，暴力就是解决问题的最佳方案教会小孩合理的使用暴力，虽然听上去政治不正确，但这就是绝对正确的事实。​​来自读者朋友”李闲”的提问：奶爸您好，向你请教一个校园霸凌的问题，希望可以得到你的解答。我的弟弟正在读初一，在乡镇上读初中。他是学习委员，有一次晚自习老师有事不在教室，督促他暂时管好纪律。班上有一个不学习的混混和周围同学嬉闹非常大声影响到其他同学学习，所以我弟弟提醒不要影响到其他同学而惹到这个混混。因此这个混混和一起玩的一个女生和几个男生，平时就挑我弟弟的刺，下课也过去挑衅他。还说周五回家的时候路上堵他，要打他一顿，让他等着。弟弟告状，我爸妈去处理了这个事情。后面就变成了他们小团伙总是阴阳怪气嘲讽我弟弟，基本上无时无刻。比如编造他和其他女同学的绯闻，大声喊他的名字说他趴着是在睡觉，下课就会去逗弄他，让他很烦。我让他不要去理会这些人离他们远点，可是这些混混不依不饶的调戏和嘲讽他，甚至以此为乐。他现在开始有点不想上学了。我妈让我多疏导弟弟，可是我不知道该怎么办了。奶老师答：美剧《初来乍到》讲的是一个华人家庭在美国。华人家庭嘛，就有很多传统的陋俗，你懂的。但是有一个故事，让我很惊讶。大儿子艾迪在小学，本来好好的，跟大家相处愉快，很随和，但是突然有个黑人小子冒出来一句Chink!Chink是英语对华人的蔑称，类似你骂黑人nigger当时全校人都惊呆了，寂静了，全部看着艾迪。​​​​艾迪非常无奈，说这下不好收场了，为了祖国，为了民族，为了传统，为了无数华人的面子，虽然我厌恶暴力，但是没办法了。于是他上去无奈的把黑人小孩给暴揍了一顿。揍完之后，肯定是被校长留下来，要见家长，艾迪严厉的父母来到了学校。一般的中国式父母，无非两个反应：一个是嫌弃儿子给自己丢脸，不分青红皂白训斥孩子一顿，一个是护犊子，不分青红皂白就耍赖，说凭什么说我家孩子。但是这里的家长都没有，校长开了官腔，开始教育小孩，说我校建校以来从未有过如此的恶劣暴力事件。但是爸爸反而冷静的说，我儿子打人了是不好，但是我想了解一下事件具体的来龙去脉。校长继续喋喋不休，说你家孩子太暴力，毛病太多，一定要严加看管。妈妈忍不住了，说儿子怎么管是我的事，了解下事情缘由有问题吗？校长说事件缘由很简单，一个同学就说了一句话，你儿子就打他。说了什么？就是一句无足轻重的话啦。到底说了什么？额，校长面露难色，说是chink爸妈一听这个词，非常愤怒，什么？！我儿子被人侮辱了，你们不保护他，不去惩罚那个学生，居然还要惩罚他？你们学校怎么干事的？不是说打架吗？打架有双方咯，为什么只有我家孩子留下来，对方呢？你们是种族歧视吧？爸爸立刻站起来，斩钉截铁的说，我要向市政厅，华人协会，教育机构，以及PTA家长会控告你们，你们是一群种族歧视者，纵容对华人的侵犯。我会联合华人来抗议示威，联络媒体，让你这个校长当不下去。校长当时就怂了。回家路上，艾迪很不解，说爸妈一向都对自己严厉，为什么这次维护自己？妈妈回过头微笑着说，艾迪，在维护自己的正当合法权益这件事上，没有什么错的，我为你骄傲！换国内，估计来的就是“他怎么就骂你不骂别人啊？”“一个巴掌拍不响吧。”这种恰恰是家庭教育的大忌。教会小孩合理的使用暴力，虽然听上去政治不正确。但这就是绝对正确的事实。被大学专业束缚，就活该穷一辈子所谓的职业精神，其实就是在合法基础上，越多的捞钱越好。​​来自沟通训练营学员“艺菲”的提问：奶爸，你好，我是某理工科211英语专业在读的大三学生，是你的训练营学员。身边人总是说英专生除了当老师和翻译没什么出路了。确实也看到了好几个优秀的学长学姐都是这样，要么考研进体制当老师要么去培训机构当老师。可是我以后不想当英语老师，所以请问奶爸，除了翻译，英专生的我还有别的出路吗？说实话，如果不做英语相关的工作，总感觉大学这个专业白读了，好浪费，对从头开始转行运营有一些抵触。现在非常迷茫，还希望奶爸能够指点一下~奶老师答：我说的话很难听，首先翻译不是一条出路，而是一条死路。然后我以我个人的经验见解，提出了一个有趣的现象。每年全国英语演讲比赛总决赛那几十个名额，基本汇聚了我们这儿英语口语说的最好的那批大学生。这些大学生里，至少50%是英语专业的学生，其它的都是什么工商管理，市场营销，金融，法律等等各类专业的。根据这么多年的观察，我就发现一个问题：​​​​这些人英语说的都是最好的，一样好。但是毕业三年后，混的最差的就是英语专业的，混的好的是其它非专业的。注意这里是同级比较：所有英语说的好的同学中，名牌大学的，英语专业混的比非专业的差，非名校的，英语专业混的比非专业的差。为什么会这样。有人说是因为英语专业没有其它方面的特长，那么我请问，工商管理，市场营销这类专业，算什么特别艰难门槛特别高的专业特长吗？慢慢的我就发现，这不是什么特长，专业，能力的问题，这纯粹就是心态和思想的问题。其它专业的人，英语说的好，但是对它来说英语只是自己诸多工具中的一项，所以他毕业后，就会心态很稳的找一份普通的商业工作，然后慢慢晋升，提高自己。而英语专业的同学，英语对他来说就是唯一的专业，唯一的工具，毕业后他就一定要找一份和英语有关的工作，于是就去选择一些职业前景非常糟糕的什么培训老师，翻译之类。但事实上，这个世界上所有的工作，本质上来讲，都不可能和英语有关系。学小语种同理，任何工作，都跟什么日语法语西班牙语没有关系。本质上，工作只和一个因素有关：钱。所谓的职业精神，其实就是在合法基础上，越多的捞钱越好。但是英语专业人的思维，没有这么务实和纯粹，他们不太容易会思考金钱的产生，流通，贸易商业的达成，他们还是想要有和英语有关的工作。一旦有这样的思维，必然不可能有什么好的事业。从今天起，抛弃这种思维，就当自己没读过语言专业，去认真找一份销售，市场，运营，商务类的实习，学习商业思维，思考如何赚钱，如何做业务。这是我能给予最好的建议。明明上班不是体力活，为什么总是感觉特别累？长期冥想的好处在于增强你的身心力量，对加强意志力，提高自信心，都有非常大的好处。​​来自沟通训练营学员“豆豆”的提问：奶爸，你好，我是第七期的训练营学员，咨询一个问题：不知道为什么我总是感觉上班非常的累，朝九晚六，工作内容虽然枯燥实际上也很轻松不是什么体力活，但是不知道为什么就是感觉累，乘地铁回家后就想躺平。平时也在坚持运动，可是总感觉身心俱疲，不知道这是为什么，体检后也没啥太大问题，我现在很焦虑，请问奶爸怎么办？奶老师答：上班经常觉得累，最好的方法是冥想。运动是调节身体的疲劳，冥想是调节精神的疲劳。如何冥想，什么叫冥想。每个人对冥想的理解不同，至今没有什么统一定义，有的书看了我都大惊失色，跟我理解的完全不同。我只说我自己的理解，和平时喜欢用的方法。冥想是指：大脑彻底放空情况下，进行想象力和思维活动的释放。所以，冥想一定要有：​​​​1，绝对安静的场所，2，耳机，录音，3，提示引导语或文字。什么叫提示语，比如这种：“想象你在一片花海里，遇到小鸟，听到泉水潺潺的声音…”类似这种，就叫冥想引导语。冥想的难度我觉得跟引导语有关，想象风吟鸟叫很简单，想象灵魂超脱地球，深处太空，俯视万物众生就很难。提示语用来干嘛的？是用来背诵记忆的吗？错！把引导语背下来再进行冥想是最差的方法，你的脑袋还是没有放空，而且在不断分散注意力。引导语是用来录的！把上面的引导语，自己念几遍，念熟了，录进手机里，配上背景音乐，冥想时候带上耳机，听录音，脑袋放空，照着提示录音做即可。一段录音两分钟，你的冥想时长就是两分钟，一段录音十分钟，你的冥想时长就是十分钟做完以后，神清气爽。性生活也不过如此。这些提示语，环境，录音和配乐，有app，有书，可以自己找现成的，也可以自己录，我就不作广告了。千万不要用脑袋记录冥想内容文字，这样还是在动脑子，效果适得其反，也不要没有提示音提示语言就瞎想，会睡着，没用。长期冥想的好处在于增强你的身心力量，对加强意志力，提高自信心，都有非常大的好处，甚至不用每天坚持，两三天坚持一下就好。佛教禅宗的什么打坐咒语我不太懂，目前我试过效果最好的，就是冥想。一定要有一个绝对安静的场所，否则容易受到惊吓，很不好。此外群体冥想是非常不错的课外活动，即一群人在瑜伽教室里，老师放着舒缓的音乐，由他来解说冥想提示语，大家都闭上眼睛深呼吸慢慢跟着提示入定，随着能力的增强，你就发现自己的心智力量越来越强。这种大课就比较长，一次冥想在20分钟到一个小时左右，效果很好，但是一周只去一次不好，有个三四次效果就很不错。此外，有人问过，如何舒缓自己上台前的恐慌，消除紧张，除了习惯成自然外，冥想是最好的方法。录一段2-5分钟的短提示音，把音量提到最大，戴上耳机，或坐或站，冥想一两次，你全身心都静下来了。我现在已经不需要上台前冥想了，但是我在大学上演讲课的时候，那个美帝博士的外教，经常用英语来引导我们冥想，这是精神力量通过冥想放松得到加强最好的案例。不懂汇报和述职，难怪你没法升职加薪你得在现在的工作流程中发现问题，提出自己的思考。​​来自沟通训练营学员“昊航”的提问：奶爸你好，本人法学本科应届毕业生，已通过司法考试，拿到了基金并购公司风控专员的offer，还没有入职。之前了解到很多公司都会需要员工做年终述职总结，想请问一下奶爸除了和同事前辈请教之外还有什么其他的方法和技巧吗？奶老师答：述职这个事看上去很小，随便走个过场就好，实际上具有非常大的作用，尤其是对于新人来说，这是罕见的能够和大老板直接对话沟通的机会。在述职会上给老板们留下好印象，对你的未来会有非常大的帮助，这是你升职时候的重要考量。而且不单单是述职如此，采用正确的职场思维逻辑，解决工作中的问题，你的工作能力就会持续进步，慢慢的你这一套思考方法就可以复制传授并且不断累积势能，良性循环越来越好。做述职的时候，最重要的是要给人留下印象：​​​​你可以独当一面。独当一面这四个字看着玄学，但其实是有丰富具体的内容的，它主要包括：1，你可以完成现在的工作，2，你对现在的工作用心了，完成的质量不错，3，你对明年的工作有所展望和基本规划，4，你能够在现在的工作中发现问题，5，你能够得出解决问题的方案，并且大胆的提出来。这5个问题，是层层递进的，非常重要。前面三个问题，是基本要求，我相信大家只要认真干活了，都能做到，在讲述这方面的情况的时候，主要要结合数据，案例，认真来讲。还有要学会包装自己，如果业绩的数字太小不好看，那就说和去年相比增长多少，如果跟去年相比增长一般，就说和其它同事同期相比超额多少。反正就是要会包装自己。不能干巴巴来一句，我做的挺好，做的不错，没了。你得有条理，有逻辑的按照自己的理解，把工作内容，强行分成一二三的几块，每块都侃侃而谈，头头是道。而且每一块，你都要结合数据，今年的数据，去年的数据，你同事的数据，进行对比和分析。做到这个，你基本可以得到老板的赞誉了。但是仅仅这样还不够，你得提出见解，而不是应声木偶。你得在现在的工作流程中发现问题，提出自己的思考。如何发现问题？非常简单的逻辑：follow the money你们公司的业务是什么？你所在的部门属于什么性质？是赚钱的，还是省钱的，还是花钱以期未来可以赚钱的？基本上部门就分成这三大性质。赚钱的，就是业务线了，不用多说，省钱的，就是财务，IT，HR之类的支持部门，你们的活做的快做的好，就能给公司省钱，花钱以期未来赚钱的，比如投资部，市场部，营销部，企划部等等。你明白了自己部门的性质，自然就明白了你的团队给公司业务提供什么样的帮助，你们的存在有什么样的意义。继而你就会发现自己的工作，提供了什么样的支持，有什么样的意义。继而你自然就会发现问题，如何提高，这是必然的事情，因为不存在完美的商业流程和商业模式。但是这里要注意，你所提出的观察，见解，发现的问题，最多最多只能局限在部门层面，不要达到公司层面。之前底层人员写两万字直接发给任正非，陈述华为的战略问题，发表自己的战略构想，任正非看都没看，直接让HR通知此人明天不用来上班了，并且在公司内部公告：级别低于XX者就妄谈公司战略的，建议直接送精神病院。这是非常正确的，因为底层员工不论多厉害，是不可能洞察整个公司的大战略的，甚至任正非自己都不能洞察——放十年前，他做梦也不可能想到华为今天会做手机还做的这么大。很多战略都是有机缘的因素的。那么如何在机缘发生的时候，能够抓住它？就是在其位，谋其政，每个员工把自己的工作达到尽善尽美。所以你思考的，不单单应该只是眼前的螺丝钉，同样也不应该是整个公司的战略，而应该是你这条业务线，你所在的团队，或者你的部门，这个层级上每天的工作细节。是否有沟通不畅，效率低下，是否有监管不力，数字不清，是否有流程模糊，效率不高。这些实实在在的实务工作，才是下属真正应该考虑的重要问题。举个例子：我有个哥们之前在拜耳做数据分析，他做了一项很简单的小建议，当时大家都用excel算数字，又冗长又繁琐，他写了一套算法给领导，缩减了30%以上的工作时间。领导过两年提拔上去做总监，继任者推荐名单，就只写了他一个人，说只有他适合。这个故事需要一点专业技能，但是只要你认真用心观察，我相信，你可能能发现问题的，至于说问题如何解决，其实你提出这个问题，就足够让领导对你刮目相看了。读书后总是忘该怎么办？比较好的书是两者结合的，一方面帮人开智，一方面指导别人开智之后怎么做。​​来自沟通训练营学员“知恩”的提问：奶爸你好，我是您的第六期沟通营学员，非常感谢你提供这么好的课程，我的人际关系得到了全方位的改善，非常感激你。私信奶爸还想请教一个头疼的问题，平时看的一些书籍，过一段时间就会忘记，请问如何把书中的知识内化，深深地记在心中，活学活用呢？奶老师答：如何把读过的书里的东西进行化用？大部分人读书的过程，简称为garbage in, garbage out哪怕看了几十本那种如何读完一本书正确的读书方法之类的东西，脑袋里还是空空如也。就好像记忆最多只有7秒。嗯，这本书的方法不错，很好，我明白怎么读书了。咦这本书名字叫什么来着？第一章写啥来着？这类金鱼症患者特别喜欢报菜名，就是书里的东西说不出什么，但是特别爱拽书的名字，以显示自己优越。我写一篇思维工具的博文，他评论留一句，推荐奶爸你读读《思考快与慢》，很有用哦。我写一篇读书方法的博文，他评论留一句，推荐奶爸你读读《如何读完一本书》，很有用哦。这就是装逼翻车现场，他写不出来“奶爸我分享下我平时的读书/思考习惯，一般是怎样怎样12345.”他只会说，奶爸推荐你看看某某书。这类某某书我都看过多少本了，你跟我这装什么逼呢？这就是智障们往往意识不到自己是傻逼，总觉得自己很聪明很有优越感。他们没有实在内容和体会，只会报菜名。那么具体应该怎么把书本内容化为己用呢？​​​​我觉得有干货的书分为两种：一种类似洗衣机说明书那种工具书，拿到了直接照着做就好，一种是写了很多原理，知识，帮你开智。现在的书籍，前一种很少了，因为枯燥，没人看，卖不出去。后者居多，但是只写原理知识，不写方法规划，就是没干货，纯装逼。比较好的书是两者结合的，一方面帮人开智，一方面指导别人开智之后怎么做。对于怎么做的部分，很容易理解，直接行动去做就好。但是对于开智的部分，很多人看懂是看懂了，但是看懂了以后，脑子里空空如也。啥也没记住。怎么解决这个记忆，化解，成为自己知识体系这个过程？我来分享一下我的经历。我人生中最早看的是故事书，读书对我来说，其实没啥意义。但是那时候我们一年级每年都要开班会，农村小学开班会没啥意思，老师们都不知道咋办，于是有人提议要不讲故事吧，可老师肚子里的存货很快讲完了，没了，于是我自告奋勇我来讲。我讲的第一个故事，应该是盘古开天辟地的神话故事，那时候大家没电视看没网络上，获得信息渠道很单一，所以传统中国神话故事还是非常吃香的。严格来说当时作为小学一年级下学期的人，我个人并不喜欢读书，也不懂读书能带来什么。读书对我来说，最大的意义就在于虚荣心，我看完了一则故事，就可以讲给班上同学听，受到同学们的赞叹鼓励，可以在讲台上大大方方的看着我平时暗恋的前排小姑娘。甚至慢慢的发展到之后只要上课结束了，大家无聊没事干，同学们就推举我来讲故事，农村的老师也不怎么负责，当时课业负担也不重，所以随便我来讲。故事大王是我二年级时候收获到的绰号。有部分同学受我启发也争先恐后的学习讲故事，但是他们的故事基本是转述，来自身边对成年人的道听途说，农村底层原生态的故事都带有大量的色情元素，我印象最深的是他二年级讲的一个故事，男主用JJ搭桥帮助全村老百姓度过洪水难关。这个故事其实一点都不好玩，班上人也基本没听懂。这位男生被老师给狠揍了一顿，后来我就很少看到他了。三四年级之后我进城读书，在城市里却还是经常有在班上讲故事的机会，也继续保持着我故事大王的绰号。到了六年级后课业紧张，我就再也没讲过故事。一直持续到了大学。从一年级的这项活动，却对我的思维结构产生了潜移默化的影响，之后的十几年时间我再也没讲过故事，读书的习惯倒是保存了下来，尤其是在让我不开心的中学，读书成了我躲避的一个好方法。但即便是这样，我现在翻开任何一本书，一篇文章，我的条件反射就是：如果要我复述这本书这篇文章，我会从哪里下手呢。这就导致我读完书之后的收获，和一般人不一样，普通人读完了觉得非常精彩过瘾，然后没了，而我习惯性的会自动的记住一些关键点，方便复述。这项习惯曾经给我造成很大的烦恼，就是让我看完小时代之类的东西都记得清清楚楚，非常心累，一直到创业之后要操心的事太多了，我才会选择性关闭掉这项功能，对于某些垃圾，我也就garbage in, garbage out长大后我参加一下领导力的培训课程，讲学习，讲师给画了一个学习曲线。学习效果最好的是读完书之后开始教人，次之是立刻去实践，最差的是死记硬背不断重复。所以我现在安排员工出去上课培训，以前是给回来给他出题，考察下学习效果。现在都变成了，学完了你就做个简单的PPT，花个一两个小时跟我们同事分享分享。读书也是一样，我布置了书目，也是让他们做个PPT，跟大家分享分享。把书本知识化为己用最好的方法就是去教别人。所以我很庆幸，从一年开始，就每周定期定时的有几十个同龄人坐在一起，聚精会神的听我说话讲故事，这让我之后读任何东西，脑子里都会自动模拟，如果有一堆人围着我，我在讲堂上，我会怎么复述讲解我手里的这份材料。这样好的成长环境和潜移默化的培养，可惜再难重现了。到底什么叫“管理能力”？这4项工具是我个人认为最好用的，也是最能提升团队战斗力和凝聚力的管理方法。​​在某网站搜了一圈所谓的管理技巧，基本全都是不痛不痒的泛泛之谈，没什么干货和实用技巧。原则策略谁都能说的开花，但是具体实操，尤其是从基层一线上来的管理者如何实操，几乎没人写过。这里简单讲讲我个人认为最好用的几个工具：1，不论你有多忙，你的效率有多高，你认为员工的能力有多么的差劲多么不如你，每天至少要有30-60分钟，或者每周至少要有1到2个小时，你要单独拿出来，和员工开会。开会的时候重点要放在三个方面：​​​​1）派活，把当天或者本周的工作重点和规划分发出去，2）解释工作背后的意义，为什么必须要完成，为什么工作很重要，3）留出一定的时间进行答疑，不仅仅针对分配的工作，任何员工的疑问，都可以提出讨论解答，且管理者有义务进行回答。这么做的意义是模仿军队管理法。军队管理法有一个常识就是，所有士兵都必须明白自己在为谁而战，因谁而战，自己的战斗理念是什么，士兵有任何疑问都可以提，并且上级有义务不厌其烦的解释，直到士兵听懂，彻底明白自己是在为谁而战，自己的战斗理念是什么。如果上级不负责解释和回答，只是使用命令强行压迫，这样的军队就不会有任何战斗力，只会变成出工不出力的兵油子和兵痞。公司管理也是如此，上级有向下属解释工作意义的义务，让下属明白自己在为谁工作，因谁工作，工作的意义和作用是什么，解释清楚下属的工作能力才能得到提高，否则就是摸鱼老黄牛。2，每天会后的第一件工作，就是要让下属列好自己当天的to do list，发到协作空间，或者群或者钉钉之类的地方，工具不限，关键是必须要让下属养成自己思考工作，自己给自己安排规划工作的习惯。但这个规划工作不可以弄的太复杂，耗时太久，应该让下属在15-20分钟，尽量10分钟以内提交，免得光是规划就花了一两个小时，加上晨会一两个小时，整个上午就没了。3，表扬和嘉奖要公开，批评必须私密。这一点是基本的集体心理学，但很多管理者不懂，他们总认为，杀鸡骇猴，敲山震虎，是最好的手段。但实际上都是适得其反的，你会议上公开严厉批评一个人，全部扣光奖金工资，你以为其他同事会被吓到了，变的很乖，变的尽职尽责，但是他们内心深处会怎么想你这个领导：卧槽，这上司简直太不是人了，太不是东西了，太残酷太严厉了，我们要不还是跳槽吧。为什么经常有一些年纪大的管理者，表示难以适应这个时代，90后95后下属太不好管了，动不动就跳槽，没责任感？因为他们蠢，不会管理。正确的方法不是负面恐吓，而是正向激励，把嘉奖和表扬的人，在公开会议上说，有钱的就给钱，没钱的就用文学词汇精神鼓励，当然也不要单纯的口头，做些证书，奖章啥的，没什么成本，但是可以起到非常好的激励作用。至于你想骂人，那么请拉到私密空间，办公室或者会议室，私下吹胡子瞪眼，尽量不要公开，而且在骂人的时候，一定要提到这点，私下骂你是为了你好，为了给你面子，让你不要在办公室里抬不起头。这样的批评效果比公开处刑要好的多，不一定所有人都会立刻改正，但大部分有基本工作素养的，都会迅速改正。4，面对工作的疑难问题不要装腔作势，要诚实，同时要和员工一起积极探索。很多管理者认为回答不了下属的问题，是很丢脸的事情，所以他们在遇到不懂的问题时候，会刁难下属：这个你要自己解决。公司雇你来不是让你学习的，是让你解决问题的。这你都不会？自己去想！别来打扰我！这种解决的态度，在基层管理岗位是绝对的大忌。比较好的解决方法，就是先听取员工的看法意见，如果他也没有好看法，那么就和他一起去寻找解决方案。员工：老板我遇到了XX问题不会。（你也不会）你：这个问题确实比较复杂，你有什么想法么。如果他有，你觉得很好，那就鼓励一番，大胆去干。如果他没有，或者想法比较差，你就这么说：这个问题确实比较复杂，我暂时也没什么好的想法，不如我们组里一起开个会，头脑风暴一下，集思广益。如果你们组就你俩没别人了，或者大家头脑风暴了也没好想法，那么这时候：看来大家也都解决不了，那我得去求助下我认识的一些高手专家了，我大概XX天内给你答复。然后你带着问题去请教别人。这里就有一个前提：那就是你作为主管，不需要是全能的。但是你也是必须得持续学习，保持进步的。不可以装腔作势，这是拒绝进步，对你的未来很不妙。目前来看，这4项工具是我个人认为最好用的，也是最能提升团队战斗力和凝聚力的管理方法。高分低能一般都是些什么样的人？所谓的智商也好，毅力也罢，到了一定高度后，决定成就的基本就是心态和性格了。​​“高分低能”是很多人喜欢用来侮辱名牌大学生和尖子生的一个词汇。我们换个思路，如果说高分低能很常见，那么高分高能的人应该是什么样子？这个就是很多人思维的盲区，什么应试教育素质教育说了一大堆，偏偏就是不知道啥叫素质，啥叫能力啊。这玩意儿毕竟不是分数那么直观，给不出准确定义。我很幸运，小时候看了几本书，什么等你在北大，等你在清华，什么高考状元谈，这些人都分享了自己的大学感受和学习经验。那时候我的读后感就是，有些人能力很强，有些人能力比较差。后来我花了点时间搜索了下当年的人名，发现我很小时候的判断，大抵准确。所以我决定结合个人经验，以及案例样本分析，斗胆对能力做一下划分：​​​​1，基本的独立生活能力 。这个是源自某一任高考状元详细写的心理历程，我不知道她现在看到会不会后悔，但是给我们很大的参考意义。她在文中不断抱怨，自己一个人处理事情很累，一个人打扫卫生做家务很累，甚至洗头发都觉得很麻烦——因为高中时候就连长发都是妈妈帮她洗的，除了饭前便后，她活到19岁，一双手没沾过水。2，性格和心态因素。在读这类书的时候，我发现一般人面对未知和困难，有三种心态。第一类是上面那个状元A，是抱怨和畏惧型，是胆怯和懦弱型。面临新的城市，新的课程，新的领域，她没有觉得很开心，很热爱，很积极，而是非常的厌恶，害怕和不适应。她有非常好的文科功底和写作水平，但是没有想过怎么发挥怎么实用，想的全是怎么这么烦，如果时光能回到高三就好了。还有就是心理落差受不了，高三时候全省第一，她最快乐，但是上了大学感觉厉害的人太多了，就很受不了。第二类不是状元，是浙大的一个师兄，他的心态没有乐观，但也没有悲观。而是平静接受，冷静分析类。他自己自嘲自己独立能力差，是个巨婴，去美国各种不习惯，什么都等老师安排自己不会主动去办理，结果第一学期差点没毕业，自嘲自己没用，痛定思痛后就开始主动安排自己的生活，在学习时候倍感煎熬也苦中作乐自嘲找乐子。他对于新的领域和新的生活没有什么热爱和积极，但是他深知这是生活必须的一部分，所以能很好的调整心态，总结经验慢慢提高。他没有第一的架子，因为从小就没拿过第一，一直都是拿第三，自己也开玩笑说自己永远是第三，全校成绩第三，大学全国第三，去了美帝也是排名第三的学校，完全没架子。这类人，通常来说就算是人才。第三类，就是天才。极度强烈的进取心和对生活的热爱，面对挑战时的热爱和纯粹。在看这些高考赢家的文章时候，很容易就能判断出谁以后会大富大贵，谁以后估计不太好。对过往生活太多感悟，写东西鸡汤一波波的，一般成就都不太高，对过往生活也有感悟，但主要是总结方法论，精确到具体怎么做的，一般都会有比较好的成就，对过往生活基本没感悟，主要是展望未来，讲自己现在做什么，并且非常开心积极的想要尝试各种不同新鲜事物的人，一般来说成就极大。基本上，我看完了这么多书，感觉所谓的智商也好，毅力也罢，到了一定高度后，决定成就的基本就是心态和性格了。而且不仅仅是高考状元如此，普通人更如此。举个例子，我开过一期英语培训班，这个训练营是按照级别和难度划分的，慢慢升级往上走。所有学员的心态都是分成三类：1，一种是不断诉苦，看他学习你自己都觉得难受，每到一个阶段，都开始不断抱怨难度又升了，又难了，太痛苦了。2，一种是冷静分析，说难度是增加了，自己评估能接受的大概是7成左右，反思自己应该做什么事提高程度，然后有哪些缺点需要改变。3，兴奋的人，保持对新挑战的兴奋和开心。一般来说，第二种和第三种学的最好。按照金圣叹的分法，第二种就是上上之人，第三种则是天人，就是天才。如果我们的情绪和性格无法改变，那么最起码可以提高理智和分析能力，利用理智来管理好情绪，这是最重要的。希望大家尽可能成为第二种人。总是瞧不起身边人怎么办？只有能够突破环境束缚甚至改变环境的人，才能配被称为厉害的人。​​来自读者朋友“进击的玲玲子”的提问：奶爸你好，我发现我总是不自觉地瞧不起别人，认为遇到的每一个人都是不好的，有这样那样的缺点，虽然我懒得告诉别人应该怎么做，但这种心态的坏处显而易见，我总是活的很糟糕，找不到好友，没有办法被人理解，自己想做的事也缺乏毅力，总是半途而废，一事无成，成了一个眼高手低，意识清醒，成就糊涂的「废物」。想请教一下奶爸，我如何能改正这个错误，如何树立正确的观念？奶老师答：​​​​陈胜早年在家务农，讨论远大理想，别人不懂就讽刺别人，说“燕雀安知鸿鹄之志”。这种傻逼行为被我们历史书大书特书表扬赞同，导致很多底层屌丝的价值观也这个JB样。我们看看另一个底层屌丝，而且是成功者同时代的刘邦。陈胜在抱怨自己身边人没能力不能理解自己，刘邦的身边人什么情况？萧何：刘邦老乡曹参：有”萧规曹随”之称。刘邦老乡。周勃：刘邦老乡樊哙：吕后妹夫，当地杀猪的王陵：刘邦结拜大哥夏侯婴：刘邦发小任敖：刘邦同事还有更多几十个不出名的不说了。刘邦团队里最出名的是兵仙韩信，但那是后来挖角挖过来的，构成自己最核心创业资本和团队的，可能就是他家门口杀猪的这些身边人。他们能比陈胜身边人强多少？所以难道是活见鬼了，陈胜身边人不能理解他，刘邦身边人就能理解？看历史书很多就不理解，为什么伟人的身边人都是名将，都是元帅，都非常厉害。而我自己的身边都一泡污，什么也没有？别人去菜市场卖个草鞋就能碰到两个万人敌不世出的名将，为啥我不行？难道真的是因为命？长大后经历了很多事才发现，究其根本，这种现象不是环境问题：而是你自己的问题。环境很难突破，人是社交动物，群居动物，必然是经受环境的影响。比如一个宿舍里的女生全都用大牌全都酷爱攀比你想用没钱咋办，这时候有大姐大热情的招呼你，带你出去吃饭，给你介绍好心的大叔大哥哥们，慢慢的用各种高档场面腐蚀你，慢慢的你就。。。common story，都完全不新鲜了。只有能够突破环境束缚甚至改变环境的人，才能配被称为厉害的人。本质上来说，这就是个人能力的差别。厉害的人能够改变环境，领导环境，他的作用是打造团队，建设团队，以自我的能力带领身边人成长，而历史书给我们的误会就是，领导人都是哭哭啼啼的怂包窝囊废，都要靠身边人的扶持才行，当领导一点能力都不用，什么事也不用做，全是底下人做了，太爽了。可能吗？无能的人只好哀叹身边环境不行，没人理解自己，帮助自己，燕雀安知鸿鹄之志。真正厉害的人，哪怕他的身边环境彻底一泡污，完全理解不了自己，也会保持沉默，理智择友，对身边人的责怪打压讽刺一点也不急不恼，甚至都不会开口反击。他们会挑剔的择友，但对每个人都很和善，绝对不会蠢到说“燕雀安知鸿鹄之志”这种蠢话来刻意跟环境作对。年轻人现在总是说要做大事，动不动就创业新媒体高管总监赚大钱，掌握的预算都是几百万几千万，俨然就是曾经的项羽刘备，但是这么做大事的年轻人，偏偏过年回家面对身边庸俗之人的挑衅嘲讽，就沉不住气。想想当年的刘邦刘秀刘备，他们身处底层时候是怎么做的？不急不闹，微笑以对，蹭吃蹭喝安心种田上街卖草鞋，哪样都被人视为没出息，小瘪三，他们可曾因为他人的否定发过火？当你身处底层，却没有什么胸怀，连身边智力不足80的人都搞不定，都会因为这些人的言行而感染情绪，还怎么搞定你未来的大项目大工程大事业？智力相近的人总是表现一致惺惺相惜的，你因为智力不到80人的挑衅而耿耿于怀动怒，非常糟糕的暗示了你俩智商可能在同一个水平线。这才是最需要警惕的！提神醒脑，提神醒脑。。。上司要跳槽带我一起走，要不要答应？直属上司悄悄告诉我他要离职了，问我愿不愿意和他一起走，去另一个公司，带我一起去，我要不要跟随他一起跳槽？要不要跟随直属上司一起跳槽，很好判断，主要看这两方面就好了：​​​​1，上司是否符合自己的职业发展需求。我在微博上说过很多次，直属上司是我们在职场中最重要的人，他在很大程度上决定着我们能否学到东西，能否升职加薪以及工作是否痛苦等。因此遇到一位好的上司甚至比薪资和平台更重要。什么是好的上司？这个不绝对，要看下属的需求，并且上司能不能满足下属的职业发展需求。每个人的职业发展需求是不一样的，要具体问题具体分析。在新手阶段，你还是个小白，没有什么经验能力，这时候你最需要的是学到东西，有这么一位愿意教你干货的上司对你来说就是最合适的。在熟手阶段，你有了一定的经验能力还不至于独当一面，那么这时候你最需要的锻炼的机会，有这么一位上司愿意给机会，给项目，让你去历练和提升自己进而独当一面是最好的。在高手阶段了，那么你重点需要的不再是学到东西和得到锻炼的机会，而是得到资源的扶持，有这么一位给钱给资源给到位有知遇之恩的上司对你来说才是最完美的。你要看自己的职业发展处于哪个阶段，需求是什么，上司能不能满足。能满足你的职业需求的，对你来说就是好上司，不能满足的，即便他确实很好，但对你来说也不是好的上司。所以，事在人为，遇到了好的上司，这时候就一定要抱住大腿，一直跟随。而上司并不能满足你的职业发展需求，只是单纯的对你不薄，你觉得很感激，那么仍然需要三思而行。能满足你职业发展需求的上司才值得跟随。2，和上司一起跳槽的诸多好处能否吸引自己。和上司一起跳槽有诸多的好处。上司跳槽想带你走，说明上司信任你，曾经的磨合让他满意，他器重你。到了新环境中两眼一抹黑，知根知底的只有你，会更加倚重你，培训，资源，机会更加偏向于你。有了上司的依赖与依靠，你就是心腹和得力干将，跟着大哥走，有肉吃的时候肯定少不了你。而且待在原公司原岗位，也会面临巨大的风险。换了新领导，作为旧臣的自己很可能被清理，被排挤边缘化处理，无法在这个公司继续发展下去，最后很可能是被迫辞职的下场。跟随上司跳槽可以避免被新官上任清洗，无需重新磨合，无需重新获取信任，节省心力。不仅如此，跟随上司跳槽往往还能进入更好的平台得到更可观的薪资待遇。人往高处走，上司跳槽的能力肯定比自己的强，上司比自己更有能力跳槽到更好的地方，跟随上司跳槽刚好是一个抱大腿的好机会，帮助你进入依靠自己进不了的好公司得到好工作和好机会。跟随上司跳槽，既避免被原公司新上司清理，又能得到老上司的重用，进入更好的平台，收获一份更好的报酬，保留继续学习成长的机会，是一个很值得考虑的事情。综上，考虑要不要跟随上司一起跳槽，答案很明显，关键看上司能否满足自己的职业发展需求，其次再看薪资，平台和发展机会怎么样。我已经告诉了大家具体怎样判断上司是否满足自己的职业发展需求，已经很实操了，那么最后就祝大家都能遇见好上司抱好大腿，事业顺利，步步高升，升职加薪。上班要不要担心和同事不合群？上班要不要担心和同事不合群?​​​​答案是不用担心。同事关系，做到表面和谐就好了。为什么这样说呢？这背后有最为关键的三大原因：1，同事不重要，直属上司才重要。在职场上，直属上司一定是你最重要的人。懂得了这个最基本最重要的道理，大多数职场问题都迎刃而解，比如上班要不要担心和同事不合群?懂得了这个道理，至少可以推理出：直属上司的上司，大老板，不重要，县官不如县管和远香近臭而已，平级同事，也不重要，既竞争又合作，表面客气友好而已，直属上司，最重要，直接决定你的绩效考评升职加薪。如果说同事不重要，不需要合群，那同事在项目合作中不配合或者故意挖坑怎么办？如果有这样的疑问，说明你没有搞懂权力的来源。现在的企业，尤其是私企，权力结构和古代的君主专制没有区别，权力不是自下而上的，而是自上而下的。权力从来都来自于上层的授予而非下级或平级的赋予。搞懂这一点，你就应该知道：同事在项目中不合作，提醒几次没反应的话，那就不应该是和她死磕到底，而是直接打小报告给直属上司，同事在项目中挖坑的话，让人防不胜防，最好的就是时刻注意收集证据，然后抄送给直属上司。当你无论如何讨好都搞定不了同事的时候，那你就应该转变思维，借助上司的权力搞定他们。如果你真正做好了向上支持，搞好了和直属上司的关系，你大可不必合群，你完全可以“拿鸡毛当令牌”，或许他们会忌惮你，他们不喜欢你，但他们一定会配合你。既然同事能够配合你，不影响工作，那同事关系不就处的恰到好处了吗？无需上下班甚至上个厕所都腻在一起，也无需在背后大家一起说上司的坏话，而是大大方方竞争，顺顺利利的配合，各司其职专注工作，各不耽误。无需合群就能达到这样理想的状态，不用担心不合群。2，上司并不希望下属合群。职场上还有一个潜规则，上司并不希望下属太合群。下属太过合群，会威胁到上司的权力，担心下属合伙抵制或造反，工作开展不下去，被质疑管理能力，被上头问责。对此，聪明一点的上司一般会用刺激竞争或者分配不公等方式来引起下属间的内部矛盾冲突，避免大家过于合群。能力强的下属，合群反而更为危险，很容易被领导视为威胁，枪打出头鸟。既然上司不希望下属合群，那为什么还私下叫我要合群一点？我是不是应该担心和同事不够合群？当然不是。之所以叫你要合群一点，不是因为你不够合群，良好的办公室人际关系是不需要合群的，而是因为上司不喜欢你，在找茬挑刺，他才故意这样说的。如果上司的喜欢你的话，他完全不用但你不合群，凭借你与上司的关系自有人会忌惮自有人会巴结你。如果上司不喜欢你，没有上司的支撑，你再如何合群和团结也没有用，同事不见得会配合你。需要注意的是，虽然上司不希望下属太合群，但并不意味着下属间就应该形同路人，遇到问题就矛盾公开化，十分对立。而是同事间，应该表面和谐，礼貌客套，非常具有职业精神，看起来干练专业，不会因为复杂难缠的同事关系而拖泥带水。因为下属间过于对立，矛盾公开化，会产生过多鸡毛蒜皮的细节小事，上司需要被迫介于与调节，这样会导致上司的事情过多，增加管理成本和时间成本，没捡到芝麻还丢了西瓜。所以不用担心和同事不合群，但要和同事保持恰到好处的和谐关系。3，和同事合群会迷失自己，交浅言深，祸从口出。与一个人合，叫交朋友，与一群人合，叫合群，而一群人意味着消息共通情报共享，共通情报共享又意味着有间谍，有间谍意味着危险，被出卖，被暗算。可惜人就是很贱：一个人单打独斗的时候，还很精灵聪明，一旦进入一个群体，成为乌合之众，就蠢的出奇。一蠢起来，就口无遮拦，交浅言深，就被别人抓住把柄，被上司的‘间谍’打小报告。为什么很多聪明的人懂得很多道理的人仍然会吃亏？正是因为他们进入群体，脑子就不好用了，受情绪左右，忍不住干一些“出卖”自己的事情。事后看起来非常非理性，缺乏常识和逻辑。实际上合群进入这种群体后就很难控制住自己。因为大家都在八卦的时候，自己就好奇多听一点，多听一点就忍不住贡献一点话题，别人暴露一点不知真假的秘密，自己也忍不住暴露一点秘密，来来回回，暴露的所剩无几。这就是乌合之众。合群的代价不仅是牺牲个体的智慧，更多的是引来祸水，切记。职场关系的重点从来都是直属上司，不是同事，不是合群。追求合群往往只能追了一个寂寞。这样费力不讨好，没什么收益，充满风险的事情为什么要做呢？如何处理来自领导的批评？应该如何去判断和处理领导的批评？一方面我们可以从领导的角度来看，他为什么批评我们？另一方面我们可以从自己的角度，如何利益最大化的应对他们的批评，采取什么措施。综合这两个角度来看，答案就很明显了。​​​​被领导批评，最好的心态当然是探讨心理，问清楚具体哪里不好，最好有数据实例支持。为什么探讨心理才是应对领导批评时最好的心态？1，你的任何小情绪都没有用，无法解决问题，只会破坏与领导的关系。质疑上司是什么居心。你质疑有什么用吗？被批评的时候还不是得装作乖乖听着。抵触心理，干嘛不说别人只说自己。觉得不公平被针对了有什么用？针对的就是你，你能怎么办？五十步笑百步还有理了？冤枉心理，觉得自己做的够好了就不应该被批评。你觉得做得好，但领导觉得做的不好，那你做的再好也不算好，领导觉得好才是真的好。面对批评时，你抵触的情绪没什么用，你又改变不了什么。你越抵触越觉得自己不该被批评，怪上司不懂你，那才是大错特错。职场上，领导从来就不会懂你和在意你。领导只在意两点：你能不能过做好向上支持，满足他的需求。他怎么去换位思考他的领导，向上支持好他的领导。从来不应该也不需要更不会考虑你的情绪和需求。因为你是拿人钱财替人消灾的，被吩咐办事，被骂，这本身就是工作的一部分。领导不懂你是常态，懂你，那才是变态。不要拿完美领导的要求来要求自己的领导，否则只会与领导愈加的对立。一对立，就容易自我中心，否定他人，无法做到换位思考。换位思考是做好向上支持的关键，无法换位思考，就无法理解领导，一直觉得领导是傻逼，又自私，愚蠢，狭隘，斤斤计较和偏心，心里总嘀咕着，为什么要这么做，为什么要批评我。这样是没法配合好领导的，自然领导会越来越骂你，长此以往形成一个不好的负循环。2，明白领导的批评有没有道理，能够帮助化解情绪，专注于解决问题。为什么被批评的时候尽可能的让领导拿出数据和实例？是因为数据和实例可以帮助我们区分领导的批评有没有道理。知道这一点才好有则改之无则加勉。可见这两位网友和大部分人，职场能力都有问题，他们未来能在职场中走多远，非常不乐观。只知道骂人，也不说哪里不对，没有例子和数据，那批评你就是在发泄情绪，没有道理。既然没有道理，那也不用反思自己哪里做的不对，不用怀疑自己的人生。而是去化解领导的情绪，要么顺着领导的话说，你说的是，这里确实我做的不好，你都这么耐心，讲过很多次了，这点小事我都出错了，责任在我，谢谢你的指导。要么就乖乖的听着，然后点点头说是是是。然后把他的话当放屁，左耳朵进右耳朵出就是了。如果领导能举出实例和数据，无论骂的再难听，都是有道理的，这时候一定要认真听。认真承认自己的错误，拿小本本记着，哪件事情没做好，哪个小细节出了问题，领导给了什么建议，一定要记得清清楚楚。这就不是在发泄情绪，而是踏踏实实的解决问题。同样不能要求领导心平气和很有耐心的批评你，还详细的指导你去怎么做。因为工作很烦躁，事情很杂乱，时间很紧张，压力也很大，一个人苦忙累大半天甚至一天了，仍然要被迫继续集中注意力工作，不可能没有脾气的，不可能心情会好的，越是责任重大背着全团队全部门kpi的领导越是如此。这一点就是作为下属需要换位思考的地方。学会去理解领导的情绪，学会对事不对人。批评你，不是因为你人不好，而是因为你事没办好。哪怕表面上批评的是你人不好，实际上也只是事情没做好。学会理解领导不是圣人，也就只是更高级一点的打工人，他们也是有情绪的，他们不懂如何恰到好处的批评人，所以批评你的时候给指导给干货的时候会带着情绪骂你不行。而你，抓住干货，紧盯怎么解决问题就好了，对情绪无需在意。所以，以后被领导批评了怎么办？探讨心理，让拿实例和讲数据，理解领导，化解怨恨情绪，对事不对人，专注于解决问题。对事不对人是基本的职业素养，希望大家都能养成，稳定情绪，职场顺利。如何有效提高英语写作能力？内容很容易培养，成年人的逻辑和思想都比较成熟，不存在三年级小学生憋不出话的情况。​​奶爸您好，我想请教您英语写作方面的问题。我是大三英专生，感觉学校里的写作课很鸡肋。老师是在我们这成家的美国外教，一个学期感觉教的东西就是标点、词汇和文章格式，他要求我们记叙文必须分成三段写，议论文必须分成五段，每一段有固定的内容，多一段少一段都不行。虽然平时有布置作业，但我真没觉得一个学期下来写作进步了多少。我打算明年申请一个海外运营的实习生，要求用英语写音乐推送相关的文案，我自己认为写作和语法造句很相关，所以买了剑桥中级语法和旋元佑老师的《语法俱乐部》，还买了奶爸的语法课，已经看了一半了。想请问奶爸还有没有什么其他建议或者更好的练习方法？非常感谢奶爸回答！奶老师答：​​​​这位宝贝你好，你说的很对，老外来教你写作确实没什么用。如果让你教我们这的一个成年人写作，你会怎么教？就是让他多读，然后注意文笔，是吧。我们回想一下，一二年级，语文老师教我们写作，用的什么方法？是近义词，成语，造句，等等。我们这的人缺的不是什么标点，格式，而是欧美一二年级的基础训练。这种基础训练才是最缺乏的。这里说一下，绝大部分我们这的人这辈子都不需要考GRE，不需要读书留学，只需要上班交流，写写邮件报告外加偶尔旅游就好，所以本文的方法不适合你，别瞎浪费时间。基础训练分成两个部分：一个叫style，这个我们这的人叫文笔，一个是条理，这个我们这的人叫内容。内容很容易培养，成年人的逻辑和思想都比较成熟，不存在三年级小学生憋不出话的情况。style这块就很难，因为老外理解的style是标点、词汇和文章格式，但是我们这的人最缺的style是：表达法，句式，节奏。节奏这玩意儿太玄乎，我们就不说了。只说表达法和句式。看懂文章不难，写出那样精妙的句子，用出那种高级表达，才难。所以最好的方法是什么？1，系统学一套语法教程，我的就不错，2，回译法。把新概念英语3抽出来，找出一篇文章，先翻译成中文，然后再看着中文翻译成英文，然后把自己写的英文和原文对比，看出什么差异，然后做笔记。平时就复习笔记。一天一篇，过了一个月，完成了30篇后，再进行复习，就是除了每天回译新闻纸，还要从第一篇开始，回译旧文章，然后再改，再补充笔记。把第三册彻底搞定，写作就没什么问题了。如果觉得不够，把第四册也这么搞定。新东方有个段子，说背熟新概念英语3和4，写作感动哭美国教授，这是纯扯淡。我这个方法，就不是被动的背诵和吸收，而是主动的对比和学习，主动当然比被动好，但即便如此，也不能让你的写作感动哭美国教授。但是采用这个方法后，你的写作用词造句水平，大约能赶得上是美国小学毕业，也就是说style初步形成，能够感受到语言文字之美，并且能够看出文章里哪些词用的好，好在什么地方，对文本的吸收和记忆力大幅度提高。对于你的一生来说，够用了，如果还想深造，就得学习经典名家作品，比如奥威尔，丘吉尔，罗素等人的作品——新概念4好就好在这个地方，它收录了罗素的文章，其他类似的短文水平也很高，我当时看到还是很惊讶的，有点吃惊，没想到亚历山大看文章的水平如此之高。这里顺带普及几个常识：1，经济学人之类的玩意儿，普通人没有看的必要，因为没有经过我上面说的基础，你看了也不懂好在什么地方，吸收不了什么东西，牛嚼牡丹，猪八戒吃人参果，纯属浪费时间，不如回家睡大觉。2，传统的文学名著可以看，但就看个热闹，别指望学东西。以《了不起的盖茨比》为分界线，它的伟大不在于开创，而在于终结，之后很少有作家用这个风格写作了，反而是同时代的海明威开创的风格，统治了世界到现在，也就是所谓的简洁。更早前莫比迪克那种用200-300个词，只写一个句子的超级华丽的技巧，现在作家基本不用了，很多作家也掌握不了这种技巧。3，托福雅思写作高分不算厉害，连写作的门都没入，甚至达不到美国人小学毕业水平。知乎曾经有一堆小朋友，仗着自己托福写作高分，拿奥威尔和罗素比较，说钱钟书的英文不好，诘屈聱牙。我给美国的文学系高材生看了之后，他表示钱钟书不是个英语学习者，而是英语文学创作者，风格非常华丽，走的就是早期的华丽和繁复风格，只是风格过时了，但英语学习者拍马也赶不上。4，写作用词最好的参考是特稿写作，比如纽约客的来信，欧逸文，何伟等几个作家水平高超，比看文学小说帮助大。5，如何教写作？把奥威尔或者海明威或者特稿的句子抽出来，长句子老师切割成完整的短句。然后给出一个主句作为提示，让学生练习把这些句子组合成一个完整的长句。这是最好的方法，也是我们大学外教对我们最好的教导，我练了好几百句，回想起来都不寒而栗。。。前同事问自己的下家，要不要告诉他？去办公室向老板提辞职，同意离职后，顺带问了一句，你是不是找好了下家，是哪家公司？工作交接的差不多了，临别之际，同事微信上不舍得的随口问了一下，你跳槽的是哪家公司？已经离职好久了，突然一天收到了前同事莫名的主动关心，一顿嘘寒问暖之后，说，XXX，可不可以告诉我你的下家啊，你在那边过得怎么样？这时候，我们要不要说实话实说，告诉自己的下家？毕竟曾经同事一场。当然不要，评论区的读者朋友都很聪明，说出了各自的理由。总结起来就是一句话，百害而无一利。对于这个问题，我们不能止步于此，我们还要来详细的分析，这样才好举一反三，而不是每次都个个击破。因此我们需要思考以下问题：1，为什么老板和前同事要打听我们的下家？​​​​对于老板来说，他们想知道的是：你去的公司是不是竞争对手的，你去的公司各方面的条件怎么样，是不是比自己这边好太多，是不是自己这边不够好，你去的公司自己认不认识相关的人，看看能不能帮你或搞你。同事打听下家，了解我们的情况，也有这么几个原因：单纯的很好奇，担心你比他过得好，想跳槽，伺机报复等等。那么基于以上的几个原因，我们要不要老实的告诉他们？当然是不要，因为百害而无一利，多一事不如少一事。2，为什么说老板同事得知我们的下家，只会百害而无一利？因为没有人会因为你的好消息而发自内心的开心，只会有人为你的不幸而暗自喜悦。你的下家如果条件很好的话，很可能会遭到许多前同事的羡慕嫉妒恨。一旦你告诉了一个前同事，意味着几乎所有的人都会知道。不仅得罪人，而且别人很容易从中作梗。老板知道你的下家，有很多方法可以搅黄你的新工作：直接开除你让你留下不良记录，拖满30天交接让你没法入职，打个电话过去造谣诋毁你让你失去offer，找关系让你过不了试用期等等。同事知道你的下家，搞你也很方便：举报说你去了竞争对手的公司让你支付巨额赔偿，在前公司散播你下家的消息让前领导讨厌你，收集你在前司的各种把柄证据举报到你的下家整你等等。除了容易被人暗算以外，还很尴尬的是，所有人都知道你拿到了一个很好的offer，即将去很好的公司，但万一这个到嘴的肥肉跑了，到时候又该怎么办？以防万一，最好还是不要告诉别人自己下家的情况。3，别人问到，应该如何回应？被老板和同事问到下家情况很常见。在线上被问到可以不理，装忙，在线下被问到，就打哈哈过去：自己先休息一段时间，可能去旅游，回趟老家，生个娃，暂时没有工作的打算，还在努力找工作中，一个都不理想，手里拿到多个offer，犹豫不决，暂时还不知道。总之，在没转正之前，能不说就不说，实在被问到，也不要告诉具体情况。为什么领导不喜欢提拔老实人？升职有一个前提条件，那就是得有空缺。空缺出现了，我们经常能看到，领导往往提拔的一些爱吹嘘拍马屁的人。老实人很不受待见。为什么领导不喜欢提拔老实人？难道真的是因为这些领导鬼迷心窍爱听谗言中毒太深吗？其实不是。主要原因有以下三点：1，老实人缺乏汇报，领导不知道他的价值。​​​​大多时候，领导提拔下属，其实对下属的要求并不高，毕竟个个都是“歪瓜裂枣”，但又得提拔一个，那就只能提拔自己最亲近最了解的那一个。最亲近最了解的那一个，是谁都不会是老实人。因为老实人缺乏汇报。汇报得少，和领导沟通交流接触的少，那领导就不知道你的工作量，更不知道你做出的努力，贡献和价值。那更别说亲近了解了。你做了什么做得怎么样很多时候不重要。重要的是你要展现给领导看。领导觉得你怎么样比实际上你是什么样要更重要。付出了太多，老实低调，不被看到，你再怎么自我感动也没有用。老实人之所以汇报少，不擅长汇报，不得不汇报的时候才汇报，就是因为不懂这个道理。领导不是不想提拔认真做事的人，而是老实人不主动展现自己的价值，领导压根看不到。领导只能看到那些经常向他汇报，提问和请示的人，经常与他们沟通，对他们更亲近了解，因而提拔他们，忽视老实人。2，老实人无法把握好利益和人性，管理不了其他人。老实人之所以被贴上老实人的标签，主要是他们的思维太过简单且不够灵活。往往不善人际关系，缺乏人情世故的智慧，不懂表达，不会拒绝，好欺负。最关键的是，他们看不懂利益复杂的局面，往往身在局中不知局。这样的人，是不适合做管理，去做别人领导的。什么样的人适合做领导？能够表里不一会套话的，能够恰到好处画大饼的，能够抓住别人利益，能够平衡各方势力，有一定手段且足够心狠的人，才适合做别人的领导。管理它不是简单的分配工作，更多的是管理人性，进行利益的博弈。而这正是老实人最缺乏最惧怕和担心的地方，他们难以胜任。因此，对于领导来说，与其提拔一个勉强会干事的老实人，不如提拔一个不太会干事但却懂得管理的人，后者要靠谱很多。3，老实人适合做苦活累活，少了他不行。一旦被贴上老实人的标签，就很难拽下来，随之就有无穷无尽的苦活累活不请自来。因为老实人不爱邀功，更不爱拒绝，是典型的好欺负。所以老实人在团队里的价值就类似沙僧，任劳任怨苦活累活全干了，能够很好的减轻整个团队的负担，这就是他们在团队中的最大作用。如果这样一个人去当了领导，那这些苦活累活又交给谁干呢？没人了。本来老实人就不适合被提拔，那不如好好让他干苦活累活，减轻大家的负担，让更有能力的人轻松一点，岂不是更好吗？也因此，老实人总是陷入死循环，越努力，越没有提拔的希望，大家都指望着白嫖帮自己做事，领导提拔不了。如果你中了其中的一点，要多注意，但不要随意代入。可以多反省，但不要给自己贴老实人的标签，好好克服改过就好。祝愿大家的努力都能被看到，祝愿大家都能顺利升职加薪，加油~工作没干多久，可不可以跳槽？​​现在是金三银四求职的好时候，随之微博后台也收到很多读者朋友的来信，问工作没干多久，要不要跳槽？要不要跳槽没法解答，这是一个见仁见智的问题。而能不能跳槽却是一个实实在在的能力问题。只要你能拿到新offer，公司要你，那你没待多久就不是问题。而你拿不到offer，待多久都是问题。在一家公司待的时间只是招聘的一个考虑点而已，需要综合分析，没必要一杆子打死。那么在金三银四的这个时候，想要跳槽该怎么办呢？1，不要裸辞，先拿到多个offer。说过很多遍了，不要裸辞。裸辞了就没有退路，以及裸辞之后更难找到好工作。为什么？现在的工作就是跳槽时候谈薪的筹码，裸辞没有了筹码，谈薪的时候就会处于弱势。​​​​因为人事经理默认有工作的人会比没工作的人更有价值。骑驴找马跳槽的人往往能够获得更高的薪资。不仅不要裸辞，而且要多拿几个offer才行。只拿一个offer，你会觉得没有退路，没选择，只能去这个垃圾公司，反而更不敢跳槽。觉得自己没什么能力，觉得自己很垃圾，找不到什么好工作，很焦虑。然而再坚持一下，多投几个岗位，认真写下简历，拿到了多个offer，你就会完全不一样。相反，你会觉得自己真牛逼，原来还可以找到这么好的工作。最重要的是，这多个offer的薪资条件可能差距非常大，一个offer可能比另一个offer要多几k甚至几十k，更好的offer遇到就是赚到。至于一个offer都拿不到，那就老老实实的呆着，该有点自知之明了。2，请假或周六去面试。既然是骑驴找马，那就得悄悄的去面试。但工作日上班，没空去面试怎么办？能调休就调休去。优先请年假事假然后是病假。请假的时间要集中。实在请不了假，可与hr协商能否下班后以及周六日去面试。实在没空，可以保持更新简历，断断续续的骑驴找马。3， 时间干的太短，离职原因要学会避重就轻的回答。你为什么从上一家公司离职？你在上一家工作没有干多久啊？这两个问题主要考验你的忠诚和稳定性。忠诚本质上也就是稳定性。你只需要针对稳定性来避重就轻的回答就好。一方面你要表达前公司上司同事都好，但是因为一些客观原因，导致没法干下去。比如：位置偏僻，附近没吃的，上班路程时间太长，工作太闲，缺乏挑战性等等。另一方面你要表达当前公司有多吸引你，你是为它而来的。这和之前回答“你的职业规划是什么”的逻辑是一样的。需要做好充足的准备：搜行业情况，行业主要分布哪些城市，龙头公司有哪些，竞争公司有哪些？搜公司情况，了解公司的品牌形象，规模，组织架构，产品，竞品与业务，客户群体怎么样？研究JD，汇报线是怎样？晋升发展怎么样？具体工作职责，流程，要求是什么？然后这样回答：咱们公司在行业中，和其他竞争公司比起来，有以下XXX优势特点，尤其是业务方面有XXX优势，所以很吸引我。咱们公司该岗位的工作流程中，哪一XXX部分我很擅长，哪一XXX部分我很感兴趣，所以想来咱们公司。咱们公司是大\\中\\小公司，相比以前的大\\中\\小的公司，我觉得咱们的公司有更好的XXXX，所以喜欢咱们公司。方法教程就说到这里了。不鼓励无脑跳槽，但996身体出问题了确实应该考虑。跳槽因人而异，需具体问题具体分析，请结合实际情况来处理。希望大家都能找到心仪的工作，保重身体。公司里发的调查问卷可否照实写？理论上是匿名，但实际上不是，具体的逻辑，这次来给大家做一篇详细的解析。1，为什么学校公司喜欢使用匿名问卷？学校和公司必须要有民主的渠道，至少表面上是。否则就成了权力人物的一言堂了，虽然事实上就是这样。需要这么一个民主的形式存在，方便占据道德高地，方便获得大家的支持，方便甩锅大众。比如：避免有人不满问题升级，但不想改变怎么办？搞个匿名投票，宣称大家有意见可以反馈，不反馈就是没意见。上司想提拔自己手下，但是不服人心怎么办？搞个匿名投票，宣称是大家都支持他，所以他才获得这个机会的。​​​​想让某员工走人，但理屈辞穷怎么办？搞个匿名投票，宣称是大家都认为他有问题，所以才降薪裁员的。所以，匿名投票只是为了走个形式罢了，不是真正的让你去做评价，领导，大老板，上司们早有定论。即便评价了，也不会认真听，认真听了，也不会改，不起作用。而且说错了话，还得罪人。因为，匿名问卷，本质上都是不匿名的。2，为什么学校公司里的匿名问卷本质上是不匿名的？所谓的匿名问卷，只是对被调查者匿名，而不是对调查对象和老板匿名。一般统计人员和老板都是能直接看到调查结果的，具体是谁发表了对谁的什么评价。网络问卷上可以搜集到详细的个人信息，你以为匿名，实际上你的其他信息早就暴露了你是谁。而投票信箱也很可能安装了摄像头，是谁举报谁投诉一清二楚。往往老板还会把这个调查结果反馈给当事人，指出谁谁谁对你有意见，你要不要去处理一下。即便老板没有点名，当事人不知道详情，实际上办公室就那么几个人，谁打得的差评，自己得了低绩效该归功于谁，谁给自己使的绊子，也都能猜到。所以匿名问卷本质上是不匿名的。3，面对匿名问卷应该怎么办？匿名评价要说好话，不说坏话。不要试图通过匿名问卷来举报谁投诉谁拉谁下水，前面说过，没有用的。说坏话还得罪人，背地里搞人比公开对着干可耻多了。相反，说好话，反而可能会有奇效。匿名评价暗地里都是会公开的，当事人知道你背后说好话，比你当场拍马屁的效果强多了。至于具体怎么说好话，得看人。对直属上司的评价，得咬死，都夸好，毕竟一荣俱荣一损俱损。用STAR法讲述，具体哪件事，他给了什么指导，起到了什么作用，并因此做出了什么贡献，所以觉得他非常好。对同事的评价，要笼统客套，因为你不确定上司或者大老板对这个同事的态度。万一他们想搞这个同事。夸具体夸好了可能得罪上司，夸差了觉得你人品也不行，要夸得一般般好，只说些不痛不痒的优点是最好的。说上司的好话要用STAR，说同事的好话要笼统客套，不说任何人的坏话，这才能明哲保身。总结起来就是，匿名问卷主要是个形式，别当真，只说好话，谨慎评价。希望大家都能安全避坑，少点挫折，事业顺利，步步高升。为什么记者随便卧底都能轻松当副总？为什么记者这么轻松就可以升副总，我们普通人想升职加薪就这么困难，费了老命？今天这篇文章就来聊聊这个问题。视频里说他去4S店里卧底调查，查了一年多，一个不小心就当上了这家店的二把手，工资是当记者的十几倍了。这就让人觉得很奇怪，为什么他随便瞎干干都能升职，而我怎么做都很难？1，择业种类问题。销售最容易出成绩，只要努力干，业绩往上叠，就一定能升职。你做个HR，行政，甚至市场之类的文职，不管你怎么努力，短期一两年内都看不到什么成绩，都不太容易有什么出彩的表现，自然就升不了职。2，降维打击。记者一般都是文化人干的工作，都有本科学历。而4S店的销售，能找到一个本科学历的，很少。很多学历高的人，干底层销售职位，不容易干好，不是因为他们不擅长。而是因为干的时间不够久，没有投入心思去研究和琢磨。只要愿意放下面子和身价，像研究高考题一样研究基层的基础工作。有考上大学的智商，很容易就把这份工作做的好。3，吃苦耐劳。这个品质大部分人都认为自己有，但实际上没有。或者说他们有，但他们没想清楚吃苦耐劳到底是怎么回事。而记者要打入敌人内部，他就必须有，必须时刻表现的忠厚老实，让人信赖。但这一条一定要和择业种类，老板种类结合在一起。记者吃苦耐劳，能升职。你吃苦耐劳，就不一定升职。为什么？kpi的侧重问题。现在的公司为了方便管理，所有的职位都有指标。但大部分指标都只是为了让你工作有事做，不闲着。并不是为了让你升职加薪。只有一个岗位是例外的。就是业务型岗位。业务型岗位不遵循职场常识：​​​​上头有空缺才能让你升，没空缺你再厉害也得等。比如HR行政，你做的再好，没空缺就是没空缺。大家在办公室做普通文员，可以体会一下。销售不一样。底层销售的业绩足够好足够厉害，上头没空缺也简单。把上头业绩不好的干掉，让你上来就行。老板的思维就是这么简单粗暴。你不需要等空缺，只需要不断努力的干，干的越多越好。不需要去混，去研究什么办公室智慧，做人常识之类的东西。而代价就是压力巨大，指标加多，不断升级。所以做业务岗位，正确的智慧是：在你没有升职之前，不要比常人多很多，多一点点就行。多一点，保证完成升职的目标，然后再去提升业绩。如果没升职，下个月给你的指标会越来越高，直到把你压垮为止。销售岗尚且如此。其它岗位就是这样了。你做的多，下个月指标和压力就会更多，而且你不是业务岗，所以都是些没屁用的事情。最后的一点，也是最重要的一点：干的好不如说的好。记者的表达能力一般都要远好于常人。不论是文书写作，销售话术，还是口头表达，工作汇报。都是明显脱颖而出的。这样的人，老板是最喜欢的。因为他见多识广，足智多谋，是个好智囊。业绩好，还吃苦耐劳。不提拔他提拔谁？所以我们职场方法论的口号，一直都是呼吁大家：不要单纯的拍马屁，而是做一个智囊型的人才！多读书，多输入，在业绩亮眼的同时擅长表达。足智多谋。办公室恋情有哪些危害？看了大家的投票情况，发现大家对办公室恋爱这件事还不够敏感，存在许多认知误区。到底能不能搞办公室恋情？答案是，绝对不可以，不论哪种环境。因为办公室恋爱实在有太多的危害，弊大于利。第一，损害公司利益，失去职业发展。公司招人进来是干活的，不是来谈恋爱的。带薪谈恋爱，和故意摸鱼划水是一个道理，损害公司的利益。区别在于，摸鱼划水是可以悄悄的没人故意举报就不会被发现的，而办公室恋情的消息则很难隐瞒，稍微眼神不对劲，动作稍微亲密一点就会被发现，八卦消息满天飞。给老板留下一心二用，工作不认真，不专注，不可靠，难当大任的印象。存在同级竞争的情况下，很难再获得晋升的机会。第二，破坏人际关系。​​​​办公室恋情，一般年龄不会相差太大。年龄不会相差太大，就容易对异性同事心生情愫。条件差的，大家都看不上，条件好的，大家都喜欢，免不了大家都喜欢同样几个人，成为情敌。大家都暗恋的一个漂亮女同事男帅哥，却成为了你的男女朋友，会招致嫉妒。如果上司对你的男女朋友有意思，那更破坏上下级关系。本无罪，怀璧其罪。和平级谈恋爱，会招致嫉妒。那么和上下级谈恋爱，往往会被质疑权色交易有所偏心。对上无法解释清楚获得信任，对平充满议论猜忌流言四起，对下无法管理下属影响工作。办公室恋情，严重影响职场人际关系。实际上，职场上的利益牵扯本身就会损害恋爱关系。到头来可能得不偿失一无所有。第三，分手后不好处理。和气的分手：抬头不见低头见，看着心里膈应，难免会带有情绪影响工作怎么办？如何面对大家的八卦评论和打探？遇到竞争，怎么放开来抢夺资源和机会？撕破脸的分手：如果对方在办公室一哭二闹要上吊，爆料丑闻，散播谣言报复你怎么办?被知根知底的前任转手给卖了怎么办？工作交接中总是被对方找茬怎么办？这些问题都很棘手，处理不好，很可能就会在公司无地自容，不得不走人，失去一个良好的工作机会。机会就那么几次，因为恋爱而断送事业前程是不值得的。Don’t shit where you eat，在讲利益的地方牵扯感情就真的很麻烦复杂了。对大家都不好。体制内，或者医生和老师有不少是互相结对的，因为办公室环境的特殊性，所以比别的工作要稳定点，但原则上即便是教师医生，我们原则上也不推荐搞办公室恋情。所以无论什么企业文化，无论体制内外，都不要搞办公室恋情。否则，只能后果自负，挨一顿社会的毒打就知道了。希望大家都能处理好和同事的关系，不搞办公室恋情，专注做好自己的事业工作，加油~职场菜鸟最严重的问题是缺少向上沟通上司不了解你，谁又知道你是在摸鱼还是在干事呢？谁又知道是你为项目做出了主要贡献呢？​​刚毕业的新人刚进入职场，把工作做好，一般都会想起一句话“凡事有交代，件件有着落，事事有回音”，能做到这样才算靠谱。但是具体如何做到交代、着落和回音呢？这并不简单，尤其是对新人来说。贯穿“凡事有交代，件件有着落，事事有回音”的主要是沟通。与直属上司的沟通，无非就三大件：提问、请示和汇报。看起来是不是很简单？简单就错了。难度不在意识方法上，而在心理情绪上。第一，缺乏向上沟通，是职场新人最严重的问题。职场新人的最大问题在于，情绪上畏惧领导，缺乏向上沟通。新人怕领导，总觉伴君如伴虎，万一说错话了怎么办？担心给领导留下不好的印象。问太多会不会显得我蠢？请示汇报太多会不显得我烦人？一旦领导的脸色不好，更是恐慌，就会一顿脑补——我会不会过不了试用期？我是不是做的不好？会不会挨骂？因而尽可能的避免沟通交涉，能不问的就不问，能不请示的就不请示，能不汇报的就不汇报。哪怕有不清楚的必须要问清楚，遇到问题必须要请示汇报的，心里都挣扎很久，就像看完鬼片不到尿憋不住的时候不愿上厕所一样。新人和上司沟通，像和老虎谈判，担心分分钟可能被吃了似的，充满恐惧。但这样是不行的。1，因畏惧情绪而导致缺少沟通，会导致工作诸多问题：提问少了，新人不懂装懂，导致没搞清楚领导的需求就瞎捉摸乱行动白忙一场；请示少了，新人自作主张，导致不知领导意见自作聪明处理失误造成巨大损失；汇报少了，新人隐藏瞒报，导致交代的事情没有反馈没有进度领导两眼一抹黑。沟通少了，就无法把事情做好，就不可能凡事有交代，件件有着落，事事有回音。2，领导最讨厌缺乏主动沟通的下属：​​​​每次都要填鸭式培养下属，不懂主动提问和思考，每次都要提前说明划清职责边界，不懂主动请示情况，每次都要主动问进展和结果，不懂主动反馈。沟通少了，就无法与上司协作，得不到上司的支持。第二，向上沟通，是为了被上司看见。想要凡事有交代，件件有着落，事事有回音，得到上司支持，就必须克服与上司的沟通问题。多问多请示多汇报，不仅是为了把事情做好，更多的还是表现自己。你做得好，不重要，领导觉得你做得好才重要，你做得好不是真的好，领导觉得你做得好才是真的好，领导对你的评价，比你的实际贡献要更重要。通过提问、请示和汇报，正是让领导了解你贡献、努力、辛苦和结果的主要途径。多提问，领导觉得你在主动思考好学，值得培养，多请示，领导觉得你尊重他的权威，分得清孰轻孰重，多汇报，领导觉得你在推进任务有贡献，做事靠谱。即便有些工作不需要太多提问请示和汇报，但为了让领导了解你，增加职场可见度，知道你做了什么，结果怎样，也可以多沟通。否则不了解你，谁又知道你是在摸鱼还是在干事呢？谁又知道是你为项目做出了主要贡献呢？多主动沟通，让你的努力看得见，增加职场可见度，是获得领导良好评价的关键。第三，向上沟通要注意方法技巧。多问多请示汇报不是让你一股脑的体现在“多”上，也要掌握方法和技巧。提问之前，起码要先有自己的思考，查过资料调过研，提问足够清晰和具体，能够举出实例，请示之前，起码看看流程和先例，看看事情大小，看看上司是否方便，要准备好AB两套方案，汇报之前，起码做好相关资料准备和结果展示，结论先行，甚至做好逐字稿，详略得当突出重点，然后再根据上司的工作风格，性格特点，脾气情绪，进行相应的调整。做好准备，主动沟通，才是职场新人获得上司良好印象的关键。至于“凡事有交代，件件有着落，事事有回音”，已经不重要，只要你做好了提问请示和汇报，那做事自然靠谱，事情自然有交代着落和回音。职场新人只要能够处理好沟通问题，工作能力就已经超过同龄人一大截了。希望各位刚进入职场不久的读者朋友，都能做好向上沟通，获得领导的支持和信赖。面试时被问到职业规划，应该如何回答？这个问题大家都答对了，但很多读者朋友要求出一期解析，所以今天就来详细的讲讲。职业规划问题，几乎是所有应届生都会被问到的一道面试题。问你的职业规划是什么，实际上并不是问你什么时候干到什么职位。他们想知道的是，你的规划和公司的发展是否一致，你能否为公司带来好处。所以，要出这道题来考察你。那面试官主要是想考察我们什么呢？第一，你的稳定性强不强。之所以必须问应届生这道题，是因为应届生或职场新人，他们毕业后的前几份工作都不大稳定。容易存在裸辞，跳槽，转行，考公考研，变换城市等不稳定的情况。​​​​公司是不愿招聘不够稳定的员工的。通过问你的职业规划，想要知道你是否稳定，打算在公司长期干下去。表现出迷茫，对未来没清晰打算，会怀疑你大概率会跳槽和转行；表现出对学历的不满，会怀疑你有升学的欲望；表现出对城市的讨厌，会怀疑你有换城市的打算，诸如此类，等等。一旦发现不稳定信号，直接pass掉。所以，在面试中，尽量避免发出类似裸辞，跳槽，转行，考公考研等不稳定的信号。第二，你的意愿强不强。意愿这东西，面试官很明白，不是看你怎么说，而是看你怎么做。他们不会相信你背的一些模板和客套话，而是通过你说的话，看你做出了哪些行动。面试官问职业规划问题，真的是想了解你什么？他们想知道，如果你得到这份工作，工作思路如何，打算怎么干。可是，如果你本身不了解这份工作，不知道岗位职责，不知道流程步骤，你是回答不出他们想要的答案的。想要回答的让他们满意，就需要做好基本的搜索和调研。搜什么？搜行业情况，行业主要分布哪些城市，龙头公司有哪些，竞争公司有哪些？搜公司情况，了解公司的品牌形象，规模，组织架构，产品，竞品与业务，客户群体怎么样？研究JD，汇报线是怎样？晋升发展怎么样？具体工作职责，流程，要求是什么？了解清楚这些，但凡有过相关的实习经历，就知道工作思路如何，打算怎么干。你做的搜索和调研，才能反映处你的真实意愿。这样才能在一批候选人中脱颖而出。第三，你的个人素质怎么样。职业规划问题，主要考察方向一致、稳定和意愿，但也能变相的考察出应试者的基本素质。1，对行业，公司和JD做了基本的搜索，分析和调研，至少能反应出：搜索、调查、分析能力强；拥有积极主动的良好习惯；做事情比较用心。2，回答得到这份工作后的思路，打算怎么干，至少能反应：1，设置目标的能力怎么样，2，规划任务的能力怎么样，2，推理预测能力怎么样。这些都是面试官非常在意的个人素质，有助于给面试官带来良好的印象。知道了职业规划问题主要考察什么，也就知道如何避重就轻有侧重的回答问题了。希望大家都能在面试中所向披靡，拿到心仪的offer。在办公室要不要帮人背黑锅？同事的锅，要么是看你好欺负推卸责任，要么是有针对性的公报私仇，每个锅都是想搞你。​​职场是一个小江湖，是最典型的利益场，利益关系错综复杂。作为打工人的我们，特别还是个菜鸟的时候，经常会感觉自己看不清职场人际关系迷雾背后的复杂利益算计。尤其在甩锅与背锅这一方面，我们比较担心。有的人背黑锅会成为领导嫡系，被人罩着。有的人背黑锅会成为「窦娥冤」，被人诬陷。对此，我们都会有一个疑问，在职场上要不要帮别人背黑锅？我们以前说过，处理职场上的人际关系问题，主要分为三个步骤，识别，处理和改善。识别很简单，涉及利益计算，大都可以用博弈论和经济学来分析问题。在职场上要不要背黑锅，从经济学角度看，关键是看成本，收益和风险。一句话，就是值不值得。如何识别值不值得呢？第一，要看为谁背锅。为谁背锅，决定了你收益的大小。​​​​1，为上司背，要看上司的人品。最基本的，上司的人品必须过关，不能是卸磨杀驴无情无义不给回报的上司。一般人品没问题的上司，你帮忙背了锅，会促进上司和你的关系，甚至成为领导的嫡系，背锅就成了职场进步的阶梯。而人品有问题自私自利只顾自己的上司，你帮忙背的任何锅都可能是定时炸弹，不仅无法兑现承诺，还会留下把柄，到最后连怎么死的都不知道。只要上司人品不好，背任何锅都毫无必要。2，为同事背，不值得。同事的锅，要么是看你好欺负推卸责任，要么是有针对性的公报私仇，每个锅都是想搞你。表面客套而又互相提防的同事关系，很难有基于利益合作的背锅。不做圣母，保护自己更为重要，同事的锅，一律不背。3，为下属背，可以但不必要。下属做错事情了，上司帮忙背，不仅可以笼络下属人心，还可以在上司面前展现自己的担当。不过，这都建立在无关痛痒的小错上，不会动摇影响到自己地位的基础上，不是所有的锅都应该背。第二，要看背什么锅。背什么锅，决定了你的成本和风险。1，断送事业前途和影响工作开展的锅不背。违法的，突破原则性的，做替死鬼的锅，一律不背。贪污、挪用公款，吃回扣，偷工减料等锅就不用说了吧，会断送自己的前程，死的很惨。不仅不要背，平时还应当保留证据，注意被别人栽赃扣锅。得罪周边人而导致工作瘫痪无法推进的锅，不要背。尤其是PM不要随意接锅，容易搞得里外不是人，在接锅前，先考虑下受影响的相关人有哪些，得罪后，工作和项目还能不能推进下去。2，帮上司争取利益和做挡箭牌转嫁尴尬的锅要主动背。各个部门争取预算，你出来做得罪人的那个人，说难听话据理力争毫不示弱，再让上司客客气气的来打圆场，这种锅主动背。上司遭遇跨部门同事的刁难，或因为小事情而遭遇大老板的批评，这种锅，主动背，你出来道歉认错——都是我的问题，我自作主张，把上司蒙在鼓里，都怪我，下次不敢了。上司当面不方便直接说的难听话，拒绝的话，你来说，一般都是一些小事，这种锅，主动背，让上司扮演好人，自己做坏人，避免上司尴尬。3，上司和你提前商量好的锅，可以背。上司让你背锅提前和你商量，说明上司人品不差，说明这个锅基本是你承担得起的，不是什么大事，通常可以背。实际上，这类锅，你背也得背，不背也得背，区别也只在于一个态度。主动接了，还可能有获得回报和感激。拒绝接了，表明你不是上司的人，以后可能会被穿小鞋或者边缘化处理。因为可以商量的锅，都不是大锅。如果是断送你前程甚至阻碍你事业发展的大黑锅，根本没法商量，也不会和你商量，悄悄做局就好了。所以上司和你提前商量的锅，基本都是你能承担得起的小锅。而一点小锅都不愿意，过分爱惜自己的羽毛，又怎能为我所用呢？所以，这种锅，还是得背。职场上要不要背锅这件事，是典型的利益计算，关键看收益，成本和风险。也就是看上司人品，看背锅的大小。希望你已经有智慧能够分辨清楚什么锅值得背，什么锅不值得背了。如何高成功率的谈加薪而不失体面？所以今天详细讲讲加薪这件事，以方便大家把握住体制外的加薪机会。首先，员工可以主动向上司申请加薪吗？当然可以。除了一些巨头公司，收入与层级相关，无需额外提加薪外，大多数公司是可以提加薪的，这又不犯法，与企业文化也不冲突，只不过需要讲究技巧罢了。而且加薪必须要主动申请才行。体制外大多数公司都是，你不主动申请加薪，上司也绝不会主动给你加薪。上司和公司只会想节约人力成本，在尽可能压低别人价格的同时，怎么可能会对你特别照顾反而还加薪多给你一笔钱呢？勤勤恳恳工作，加班加点，以期上司看到自己的付出和努力，而后坐等公司给予加薪，这是不现实的。尤其是大量小规模的私企，你不主动谈薪是不行的。你过于认真、努力、老实，像个沙僧一样，默默做着事情，从不提要求，只会让上司觉得，你能力不行，你怕丢了这份工作，不仅不会加薪，而且还会加倍压榨你。这就是很多员工从不提加薪，待过几年确无涨薪后，一气之下突然离职走人的原因。其次，提加薪的重点是什么？提加薪时候的重点从来都不是力求成功。​​​​因为只要你足够有价值，不需要什么方法，提出来老板立刻就答应了。提加薪最重要的不是成功，也不是避免失败——只要老板觉得你没价值，不管你怎么说，都会失败。提加薪最重要的是，提完以后，避免尴尬。失败了以后，双方怎么心无芥蒂的继续合作，这才是提加薪最重要的。想要失败后不尴尬，不影响合作，那就要有仪式感，要有一套标准化的加薪流程，把加薪这件私事转变为制度化的公事。带有仪式感的去提出加薪请求，即便失败了，上司也会觉得这个下属不错，不会觉得尴尬，也不影响以后的合作。所以，如何有仪式感流程化的提出加薪请求？这个其实我们在微博说过很多遍了。1，不能打听同事工资；2，大多数情况要求涨薪8%-10%比较合理；3，罗列自己的贡献和取得的成就，做个ppt，背诵逐字稿，好好准备pitch；4，事先向上司预约，让上司有心理准备和做功课的时间；5，在公司经营良好的时候提，或刚好为公司做出巨大贡献时候提，此外，不要周一周五和大清早去提；6，穿着正式有仪式感；7，不要拿其他公司的offer和离职来威胁上司；8，不要抱怨薪资低，更不能与其他员工攀比；9，一年只申请一次加薪，切记频繁申请。按这些要求来准备，不会出现太大的问题。最后，申请加薪失败怎么办？在申请加薪这一点上，永远要记住，上司其实并不在意你付出多少，应得多少，是否觉得亏欠你，他们只在乎你是否还有投资的价值，是否还有利用价值。如若你还有投资价值，你主动申请，有可能成功，如若没有投资价值，你主动申请，不大可能成功，这就是我为什么说，在申请加薪时，必须准备ppt，罗列和展示自己对公司贡献和价值的原因，你必须证明自己有投资价值才行，这样才有仪式感，即便失败也会太尴尬。但确实已经失败了的话，那么如何表现至关重要，它决定着上司对你的态度：1，无论出于什么原因加薪失败，都要及时表达对上司的理解，感激和忠心。理解上司和公司的考虑及难处，感激上司对争取加薪过程的付出，表达自己对上司的忠心会继续努力弥补不足做出更大成绩。2，避免表现出失望的情绪，避免懈怠的行为，要表现出你对加薪失败毫不在意，没有受到什么影响，和往常一样。如果你很失望，那就悄悄骑驴找马，另谋高就，而不是失望和懈怠，否则会被上司误以为你加薪失败后不愿认真工作，与他对抗，可能会被边缘化处理。3，找到他们认为你不足的地方，以更加积极的态度工作。申请加薪失败如若还能以更加积极的态度工作，不仅会打消上司对你的顾虑，而且还会让上司眼前一亮，更加欣赏。做到这几点，便会让你安全着陆，恢复到正常的工作状态。总的来说，申请加薪最重要的不是成功，而是失败后如何不影响正常工作，因此要注意方法和态度。祝大家都能早日升职加薪，事业顺利~打工人如何快速成长进步？上司是没有义务要培养你的，能遇到一个“不问不答，有问必答”的上司，就足够值得你庆幸和珍惜​​大学生毕业刚进入职场，最重要的是学到东西。为什么毕业三年后大家感觉与别人的差距越拉越大？因为前期的基础不一样，学到的东西不一样。学到很多东西，打好了基础，做出了业绩，有了知名项目，甚至独当一面，去哪儿跳槽都是香饽饽。没学到东西，只有经验却没有经验值，拿不出可以写在简历上的成绩和经历，在哪儿都担忧。那什么决定着我们能否学到以及能够学到多少东西呢？​​​​首先，最重要的起关键性作用的肯定是遇到好的上司，能力强，有干货，愿意教。进而能学到一线的工作方法，得到锻炼，持续积累，逐渐能够独当一面。遇到差领导，不愿教，自己摸索，脏活累活占你时间，事倍功半，能力很少增长。这就与别人形成了差距。好的领导，是决定你学到东西的第一层，也是关键一层。为此，可以多面试去筛选出好上司。但要注意，筛选上司不是一个意愿问题，而是一个能力问题。你必须提升你的求职面试和表达能力，能拿到多个offer，才有筛选上司的机会。求职、面试、表达、如何筛选上司，这些我已经在微博上讲过很多遍了，这里就不赘述了，自行搜索即可。其次，和上司相处，如何尽可能的学到东西，才是第二层。大学生新人刚进入职场，对于学习，常犯的错误就是把上司当老师。在学习上是典型的填鸭式思维。如果上司不主动，不培训，不问你，你就没自学的意识，不会自觉地做好搜索和调查，然后千方百计追着问，求指导。总期望着上司像个老师，把任务安排的明明白白，今天该做什么，什么时候交，甚至能猜到你有不懂的会主动提醒你，这不现实的。职场新人不能像个癞蛤蟆，戳一下动一下，等着被安排，不主动思考。否则，上司觉得你又懒又蠢，你又觉得上司画大饼说好的培养怎么没了？这怎么能学到东西呢？公司不是学校，上司不是老师，上司的工作重点不是培养下属，新人不主动，怎么可能等到上司主动呢？上司是没有义务要培养你的，能遇到一个“不问不答，有问必答”的上司，其实就挺值得庆幸和珍惜了。想要学到东西，只能靠你主动，尤其是多问。遇到问题不要老想着自己解决，多问，多沟通，多汇报，及时联系上司怎么处理解决，次数多了，就能总结出方法论。上司再好，职场也需要靠自学，克服填鸭式思维，主动，多问，多总结，是学到东西的第二层。最后，是第三层，如何正确地处理职场上的情绪。大学生新人刚进入职场，情绪问题会阻碍他们从上司身上学到东西——对陌上的职场环境胆怯，畏惧上司，畏惧权威。这个问题非常的普遍，在职场初期尤其明显。一方面非常在意上司对自己的评价，担心出错，给上司带来不好的印象，从而过度关注自我一惊一乍，一方面又非常怕被批评，怕挨骂，玻璃心，容易胡思乱想，甚至联想到自己会不会被开除，杞人忧天。可是，沉迷情绪是不行的：过度关注自我就难以换位思考，难以换位思考就难以发现上司是在怎样的教你，是干中学呢还是先理论后实践呢？是做示范呢还是只讲道理呢？是主动带领你呢还是被动等你提问呢？不够对事不对人就难以实事求是，难以实事求是就无法区分干货与情绪，是单纯的在骂你呢还是骂中带有指导呢？是想打击你呢还是很恨铁不成钢呢？那怎样处理好这些情绪？一是、放下对自我的关注，不要过度担心犯错。上司并不关心你是怎样的一个人，只关心你是否足够安全、忠诚、听话，值得信任，所以你不用担心出错，你大可用好学的态度去对待犯过自己的错误即可。只要不自作主张，及时汇报和请示，实际上也犯不了什么大错。即便犯错了，也许挨骂少不了，只要犯错愿意承担责任，知错能改，仍然是孺子可教。犯错后上司的提点，不也是学习的一种吗？二是、对事不多人，实事求是看问题。在职场混，出于对未来事业发展的考虑，如何从上司身上学到尽可能多的东西，至关重要。既然目的是学到东西，那挨不挨骂，其实并不重要。挨骂很正常，不挨骂很幸运，但怕挨骂就不行，缺少抗压能力。上司脾气暴躁，那我多挨挨骂，习惯就好了，脱敏就好了，人在职场混哪能不挨刀，只要能在骂人的同时讲干货就好了。只要能学到东西，你骂你的，我听着就是，干货部分的内容我左耳朵进右耳朵不出，反复琢磨记忆，骂人情绪宣泄的部分我左耳朵进右耳朵出，毫不当真。学会抛开情绪看问题，分得清什么是宣泄骂人，分得清什么是干货指导，这就是实事求是。能在骂人的同时给指导，那就是好上司，只骂人不给指导，那就是垃圾上司，这就是对事不对人。处理好畏惧情绪，客观的看待领导，才能向领导学到很多东西。进入职场，想要快速成长，尽可能遇见好的上司当然最好，如若遇不到，那就尽可能积极主动，多提问多思考，同时能够克服对领导的畏惧情绪，多关注上司的干货。有心人天不负，一定能学到东西的，需要你用心。祝大家都能在职场上遇到好的上司领导，有所成长进步。员工离职，上司是否可以指出他的缺点？今天就深度分析一下，为什么对离职前的下属，不要指出他的缺点？答案显而易见，只有坏处，没有好处。​​​​首先，说了问题也不会听，听了也不会做，会打击自信心。很多读者朋友可能会认为，只要他好学主动问，作为上司，人之将死其言也善，出于好心就应该指点一下。但缺乏管理经验的职业经理人，在管人方面往往有两个问题：一是，总高估自己的圣母程度瞎操心，二是，总高估下属对批评的接受能力。你必须认识到自己拯救不了这个世界，下属离职，忍住好为人师欲，是作为上司作为职业经理人最基本的素质。你说的话，不论多准确，多有道理，多为他好，他都不一定会听，你改变不了也拯救不了他，说再多，实际上也不起作用。而且，听了也不会做。提出批评指出错误指导不足，应该是下属在职时候关注的事情，这是上司的义务，而下属离职时才指出不足，这就是本末倒置。如果你说的，他会听，还做了，至于会沦落到离职的地步吗？指出问题没有用，说了也不会听，听了也不会做，想做也不一定能做得到。况且，年轻下属经不起打击，分辨不了真心为他好还是在打击他。你不应该高估下属接受批评接受不足的能力。你批评他指出错误缺点不足，他离职后混得风声水气，不会感谢你，只记得你的打击嘲讽；你批评他指出错误缺点不足，他离职后混得落魄无声，只会责怪你，是你打击了他的自信。相反，你鼓励他，他离职后混得风声水气，会感谢你，是你在支持他，给了他自信；你鼓励他，他离职后混得落魄无声，会感激你，因为你的支持而感觉欣慰。批评百无一利。其次，你的意见不见得有用，更不见得符合年轻人的需求。你表面上看起来是个职业经理人在管人，也是从底层员工爬起来的，知道下属有哪些问题，应该如何改善。实际上，这只是你的自以为是，你指出下属的错误不一定准确，给出的建议方法不一定有用。如果你能一针见血戳中问题，指出不足并提供合理的建议方法，那你为什么你没有培养好下属让他想辞职？为什么你不去做人生导师？大多数时候，领导比下属更自以为是，盲目自信，下属只是看破不说破。而且，时代与价值观也是问题，你的指点或许出于好心，但是后浪有后浪的生活，你认为年轻人要多听老板的话讨好老板多点忍耐，可后浪们才不想狗，哪管你那么多。70、80、90和00后，思想差异巨大，无法理解上一代人，又无法理解下一代人，你以为自己是好心指点，人家却觉得是要离职了你还不忘作妖。这一点上，好心可不见得能换回好报，何必呢？最后，职业精神的要求是，离职时，多给鼓励，少给批评，好聚好散。都已经离职了，就没有义务去教导培养曾经的下属了，说多了就是好为人师。离职即分手，分手见人品，对方不是自己人了，那最重要的就是客套。这样，既有利于公司和自己的声誉，下属离职后不会到处骂你，还满怀感激。客套客套，多说好话，鼓励鼓励，在对方心中落得一个体面的印象，日后才能好相见。为什么离职时不要向领导指出问题？在前任面前，还瞎说什么大实话。​​之前发布过一篇投票，你要离职，老板非常诚恳的希望你对公司和他自己的问题提出一些建议，你应不应该说实话？没想到竟然有如此多的读者朋友选错。评论区也有读者朋友让我做一篇V+分析，所以今天我们来详细讲讲，为什么不应该说实话？​​​​说了实话，给老板指出了问题提了建议能得到什么好处吗？答案是，没有好处，只有坏处！首先，老板并不是真的想问你问题。你离职时老板向你征求问题建议，要么是客套谦虚一下留个好印象好聚好散日后好相见，就像分手小情侣，都是我不好，你可以指出我的问题，但实际上只是客套，让对方自我感觉良好一点少点难过不是对方的错，好聚好散。要么是想看看你对什么不满意，变相打听你离职的原因，是工资给的太低还是自己太作逼，控制控制下属离职率，提升画大饼的能力。根本不是想知道自己有哪些问题公司有哪些问题。因为有啥问题，自己还没有点逼数吗？需要轮到你一个底层小员工来指出？所以，你认真，你就输了。你不会真指望老板会被你的真诚打动，成为你的真心挚友吧。你屁颠屁颠老老实实发自肺腑感动至极地说出公司和老板的问题，他只会觉得你是傻逼。老板的心理状态是：1，不会吧，阿sir，我就客套一下，你还当真了，2，你就底层一个小员工凭什么轮到你指指点点，你有什么资格说这种话，3，woc，工作的时候发现问题你不改进做好，现在拍屁股走人了才说，4、你这德行，指不定要到处说我们的坏话。老板只会越来越讨厌你，觉得你不仅蠢而且坏还没职业道德。说了实话指出了问题，丢了这个人脉，但你新工作的背调还要指望他，怎么办？其次，提出问题说实话是对领导的否定和冒犯，让领导不悦。论迹不论心，你发自内心真诚友善而又赤裸裸的去哪壶不开提哪壶，指出一些大家不愿提及，睁一只眼闭一只眼的问题，就会非常尴尬，让领导难堪。情绪重于事实，你认认真真点出老板和公司的问题和不是，否定老板，会让他表面上虚心接受实际心中有一万只羊驼奔腾，领导很可能认为你针对他，揭开旧伤疤，让他不痛快，他恼羞成怒暗地里真的可能要怨恨你，搞你。最后，提出问题，却解决不了问题，显得讨厌和傻逼。1，老板知道有哪些问题，但老板又不是绝对控股最高层，问题没法解决，有心无力，只能睁一只眼闭一只眼，2、大公司积重难返，谁不知道有问题，但那又怎样？公司垮了还可以跳槽嘛，股东和职业经理人又不是100%的一条心，3、有问题又怎样？公司是动态发展的，哪个公司不是一辈子与问题共存？值得解决可以解决的问题早就搞定了，轮不到离职的时候再来问你。剩下的，都是无法解决的，你指出来根本没有意义。最为关键的是，你只会指出问题，却给不出建议。你只能做问题发现者，却成为不了问题解决者，你提出的问题就如同放屁。你说你很有能力很牛逼，能给出良好的建议，那你为什么不去麦肯锡做咨询？在这里干吃力不讨好的事情？即便你戳中了问题，给出了切实可行的建议，但人微言轻，你说的话还不是被当作放屁。你看，说实话指问题提建议，完全是百害而无一利，何必呢？离职时老板向你征求问题，最好是避重就轻的说好话，拍马屁，表达感激。客套一番，做人留一线日后好相见。离职如同分手，好聚好散。管我屁事，关你屁事，一别两宽，各自安好。在前任面前，还瞎说什么大实话。为什么提了辞职就一定要离开？当你提了辞职那一刻，不论留下来与否，你都不是自己人了，因为你有异心，你是颗定时炸弹。​​对于提了辞职就不能留下来的这个事儿，我们之前在微博已经说过很多遍了，但是架不住很多网友继续追问为什么，所以这次来详细的讲讲。​​​​在职场混，最基本的职场法则就是谈利益而不是谈感情，必须深谙利益分析法。利益分析法的关键在于要换位思考，思考别人的利益。自己这样做，对老板有什么好处，那样做，又对老板有什么好处。多思考自己的行为对老板利益带来的影响，这是利益分析法的第一点。利益分析法的第二点是，老板是以利益来做决策和行动的，老板表面上的感情牌背后其实是对利益的考量，所以别对老板有太多的感情期待。毕竟慈不掌兵义不掌财是老板们的自我修养。懂得了这个方法，就能够很好的去分析离职被挽留这回事儿了。首先，你提出离职后，为什么老板都会挽留？你提离职，老板挽留，肯定是从他自己的利益角度考虑，而非感情和交情。所以我们应该思考，你的离职对上司的利益有什么影响？对老板来说，员工只是成本和工具。留你，要么是你省钱：1，谈薪时要价低，薪资倒挂，用你很便宜；2，你有一定的不可替代性，招人挖人培训适应耗时耗钱耗力毫不划算；要么是你好用：1，业务繁忙，不能掉链子，你撂挑子不干走人，短期没人能顶替，会带来重大损失；2，你是稀缺人才，公司确实需要你依赖你仰仗你。也可能是走过场：1，表面客套，显得自己大气，做人留一线日后好先见；2，流程式挽留，凡事离职都要假装挽留一下，走个流程，显得专业。反正都不是老板舍不得你，在意感情，缺你不可。如果老板确实需要我，为啥我不能接受挽留必须要走？还是得从老板的利益角度考虑：你提了辞职，又留下来，没有稳定性，说不定啥时候又跑，业务和组织必须稳定不能掉链子，得有个备胎来代替你。你提了辞职，又留下来，随时都可能跑，不能处于完全控制的状态，必须好言好气的发布命令有所顾虑骂不得，还是得到找一个听话的人来好沟通一些。你提了辞职，又留下来，不知道什么时候会溜，那就不能在你身上投入任何精力和资源，也不能指望你的成长为公司带来更多利益，最好就是用后即弃，卸磨杀驴，招新人从头再来。提离职就是提分手，必然会带来关系上的割裂。没有破镜重圆的关系，只有心生隔阂后的临时将就，而后骑驴找马，卸磨杀驴。开弓没有回头箭，提了离职，早晚都得走人，而早走和晚走是有区别的。早走，提了离职后雷打不动油盐不进表面客套甘地式辞职，公司只会把你当做一个正常要走的员工，没有什么特殊的印象，说不定背调还能美言一番，未来有机会吃吃回头草。晚走，挽留下来，给新人培训而后被代替，被穿小鞋，被边缘化，被逼主动辞职又或被裁掉，搞得相互没有好印象。当你提了辞职那一刻，不论留下来与否，你都不是自己人了，因为你有异心，你是颗定时炸弹。不是真的想挽留你，是暂时利用你，只要找到备胎，立马一脚踹掉你。所以，早晚都要走，还不如早走，再怎么挽留都坚决要走。提了离职不走的问题还在于，没有找好下家！职场人不存在辞职一说，只存在跳槽，切忌裸辞。有了离职的念头就应该早点写简历，骑驴找马，找好了下家再提辞职，然后拍拍屁股走人。提了辞职又挽留不走的，反而暴露了没有下家，如果找好了下家又赖着上家不走，那不是更无耻的首鼠两端吗？这是一个更严重的问题。可是遇到领导加薪挽留怎么办？反而更得走人，离职时的加薪其实是一种要挟，钱给的越多，越不痛快，卸磨杀驴的时候越残酷。想要加薪，就不要提离职，提了离职就别指望加薪，想要加薪，大大方方讲出来，认认真真的准备就好。所以，要么不要脑子一热提了辞职，要么提了辞职就坚决要走。多说一嘴，一诺千金，不要反反复复，在职场上是一个很重要的品质。出来混是要讲信用，说了走人，就一定要走人，这样才靠谱。不懂市场营销，难怪你赚不到钱市场部每天到底在干什么？​​奶爸你好，可以推荐几本市场营销入门的书吗？我是工科本科生，未来打算做市场营销，想自学市场营销的基础理论，万分感谢！答：全世界能赚钱的工作只有三种，分别是技术，销售，市场。技术方面现在也就代码能赚到钱了，更多赚钱的渠道主要靠市场和销售。当然有人说投资也能赚钱，这个不否认，但它不可能让你从0大1，反而会让你从1到0.最适合年轻人致富的工作，无非就是各个行业的销售和市场职能。世间万物几乎所有的赚钱途径，也都是市场和销售的变体。有人说咨询和律师不算，算技术。但咨询和律师是非常典型的「顾问式销售」。一般的销售都是推销型销售，即我来介绍我的产品如何，让你来买。咨询和律师不是，他们客户有问题，有疑难，他们给予解答，通过顾问咨询的方式，来出售自己的服务。这还是销售的一种。其它的各种赚钱工作的变种，基本也都是从销售市场衍生而来。甚至可以说商业的一切，都是从市场销售技术衍生而来的——技术提供产品，根据产品的不同决定是用拜访销售还是广告营销的方式卖出去。作为业务类的两大王牌岗位，销售工作很容易懂，无非就是买和卖，上门推销，请客吃饭。市场工作就很难懂，尤其是看了网上的一堆市场人写的文章和教材后，就更难懂了。在知乎搜索，哪怕是市场人自己写的东西，也都是这种：一名优秀的市场人，必须是一个对人了解的人。了解人，包括了解人类共性、发展、规律；了解人群构成、分类、特性；了解个体差异、性格、习惯等等。市场偏策略宏观一些，销售偏执行。上面这些东西，对于一个外界的小朋友，有志于毕业后从事市场工作的人来说，看完了该不懂还是不懂。这个其实就挺诡异，要知道出人头地的方式方法很少，一共就三大王牌岗位，其中一条居然绝大部分人完全不明白，毫无概念。当然这不能怪外行不懂——因为大部分市场人自己也不知道自己在干什么，每天基本等于梦游混子。低级到如此程度的一个职能，你让他们给一个外行人简单易懂的说说自己每天在干什么，除了装B让人听不懂外，他们就真的什么都说不出来了。看书也没用，书更讲不出市场部在干什么，如果说了，你会惊讶的发现原来这么low和做销售的电话销售，传单，卖场促销，上门拜访，没区别，甚至更low事实上想了解市场部做什么首先就要了解公司类型。是2B还是2C2B的中小公司虽然也有所谓的「市场部」，但其实他们没有什么市场人员，只有干销售的，他们的市场部就是销售。因为2B的客户主要是大客户，企业和政府部门，不需要靠什么市场活动来搞业绩，只需要销售去攻关即可。知乎有人说：市场偏策略宏观一些，销售偏执行，但是很多中小私企人员配置不够专业，常常混为一谈。这说明不是中小私企不专业，而是国内大部分市场人就不专业，对商业的认知颇为肤浅，连2B和2C的区别都不懂，就开始对国内企业的市场部配置指手画脚。市场根本就不是偏宏观，销售也根本不是偏微观。销售和市场的不同是由于生意成交的渠道和模式不同而导致的。2B的公司客户全国可能就几百家，你去电视打广告根本没屁用，这时候就必须要销售去攻关，2C的公司卖的是民用品，全国的顾客可能有几个亿，你怎么用销售人员去攻关？只能通过打广告和网店的软文广告来转化。分个屁的宏观微观。销售经常要做全国市场分析，决定来年的预算配比的，这叫什么微观？市场部大部分人每天的工作就是做ppt做表格，这叫什么宏观？因为生意模式的不同，导致做生意的手法不同，这才是市场部和销售部的主要区别。那么市场部每天主要做什么？先说简单的，2B公司。中小型2B公司没有市场部，哪怕他们那个部门名字就叫市场部，其实也都是销售，这些可以略过不看。只有大型2B公司才有市场部，但基本都是销售的附庸，相当于盲肠，阑尾之类的，主要就是做两件事：公众口碑，KOL营销。公众口碑就是打广告，讲故事，树立公众对自己的良好感觉。KOL营销指的是专家营销，而不是大V，就是在产品领域内找专家。比如肿瘤药，需要搞定的是肿瘤领域内最厉害的专家，就那几个人，他们愿意用你的药，全国基本上就都愿意用你的药。这个部分的市场太过简单，而且鸡肋，基本没什么地位，也不是太有发展前景，可操作性的技术含量更是有限，而且只有大公司的2B才配市场部门，门槛极高，普通人这辈子也接触不到，因此略过不详细说了。2C的市场部是王牌部门，主要就做一件事：转化。因为2C的顾客数量大，不可能靠销售人员去拜访推销，所以必须去做转化。做转化的主要工具，就是做活动——市场活动做活动分为线上和线下的活动。线下就类似大家的社团，搞比赛，搞晚会，搞这个那个的，市场部做的和这个也差不多。区别就是线下的市场活动，卖场促销会多一些，晚会比赛少一些。因为我国的社会生态，现在的市场活动主要是线上的，比如说天猫节，双十一，这些都是市场活动。你打开网店的首页海报，可能都是市场部努力两周的结果。既然市场部的重点就是做活动，那么市场人日常的工作是什么？这里很多人就不能理解了。对于市场部中层，有一定的决定权，他的主要工作是：做预算和活动规划，做PPT跟上头开会，讲PPT，争取预算，跟下属开会，头脑风暴，决定策略，听下属讲PPT，定下策略，决定谁值得培养。市场部的底层员工，主要工作是：开会，参加头脑风暴，写PPT，开会时候讲PPT，做表格，开会讲PPT时候把表格里的数据用出来，写报告，写报告时候把表格里的数据用出来，帮老板做PPT和做表格，写文案，做图做海报，打电话，发邮件，聊微信。市场人对这些简单繁琐的工作会有很多高大上的日常工作描述：2B公司要重点抓品牌的行业影响力—其实就是开会，打电话让客户公司里的采购科长，业内的几个老专家来某个地方开会，送送礼——具体到日常就还是开会，定策略，申请预算，然后打电话邀请，准备礼品，宣传资料。2C公司要进行市场目标、市场/产品分析与定位其实就是查数据，做表格，写报告，做PPT，或者查数据，帮老板写报告，帮老板做PPT。然后开会时候讲PPT，或者听老板讲PPT。还要进行区域调研分析与定位同上。每日对市场趋势进行分析及预测——同上，可能要加一个开会头脑风暴，也就是奇思妙想/胡说八道。品牌传播、产品推广、影响力渗透、行销活动无非就是做海报，联系广告商做广告，联系渠道商做推广——当然对于小卒来说，主要不是这个，你主要负责打电话，和广告商渠道商开会。看明白了没有，市场人每天干什么？写PPT做表格开会所以市场人最需要的是什么能力？PPT和表格很容易做。关键就在于开会时候的发言。发言有三点，第一是表达形式，第二是事，第三是人。表达形式就是逻辑组织和口才，事情就是你对产品和市场行业的洞察了解，人就是你对广告商渠道商以及上司的了解需求。市场部的人并不是研发部，精确到每个小数点的那种，很多都是胡吹扯淡。老板需要什么，你就提供什么。老板需要诸葛亮，你就给正确的指导，老板认为A方案比B方案好，你就做出一份报告证明A比B好，老板认为B方案比A方案好，你就做出一份报告证明B方案比A方案好。对市场产品营销有深刻的洞察，善于专业表达，会混，懂得拍马屁。这就是市场人的关键能力要素。这些是任何一本教科书都不会告诉你的。下面最后一部分是重点：对于很多已经在工作，认为自己做的不是市场工作，但实际上就是在做市场工作的人，他们每天在做什么？1，社群运营，社群内的转化——这个就是市场，2，新媒体运营，思考涨粉——这个仍然是市场，3，新媒体写作，内容涨粉——这个还是市场，4，用户运营，抓数据，看数据——这个也是市场，5，拍拍小视频带带或——这个仍然是市场，6，市场运营——这个不用说了，就是市场，7，你主业是HR，你在B站录视频涨粉，然后卖你的课和咨询——这个还是市场，你以为是你是HR，其实你是在做市场，8，你主业是程序员，你没事上微博写点文章，然后卖你的培训课——这个仍然是市场。发现了没有？市场，就是一种获取流量，高效转化的做生意方法。所以你看。凡是涉及到庞大的用户群和消费者群的工作，带有转化，流量，拉新，等字眼的，统统都是市场。能否做的好就看你能不能在一堆繁琐的工作中，理出一个头绪，把这些工作都排好顺序，提纲挈领，以后自己单干或者升官了，可以良好的把活安排下去。希望我说的足够清楚了。升职加薪的真正关键是什么？按利益行事，才是直属领导各种行为背后的核心逻辑。​​我们的读者朋友都知道，搞职场人际关系的重点在于你的直属领导，而不是同事。直属领导拥有你升职加薪的决定权，按照follow the money 与 decision maker 的逻辑，他才是你最需要搞定的人。至于怎么搞定，很多人就开始犯迷糊了。​​​​有的说能力最重要，天生我材必有用，有的说关系最重要，肥水不流外人田。东说东有理，西说西有理，我们得用利益分析法换位思考来解决这个问题。直属领导最在意的是什么？当然是自己的利益。按利益行事，才是直属领导各种行为背后的核心逻辑。职场上的业务冠军为什么老是无法升职？因为不符合领导利益。把业务冠军提成领导，那公司的业绩和活儿靠谁拉起来？搞定直属领导的逻辑，就是换位思考他的利益，提供对应的价值。领导也是社畜，他的利益，也是升职加薪。你工作的核心，就是做好向上支持，先成就领导再成就自己，让他愿像候选人般培养你。他升职加薪了，有了职位空缺，愿意提拔你，你才有可能够升职。那什么叫做向上支持？提供情绪价值、工具价值，说人话就是让他更高效更开心更轻松更安心的完成他的工作。高效，意味着下属：1，迎合领导的性格和工作方式风格，与领导打好配合；2，换位思考，了解领导的利益、思路、需求和重点；3，减少沟通成本，擅长请示、汇报、包装、展示和说服。开心，意味着：1，拍马屁；2，感恩；3，送礼；4，关心；5，归功领导；6，维护领导尊严。轻松，意味着：1，独当一面，业绩过硬；2，帮忙解决相关琐事。安心，意味着要：1，忠诚；2，靠谱；3，愿在小事上出面背锅。换句话说，所谓的向上支持，就是要有着业务冠军般的能力和秘书助理般的服务意识。向上支持，就是和领导搞好关系的关键。当然，不同的工作环境，迥然不同。体制内，升职加薪靠资源背景和学历，所以应该朝学历和关系上靠；体制外，升职加薪靠能力忠诚和配合，所以应该朝能力和忠诚上靠，竞争越是不透明，业绩越是难以衡量，就越要朝表现和包装上靠，竞争越是透明，越是对业绩有要求，就越要朝能力上靠。最后还得提一点，向上支持的前提是，直属领导值得被支持。如果领导有脾气没能力混吃等死不维护手下利益，爱恐吓，精通PUA，只把你当工具人、棋子和背锅的，还学不到干货，就不要去支持，而是骑驴找马随时做好跳槽的准备。多面试，多跳槽，不管再难，相信你一定能遇到一个好的领导，值得你去支持和追随。你也一定会成为一个好的下属，值得被栽培。大家加油，祝人人都能升职加薪！跳槽后悔了，还可以回原来公司吗？下面我们开始对这个问题进行深度的解析。​​​​跳槽后悔了，还可以回原来公司吗？当然可以，我在网易那会儿，就见过许多管理层的人跳出去又跳回来的情况。没有大家想的那样，低声下气，备受打压，必须得忍辱负重。相反是升职加薪一路高歌，并没太大影响，该干嘛干嘛。公司招人，陌生的新人，与熟悉的旧人，哪一个更可靠可信？公司急用人，有回来的旧人放着不用？除了少数的奇葩公司，并没有相关法律或者行业潜规则说不能跳槽吃回头草。公司不是谈恋爱，分手一次没了最初感觉就不能破镜重圆。公司是利益驱动的组织，只在意员工的意愿与能力，是否能弥补岗位空缺把项目推进下去，把业务进行下去，是否对业绩和营收有帮助，才是公司最主要的考量。只要是按公司规定的流程和手续走的，正常原因离职的，风评没太大问题，完全可以大大方方的回去。提了离职就必须走人，但不代表以后就不能回去。你觉得丢脸，低声下气，只是你自己的感觉，不重要。优秀的人才跳来跳去是再正常不过的事情，跳槽又不是绝交拉黑。当然，面对这样场景类的复杂问题，能与不能，可以不可以，是与否，我们都不能简单粗暴的下结论，否则就是典型的二极管思维。我们要掌握马克思主义的一条基本哲学原则，具体问题具体分析。如何进行具体问题具体分析？在思考选择什么之前，先反思自己有没有得选，是破除选择困境的第一点。区分、梳理、认清自己有哪些拿在手中的真实选项。很多时候你根本没有选择却误以为自己有选择。你回不回去，与你能不能回去完全是两码事，你得先能回去，才有资格再去考虑回不回去的事情。还是那句老话，大雁射下来再考虑怎么烹饪，你得先去了解自己能不能回去，有没有希望回去，不然就是浪费时间。好马可以吃回头草，前提是草儿心甘情愿被吃。所以，得先解决能不能回去有没有希望回去的问题，这才是我们的主要矛盾。能不能回去的决定权在别人手上，这时候最关键的就是换位思考：对方有没有职位空缺、有没有招聘需求；是否介意忠诚度；是否接纳回头马；你是否人岗匹配；你是否对项目或业绩有更大帮助；你的要价是否划算；这些都非常重要，为此你要做好情报的搜集与调查工作，联络人脉，笼络人心。偷偷的联系以前的同事，请人吃饭，打听公司内部的招聘情况，再请以前上司吃饭，摆出投靠的姿势。把内部消息搞清楚，把有实权的人搞定，人家愿意收你，你才有机会回去。也因此大家要记住，分手即见人品，离职的时候好聚好散，多说客套漂亮话。做人留一线，日后好相见说的就是这种情况。最后是我们的次要矛盾，如果能回去，要不要真的回去？以前离职的问题有没有得到解决？是被请回去的吗？薪资待遇有提升吗？升职了吗？更有发展前景吗？当前回头草最好吃吗？还是自己没有选择，被迫吃回头草？这些问题，就需要你自己思考清楚了。最后再重点区强调一句：本专栏所撰写的一切都是「职场公理」，指的是「合理的事实应该是这样的」，而不是事实本来就这样，你所处的职场环境可能一点都不是这样的，比如某些生儿子没屁眼的老板和企业就规定绝对不可以离职，离职了就要拉黑名单。明白这些公理是要让你有能力鉴别正常的企业和老板，以及充满自信的在职场上去做对的事情。如何把英语学精深？新年学英语​​​很久没发英语方面的文章了，今天写一篇。英专，或者说想要把英语学到比较高深的水平，应该怎么学？英专和普通英语好的人的区别，主要就一个，是表达。注意，不是词汇量和口语，更不是口音。口语这个东西说实话并不难，只要不要脸大胆开口练总能练的还可以。口音也不是英语好的标准，这个主要是天赋，就好像普通话大家说的都有口音，英文自然就不可能学到纯正。词汇量就是笨功夫，全靠背，不讲什么技术含量。真正有技术含量的，其实就是表达，跟中文一个意思，中文一张口就说话有水平和内容，主要就是看表达，英文也一样。内容这个靠个人修养，不属于语言技巧，单纯的语言技巧，那就是表达了。所以，想真的把英语学好，第一，一定要精专语法和搭配，张今老师的书可谓神作，她的学习心得也是从普通爱好者到水平精深的高手转变的不二法门。如果看不懂​​​​可以从张满胜赖世雄旋元佑等老师的书开始入门；第二，一定要猛读，我个人建议最好先读当代各类财经商科，再读当代知名文学名著，最后转到经典名著；第三，一定要精研小词用法，把牛津3000的词分词性，对着一本学习词典把最普通词的所有英文解释义项搭配例句都牢牢记住并大声朗读做到脱口而出，这一项工作就能让口语写作的功力提高一大截，第四，大一下学期就得开始只用英英的学习词典，不用任何中文和双解字典，大二开始尽可能多用母语词典，推荐次序是柯林斯cobuild—新牛津—美国传统；第五，惯用法图书一定要多读，叶永昌陈用仪的书必须全部买来或下载打印通读，彻底扫清思维盲区；第六，一定要学会用母语国家学生的各种常用工具书，包括thesaurus, usage, collocation等词典。做到了以上最基础，英专才能好意思说自己足够专业。否则现在英语普及了，大家都大量浸泡听力输入张口就流利英语了，你还只知道背单词背课文，英专怎可能有优势？这些本来就是传承百年的基本常识，诡异的是不知道为什么大部分人不知道，还拿小儿科当优越感，耸肩。我非常不爱在公开平台说这些，一方面太多太细碎写的太累了，而且说太多老有出卖专业机密的背叛感，另一方面我一直以来的工作主要是科普，普通人实用入门就好，没必要花这么多心力学到这程度，况且门都没入就给太多反而让他们学不好，但是专业生当然必须学到精深。以上方法我在学员身上实验，基本效果还算满意，GMAT写作满分什么的——我从来不认为自己单个水平高就是个好老师就可以吹牛，这是卖弄显摆而不是认真的教育从业者。能不能设计出普适的系统，针对学生每个阶段的不同特点对症下药，才是最显教学功力的地方。光自己学好没啥了不起，能培养出几十上百个水平厉害超越自己的学生，才是教师的基本成就。祝大家一切好，学习路上收获满满，不半途而废。年底述职应该如何做？总结报告​​述职这个事看上去很小，随便走个过场就好，实际上具有非常大的作用，尤其是对于新人来说，这是罕见的能够和大老板直接对话沟通的机会。在述职会上给老板们留下好印象，对你的未来会有非常大的帮助，只是你升职时候的重要考量。而且不单单是述职如此，采用正确的职场思维逻辑，解决工作中的问题，你的工作能力就会持续进步，慢慢的你这一套思考方法就可以复制传授并且不断累积势能，良性循环越来越好。做述职的时候，最重要的是要给人留下印象：你可以独当一面独当一面这四个字看着玄学，但其实是有丰富具体的内容的，它主要包括：1，你可以完成现在的工作，2，你对现在的工作用心了，完成的质量不错，3，你对明年的工作有所展望和基本规划，4，你能够在现在的工作中发现问题，5，你能够得出解决问题的方案，并且大胆的提出来。这5个问题，是层层递进的，非常重要。前面三个问题，是基本要求，我相信大家只要认真干活了，都能做到，在讲述这方面的情况的时候，主要是结合数据，案例，认真来讲。​​​​还有要学会包装自己，如果业绩的数字太小不好看，那就说和去年相比增长多少，如果跟去年相比增长一般，就说和其它同事同期相比超额多少。反正就是要回包装自己。不能干巴巴来一句，我做的挺好，做的不错，没了。你得有条理，有逻辑的按照自己的理解，把工作内容，强行分成一二三的几块，每块都侃侃而谈，头头是道。而且每一块，你都要结合数据，今年的数据，去年的数据，你同事的数据，进行对比和分析。做到这个，你基本可以得到老板的赞誉了。但是仅仅这样还不够，你得提出见解，而不是应声木偶。你得在现在的工作流程中发现问题，提出自己的思考。如何发现问题？非常简单的逻辑：follow the money你们公司的业务是什么？你所在的部门属于什么性质？是赚钱的，还是省钱的，还是花钱以期未来可以赚钱的？基本上部门就分成这三大性质。赚钱的，就是业务线了，不用多说，省钱的，就是财务，IT，HR之类的支持部门，你们的活做的快做的好，就能给公司省钱，花钱以期未来赚钱的，比如投资部，市场部，营销部，企划部等等。你明白了自己部门的性质，自然就明白了你的团队给公司业务提供什么样的帮助，你们的存在有什么样的意义。继而你就会发现自己的工作，提供了什么样的支持，有什么样的意义。继而你自然就会发现问题，如何提高，这是必然的事情，因为不存在完美的商业流程和商业模式。但是这里要注意，你所提出的观察，见解，发现的问题，最多最多只能局限在部门层面，不要达到公司层面。之前底层人员写两万字直接发给任正非，陈述华为的战略问题，发表自己的战略构想，任正非看都没看，直接让HR通知此人明天不用来上班了，并且在公司内部公告：级别低于XX者就妄谈公司战略的，建议直接送精神病院。这是非常正确的，因为底层员工不论多厉害，是不可能洞察整个公司的大战略的，甚至任正非自己都不能洞察——放十年前，他做梦也不可能想到华为今天会做手机还做的这么大。很多战略都是有机缘的因素的。那么如何在机缘发生的时候，能够抓住它？就是在其位，谋其政，每个员工把自己的工作达到尽善尽美。所以你思考的，不单单应该只是眼前的螺丝钉，同样也不应该是整个公司的战略，而应该是你这条业务线，你所在的团队，或者你的部门，这个层级上每天的工作细节。是否有沟通不畅，效率低下，是否有监管不力，数字不清，是否有流程模糊，效率不高。这些实实在在的实务工作，才是下属真正应该考虑的重要问题。举个例子：我有个哥们之前在拜耳做数据分析，他做了一项很简单的小建议，当时大家都用excel算数字，又冗长又繁琐，他写了一套算法给领导，缩减了30%以上的工作时间。领导过两年提拔上去做总监，继任者推荐名单，就只写了他一个人，说只有他适合。这个故事需要一点专业技能，但是只要你认真用心观察，我相信，你可能能发现问题的，至于说问题如何解决，其实你提出这个问题，就足够让领导对你刮目相看了。混职场要不要给领导同事送礼？基本原则问题​​​这也是一个高发的鬼打墙问题，反反复复有人问，不论回答多少次。因此集合成一片付费文，再有人问，直接让他购买即可。首先说说给领导送礼，比如他要过生日了。这个一定要明白两条原则：工作性质原则能力匹配原则​​​​先说工作性质。即搞清楚你们的工作环境是什么性质，是主要靠业绩说话，领导也有很大的业绩压力，还是主要靠「混」。靠「混」的环境有很多，主要就就是国企和体制内，更具体的就不方便说了，它主要就是领导一言堂，没压力，很稳定。这种环境里，主要就是领导喜欢谁，谁就过的舒服。但也要看「混」的比例。如果一个公司靠「混」的成分超过了50%，就没必要送礼了。因为在办公室里，基本没活干，不看能力业绩，说明这种办公室没有一丝一毫的晋升可能，领导也没什么权力，没法开除你，你顶他他也只能吃瘪。这时候送礼，就是打水漂，没任何收益。靠能力50%，靠混50%的工作环境，一定要给领导送礼，靠能力70%以上，这种环境下，可送不可不送，因为领导最看重的是你的能力，而不是你的做人，只要你能力强能解决他业绩压力，他就自然喜欢偏爱你。然后是能力匹配选择。我们刚才说了，靠混的成分超过60%的公司，就绝对不要送礼了，因为送了没意义，这种工作没前途，没收益，领导不可能给你机会。现在谈谈靠能力大于50%的环境，你要不要送礼？这里主要看你的能力。如果你的能力不行，不论给领导送什么奢侈品，都没屁用。因为领导最大的用来是业绩，需要你解决问题。他过生日你送礼，他可能会心头一暖，但之后你工作表现平庸，他很快把你忘了。投资等于打了水漂。除非你工作表现很好，他才乐意。综合这两条原则，我们可以得出结论：靠能力50%，靠混50%，你能力差，那就别送了，没任何屁用，靠能力50%，靠混50%，你能力强，那一定要送，而且要送大礼，靠能力70%，靠混30%，你能力差，那就别送了，没任何屁用，靠能力70%，靠混30%，你能力强，那可送可不送，看你自己想法。归根结底，还是在于个人能力，和对环境的审时度势。那么同事过生日，要不要送礼呢？众所周知我对同事的态度就一个态度：好听点叫死道友不死贫道。难听点就是去他妈B的。所以要不要送，看你和这个同事关系怎样，关系好就送，关系不好就不送。最后，有人说送礼这个要在乎别的同事的面子，比如：应该先问问其他同事前辈，如果他们都不送东西給领导，就你们送，那会很尴尬，如果他们送，那你们也得送，但价值得低于前辈的。这纯属自以为是的大SB想法。你送礼的目的就是为了让对方开心，而不是让大家都开心。只要领导喜欢你，偏爱你，就注定会有同事不开心，甚至仇恨你。因为这种破事什么都不敢干，吃屎都吃不上一口热乎的。送礼最重要的是收礼人的想法。别人怎么看，管他去死。大学毕业后同学同事婚礼到底要不要随礼？很多人居然完全不懂这个基本原则​​后台太多人鬼打墙问这个同一问题，重复率太高，因此总结成一篇文章，以后有人再问，就让他购买本文。大学毕业后在办公室要不要随礼，它只需要考虑一个原则：等价交换原则随礼的目的不是去真心祝福别人。而是自己以后做事了，好把这个钱收回来。在这个钱一送一收的过程里，感情发生了交流和沉淀。所以随礼的前提是必须有一个「等价交换」的环境和氛围。​​​​农村人喜欢做事，喜欢大操大办，喜欢迎来送往，宾客都要给礼金，就是因为这个原因：生活环境，节奏，模式固定单一，20年前这批人，20年后还是这批人，所以大家互相随礼，本质上不会出现最大输家，因此这套模式可以留传。城市化是极度反乡村的，大家的流动率非常高，今天在一起亲热，明天就跳槽谁TM还认识你，所以就绝对不能靠礼金来往来。在这种环境下，即非稳定环境公司，仍然有人强行去营造「礼金往来」的约定和习惯，那只能说明：收礼金的人是坏，随礼金的人是蠢。所以在一线城市的正规公司里，是根本就不流行这套的，包括领导也不流行这套，哪怕他结婚了，最多也就自己第二天买点糖来发，仅此而已。邀请同事参加婚礼收礼金不可能的。除非这个同事是圈子内的稳定伙伴，认识很多年的，比如合伙人，核心决策层高管等等。只有这种，建立私交才有必要。家庭等于隐私等于私交。做事就是极度隐私的事情，非稳定的私密朋友不可。现在的问题出在广大二三四线城市，以及一线城市的某些SB公司里。这些公司的里的某些人，肮脏龌龊，又想享受城市化的流动性，又想享受农村里的礼金收益。所以他们有任何事情都要邀请办公室同事，哪怕同事流动率很高。越高越要邀请，不赚白不赚。这种人就极度缺乏基本的职业精神，且生儿子没屁眼。目前广大二三四线城市人的生活节奏越来越像一线，但是思想意识仍然很落后，还是农村。二者结合，就会出现很多恶心的坏人，和很多愚蠢的笨蛋。前者坑人，后者被人坑。那么在什么样的环境里需要随礼？这个也非常好判断。你扪心自问：你来上班是为了干什么的？是努力精进，做好业务，持续进步，不断跳槽，获得更高的地位和级别的？还是基本上没什么出头的可能，只能维系好小圈子里的和谐关系？这两者是互斥的，不存在统一的可能。你想有所成绩，注定会得罪人，哪怕你没有损害妨碍他，他只是嫉妒都会看你不爽，同事关系不可能太好。你想维系同事关系，在乎别人喜不喜欢你，你就不可能有出息有进步。你想清楚这点，就知道要不要随礼了。除了这点外，就是看稳定性：你要随礼的对象，未来还跟你有没有联系，你能不能把这个钱收回来。不能，那你就不该随。所以大学室友，同学，高中同学做事要不要随？看关系。同事领导做事要不要随？看你们未来的稳定度。为什么有的人从不读书但其远见、思维方式、做事方法却那么卓越？家学和教育​​上网看到一个讨论：为什么有的人从不读书但其远见、思维方式、做事方法却那么卓越？我工作十几年，打过工，干过个体，自己创业开公司，自认为经验还算丰富，见过无数的人。老实讲，我真的没见过这种人。亲自接触过的有成就的人，都阅读量惊人。阅读量惊人的，不一定有成就，但有成就的人肯定阅读量很大。哪怕是乞丐皇帝朱元璋，学习也刻苦努力，而且是30多岁以后仍然在持续学习。 ​​​​但读书并不是万能的，有一件东西，它的作用远大于读书。言传身教的作用远大于读书。我妈从小就做生意，一直在集市上摆摊，偶尔我会去帮忙看着摊子，她会手把手告诉我哪些顾客是真的想来买东西，哪些顾客只是来随便逛逛，什么时候可以接受还价，什么时候一定要咬住价钱。不仅如此，她还会经常谈论起集市上各家亲戚的生意状况和顾客交往，这让我对方法经验有了一定的对比，从而明白对错。我妈从不是个教育家，也没看过多少书，不懂从心理学社会学的根源出发把这些事讲清楚。但她传递给我的生意经和为人处世的常识，到现在我仍然在使用。我以为这是一个普通家庭的基本教育，但长大后发现，这还真的是罕见。父母和孩子之间少有聊天和交流，这才是常态。但我只是普通家庭，就有这样的生意经。不敢想象科学家工程师大富商的家庭，他们的子女受益能有多少。除非父母过分忙碌，完全不爱家庭，和孩子关系淡漠。稍微有一点交流，学到的东西很多都是通过读书一辈子都得不到的。​​​​而且普通人家的子女，随着收入的上升，每走一步都是陷阱，说难听点万丈深渊也不过分。一年赚一万和10万，基本没区别，都是一样的过法，一年赚100万，甚至500万，也都还好，少乱花，多省下来买房就好，一年赚个上千万，几千万呢？这时候必然要涉及到资本运作，投资管理。如果是一个普通或者贫民人家的子弟，从0开始慢慢到达这个级别，他面对的每个选择都可能是万丈深渊，如履薄冰，战战兢兢。稍微一个不小心，就是倾家荡产，甚至牢狱之灾。等于奋斗了半生乃至一生，所有的财富全部白费。但如果他一开始就有一个亿万富豪的父亲，都是自家人，手把手的教，会不会好很多呢？小马当年做聊天软件，就缺了几十万买服务器，全中国都跑遍了求爷爷告奶奶的找融资。在这期间遇到了无数的诱惑，很多大佬都说就你那个破软件，不赚钱还亏损，图什么呢？来来来，这里有个60万，你卖给我得了。小马当时只有29岁，就差一点点就卖了，最后说是因为价格原因，没谈拢。很多人看到这个案例，都高赞小马这位年轻人高瞻远瞩，魄力十足，硬扛到底。但是事后听说他的爹地是一家上市大集团公司的CFO，日常的工作运作就是几个亿几十亿的大项目。再想想小马的创业路，好像，也不是真的需要过人的眼光，毅力，魄力。背后有诸葛亮撑腰的感觉，好极了。当然，这也不能说明一切问题，也有反例，公子哥投资失败欠债的例子比比皆是，这里不提了。但这种家族传承智慧，显然是一种捷径，相比较所谓的家财。智慧和经验，尤其是一手的亲身体会和知识，更宝贵。所以普通人怎么办？好就好在这是个信息社会。信息社会里，只要你想，总是能够打破信息不对称，从而实现信息通畅的。比如求职，你随便搜搜，都能看到各大公司的面经，各种无数的简历和面试方法。当然互联网上只有低端的人生经验，风险投资，融资这种也不会写上来。这个时候就要靠人脉了。这里的人脉一定要注意：必须是相互交换的人脉。而不是生意伙伴。在国内做生意，尤其是2B生意，基本上都是建立在欺骗的基础上的。理财听基金，买房听中介，有事听律师，很可能要完。我自己创业，曾经遇到过很大的难题，就是到底要不要接受融资。我带着这个问题，找了我认识的一个投资人朋友，他只做PE阶段，对小公司并没有兴趣，和我没有利益纠缠，只是朋友。他给了我很多宝贵的建议，让我少走了很多坑。我后来要打官司，也不是随便看广告找了个律师。而是找到了信得过的律师朋友推荐，我教他做自媒体，他跟我讲律师行业内幕，最后找到了个满意的。买房投资时候同样如此，我并没有听中介的，而是找了个靠谱的中介朋友，他没兴趣做我生意，我教他自媒体，他教我如何投资买房。多积累一些技能性的知识用来交往，拥有一些各个行业的厉害朋友，但又不是直接做生意打交道的。对于成年人来说，非常重要。最后的最后，虽然读书不如家学，不如人脉，但总比一无所有来的好。如果你没有家学，没有人脉，那么就更要读书。因为起码比不读书的人，有竞争力。如何在短短几个小时内就改变人生？不自律怎么办​​来自上海的读者朋友Sophia提问：奶爸你好，我现在读大二，感觉自己很没用，经常列好的计划完不成，拖沓，三心二意，半途而废。请问有没有可以提高自律的方法呢？答：11年时候我在豆瓣认识了一位网友，老陈，老陈当时刻苦自学英语，默默学好后，给我反馈，因此成了朋友。跟老陈熟悉之后，我发现这人很有钱，而且是一无所有白手起家的很有钱。15年时候他专门给我打了个电话，说他今年做的不错，建了几个基金，老婆孩子和孩子的孩子的孩子，都不用担心未来的经济问题了，以后他们想干啥就干啥。我在12年的时候，就跟这么一个人成为亲密好友，并且保持非常密切的微信沟通往来，交流学习困惑和人生困惑（他英语学习我职场事业），对当时25岁不到的我来说，是大有裨益的，而且可以说是机会难得，十分宝贵。因为老陈我后来还结结实实发了笔小财，这个是我和他搞的投资项目，属于物质上的，但是相对来说，对我来说受益最大的，其实是一笔精神财富。老陈给我分享的人生经验和心得中，让我觉得最珍贵，最有用，最值得每个年轻人都要去尝试，甚至可以说是在短短几个小时内就能改变人生的方法，我今天全部都写在这里，分享给大家。这个方法，网上应该已经有很多版本了，也逐渐流传成了各种版本的鸡汤故事，但是在12年时候老陈就跟我提到过了，所以我怀疑他可能是这个鸡汤的始祖，当然老陈提供了完整的步骤和方法论，所以比简单的心灵感悟和鸡汤，要强多了。这个方法，很简单，老陈称之为“时空穿梭法”，步骤如下：​​​​找一个安静的场所，适合思考的地方，准备好纸笔，写下你在过去的成长生涯里，最后悔，最希望能穿越回去改变的一些事情或者个人特质。我那时候在纸上写的主要包括1，没有认真学习，错过了高考的好机会；2，填志愿太不谨慎了，没有选择发达的上三角地区，反而去了内陆省份，导致在校的经历和实习经验也很难看，毕业时候走了不少弯路；3，大学时候遇到怦然心动的女孩子没敢上前搭讪，结果那种感觉再也没有了；4，没能控制好饮食，导致发胖；5，没能在全国大赛时候再冷静一些，再镇静一点，拿个好名次。还有很多诸如此类的后悔事宜，一条条都列出来了，但是主要就这五条。写好之后，把这张纸丢到一边，闭上眼睛，开始冥想。想象你现在已经到了晚年，行将就木的年纪，生命中充满了各种悔恨和不甘，但是岁月无情，已经不再给你多少机会了，这个时候，如果你有一次可以穿越时空的机会，回到年轻时代的现在，你会去改变哪些事情？然后你睁开眼，砰的一下，你已经恢复了现在的青春，那么你会改变哪些事情？拿出纸笔，开始迅速的写下，你认为现在有哪些事情，可能会让晚年的自己后悔。我主要写下了这两条：1，事业未竟，壮志未酬，这还不算可怕，可怕的是明明有这个潜力和才能，却徒劳浪费时间，沉浸在小聪明的洋洋得意中，未尽全力；2，没能管理好自己的饮食和生活，健康损毁；之后，把这两张纸拿出来，把它们合在一起，开始分析。首先叉掉那些不可能弥补的事情，比如说高考，比如说全国大赛，然后把注意力放在那些现在可改变的事情上，开始考虑如何去做，如何去开始落地。然后你就会得到一个mission list，这个list，就是你的人生攻略，就是你后悔一生，万般愤恨，突然恢复了青春，得到的第二次重启的机会。试问一个行将就木的老人，突然恢复了青春，他会不会欣喜若狂？既然这样，现在时空穿梭，恢复青春的各位，是不是应该珍惜时间，充实的过完一生？完成这份mission list后，把纸条放在自己的钱包皮夹里，每次你懈怠，想要堕落的时候，都要拿出来看一遍，提醒自己：这是我的第二次机会，我的重启人生，不能像前一次一样再浪费了。我当时花了一个下午，几个小时的时间，完成了思维上的穿越时空，得到了这份list，现在五年过去了，我们看看现在的情况如何：1，高考失败了，弥补不了，但是学习是持续终身的，所以必须坚持学习，输入，充实自己。所以后来，我出了一本销量过百万的书，一手负责开发英语学习类app，现在手头还有很多本的书约。2，高考没选好地域，导致经历背景很难看，但是工作之后，我一路名企，还算是积累了不错的职场履历。3，没能在全国大赛再冷静一些，错失良机，没能拿到好成绩。所以我积极参加各种线下的演讲俱乐部，和很多人成为朋友，有了很多有趣的经验，并且因为工作原因，后来被全国大赛邀请成为总决赛评委，再在网上分享自己的比赛和演讲经验心得，对很多人都有了助益，曾经的网络受众，后来拿到了全国第五，坐在评委席上的我也忍不住激动的为他鼓掌叫好，再后来参加比赛，晚宴时候被一堆选手围着要合影，询问我的帖你们看了没，纷纷答看了，问有用么，纷纷答非常有用，十分感激。那个时刻，真是堪称我的高光时刻。4，事业未竟，壮志未酬——去年认识了合伙人，开始开公司，很多想法都在有条不紊的慢慢落地，建设，去实现，不论成果如何，起码真正的往人生理想投入努力了，这已经比很多有理想却不敢追求，甚至连自己目标理想都不清楚的人，要好多了。5，大学时候遇到怦然心动的女孩子没敢上前搭讪——去年遇到一个超喜欢的女生，大胆去追求，虽然失败了，失恋了痛苦大病一场，但回想起来，总算是没有之前的懦弱，不堪和悔恨。6，没能控制好饮食和生活，健康管理——这条至今仍然做的很不好，还在和自己的弱点挣扎。我当时写了6项，弥补了3项，开始行动1项，失败了1项，还有1项做的一般，打算今年重点投入。总的阶段性回顾下来，尚算不错，过去五年总不算是一个浪费时间，碌碌无为的废柴上班死宅。这么一个简单的几小时冥想，思考和列清单的动作，对于个人的激励和驱动作用是巨大的，如果有可能，我推荐大家看完本文，都能去找个安静的地方，认真的按照本文的方法去好好思考下。相信我，当你的皮夹里有这么一份清单的时候，你做任何事都会有条不紊，风轻云淡。没有人，可以轻易的打扰到重生后的你。加油，请坚定的活下去！“消费者思维”是成长的最大陷阱！知乎上有个女生提问中产阶级如何晋升到上流社会，说了一堆描述，简直要乐死我了：张口闭口阶级，眼光，格局，觉得自己对奢侈品和艺术品的品味很好，要会多国语言，要旅行探索心灵，开拓视野，要有格调，要会社交等等等等。当然她对自己的目标要求是这么描述的：大概就是无论在国内还是国外，有平时自住的别墅或公寓和度假屋，能把一线品牌的奢侈品当日用品来消费，每年两次可以不用考虑钱的旅游，可以比较轻松地养育两个孩子，并能允许他们自由地选择专业和未来发展道路。这个就是典型的知乎癌——这些人都敢批评雷军和周鸿祎的着装品味不好，不够高雅有格调，他们估计还深深的认为雷周不算上流阶层吧。雷军目前在中国福布斯排行是第三还是第五，兰博基尼法拉利开一辆撞一辆再扔一辆完全可以，当然互联网人的生活方式都比较屌丝，运动鞋格子衬衫十五万左右居家自驾车是标配，因为生活不够奢华，所以经常被时尚达人和键盘侠有钱人瞧不起。他们认为一个人的品味，格调，视野，格局，着装，谈吐等等，决定这个人的社会地位和阶级，并且敢于因此去瞧不起真正的亿万富豪。问题是，所谓的社会阶层，跟优雅、品味没半毛钱关系，无非只跟两个因素有关，权力，还有金钱。至于说什么学历，教育，艺术能力，会演奏乐器，绘画，多国语言，奢侈品，人脉，品味，眼界，格局，认知什么的，永远不是阶级跃升的重要因素和渠道手段。看重所谓的“艺术，品味，格局，眼界，旅行，奢侈品”等元素，表明你的心态和思维模式仍然处在一个“消费者”的层次，而作为“消费者”是永远也不可能提高自己的社会层级的——因为想发财，最重要不是优雅，不是品味，更不是什么格局眼界，而是你的经商能力，和捞钱水平。​​​​换言之，想提高社会阶层，就必须得创业，去经商，要成为一个“创造者”而不是“消费者”。年轻人看重的所谓上流社会品味审美格局眼界等等，那些人是世袭得到的权力和金钱，有空闲时间，这是果，而不是因——创一代很多都穿的糟糕像个乡镇企业家，然而没有人敢质疑他们属于上流阶层。那种生活，不属于创造者，只能是消费者坐享其成，而消费者的主要任务是守成，不是开拓和创造，这种人的经验和生活，参考意义为零，对你的目标没半点用。应该多看看创造者的经验和故事生活，但是这类人的生活，就几乎彻底远离什么浪漫，品味，格调了——常年加班，满脸尘土，衣服皱巴不合身，身为女性还要下车间和工人打成一片，等等等等，这些才是开创者么在努力时的常态，这就是社会的残酷性，也是希望大家都能意识到的。最重要的就是要转换思维模式，以一个创造者的身份去看待这个世界，而不是以消费者的视角试图享受世界，光有消费和享受的心态，你永远不可能达成自己目标：我下面用一些年轻人常有的想法和犯的错误一一举例，来仔细剖析下所谓的“消费者思维”。1，我热爱旅行，旅游大大提升了我的眼界，也去了欧美和东南亚的一些国家读书交换旅游，自认为眼界还算开阔。错！最好变成：哪些国家的旅游景点人文风景比较有吸引力，比较适合我在中国开展旅游业生意，如果我想通过旅游业赚钱，我应该选择什么路线，什么国家，什么方式来赚钱比较好，网上都说旅行社模式在消亡，那么什么模式在大热，怎么展开，如何招揽客源，如何控制成本等等。你未必要做旅游业生意，并以此来达到你晋升阶级的目的，但这不耽误你可以去了解一下这门生意。2，女孩子就应该用奢侈品，奢侈品可以彰显我的品味，要努力赚钱，多尝试错！最好变成：我有没有可能创造自己的时尚品牌，用什么方式渠道来经营，现在国内奢侈品市场这么大，能不能打国货设计思路来赚钱？你未必要做奢侈品的生意，并以此来达到你晋升阶级的目的，但这不耽误你可以去了解一下这门生意3，有钱人的小孩都有艺术特长，我也想培养自己的艺术品味，有空练练乐器和舞蹈。错！最好变成：现在家家户户都在做亲子艺术培训，这门生意这么火，市场有多大，我怎么去了解了解（搜搜知乎啦，找培训班老师问问啦，打听打听报名费和人数啦等等）？如果我未来去做这门生意，前景如何？你未必要做艺术课程培训的生意，并以此来达到你晋升阶级的目的，但这不耽误你可以去了解一下这门生意4，有钱人家孩子德智体美劳多样发展，我也想跟他们学习多健身，把大把时间花健身房里。错！最好变成：健身培训，健康行业是中国社会未来很大的蓝海，目前这方面成功的案例有哪几家，一般模式如何，怎么进入这个行业，一般做什么运营模式？你未必要做健康产业的生意，并以此来达到你晋升阶级的目的，但这不耽误你可以去了解一下这门生意。5，人脉很重要，要培养自己待人接物的能力，要培养社交技巧和能力错！最好变成：既然这么多人都想拓展人脉，那么高级会所，婚介，演讲口才培训之类的生意，是否可以了解一下？你未必要做天上人间妈妈桑的生意，并以此来达到你晋升阶级的目的，但这不耽误你可以去了解一下这门生意。6，有平时自住的别墅或公寓和度假屋，能把一线品牌的奢侈品当日用品来消费，每年两次可以不用考虑钱的旅游，可以比较轻松地养育两个孩子，并能允许他们自由地选择专业和未来发展道路。错！这种还是标准的“消费者”心态，钱是个好东西，可它不会从天而降，品味和优雅也是个好东西，但也不能平白发生，金钱带来的享受是很好，但这仍然不是开创者的心态建议改成：不要想金钱带来的享受，而是直接以金钱为目标，直接的目标就是金钱，享受可以不用考虑了。你所做的一切就必须是以合法的攫取最多的金钱为基本，如果仍然是以享受为目的，会让你的野心受制，而且会不断的掉坑，永远也做不到一线品牌的奢侈品当日用品来消费（这得需要很多很多钱，普通人一辈子也赚不到的钱）创造者是注定做不到像消费者那么优雅轻松的，你得扪心自问，是赚钱本身给你带来的乐趣多，对你的刺激更大，还是享受给你带来的乐趣多，刺激大，如果是后者，那么得彻底转换这种思考模式，因为目前没有任何一个创造者是贪图这种享受的。题主向往所谓的三级权贵富商，那么为什么不多看看他们的故事呢？王健林：三套西服是今年唯一消费关于雷军有什么有趣故事？ - 雷军（人物）为什么雷军的形象如此亲民？丁磊有哪些有趣的故事？ - 网易如果你稍微庸俗一点关注些这些“创造者”，你会发现他们的共同点都惊人的相似，即都是以事业和金钱本身为驱动，而不是以享受为驱动，很多这类已经达成题主目标的人，甚至不懂花钱，不会享受，有钱了以后需要别人教他怎么花钱，怎么订做西装，买什么手表而在赚钱能力不足的时候，就非常懂花钱，非常会花钱，对各种牌子如数家珍特别了解（本身还不是消费品市场的从业人员），这个对于年轻人来说是非常危险的事情除非你本身就是富二代，否则消费者思维根深蒂固的人，永远也不可能成为创造者，他们最好的结局就是为创造者打工，并且去购买和消费创造者们创造出来的品牌，乖乖把钱交给创造者们，让他们越来越富，自己始终饿不死撑不着。小镇做题家们应该如何自救？拓展学习的范畴就好​​来自上海的网友小明提问：奶爸你好，我在上海这边读书，机械专业，这个专业的出路非常糟糕，工作负担艰苦我能撑得住，但是收入实在太低，且基本看不到前途，我们班里一般的都转码了，也就是所谓的自学代码。我最近在网上无意间发现了小镇做题家和985废物这两个词汇，觉得挺有意思，想和您探讨下，您觉得农村的孩子真的就像这些文章里说的，缺乏什么眼界，观念，格局，见识，魄力么？这些虚头巴脑的东西真的有什么实际的用处么？答：小明同学你好。你提的问题非常好。小镇做题家根本不像各类文章里写的那样，缺乏什么胆识和魄力。因为胆识和魄力这种东西，没任何屁用，也根本说明不了一个人所谓的「能力」。​​​​如果你大学刚毕业，你爸就突然跟你说，其实爹地一直都是全国首富，这里有5亿人民币你拿去创业，如果失败了你来找我，我再给你5亿。一共就这两次机会，如果你都失败了，那不好意思，只能乖乖回来上班，继承家里的百亿资产。请问，在这种条件下，你会不会胆识过人，魄力十足？当然一定会啦。那这种胆识和魄力，对你的工作和事业有任何帮助吗？没有帮助，因为上一个一模一样情况的人，已经创业失败，败光的不是5亿，而是20多个亿，一度上了法院的失信人名单。所以谈什么性格，魄力，完全没任何意义。小镇做题的问题只在于一点：把能力欠缺变成感觉化，而不是冷静的把感觉变成能力化。什么叫感觉？就是容易想太多。自己穿森马飞跃，看到别人穿阿迪耐克，就觉得不是一个世界的人，觉得无法融入，觉得自卑被人瞧不起，觉得没法相处。工科生还好一点，最多只是焦虑沮丧和自嘲，文科生商科生法学生是这种无用的低级情绪的重灾区，长期陷于自卑和抑郁之中无法走出来。什么叫把感觉能力化？就是觉得自己需要什么，就朝这个方向去努力，哪里欠缺就锻炼哪里。所谓的小镇做题家，求的无非就是毕业后找到好工作，有殷实收入，那么就朝着这个目标去努力就行了。赚钱就是得靠商业化，商业运作需要懂产品，懂人，懂账，这三点能做到任何一个，都会是温拿级别人物，但是三点精通哪一点都比较困难，最好的是每一样都略微懂点，或者某两样懂的多点。一般来说三样全部精通的人是什么级别的呢？翻翻杰克韦尔奇自传，这本书的作者就属于三样都通的，基本都是大集团公司CXO董事长级别，被各大名牌商学院供奉着做案例研究的那种。懂产品，就是好好学专业，并且争取去学习，明白实际工作情况，懂帐，就是都阅读财务金融和经济知识，经济学原理，财务常识多看看，至于懂人，并非是社交，一定要融入圈子，这个主要是影响力的问题。影响力，最大的关键因素，是懂得如何表达自己。表达自己的场合包括且不限于：开会，演讲，辩论，吵架，主持活动，口才，写作等等。甚至自媒体拍短视频，都是表达自己的绝佳途径，如果说拍视频需要的道具太昂贵，那么写脚本，写文章，非常廉价，并不需要太贵的机器。应对这类表达的场合，我的个人的经验是，对于绝大部分人来说，文笔不是最重要的，逻辑和思维才是最重要的。对于我们中文母语来说，各种措辞，语句，词汇量，语气情态等等，都可以慢慢学，一辈子慢慢补充拾遗，这些属于零碎的闪光和幽默点，而真正最重要至为关键的还是整体的逻辑框架，相当于语言的系统。掌握了这种思考的方法和抓主题的能力，哪怕是用大白话也可以进行良好的表达并令人信服。在做自媒体运营写文章时候，如何让非常认同，感觉十分畅快，造成高传播率，很重要的一点就是把普通人内心的强烈想法，条理清楚的，不疾不徐的，有逻辑的表达出来，不需要什么文采，只需要明确清晰的框架，就能够获得极大的赞同。这个能力，基本上是任何有点能力的人的标配，当然，公开表达和私下表达，即时讲话和已备写作都会有很大区别，侧重点也都不太一样，都需要慢慢练，但是至少在某一个场合的表达方面，所谓的成功者其实都具备这种能力，这也是所谓聪明和智商的体现。培养逻辑和叙事思路有一个非常简单粗暴的办法，学英语，学到一定程度，大量翻看国外的GRE，GMAT等考试的语法和写作指南，并且照着托福雅思GRE GMAT国内四六级考研等各种考试的真题口语写作题目一一写几遍，跟朋友多讨论，可以不用英文，只用中文讨论，这么做能帮你的口才提高不少。不要小看这个能力，等你毕业了你会发现，这个能力比什么学历和专业都要重要的多。当你明白了这个基本常识，那么就可以有意识的开始努力锻炼自己了。去图书馆借几十本相关的书籍，认真看书，并且加以运用。参加辩论社，演讲社，私下里自己不断的进行即兴演讲和辩论的训练。我在大学时候，谷歌了几百条英文演讲的题目，每天早上起来抽一个，自己大声练习，录音，计时，听录音，纠错，改正，重来，一遍遍的坚持，有整整一年时间都是做这个工作，雷打不动每天两小时。做到这样的努力，何愁口才不好呢？顺便英语口语也练了。小镇做题家其实已经有了非常好的起点，起码智商很高，既然这样，何不放手一搏。在乎一些零碎的情绪，实在没太大必要。做事情经常半途而废怎么办？奋斗者更应该寻找同伴​​来自南京的网友小李提问：奶爸你好！英语学习中制定的计划经常半途而废，有时还甚感枯燥无聊，仔细想想从小到大，不仅仅是学英语如此，好像做任何事情我都是如此，非常容易半途而废，间歇性的雄心壮志，最多两三天就又沉沦了。最后恶性循环，不断开启项目，不断放弃，陷入自我厌恶的无限循环里，时间一天天浪费过去了，自己却毫无长进。作为了解您的过往经历的人，知道您也是从很低的起点环境里肚子努力到现在的，所以不知道您是否有过类似的体验和经历？当时又刻意的做过哪些事情去调整？希望奶爸能和大家分享一下。答：​​​​中国人相信孤独的奋斗者，经常讲那种一个人默默奋斗，力挽狂澜，独自一人进行阶级跃升的传奇故事。很不幸，不论是从心理学角度来说，还是从实战经验成果上来看，这种自我成长和修行的想法，都是彻头彻尾的错误的。看龙珠，孙悟空最开始奋斗不是独自一人，而是和小林，在武天老师的带领下一起修行，看火影忍者，鸣人有佐助小樱，有卡卡西自来也老师；看海贼王，路飞有Zoro，有山治，有乌索普，有娜美，有乔巴。看欧美的偶像片：心灵捕手→马特达蒙有本阿弗莱克十月的天空→一群小朋友搞火箭的故事卡特教练→一群小朋友打篮球蜕变的故事日本Jump的三大主题是，友情​·努力·胜利小时候不懂，以为这三大元素是割裂的，现在成年了回头看，这三大其实是紧密相连的。没有友情，没有同伴，孤独的奋斗和努力必然不会坚持下来，坚持不下来，必然无法走向胜利。奋斗是孤独的，所以奋斗过程中要寻找伙伴所以呢？合理的安排社交调剂，劳逸结合，和伙伴们一起奋斗，共同成长。这里需要注意的是1，不是你同学就是伙伴的，大学里垃圾的同学多了去；2，好大学也未必能找到伙伴，各有各的堕落；3，学英语去英语社团，找到投缘的，一起制定计划，一起努力，是最好的；4，定期社交，比如一周见两三次，或者一起上自习，坚持学习；5，如果是异性，就更好了，人身大事都解决了；6，定期去英语角使用英语虐菜，是我当年的兴趣爱好，可以刺激自己坚持学习，良性循环；7，如果身边找不到伙伴，那么就上网，比如微信群，QQ群啥的，但是老实说，傻逼也挺多的，可以自己组织一个小社群，十个人最多了，大家互相监督，鼓励，打气，这是最好的。​8，但是要合理控制自己玩手机和上网时间，把别的群都退了，只留这个群。以上，好好加油~附上我曾经的旧文：浅谈如何坚持不管学英文还是减肥，坚持都是很多人难以克服的难题。所有人都知道坚持很重要，但很少有人知道，哪怕是坚持，也必须讲究方法。今天不说如何学英语，说如何培养毅力，如何更好的坚持。这篇文章主要是因为看到了某位同学在我的豆瓣小组里的网络日志打卡帖，觉得很有趣，所以信手写两笔。原文是这样的：觉得自己很没用。。。累什么的都不是借口，你上午踩着高跟鞋逛了两个小时你特么不喊累，你洗澡洗两个钟头你特么不喊累，你在猫组潜水看各家猫咪的捷豹你特么不喊累，看几分钟音标你居然就睡着了，音标是催眠的啊啊啊？？？你妹！都不用奶爸骂了，自己就想狠狠骂自己​无独有偶，我想起来前几年网上非常红的自我警惕咆哮体，见下图这里面有减肥的，有考研的，有努力奋斗工作的，但是这么多年过去了，这些人成功了么？肯定没有，不然立誓的人那么多都成功了，我们身边的社会应该会更好才对。这类图片和自我辱骂给社会的唯一积极作用，就是让这些人现在回头看，感到满满的尴尬，无法直视自己过去的傻逼行为和言论。所以它现在在网上已经彻底绝迹了，再也找不到了。为什么绝迹了？因为没有任何屁用呗。这种自我辱骂和批评的激励机制是非常糟糕而且危险的，但因为我们从小到大都是被父母家长这么骂着长大的，所以这种自我辱骂似的自我监控还是非常普遍的，几乎每个打卡帖之中都能看到相当大量这类的文字，而一旦这类字眼出现了，基本最终结果往往是失败，因为它并不能成为一个很好的正面激励，只能是不停的给自己消极反馈，到最后就越来越糟糕。那么真正的正面激励和可以让你坚持下去的机制应该是什么样的呢？我和基友老陈讨论过很多次这类话题，最后得出了几个比较简易上手的方法和策略：策略一：用记事本来监控自己的学习流程任何长期性自我改造和自我学习的过程，都必须在自己的监督和跟踪下完成。如果没有这种自我的观察和反刍，肯定会失败，把这么一个长期的大计划仅仅交给你自己的毅力和坚持力，很明显是对自己的不负责任，所以做记录是非常必要的：减肥需要定期量体重、量尺寸，学英文也要定期做记录和反刍。最好的办法就是使用记事本，像美剧《吸血鬼日记》里面的文艺小姑娘那样每天写Dear Journal（亲爱的日记），记录下今天都做了什么事情吧。对自己的日记本倾诉，也是个极好的减压方式。我刚毕业的时候，因为工作压力大，记录了满满一大本的日记，现在APP功能强大，推荐各位最好在手机里面放一个离线笔记本，每当压力大或者想到什么好点子的时候，顺手记几笔，释放自己的想象力和压力。当然，做记录也是有技巧的，这个技巧有很多很多。这里，我们就把几条比较实用的基本技巧列下来供大家参考：（1）首先列出整体的学习计划，然后记录完成多少或者有什么新想法。（2）记录时间可以以天为单位，也可以两三天记录一下。如果工作太忙，那么周末至少要抽出一个小时，好好回顾一下本周的学习历程。等你过了半年或者一年，再看自己的周记，会非常有成就感的。（3）最重要的一点，要时刻记录下自己的收获和成就，把自己的英语水平时时都记录下来。在完成重大突破的当天，可以自己去庆祝下，并且给那一页记上书签，方便自己时时翻阅，达到自我激励的作用。​策略二：列计划的时候绝对不要自我期望过高从未有人指出过的一点就是：人的willpower（心智力量）虽然从本质讲和肌肉力量不同，但是模式和原理是差不多的。身体病了，我们要吃药看病，心理和情绪出了问题，大家就不知道怎么办了，甚至认为是自己的毛病。没有人一开始锻炼身体的时候就立刻把健身房全部的机械都加上，这样别说练好身体了，会直接把自己压死。同样的，很多人在锻炼心智的时候就非常不理智，没人注意过循序渐进，而是一开始就直接把大量任务往身上背，这跟你练身体时不慢慢增加杠铃重量，而是直接增加到最大量把自己压死是一个道理，所以心智也一定要合理、循序渐进地培养。几乎所有人都会在计划实施之前对自己认知过高，并且过高估计自己的毅力和行动力，所以那种考研、美容、护肤、减肥、塑身、男友一手抓，还要同时修炼气质、谈话技巧等类似的计划屡见不鲜。而这类计划也很容易半途而废，因为想要的太多，却没有足够的心智力量来支撑，你举不起来这么重的杠铃，当然就会失败了。正确培养心智的方法应该是首先选择一件最简单的事情开始坚持做，一段时间后形成习惯，不需要再耗损自己的心智力量了，这个时候再安排时间，做另外一件事。比如说，你希望能够养成早睡的习惯，同时保持学英语的习惯，那么前两周或者三周，什么也别做，只保证一点，每晚10点，不管什么情况，立刻上床休息，就是天大的事情和计划，也上床休息，第二天早起。等养成了这个习惯之后，再看看时间安排，把学英文的计划加进去。否则两手都抓的结果就是：英文学习搞到很晚，晚睡，第二天起不来，心情糟糕，自责，拖延，然后学英文继续搞到很晚，恶性循环开始……策略三：养成立即行动的习惯每个人都非常容易过于乐观地估计“明天的自己”，而没有把现在的自己抓紧——很多事情就都推到了明天或者下一秒。于是，拖延症开始了，因为未来在年轻的自己看起来似乎无限长，可等你到60岁时猛然发现，一事无成。所以，当你决定做某件事的时候，不要给自己找借口，列个计划都要好几天。事实上，所有计划都是你自己调节的，只需要花上5分钟写上自己要做的事情，然后从最容易的那件事开始做就可以了。一定要牢记一点：it’s now or never（现在就付诸行动）。later（之后再说）或者tomorrow（明天开始）之类的词在我们的字典中，其实等于never（永不开始）的意思。绝对不要再说任何类似freshen start（新的开始），tomorrow is another day（明天会是新的一天）之类的话了。从现在开始，永远都是从现在开始，你已经开始了自己的进程，It’s now or never, never tomorrow, and never next second!（现在就付诸行动，永远不要等到明天，永远不要等到下一秒！）策略四：要主动养成正面的自我激励模式长期性的自律性行为，大家应该更有意识地给自己正面的激励，坚决避免自怨自艾和自我辱骂式的监督模式。国外的数据也显示在充满正面鼓励的环境下长大的小孩比在充满咒骂环境下长大的小孩更亲近人、更容易和人相处，能力更强，人生更加顺利。一般来说，正面性的自我激励方法，需要注意这三个方面：（1）首先要避免“不要……”的口号，而应该说“要……”的口号做个测试，请你现在不要想象一头大象戴着个绅士帽，满面微笑，笑容猥琐地在天上飞。你失败了，因为你还是忍不住想象了。同理，当你喊口号激励自己的时候，“不要放弃”，其实就是不停地给自己心理暗示，让“放弃”这两个字在脑袋里面根深蒂固。你应该对自己说：“要坚持到底，要坚持到底！”根本就不要在脑袋里想“放弃”这个词。再比如，“不准吃零食”的口号改成“保持空腹感，保持空腹感，一日只吃三餐，一日只吃三餐”会更好些。所以从今天开始，就要把任何负面的口号和情绪全部都改成正面的！（2）使用沉溺性的自我奖励机制在你一开始列计划的时候，一定会意识到，中断计划的情况肯定会发生，但是绝对不要以此来自责，让负面思想充满脑袋，你需要做的其实很简单——建立自我奖励机制。阶段性目标根据大小，可以建立不同的奖励机制：比如说学英文，你可以说自己两周努力把音标学完，然后周末就什么也不做，去商场痛快逛半天，给自己买件衣服；比如说减肥，每天一个小时，坚持锻炼和控制零食，两个月之后，可以奖励自己一顿大餐，然后设定更高的目标，再去坚持锻炼三个月后，再来奖励自己一次；比如说财务控制，坚持三个月的记账之后，可以给自己买个一直想要的东西；比如说要每天坚持看书考研，但是一看书就犯困，这个时候不要责备自己，而应该换个思维，对自己说，这个下午我坚持把书看完，晚上就吃顿好的，我考上了，就给自己放一个月假，好好旅游。这种自我激励就代表：我要做好某事，然后就可以如何如何，而不是我不该做什么，一旦做了我真没用，真是狗屎。毫无负面情绪影响，人生过得才更加轻松，而且成长得更好，更容易完成自己的目标——这个才是良性循环。（3）要坚决杜绝自我辱骂式的良心谴责办法前文提到的自我咆哮体是最糟糕没有之一的方法。对一个开始养成好习惯的人来说，心智肌肉力量是很薄弱的，所以失败的情况都是非常正常的。最重要的是，你失败往往并不是因为自制力不强，而是因为计划得不切实际。一开始进行某种技能训练的人是不可能把所有娱乐玩耍的时间全部都排出去的，看着书睡着了的情况也是肯定会出现的，而自责、自骂只会加重负面情绪。而按照人类的天性来说，看着书睡着了其实是非常正常的，你只能接受，顺应天性，而不是自我辱骂和打击。如果你老是这么辱骂自己和自我咆哮，其实跟自暴自弃一样可怕。你的心智就好像一件宝物，你应该去小心地呵护它、灌溉它，这样它才能慢慢变得强健。每个人都应该珍惜和爱护自己，不管是身体，还是精神，而自我辱骂是不可能让你变得强大的。总结：四大策略：（1）保持记笔记自我监控（2）起始小期望，牢记循序渐进的道理（3）养成立即行动的好习惯（4）绝对不要以自我辱骂的方式进行激励，保持正面奖励机制以上就是简单的四大坚持的办法。为什么说富不过三代是个大概率事件阶级跃升很难，阶级下滑倒是很容易​​古代人的思想观念，很多时候完全不是我们以现代人理解的那回事。因为社会结构已经完全不一样了。比如曾子说过「修身齐家治国平天下」，这句话让现在众多有志青年们头痛不已，因为自己的老爹老妈经常拿这话唠叨他们，催他们赶紧结婚，连家都不成，怎么创业，怎么搞事业？从小到大听这句话我就一直觉得逻辑有问题，结婚只是私生活，跟事业有半毛钱关系？长大后看了比较多的历史书才明白，这是因为古代的那个「家」，和现代的这个「家」，含义概念完全不一样。古代人的家，尤其是贵族的家，那是一个生态完整的小型社会，有田地，有佃农，有仆役，有家规，家族产业就起码有上百人在打理。在春秋战国时期的「家」，更是不得了，人家那不是「小家庭」，而是封建领主，周王室把天下分封，封了几百个小国家，慢慢兼并成大国，大国的国君再把自己的国土分封出去，分给下面的大臣，这些大臣就是封建领主，有农田，有人手。更重要的是，在自己的封地里，还可以自己开设政府，有幕僚，有军队，可以独立收税。而家主为了考察自己的后代，会特意让他们管理经营一片土地，建设自己的产业，看成绩效果如何。这个所谓的家，其实就是自己的封地，你连自己的封地都管不好，你谈什么去管理整个国家，去治国平天下呢？这个所谓的齐家，跟结不结婚半毛钱关系都没有。明白了这个，一下子也解开了我长久的疑惑：看三国历史，感觉世家大族是最容易出人才的，荀彧和诸葛亮都是大族子弟，袁绍和杨修都是四世三公，司马家也经营多代。各个都是杰出精英，在历史上留下了浓墨重彩的记录。但是我们又有句老话，叫富不过三代。家境优越还努力，跟富不过三代，到底哪个才是对的？​​​​两者都对，但前者只适用于古代，而后者越来越适用于现代。这还是跟「家」的含义有关系。古代的家，都是大家，豪族世家，有人口，有经济，兼并土地，纳收田赋，俨然独立王国。哪怕秦始皇废除封建，大家族里仍然是可以养死士和庄丁的，说白了就是私人军队。在这样的家族长大，从小就接受最一流的教育，请来的老师都是最顶尖的，有家族私藏的图书馆，军政大略都可以直接学。但教育只是一方面，甚至不是最重要的，我们都知道最重要的是：实践和成长的机会。因为家里就是一个小型独立王国，10几岁就开始打理家族产业，管理家族事务，给自己老爹献计献策。而且大家族的后代众多，堂兄堂弟等等无数，谁当族长？从小就有各种竞争意识。因此你看古人的人才，会显得非常早熟，早早的就知道自己有做什么，怎么做，且有丰富的实战经验。其实不是古人早熟，而是现代人越来越晚熟，被弄的越来越白痴而已。小时候看诸葛亮陈登年纪轻轻就雄才大略，感觉不可思议，现在你让一个应届毕业生去给上市公司出战略和管理经验，不被骂死就不错了。可如果你知道世家子弟从小的成长环境，以及实战经验，十几岁就开始积累实战经验，把自己的小家封地管好，长大了无非就是向诸侯王推广成功经验而已，跟现在的应届毕业生完全两码事。你自然不会再感到惊讶。然而随着历史的推进，科举制的发明以及中央不断打压豪强的举措，家族规模尤其是这种独立王国，被分割的越来越小，家族后代得到锻炼的机会自然也就越来越少，小地主家庭越来越多，常年把时间浪费在四书五经上，而不是真正的军政策略技能，甚至安于享乐根本不尽心尽力从小积累实务经验，自然富不过三代的情况也就越来越多。这方面最典型的就是从晚清近代开始：李鸿章的大儿子李经方没啥才能，振不起来，搞复辟失败，退回隐居，二儿子李经述最得重视，可惜给老爸守孝时候就死了，三儿子李经迈陪大哥一起，事业失败。但总体这代人还算生活富足，开拓不成，守业有余。到了孙子辈李国杰，抽鸦片嫖妓，得梅毒，恶劣难改，败光了芜湖家产，之后还投靠汪伪政府，被暗杀。至于当时的全国首富盛宣怀的后代更糟糕，老盛有诸多全国第一的头衔，比如第一招商行第一制造局什么的，但是小盛盛恩颐就只有一个头衔了：民国第一败家子。同样早早染上鸦片，把老盛的公司弄的每况愈下，死时穷困潦倒，老年给自己家的别墅当门房。这种后代约等于白痴的情况，到了如今，达到了登峰造极，我们的家庭和社会是严重割裂的，学校教育和社会的割裂更加严重，奢侈化昂贵养子的方式从未有过。小孩从小到大一直生活在温室里，和社会完全脱离，毫无任何实际经验，一直到大学毕业，这样的人想不变成白痴，都很困难。和封建时代大家族的子弟们从小就进取心强烈，争夺家主之位，最次也要弄个独立的封地有自己的事业，这种小小年纪就早熟不同，现代的所谓的名门之后，再怎么培养，也几乎是和社会割裂的，要么是安于物质满足天生充满了愚蠢的优越感，要么是一张白纸对社会一窍不通幼稚浅薄。这样的白痴不要说再创辉煌，守住家业都是难事。那么普通中产和平民就会好吗？恐怕更加恶劣，集中化教育和人为强行制造社会割裂，受危害最严重的还是中产和平民的后代。这使得绝大多数人，都把宝贵的时间浪费在屁用没有的问题上，比如迷茫，比如到底怎么找到自己人生方向等等。其实从13岁开始人的抽象思维就基本开始形成，这时候就必须要积累大量的社会经验和独立处理事务的能力，但不要说中学了，就大学绝大部分人也是被父母当白痴来养，丝毫不动什么叫独立什么叫事务处理。这样的人被时间推着进入了社会进入了职场，怎么可能不懵？不躲避？不懒散？不恐惧？不慌张？有出息反而是个极个别案例。所以说，阶级跃升的通道狭窄，但阶级下滑的通道，可是宽阔且顺畅。为什么不会打牌的何鸿燊却能成为赌王？何鸿燊本人的经历，既不传奇，也不浪漫，甚至非常枯燥。更有趣的是，他本身很可能完全不爱赌博，甚至连牌都不会打。看何老板的履历，你根本看不到这个人有赌博的嗜好，甚至牌技可能完全没有，那为什么他被称为“赌王”？何鸿燊被称为赌王，主要是因为他从事博彩业生意，他是这个行业的大佬，澳门的大多数赌场都是他开的，仅此而已。能够创下这么大一笔家业，光是靠个人努力肯定是不够的，何鸿燊出生在那个亚洲经济腾飞，局势风起云涌的好时代，也正是借着时代的运势，拼命努力，最后几乎垄断了澳门的博彩业。何老板从少年时代开始就辛苦创业，20岁当贸易公司秘书，22岁成金牌业务员，26岁创立公司，做煤油和纺织品生意，33岁在香港开展建筑房地产生意，在1959年也就是39岁财产过千万成为富翁。那个年代的千万富翁，是真正的大亨了，但在这个时候，他仍然和“赌王”不沾边。机遇降临在1961年，澳葡政府规定博彩业须通过专营制度实施，也就是说，私人也可以开赌场了。那年何鸿燊41岁，他与霍英东合作一举拿下赌场独家专营权，随后兴建了多家赌场。博彩业也成为了他最来钱的事业，身家曾一度高达100多亿美元。在最狂野最传奇的电影世界里，赌神高进的身家不过是十亿美金，不到现实“赌王”的十分之一。跟电影完全不一样，他被称为“赌王”并不是因为他牌技高超，或者赢了什么世界赌王大赛。而是因为他抓住了好时机，做起了博彩业生意，开设了大量赌场，成为了真正的业界大佬。现实世界里很多人都觉得彩票和赌博可能让自己暴富，而讽刺的是，赌王却是标准的辛苦创业，勤劳致富的典范。我刚知道这个事情的时候，也是震惊的，啥，啥，啥？赌王居然可能完全不会打牌，甚至对打牌压根就没兴趣？后来仔细想想，赌王不赌，毒枭不吸，这也是非常正常的嘛。再后来，发现李嘉诚叫“塑料花大王”，也不代表他就是化工和机械知识特别丰富，而是说他卖塑料花卖的特别好罢了。再后来，国内的房地产业发达，出现了很多“地王”，也不代表这就是种地种的特别棒的，或者特别会盖房子的，是吧。在餐饮业的运营历史上，一直以来我们都有个问题，那就是为什么日本能够盛产各种美食之神？光是在东京就有江户三神的说法——寿司之神”、“天妇罗之神”、“鳗鱼之神”其中因为一部纪录片声名大噪的，就是寿司之神小野二郎了。那这个寿司之神，和我国的赌王有啥关系。有的人会疑问，难道寿司之神也可以跟赌王一样，完全不懂手艺，就能开饭店还能开到米其林三星了？你还真别说，还真有可能，最起码所谓的江户三神，不过是过度营销的说法。日本人对于营销的精通，可远远超过了他们在日料方面的手艺。大家想过没有，为什么中国就没有什么“麻辣小龙虾之神”，“烤冷面之神”等等说法呢？其实还是有的哇。我们有“豆腐西施”我们还有各类大王啊但是两相对比，为什么我们就觉得日本人的寿司之神，比较优雅，高贵，精致，大气。而国内的各种西施，大王，就比较土气，廉价呢？原因很简单，最起码在餐饮业方面，日本人比较擅长营销和炒作，而我们中国人的品牌意识和经营意识还不够强。日本的美食栏目和纪录片的口才不要太好，在他们嘴里就没有不好吃的东西，没有不高超的手艺，简单捏个饭团，能说的比火箭科学还要高深，烧菜用的火炉子，能说成是某个大师特有三十年才产一个，学徒学捏饭团，硬要人学个好几年。这种东西，不过是满足了小资群体自命不凡的消费心态罢了，什么炉子，饭团，不论怎么努力，不可能会有多高深莫测，这些不过是营销和包装话术而已，也真未必有什么三十年，反正你也吃不出来。大量冗长无用的仪式感，加过度吹捧的匠心，大师和食材，结合在一起，就是所谓的江湖三神了。反正奥巴马去吃了一回，没吃饱，飞奔去大快朵颐了一顿汉堡。你看，这就很尴尬了。小野二郎做寿司的确是很厉害，但是寿司这种美食，不论你怎么努力，它在味道上，也就是那个味，你不可能把寿司吃出澳洲龙虾的味道，更不可能吃出广告里那种什么特殊的泉水，三十年做一个的炉火，以及十年的捏饭团功力。这就是个寿司，非常简单的玩意儿。厨艺不论怎么修炼，终究有瓶颈，那到底怎么才能卖的好？想要生意好，那就必须疯狂营销啊。所以就发明了大量冗长的仪式，一个严格繁琐无用的拜师流程教学流程，加上铺天盖地的内容营销和品牌打造。配合上宰死人不偿命的价格，一个爆款成了。寿司之神让你以为，认真做一件简单的事，做十年，二十年，一辈子，做的比任何人都要好，你就能成功。但其实，对于某些事，比如寿司，你练两年和你练20年没任何区别，这玩意儿既不是弦理论也不是场论更不是啥火箭科学电动车核聚变理论，有啥可研究的，无非就是费点心罢了。真正出奇制胜的，是商业+营销。对于绝大部分人来说，非常容易被一个词所洗脑，哦不，是所感动。这个词叫“匠人精神”。日本人喜欢用在市场营销里的词，这几年在大陆也越来越流行，一开始我觉得就是个骗人的玩意儿，后来发现，其实我们每个人，或多或少，都有匠人思维。匠人思维是我们本能的一个思维习惯，那就是，坚持做某件事很久，做到最厉害，我就有钱啦！这里的矛盾之处在于，做某件事很厉害，是怎么和有钱这件事，画上等号的。认真读书，好好学习，考大学，考硕士，考博士，然后赚大钱的这种思维，其实就是匠人思维的变体。这里就有几个问题了：1，你认真做的事，真未必就能赚大钱，很多专业，比如xx，xx，还有xx，为了避免脑残喷，我就不说具体哪些了，你们开心就好，2，你认真做的事，确实能赚钱，但是赚钱机会太少了，或者成本太大了，比如搞肿瘤药的靶向研究，研究生物制剂，博士毕业后很值钱，拿个百万年薪也有可能。问题就在于，有人天赋一般，读不了名校博士搞不了高大上的发明，机会就那么点，怎么办？还有就是成本过高，真搞出头，至少都三十六七快四十了，忍不了，怎么办？你真的确定，要在这个匠人方向努力十年，集中精力，认真做事，做到最厉害，然后就能赚大钱了？事实上这个世界上没有任何事情是能够确保你就能赚大钱的。除了赚钱这个行为本身，也就是搞商业。匠人思维，就是我要好好学习，好好努力，读本科，读硕士，读博士，然后就能赚大钱了。而商人思维则是：我这个专业/行业，有哪些产品或者服务，这些产品有哪些准入条件，我能不能做，如果我暂时做不了，那么这些产品有哪些厉害的制造商，我怎么加入他们？他们的官网招聘有哪些要求，怎么满足？如果一时半会进不去，满足不了，那么我应该怎么调整计划和补足？工作一段时间后，积累了一定的经验，那么我还得考虑，我的人脉和资源，能够让我开始做什么服务或者产品，我怎么去包装和宣传他们，是否足够，如果不足够，我应该怎么积累和改善？这个，就叫商业思维。不痴迷于某种专业或者技能本身，而是想想，围绕这个专业和产品，有哪些企业，我怎么加入这些企业，未来我是否有可能也创立一家类似的企业。这个，就叫商业思维。所以很多医学生找我，奶爸，我读医只能去医院，怎么办啊。我的回答非常粗暴，根本不听也不安慰，直接报菜名：通用，飞利浦，西门子，辉瑞，礼来，罗氏！正如何鸿燊可能完全不懂赌术一样，医疗大王也可能不会治病，只是他开的医疗公司最大。我想我已经借着赌王这个案例，说的足够明确了。所以何猷君火了，你有没有必要学富二代的修养，教养，学术，读书，生活方式？有必要，但你学不到，这些没有任何参考性。你只能学富一代的爸爸们的商业思维，和实干赚钱，这个就一点也不浪漫，和优雅了，而是非常市侩，低俗，跟学历，颜值，身材，都不沾边。名校，优雅，颜值，那是留给你儿子的，不是留给你的。所以不要瞎跟富二代比努力，不要瞎看富二代报道，看到这些事，多琢磨琢磨他们的爸爸。这才是最重要的。跟渣男离婚后，如何养育孩子？孩子永远不可能跟渣男父亲学到男子汉气概​​奶爸您好，关注您的微博很久了，我也是您交际沟通训练营的第一期学员，想先向您说声谢谢，感谢您的倾情输出，带给我们这么多干货，真的真的都非常有用，经常会让我有种醍醐灌顶的感觉。这里是想请教奶爸一个问题，我是一个8个月男孩的妈妈，如果和老公离婚自己抚养孩子长大，有多困难？我在一家省属国企，年薪20w不到一点，海龟硕士，最近在准备口译的考试争取之后副业翻译。是这样的，今天无意发现了老公从2018年到现在的女票女昌实锤，有聊天记录和他自己录的视频，同时发现了他的网贷记录，金额不大但是借了很多app，而且三张信用卡都有欠款。看了您的微博，我知道出轨和网贷都是0次和无数次的区别，所以我想果断放手。唯一担心的是我这么做对孩子的成长有多大影响，尤其是男孩，三岁之后的教育更要以父亲为主，我该怎么做才能把他抚养成一个心智健全、有责任心有担当的男生？耽误奶爸您的时间了，盼复为谢！🙏答：家庭教育有一个基本原则。这个原则就是：没有完美的家庭教育。家庭教育不可能完美。你只能尽可能选择不怎么坏的家庭教育。止损，才是家庭教育最重要的核心原则。换言之：夫妻恩爱，爸爸厉害，母亲温柔，两个人一起给孩子做好榜样，一家人在一起其乐融融，固然是好的，但是单亲家庭，不一定就是最不好的。因为有一种家庭，是最糟糕的。就是夫妻某一方，吃喝嫖赌，五毒俱全，样样都来，还勉强维持着婚姻，这种家庭，对孩子是最恶劣的。绝对不可能教育好孩子。必须立刻止损！立刻离婚！所以你考虑离婚是对的。不考虑离婚，和劣质伴侣，劣质父亲强行在一起，才是脑残选择，更多时候是用孩子为自己的懦弱做掩饰而已。首先为你鼓掌！接下来我们来聊聊正题，单亲妈妈如何富养孩子，尤其是抚养男孩。​​​​在孩子的成长过程中，父亲的角色确实非常重要。因为一般的男孩子都想打败自己的父亲，所以潜移默化当中，会以父亲当做自己的行为标杆。但是如果没有父亲的陪伴，倒也不是完全没有办法。在孩子3岁以前，特别注意对孩子的信任感建立。因为这时候孩子唯一能相信的就是母亲。三岁左右的孩子能感觉到的自己跟别人的不同，但还不是特别重要。只要孩子的母亲时时刻刻都能照顾的孩子的情绪，让孩子相信母亲任何时候都会跟自己站在一起就行。只是要注意，别弄过了，变成溺爱。不是孩子要什么都行，而是哪怕拒绝孩子的要求，也要陪伴在孩子身边。比如孩子想要玩具，但是不能给买，和颜悦色说清楚，然后抱抱孩子，陪着他就好。3岁到6岁，孩子在幼儿园里会明显感受到父亲的缺失，因为其他小伙伴有。这时候要特别注意，尽量亲自接送孩子，建立情感连接。各种班级举办的家庭比赛，也要尽全力参加尽全力赢，让孩子感受到没有爸爸也一样能赢，建立孩子的自信。7岁到12岁，基本在小学度过，这时候特别注意孩子结交的朋友，这是孩子第一个朋友圈，他们的影响会超过父母。别让他多跟单亲的孩子接触，而是尽量跟乐观开朗的孩子，多邀请孩子来家里玩，让小伙伴们都感觉得他有个好妈妈。12岁以后，孩子的自我意识萌发，这时候要跟孩子建立相对平等的关系，尊重孩子的决定，哪怕觉得孩子提的要求不对，也要耐心讲道理，把双方置于相同的规则之下，让孩子明白自己做的决定自己就得担负责任。上高中以后，让孩子明确感受到你一个人把他拉扯大的不容易。但不要自己跟他说，而是让他感受到。这样可以培养孩子的同理心和仁爱之心。同时多引导他去关心穷人，尽可能帮助别人，这样孩子会有责任感。这些都做到，基本就能保证即使是单亲家庭，孩子也能心智健全，乐观勇敢，敢于担当了。最好的教育，永远都是言传身教。言传是为了塑造孩子的价值观，让孩子明理。身教是以身作则给孩子树立榜样，让他可以模仿。最后的最后，请各位母亲一定要记住：男子汉气概，并不是男人的专属。如果说男子汉气概指的是：有勇气，有担当，有事业心，工作认真负责，为他人着想。那么这不是男子汉的专属。而是一个优秀的人，就应该这样。一个好母亲，也可以有，或者说必须有“男子汉气概”。这位母亲，我为你喝彩，加油！为什么你就是遇不到贵人，没办法上升？预判和推理能力至为重要​​混社会，混职场，最基本的能力就一项：预判和推理。这是智人生物区别于动物的最基本不同点。深夜尽量不要一个人在街上行走，更不要进小巷子，一人在酒吧里千万不要喝醉。这些就是最基本的预判。在职场协同工作，沟通件交流，与人斗争的时候，从自己的行为和动作，将要从事的举动和项目，来推理出对他人带来的后果，他人因此可能有的反应，以及这些反应对自我的后果和影响。这些，都是预判和推理。这很重要。小白们在这方面一般有两种典型的错误：1，完全不知道还要预判，根本不会去思考还有什么影响和后果，想到啥，直接就说。完全不过脑子，也不动脑子。2，知道要预判，但拒绝预判，只沉溺个人情绪里。常见想法包括：好难，心好累，不想跟人打交道，好害怕，好恐慌，不知道要做什么。他们无法静下心，来认真分析和预判，并且将其训练成自己的常规思考工具。这个不叫内向，内向的人也是有预判能力的，只是他更喜欢独处罢了，但和人相处不代表他就不擅长。​​​​这个叫懒，蠢，弱。大脑不喜欢分析和预判，都已经生锈了。第一种大大咧咧的人，充满勇气，往往容易犯错，但犯了错之后，被社会教育了，明白要预判，不该自以为是了，往往能长个经验。从不懂，到懂，是可以的。第二种就很糟糕，基本没救了。明明懂，但是不想使用，懒得使用，或者拒绝使用，这类人被社会教育之后，就会沉溺在自我情绪里无法脱离，感觉自己抑郁了，好想死，最后会真的患上心理疾病和精神疾病。学习预判其实非常简单，但也没法一蹴而就，朝夕可成。只能慢慢积累。人作为社会动物，他的行为是讲究逻辑和套路的，哪怕很多看似没逻辑的古怪举动，仔细思考，其实都能找到背后的套路。你看我这篇文章，就把生活中的懦弱无能和风风火火的小白都分析的一清二楚，更不要说正常人了。按照基本的人情，风俗，常识，逻辑来推理，就不会犯大错。但人情，风俗，常识，逻辑，需要积累。换言之这个事情需要经验。比如如何拍上司马屁？如何拍客户马屁？如何讨女生欢心？人际关系和职场晋升，其实跟泡妞一样。是需要不断练习，不断积累，持续训练的。经验丰富的人，自然驾轻就熟，游刃有余，也就是所谓的老司机。经验不丰富，那当然就是处男了，啥也不懂，啥也不会。所以凡事不要着急，把所有场合都当成训练，慢慢来，慢慢积累经验，以后就会越来越顺利。不要着急，恐慌，惊惶失措，而是认真吸取经验，模仿他人，从他人身上学习。这个，就叫凡事多长个心眼。说一口流利的英文能给自己带来多少额外的收益？其实没啥收益​​来自山西的网友小F提问：奶爸奶爸，在中国，操一口流利的英文能给自己带来多少额外的收益呢？值得那么废寝忘食的学么……答：操一口流利的英文能给自己带来多少额外的收益呢？带来不了什么收益​​值得那么废寝忘食的学么？值​​​​我来列举几个英文好，赚钱多的例子：​1，外企的CEO，年薪千万以上，英文很好，但更重要的是，他的资历，背景，成绩，都很厉害；​2，全国销售总监，​操着流利外语和亚太沟通，但更重要的是，他的业绩是全国第一；3，SAT名师，一年收入一两百万，轻松松，英语固然好。但更多的，是靠他擅长教学，或者擅长营销。再来列举几个英文不好，赚钱多的例子：1，雷军，are you OK满天飞，财力，不用我说了吧；2，刘强东，宿迁English，财力，不用我说了吧；3，无数互联网大佬，都不会英文，财力，不用我说了吧。你会说，马云，李彦宏英文流利，赚钱了可马化腾，刘强东，雷军，钱未必少吧，英文也不好啊。可见英文水平就是个锦上添花的东西，不是雪中送炭，不是赚钱的核心你可能会说，英文好了，当高翻，老师，不是很赚吗？首先，高翻赚不了几个钱，还辛苦的要死；其次，当老师，想赚大钱，核心能力真不是英文水平，新东方名师的英语水平肯定比不上大学教授，但他比任何一个教授校长收入都高。当老师，最重要还是靠教学水平和个人品牌的营销能力。所以赚钱的核心是啥？是你的思维，能力，口才，行动力，韧性毅力，还有你的​专业技能。所以？对英文不感兴趣的就别学。对英文感兴趣的就好好学。有专业技能的，可以考虑学一学，锦上添花，没有专业技能的，最好还是学一学，因为这是成本最低的技能了。如何学好英语，这里有张思维导图：当代大学生最常见的致命问题来自东北的网友小红提问：奶爸，你好。我是辽宁大学的一名大四学生，女，本科保险学，目前保研到本校的金融学学硕，学校一般希望自己还能继续努力。想问研究生期间应该怎么规划？个人背景：本科期间参加过一次创业比赛，一直坚持学英语。留校继续读博是最后的选择，更倾向于就业。就业方向对财经媒体更有兴趣，但缺乏实习不敢随便说自己就一定要做什么。研究生还是在沈阳读书，实习单位和岗位很受限制，研二以后应该可以较自由地实习，毕业后的目标城市是可以去北京。希望奶爸能尤其在以下方面给出建议：1.本科参加过保险北美精算考试，是否需要完成剩下的几门考试？还是重新考CFA，填补自己在金融其他领域的知识空白？2.研究生期间想要进一步提升英语是否还有必要参加一些口语竞赛之类的比赛，还是争取把雅思成绩提上去就可以了？3.做事果断和认真选择或计划之间如何平衡？尤其是在对未来的计划并没有很明确的时候？4.感觉现在这个年龄不知道自己想要什么或者想要的东西是否现实，在选择或者做决定时应该用一个怎样的思维尽量避免走弯路？。希望奶爸可以点出我的个人问题，提出建议，感谢奶爸的一直以来的陪伴🙏答：这种学生看似优秀，其实是最令老师头痛最难教好的那种。优等生不用教，自己就能学好，差等生什么都不会一张白纸慢慢灌输也能学好。一知半解自以为是的，光是清除脑子里的错误观念，教师都要下去半条命。甚至有的人一辈子，也没办法帮他去清除脑子里的错误观念。比如这里提的问题：​​​​34太过宏大基本没啥P用压根都不用回答我们就不说了。只看1和2这个学生陶醉在两个问题中无法自拔：1，更喜欢长远规划，忽略眼前实事，2，更关注事情要不要做，而不是如何做。但其实，只要你分析下事情应该如何做，不需要太久，最多几天时间，就明白该不该做，先做什么后做什么。以三件事举例：学英语精算师CFA每件事，稍微分析下，就能知道每天需要几个小时，大概需要多久才能见到效果。这是最基本的项目管理和学习能力的思维本能。精算师和CFA我不懂，但是我去书店翻翻书，拿起来看看，评估下我的理解消化吸收能力，我就能知道，我每天几个小时，需要多久才能啃下来。然后我看看研究生的课表，打听下每天的时间，大致的时间规划就做好了。对于优等生，三件事可以兼顾，早上学英语，中午下午晚上搞精算和CFA对于笨人，只能一件件来，早上学学英语，精算师考了就算不错了，以后有机会再看CFA对于不上不下的人，就是狗熊掰玉米，觉得英语好，学两周英语，觉得CFA好，又学两周CFA，最后英语也不行，CFA也没考出来。啥也没学成。我们的应试教育做的如此之好，从小到大不断的强迫大家书本阅读和考试，为的是培养什么能力？最基本的学习和规划能力。遇到熟悉和陌生领域，评估自己的理解吸收水平和进度，做出时间规划。这是我们从一年开始到大学，整整12年时间，都在重复做的一件事情，也是最重要的一件事。现在你自己不去评估，去问一个外人帮你评估，这足够说明看似雄心壮志，其实懒惰无比，而且对自我的学习能力，也从来都没有一个基本认识——最后这点，是非常致命的。战略问题，判断方向，对于一家成熟的企业，一个成熟的经理人，是非常重要的，因为他们有了完善的资源和武器，必须要去良好的使用这些武器和资源。但是学生没有武器，没有资源，正是非常重要的打磨武器，积累资源的黄金时代，思考如何做，远远比要不要做，更有意义，思考下如何做，自然就知道自己是不是这块料，该不该放弃和该不该继续了，这才能做到所谓的心里有B数。不思考如何做，只思考做什么，选哪个，本质上来说，都是荒诞可笑的。要不要考研——考研不是你想考就能考上的，要不要考公务员——考公务员不是你想考就能考上的，要不要学CFFA——CFA不是你想考就能考上的，要不要练英语——英语不是你想练就能练成的。在思考要不要做之前，多思考怎么做，最后的结果，你自然就会知道，要不要做了。比如我从不讳言，我不考公务员和研究生，不是因为我觉得不应该，而是因为我缺乏学术能力和考试能力，时间稍微规划下，什么都不够，那就放弃。努力工作真的不怕“过劳死”么？职场工作的真相​​昨天写了篇博文，说想出人头地就得努力，就得把事业变成生活。工作即生活，事业就是一切。大家深受鼓舞，评论区很多同学都表示加班到半夜都有冲劲了。这让我不得不专门撰文，再次强调下，努力工作这个事，过犹不及。可以努力，但不要影响自己的个人健康。1，不要久坐，坐超过40分钟就站起来散散步，哪怕只有两分钟也是好的，2，多饮水，普通的矿泉水555毫升，尽量每天喝5瓶以上，自己那个矿泉水空瓶，接公司饮水机，没事就抿两口是最好的——这样还能不至于久坐，自动提醒你起来走走，不用非得在本楼层洗手间，可以去别的楼层，撒带薪尿，3，三餐要定时，不要大吃大喝，不要吃零食，如果刚毕业没钱，全家也是可以的，但要按时不过量，要学会排遣寂寞孤独压力，不要用暴饮暴食来排遣，4，一定要学会排遣恐惧寂寞孤独难过的负面情绪。那么应该怎么排遣和减压呢？​​​​排遣寂寞情绪和压力最好的方式就是社交，没有之一，哪怕只是找好朋友微信上吹吹牛也好，但是朋友不可能时刻和自己生活在一起，日常中的独处，孤单，寂寞，空虚，纠结，迷茫，恐惧，焦虑，担心，仍然一定要自己消化，没人能帮你。这时候我建议一定要有自己的兴趣爱好，比如看书，看小说，哪怕只是一点点都可以，再比如看电影，美剧等等，当然更推荐运动，体型正常的推荐慢跑和快走，超重的推荐买个速度球和手套在家打。人一定要有兴趣爱好，哪怕是韩剧也可以，无所谓高不高雅，这是调整你身心健康的良药。我阅读量大，主要就是因为这个，没有逼着自己看书，而是放松。5，加班可以，但一定要有度。我的个人原则：一定要有双休，不管什么样的工作都必须有双休，不保证双休绝对会对智力，工作水平，和身心健康产生严重的影响！劳逸结合就是工作日狠命干，双休日一天狠狠睡觉，一天用来出去游玩约会社交，没有双休绝对是恶法狠毒！丧尽天良！所有996的企业家都应该被钉在耻辱柱上，遭受万人唾弃，永世不得超生！普通的工作时间，尽量做到10点之前要下班，而且要有双休，双休非常重要，偶尔的11点下班可以理解，但是一周尽量不要超过1次，996，10106，007的工作，对于普通员工来说，是无聊无意义的，留着他们也是浪费公司水电和空气，这种作息时间只针对这几类人有效：1，中层以上。这些人的事情虽然多，但负担并不重，而且工作本身可以给他们带来成就感。心流这本书里写有人12点下班还能精神抖擞活力无限，给了一堆狗屁不通的理论解释，却忽略了一个最基本的常识，上班越上越精神，越来越活力无限，只可能存在于一个群体身上，那就是中高层，因为他们的工作是正向循环，刺激越来越大，今年搞500万的项目，明天项目汇报三千万，运筹帷幄，决胜千里，简直是做皇帝的快感。中国古代有几个皇帝也是出了名的工作狂，比如朱元璋和雍正，这也是因为他们的工作刺激回报足够大，不单单是因为毅力过强。中下层的工作，是没有什么正面快速的激励和回报的，举个例子：我每天拉下属出来训话，这种权力感本身就是工作的极大愉悦，普通下层员工，上哪去体会工作愉悦感？美剧电影里的工作狂，为什么能够成为工作狂，是因为他们从工作中就可以收获到身心健康，事业成就，丰厚收入，他们的办公室宽敞明亮豪华，工作一小时就可以运动几分钟，累了就可以躺沙发上小憩一会，饿了就吃点小零食，没灵感了就看看图画书，想家人了视频打电话，表面看也是007，全都待在办公室里。可他们跟底层小员工，有得比吗？更别提李嘉诚这种所谓的“工作狂”一直干到92岁了——10点进办公室，中午约人吃午饭做水疗+休息到3点，有空就回办公室视察一下，没空就去约人打高尔夫，晚上就邀请大佬酒会，到了10点看看书准时睡觉，天天如此，周六周日全年无休。这确实也叫工作，也是996，很多重要的项目都是在酒会上谈下来的，也确实需要耗费心力动脑子。但这种工作带来的压力，焦虑和挫折感，能有多少？跟普通顶层员工能比吗？别忘了，每个电影里的“工作狂”，都有1个以上的助理，为什么他们叫工作狂，助理的工作比她们更繁重，助理却不叫“工作狂”。2，底层职位，但收入待遇是行价的2-3倍以上。我刚毕业时候，程序员不怎么吃香，还不流行996，真正最吃香的，是金融和高端咨询。这些职位的行价是15-20万，当时大学生毕业平均3千，5千算很好，8千就是人中龙凤。而这些职位基本月薪都有1.5万了。也就是行价的2-3倍以上。那是真的要通宵和007，但即便如此，也只是周期性的，不可能全年都这样，否则真会过劳死。有项目，通宵一下，一两个月坚持坚持，没项目了，按时上下班，8小时工作日，下班玩，周末玩，劳逸结合。以前是高端的金融和咨询，现在则是互联网的研发和项目，但是后者更苦逼，因为全年无休。而且不要瞧不起这类岗位，你不想干了，几百个人都盼望能顶替你呢。3，底层职位薪资低，但有极大的提成刺激，比如项目销售，大客户销售，营销转化有一类职位几乎都是007，底薪也不高，刚入行甚至没有底薪。这类职位就是销售和营销类。这种其实是合理的。因为他们的工作本身就带有很强的生意和销售性质。做成一笔买卖，好点的销售都能有5%左右的提成，大客户销售的项目，很多都是以上千万算的，也就是一笔买卖就有50万进账，很多人一年做成两三笔买卖不是啥问题。这还是工作三年的普通人，都可能会有这样的机会。所以这种007也正常，而且他们的工作压力并不大，工作性质主要以拜访和社交为主，并不是什么文员工作。办公室伏案的长期工作，则非常不值。大致就是以上这三类。换言之，如果你现在的工作：1，没有提成点，不具备生意和创业属性，2，不具备高薪属性，3，不具备管理和权力属性，只是枯燥的伏案办公室对着电脑的文职工作，却还让你996，这种工作就是最糟糕最恶劣的。这种工作能够接受的底线是995，周末至少要给全了，让你休息，读书，社交，思考，回顾分析总结，你才能有前途，有未来，有出路。否则就是药渣，被压榨光了，以后就扔掉。怎么可能还会有什么前途和未来可言。996并不可怕，可怕的是996还事多钱少出路窄。性格内向天赋较差，还有没有可能赚大钱？精准分析性格和成就的关系​​做辅导老师尤其昂贵机构的辅导老师，最有趣的人生体验就是我们的客户基本都是同一类：生意做的很好，赚钱很多，做人八面玲珑，说话滴水不漏，但文化水平低，看不进书，看书就头疼，看完了脑袋空空如也。注意，这个文化水平和学习习惯，跟学历没关系。不论是学历高还是学历低，这一类人都有这种共同点。我在老家县城也遇到过很多这种人，都挺有钱，在生意上挥斥方遒。但是这些人，在自己的家庭上，统统都一筹莫展。说难听点，大丈夫难免妻不贤子不孝，女高管难免夫窝囊子无用。这是因为在外生意是有逻辑有规矩的，这个规矩就是利益，一切从利益出发什么都能搞定。但是家庭养育和关系相处，最不能看重的就是利益。不能看利益，就要看心理学和教育学，心理学教育学，就是个文本输入技巧练习的学科，他们就捉襟见肘了。这些人文化水平不高，赚钱很多，主要就是因为天赋性格好。天生性格就外向，屁股坐不住板凳，很擅长体会人与人之间那种微妙的氛围和感觉，更能轻易阅读出对方的微表情和心理活动，所以做生意赚钱混职场，无往不利。但让这些人去教别人，去复制粘贴自己的技巧，自己的能力，既然系统化规模化流程化集团化作业，不断复制自己的生意规模，他们就做不到了。因为没文化，不懂归纳总结，讲不出东西出来，技巧无法复制。茶壶里煮饺子，倒不出。这类人的小公司，都属于独强人公司，就是全公司上下，厉害的就他自己一个。团队都是智障，伴侣都很窝囊，孩子都是废物。所以你看，仅仅是天赋好，性格外向，天生擅长打交道，也是不够的。事业会遇到极大的瓶颈，家庭一塌糊涂。仅有天赋性格不行，还得有知识是有文化，善于分析总结归纳改善练习提升。看到这里你可能会疑惑，既然这样，我好歹也受了9年制义务教育，也考上了大学，觉得自己也有知识有文化。为什么我还是这么废柴，这么凄惨，连这些有钱的土老帽都比不上？原因很简单，因为你所谓的有知识有文化，只是你以为你有知识有文化而已。实际上，专门针对混社会这件事：你既没有天赋，也没有知识文化，更不擅长分析总结归纳改善练习提升。不要生气，这是真实的调查结果。我曾经对每一个因为社交而苦恼，因为内向不知道怎么发展自己的投稿，都问这些问题：一年看多少本新书，有没有搜过这方面哪些书比较好，有没有按照书来进行实践练习和提升。问了大概100多人，得到的结果无一例外都是：​​​​基本不看书，一年看新书不到三本，没搜过，没练过。所以我反复强调的：知识文化水平，和学历没关系。有学历的傻子和文盲，遍地都是。什么都不会，先天的天赋性格和后天的技巧修炼，都没有。那当然就很差了。那么，到底是先天的天赋性格重要，还是后天磨炼出来的技巧重要。答案很简单：技巧，技巧，永远还是技巧最重要。因为技巧可以复制，可以带出一整只军队出来。哪怕是天赋强的人，他也要多读书，多总结思考，把自己的技巧体系化整理出来。不论是马云还是咪蒙，都在公司开发过系统培训课程。这是所有大公司的必经之路。所以内心自私凉薄，刻薄乖戾，厌恶人类，讨厌社交，这类所谓的喜好和性格，重要吗？完全不重要。自私不喜欢为别人着想，那就学习技巧，普通人会在哪些情况下有需求，表达需求的时候会有什么体现和反应，为什么他们会这么想。多观察，多体会，多学习，发挥不了情商，就发挥自己的记忆力，努力多记住各种不同的场合和细节。久而久之，慢慢的你就会越来与擅长为人处世。这就是观察，学习，分析，总结，认知，练习，提高的整个流程。那么这个流程和读书有什么关系？不读书，全靠自己观察和学习，自学，难度太大，而且不系统。看书，相当于有老师带着，提前手把手喂给你，哪怕你不理解，记不住，以后遇到类似的场合，都会不断加深你的印象。所以看书，可以省事，提高学习效率，但如果你只看，看完了就忘，不实践，那也是没啥用的。推荐几本和赚钱领域相关的书：商业常识两套即可：《大败局》+《五分钟商学院》，沟通交流：《关键对话》，《非暴力沟通》上司关系：《参谋助手论》，《机关的机关》公务员：《大手笔是怎样炼成的》演讲口才：《故事思维》，《故事经济学》，《乔布斯的魔力演讲》（这方面不要看ted出的书，ted出的演讲类书籍非常不好，想练好口才绝对不要接触他们的书）外企生活：《杜拉拉升职记》，《做单》，唐骏全系列（此人争议较大，批判性阅读）逻辑思维：《学会提问》，《金字塔原理》销售+营销：《销售就是要搞定人》，《超级符号就是超级品牌》（华与华的全套都推荐）公司管理，团队领袖，掌控人心：《君主论》，《长短经》，《韩非》+彼得德鲁克本尼斯。大致就是这些。请大家常看常新，实践运用，反思提高。未来会越来越好。愿人人有书读，人人有钱赚~讨好型人格和极度自卑者如何成长？想清楚事情自然就能放下。​​​如何判断自己是不是讨好型人格或者全方位的极度自卑缺乏自信。1，学龄前是否有过印象深刻的无来由被父母打骂，甚至虐待的经历？2，被打骂的时候，戾气报复心理是否基本没有？3，被打骂的时候，无助恐慌的心理是否占了绝大多数？4，从小到大得到的表扬和鼓励是否很少？5，成年后是否经常难以拒绝别人？6，成年后是否经常有无理由的希望“孝顺父母做好人”的想法？7，成年后进入到一个陌生环境，任何一个环境，是否会觉得比较强的紧张和焦虑？以上7项每项为1分。得分超过2分，基本是比较严重的自卑人格，得分超过3分，基本可以确定为讨好型人格。讨好型人格，全面自卑心态的养成，主要在于学龄前，孩子最不懂事的时候，长期处于恐慌害怕的生活状态，导致成年后心理没有安全感。马戏团驯服小象，用的是一条普通的铁链子，象的力气小挣脱不了，产生恐慌，等象长大了，力气粗壮，稍稍一挣脱，链子就断了，但它绝对不会这么挣脱。为什么？因为物理上的锁链很容易挣脱，但是心灵上的锁链很难挣脱。对于讨好型人格的同学来说，心灵上的枷锁，就是小时候的恐慌，害怕，缺乏安全感。这导致他们长大后，遇到外界的任何人或事，哪怕是个傻逼混账，第一本能反应也是想着去讨好他们。不要觉得讨好型人是弱智低能，这种人可能很优秀有很多优点。但因为该死的性格弱点，没办法发挥自己的优点，更没办法自我成长。本文主要提出一些切实有效的方法，挣脱你心灵上的锁链。1，因为家庭感情的缺失导致成年后人格偏差，想要让自己的人格更完整，情绪变的更平和，最好的方法，就是生个孩子，然后和ta一起成长。这相当于童年重现，这是最好的方法。但对于大部分人完全没有可实现的条件和前提，甚至年轻人过早的生儿育女，容易跌入内卷陷阱，只会让情况更糟，不可能做到理想的童年重现。因此只好pass2，因此需要看看第二个的方法——获得一个安全感的环境，得到无条件的爱意。也就是爱情。这个基本等于痴人说梦，实现难度比第一条更大。自己都人格缺失，却想要得到完美恋人，基本不可能。以上两条是纯理论性的，完美条件下给出的方法，基本没有可实现性。以下是具有可实现性，但是没那么完美，只能大幅改善提高，但是很难彻底治愈的方法。​​​​1，硬着头皮打破锁链一次，从最简单的拒绝开始进行练习。马戏团的小象如果挣扎想打破锁链，得到的就是一顿打，无助又恐惧，小孩子如果想打破锁链，得到的也是一顿打，无助又恐惧，但是如果成年人想打破锁链，得到的会是什么？什么也没有，什么也不会发生，得不到任何损害。想清楚这个，就不用害怕拒绝别人。所以一定要从最小的小事，练习拒绝别人。练习要循序渐进，不能一上来就挑战高难度。比如你拿董事长拒绝，董事长让你周末去给他擦车，你说no，那你惨了，起码三个月没收入，比如你拿辅导员教导主任拒绝，让你周末去订文件，你说no，那你惨了，评优奖学金估计啥的都没了。要从最普通的，惹得起的同学开始练习。同学让你订饭，你可以带也不可以不带，那就想个借口：抱歉，待会我直接去自习室，不回宿舍了，你找别人吧。同事让你带个东西，你可以带也可以不带，那就想个借口：抱歉，在外面很忙，实在没办法，你找别人吧。注意，练习的场合不是说你不想带，敢怒不敢言，或者你物理条件实在没办法帮忙，或者被逼的必须帮忙。这种不叫练习。最好的练习场合，是薛定谔的状态。即，给别人帮忙，你可以做，也可以不做的时候，拿这个场合来练习拒绝。只要你拒绝了一次，你都会神清气爽，感觉原来拒绝别人这么爽啊。从人际交往的角度，我们肯定鼓励大家做好事，多帮忙，但是这个练习非常重要，这相当于人格自尊的重塑。刚开始练习时候，3-7天内，至少要拒绝一次，也不用太多，拒绝个五六次，你就理解这种感觉了。欺软怕硬练习法，超爽的。2，独立生活，和父母保持冷漠，一个月最多一次电话不到。接受这种家庭的残缺，淡然处之，内心接受这个事实。3，怼自己朋友一两次，如果能怼班干部就更好了。现实中怼人，而不是网络中的吵架，对于养成强硬，独立，自强的性格很重要。但一样，要循序渐进，没事怼老师，上司，老板，那是找死。拿班干部下手最好，尤其是跟你关系好的班干部。如果已经毕业了，那就拿朋友开刀。注意，不是吵架，不是生气，而是表达对他的观点的反对。要心平气和的交流和讨论，反对他的意见，而不是破话你俩的感情。不用太多次，一两次就行。4，转变思维，发展能力和实在的业绩为主，而不是在乎身边人的意见。给自己列下3个左右的目标，短期内可以培养的能力或者事件。然后全力以赴的去做，如果有人说三道四指手画脚，你觉得难过，愤怒，都行。但是千万不要停下脚步，硬着头皮坚持下去。直到做成了，哪怕只是一件事。做成后，你就会明白，只要能力足够，和身边人保持关系冷漠疏远，其实不会有什么影响。不用恐惧身边人不喜欢自己。以你完成的最小的目标作为杠杆，支撑自己的勇气和信心，循序渐进去设立一个更难点的目标。慢慢的，逐渐升级，能力提升。当你做到了以上四点后，会觉得自己的软弱本质的外面，多了一点坚硬外壳，很不错。这只是最简单的第一步，后面要客服的问题还有很多。人嘛，总要struggle，和自己的性格缺陷斗争是一辈子的事，放松心态，接受自己的不完美。年薪百万却仍然活得焦虑恐慌，怎么办？铁饭碗不是在一个行业吃一辈子饭，而是在哪都有饭吃​​看本文前请设置特别关注「恶魔奶爸」，方便第一时间看到更新。来自深圳的网友小黄提问：奶爸您好！替我先生提问，他在承担现有家庭负担下的职业道路选择问题。家庭情况：夫妻均30岁整，坐标深圳。本人教师，年税后30w；先生，菊厂研发，年税后60。深圳月房贷支出等于我的工资，三线城市房产一套做家庭意外支出，小孩一名2岁。诉求：先生长期9026工作时长太辛苦，绩效优但影响了健康和家庭。写作能力较差。选择1：在菊厂坚持争取到40岁可退休，有过35岁被裁风险；2：直接辞职考公，成功几率不大；3：换公司，薪水减1/3，工作时长996左右，减负不明显；4，其他。请求奶爸赐教，不胜感激。答：HW税后60，税前那是标准的年薪百万了。年薪百万仍然紧张焦虑，按道理讲不应该。但也很正常。我有个好几个哥们，在鹅猪狗厂之类的地方，也是年薪百万。然后最近有个大新闻，有个网站叫91，上面有个夯先生，犯事被抓了。他两年时间约了100多个女孩，偷拍视频，上网贩卖牟利，被判了10几年，被记者问为什么他能得手100多次的时候，回答说因为自己是外企高管，年薪百万，出入各种高档酒店，飞机头等舱候机室，所以经常能约到漂亮的酒店实习生大学生和空姐，有时候公司活动还有会议，所以还能约到模特。而且不是自己主动，而是这些漂亮妹子跟他搭话。看完这个报道，几个哥们跟我谈起这个事，大家都陷入了沉思。除了我以外，他们每个工资都比夯先生高，长的比夯先生帅，为什么就是生活质量完全不一样呢？一个是幸福的泡妞人生，另一个则是底层屌丝加班狗。这让我想起另一个哥们，在陆家嘴当个中层经理，也是年薪百万，他跟我说自己的工资倒在其次，主要是福利不错，住房补餐补交通补七七八八不少，比如吃饭，光是饭补每个月就过万了，补贴七七八八加起来一个月报销额度3-5万，所以他的年薪百万基本等于不花钱净入，每年净剩60万。我就问了互联网圈的那几个哥们，你们有这福利么？纷纷回答有个屁！出差妈的都是锦江之星的标准！这个，就是问题的关键所在。​​​​插播一下：9026指早上9点晚上凌晨2点，一周工作6天，比996更狠。当然华为给的薪水也足够，没得讲。一样都是这个作息，为什么王健林可以凌晨4点起床，身体没影响，你这么工作身体就完了？为什么李嘉诚每天工作16个小时，身体没影响，你这么工作身体就完了？为什么刘强东可以吹嘘地板上的闹钟，身体没影响，你这么工作身体就完了？是因为你的精力不如大佬吗？错了，是因为大佬的工作节奏跟你不一样。富豪都喜欢夸赞自己很勤劳，日理万机，只不过他们把娱乐活动也算作工作——或者说，这种娱乐，就是他们的工作。李嘉诚早上6点起床去高尔夫球场和亿万富翁老友、自家公司高管或潜在生意伙伴打球。10点到达位于长江中心的办公室，第一件事就是阅读秘书早已准备好的各份报刊浏览要问，然后开始一个个电话通知高管，交代当天的企业任务。到了11点半，做个按摩。下午1点吃个午餐，继续工作。下午5点可能继续做个按摩。晚上6点左右和生意伙伴吃饭玩牌，晚上10点睡觉。和老友打球打牌谈生意，就是他们工作的主要内容，而且这很重要。如果马云不陪以色列总理打牌打球，阿里巴巴在以色列就铺不开生意。这种看似轻松的工作背后，是自由的时间和宽松的办公环境。把大佬们往下降一级，公司的管理层，同样如此。独立办公室，困了就打个盹，饿了就让秘书订餐，身边有人拎包。一线的程序员就很惨，那种工作环境类似养鸡场，跟职业高管不能比。以前人说，白领工资不过万，摊煎饼果子，富士康工人，家政月嫂都可以过万。所以为什么还要当白领呢？因为白领的工作环境在空调房，而且还可以休息，摊煎饼果子，富士康工人，家政月嫂的工作环境完全不能比。现在拿互联网行业的底层程序员和传统行业的商业高管比，一个道理。一样都是年薪百万，为什么我的朋友们过如此苦逼，而夯先生们却可以轻松松到处随便玩女人？因为工作环境和工作内容差太多了。更重要的是，管理层是增值，但是底层程序员是在贬值。管理层为什么很宝贵，不需要担心35岁被辞退？因为他们是派活的，管人的，而不是亲自干活的。能把活派的好，把人管的好，才是一种稀缺能力，无法替代，但是一个底层程序员，一辈子只做一个模块，用到中年用废了，随便找个借口开了，让年轻人上。这种情况是好事还是坏事？当然是好事，因为在没有互联网行业之前，底层技术员，普通员工，奋斗一辈子也没机会上去，更不可能拿到年薪百万。现在最起码底层的技术员拼一拼，还有点出路。但这种好运气，造成了两个问题：第一个问题就是，很多人因此心里没有B数，认为赚钱都是靠自己，而不是行业的东风。一样都是底层，传统行业的小兵，只满足于能买套房就够了，但是互联网的底层小兵，却自认为自己是中产阶级了，不仅要买套房，还要买两套，还要在市中心核心地段买，买贵了，房贷加的高高的，孩子还要上优秀幼儿园。一边心有惴惴朝不保夕，然后还要房贷过几万，孩子再去念十万的幼儿园。这样的结局一般就是把自己逼死，跳楼。所谓的年薪百万，其实不过是一种假象，真相就是自己和富士康加班加点才能月薪过万的工人没有什么本质区别，那么欲望就应该小一点，首先就不该买太大房子，其次更不能买两套，孩子也不应该上太好学校。尽可能快的把房贷供上，什么都搞定了，没压力才是最重要的，当前的首要目的是守成，而不是突破。对于年薪百万的人来说，减轻压力，让自己生活不变差最好的方法就三个：1，不要让老婆不工作，2，买小点的房子，3，孩子不要搞太贵的教育不要自以为自己是成功人士中产阶级，你算个屁。听我一句劝，不至于让你把自己给逼死。然后是第二个问题，傻逼们因为运气拿到了高薪了，却失去了传统最基本的职业规划常识。一般的传统行业职场底层，刚入行薪水4000，他们的想法无非两个：1，好好混，增值，增加资源，往上走，当经理，当总监，年薪百万，2，努力增值，等到有机会，自己跳槽出去，做生意，创业。这两种都是正确的职业规划常识。但是互联网行业的人，刚入行就拿到了40万以上年薪，想的却不是升职。而是维持。一旦思维陷入到维持的窘境里，这职业道路就很危险了。以前西门子飞利浦微软刚进入中国的时候，月薪8000招了一堆维修工程师，这些人给公司干了20年，现在月薪也就一万没啥变化，但是都很满意，很开心。现在的BAT华为这类公司，其实不过是把这套东西复制了一遍，只是它们做的更绝一点罢了。作为员工，已经拿到了这么多薪水，却盲目焦虑，盲目乱搞，失去最基本的职业规划常识，是极度愚蠢的。什么叫职业规划常识：1，财富富集和不可替代的岗位，永远是业务部门，而不是技术部门，2，技术永远是商业工作的第二位，资源的积累才是第一位的，3，什么叫资源积累，即结善缘，得善果，广交朋友，4，工作的第一要务不是保住眼前工资，而是想尽办法去升职，如果升职停滞，那么应该不折手段想办法去业务部门，5，知道自己缺什么就补什么缺少沟通表达能力就想办法多练，缺少和人打交道能力就多练！这才是基本常识，而这位题主的老公却神奇的绕过了所有常识。逃避的只有工作，却没想过逃避欲望，争取的只有金钱，却没想过争取职位。从某种意义上来说，华为太实在，惯坏了这帮人。如何识别出一项工作的好坏和前途？先把3个JD贴上来，简化一下：工作1，某灯泡照明公司的市场部实习。国际No.1 照明公司！急招！市场部实习生一名（marketing intern）实习内容：1、协助产品经理下一些样品订单2、帮助产品经理邮寄一些商务样品到世界各地3、维护 TOOLIP样品信息数据库4、作为产品经理和供应商之间联系的纽带， 处理一些日常事务岗位优势：跨文化国际交流环境全面系统的人才发展体系充满活力的专业团队多语言工作氛围任职要求：1.需要认真细心，应变能力强，英语专业优先。2.每周工作2至3天，任期6个月（留用时间长者可优先录用）工作2，某纸巾品牌的市场部实习生。中国通路市场部实习 优秀可留用工作内容：1、该职位支持贸易市场部开展日常经营活动，主要负责数据的收集和分析。目标是让TMKT更多地关注业务机会，而不是运营工作。2、下载、整合和更新各种数据和报告，进行基本分析，并与相关利益相关者沟通；3、负责所有的文书工作。帮助填写各种内部/客户格式；申请并跟踪采购订单申请批准/签署招聘要求：1、本科生在读（专业不限），能提供3-5天工作日2、细心，好学3、有独立完成项目的能力和责任心，对社交媒体和流行趋势敏感工作3，还是某纸巾的市场部实习生全球健康卫生护理领域的领导者。年销售额逾180亿美元.产品销往超过175个国家和地区。工作内容：1、协助产品经理逬行产品管理和系统维护，全面了解市场部的工作2、与公司其他部门沟通，保证项目顺利进行。能提升个人沟通技巧与团队协作能力3、与外部agency对接，沟通宣传物料设计等事宜。4、参与市场线上营销活动前策划和执行，提高marketing sense工作要求：1、聪明，靠谱，有责任心2、对95后潮流有sense和自己的认知3、本科研究生不限，专业不限4、能连续任职6个月以上的优先，过去有FMCG实习经验的优先我提的问题是：上面三份工作，哪一份最有前途，最能学到东西，哪一份最垃圾？标准答案是312:工作3最好最有前途，最能学到东西，工作2最差最垃圾，自毁前程，工作1还可以，不好不坏，不算太过。如果认为工作2最好的同学，可能是职场天赋和工作天分有点问题，需要留意这个的。当然没关系，因为我天赋就很差，基本全靠后天自己琢磨。在正式分析答案，解释为什么标准答案是这个之前，我们得必须明确的搞清一个概念。到底什么叫工作能力？这里的工作特指商业工作，和体制内晋升，学术研究无关。有的人说，工作能力就是能赚到钱，做事靠谱，有时间观念，按时提交结果，社交能力好。对，没错，这些是都挺好的，但这些能力之间的逻辑关系是什么？是否存在主次关系和递进关系？什么样的能力才是核心能力？做事靠谱，时间观念好，是不是就一定能赚到钱？更深入一点，赚到钱的确很棒，可问题是，到底什么能力决定了是否能赚到钱呢？大家可以思考下这个问题：到底什么叫工作能力？然后再往下看。说一千道一万，所谓的工作能力，就是一句话：​​​​深入并且准确的了解到这个社会和市场的真实需求的能力这个能力更进一步，高一个等级：可以创造，激发出社会和市场庞大需求的能力这两个能力，就是所谓的工作能力，其它的一切什么拍马屁也好，时间管理也罢，统统都是在这个能力基础上的附庸。少了这个能力，其它方面的能力越强，人就越痛苦。因为不了解需求，你就没有方向啊。而这个能力，尤其是第一个了解的能力，恰恰是几乎所有大学生，和大部分职场人都没有的能力。那么应该如何培养这个能力？从实践中观察，分析，思考，学习，总结而来。那么什么叫实践？实践不是运用，商务实践和工作不是运用你的知识技能。大部分人其实就会个应试教育，压根没啥知识和技能。实践，其实就是对真实商务信息的接触。实践就是接触。在接触中，你才有锻炼和实践的机会，才会慢慢提高，才有了知识和技能。当然这只是外部因素，内部因素同样重要——比如有很多傻逼，哪怕给了他再多的帮助和实践的机会，他还是啥也学不会，啥也学不到，只会抱怨工作差，学不到东西。所以到底应该接触什么？所有的工作，只要是商业工作，都一定会接触五大因素：1，接触流程，2，接触事务，3，接触数据，4，接触人，5，接触导师。这5大因素里，最重要的是什么？4，接触人。商业工作就是和人的工作，不论是内部同事配合，还是外部的客户商，供应商，渠道商的交流沟通。只有不断的和人接触，和真实商业社会的人打交道，你才能潜移默化中，慢慢培养出对市场，对社会，对人性的需求的察觉能力。不和人打交道，只靠教材，数据等纸上谈兵，说实话，除非你是天才，否则不可能培养出这个能力。对于实习生和新人来说，除了接触人外，还有一个非常重要的因素，那就是5，接触导师。导师当然也算接触人的一种，但是导师是一个额外的重要因素。有了导师，就能加速的提高自己的工作能力，没有导师，当然也可以提高能力，但这里就真的变成了天赋大比拼，天赋好的人，无师自通，天赋不好的人，没法自通，哪怕在好的工作岗位啥，一样啥也学不会。9成9以上的职场庸人，都是这么来的。活活糟蹋浪费了好工作好机会。喜欢看我投稿案例的人，肯定明白这是咋回事。接触人，实践锻炼有了，导师也有了，还需要什么？1，接触流程，流程的各个环节有各种不同的人，挨个见一面，全方位对市场的了解就有了。有了这三个，接触事务就是理所当然的事情了。最后说说接触数据。很多人认为，数据是个万能的东西，非常牛叉，科学，精准。我想问问你：你不了解市场的真实需求，一无所知，没有导师带过你，培训过你，你没接触过整个流程，没有宏观概念，了然于胸，你没接触过各方面的人，和人打交道一窍不通，你没接触过太多的工作事务。在这种情况下，你接触数据，你想得出个什么结果？你能靠着看数据就精准的监控市场，了解需求？你能一毕业就靠看数据得出精准战略，分析出正确结果？想多了，各位老弟老妹。纯粹的靠数据来管理公司，分析结果的人，是完全不存在的。CFO CEO也不行。主要依靠数据来进行公司管理，业务管理，结合人，事，流程来下判断的人，的确有。各大CFO CEO，部门团队的领袖，都是这么做事的。问题是，高手这么做事，是因为他能从数据上看出东西来，得出干货来。你刚毕业屁都不懂，直接就做数据工作，你能看出什么？说是数据的收集，录入和分析。其实说白了，就是做表格，做PPT，录入数据。这种工作有个几把毛的前途？能学到个几把毛的本事？当然，我们要承认，特例肯定存在，还是有天才的。内因和外因都很重要。我们这里只讨论外因，而且外因不可能百分百决定以前事情，只是说大大的提高成功的概率而已。所以，工作3，市场实习工作。要接触产品经理，接触导师 ✔️要同事沟通，和agency打交道，接触人 ✔️要跟整个流程，接触流程 ✔️有了导师，人，流程，那么事物和数据，是自然而然一定要接触的 ✔️5项重要因素，统统都有。工作3最好，能学到最多东西。工作2支持整个市场部，没有明确对象，换言之，没有导师 ✘基本不接触人，只接触数据 ✘这种工作，看似科学缜密光鲜，但是大致上，基本就是枯燥无聊，而且市场部那么多人，随便谁都可以来颐指气使一番，处处受气。工作累，受气重，浑身难受。一项优势都没有，垃圾。工作1要协助产品经理，接触导师 ✔️要给供应商发货，接触人 ✔️只负责一小块，不接触流程 ✘所以工作1，不好不坏，只能算尚可。希望我说的足够明白了。更希望大家严格按照这套分析方法，去分辨好工作坏工作。找个清闲的工作，业余时间做做副业，能有多大出息？奶爸你好，本人师范小学数学专业毕业生一枚，前段时间一直迷茫，现在自己对人生有了一个初步的规划，想请奶爸给些建议。目前有两个方向可以选择：一是私立学校，地方比较好一般是大的区县里面，工资比公立学校稍高，但是压力比较大，留给自己充电学习的时间很少。二是公办学校，目前只有通过公招考试进去，一般只是区县的乡镇，但是压力比较小，只是乡镇地理条件不是很好。另外我有几个爱好就是英语和旅游加摄影，英语水平只是在6级，摄影在大学时期拿过奖项，我现在想选择乡镇公办学校，压力比较小，在做好本职工作之外，利用业余时间自己好好提升英语和摄影水平，在寒暑假多出去走走，以后也想用这两个爱好发展副业，这样的想法合理么，或者奶爸有更好的建议么，谢谢答：​​​​单纯只说工作，​分三种：1，在工作中就能让你学到很多东西的，使你进步的。这是最好的公司和工作，一般这样的公司包括宝洁，强生，通用，西门子，飞利浦，网易等等，公司内部不仅有培训，而且有导师制度，固定会有一个老员工免费带你，你去问问题，迫于公司制度必须回答，手把手教你。当然即便是在这类公司里，仍然可能学不好，因为公司指派给你的mentor可能是个傻逼，毕竟傻逼的概率始终会有，任何地方不可避免，但是因为这类公司本身足够强，所以可以和别的同事偷师学艺，仍然是极好的。2，工作本身不能让你学到东西，需要你发挥输出，而不是让你在工作中输入的工作。比如私立学校，本身上课是掏空自己，必须课下自己输入提升，但是没有时间，每天都要上课，时间一长，不能可持续发展。新东方等大牌机构，对新人老师也是这样的，一天十小时，压榨。相对来说，四大等财务金融机构就好多了，工作本身能学到东西你想考CPA CFA，还会给你发带薪假期和考试费用，让你慢慢准备。注意：工作5年后，你遇到的几乎所有工作，都需要你发挥，而不能再让你学到什么东西了，因为你所学的基本差不多学到了，这时候最需要的就是发挥和输出，如果想真正学到什么，就要靠悟性和坚持自学了，比如考GMAT去商学院，比如自己反复琢磨业绩和流程细节，慢慢升职不断提升自己。这个时候公司的培训制度和mentor制，对你没啥用的，而且你作为老员工，反而要培训别人。这一点一定要牢记，学得到东西的工作是少数，学不到东西，让你发挥才能做贡献的公司，才是多数。所以想学东西，一定要注意自我提升，不能处处等公司，等培训，等领导，等上级3，本身学不到东西，但是空余时间多的工作，可以让你大幅度的发挥个人兴趣爱好。​爱因斯坦在专利局，清闲时候搞出了相对论；卡夫卡当公务员，清闲时候写出了变形记；刘慈欣在国际机关上班，清闲时候拿了雨果奖和幸运奖。所以，你懂的。这年头想要实现理想，最终必不可免，你必须走向类型2的工作：爱因斯坦的工作是类型3，搞出了相对论后，还是全职当科学家搞研究了；村上春树现在也全职写作了；恶魔奶爸一开始只是业余时间写写豆瓣微博，主业是秃子，副业是猎头，后来不还是专职，全职做了在线教育，全身心发挥自己，加业余时间百忙中充实自己。当然，秃奶比不上爱因斯坦和村上，奋斗一万年也比不上。所以，在类型1或者类型3的工作中，工作若干年，充实自己变好了，然后专职成类型3是完全可行，并且可能是健康合理成长的唯一道路。真正让人担心的就是：类型1的工作，有公司氛围，压力，同时，催着你走类型3，则完全靠你自觉你有没有自制力，意志力，行动力，这个，就要看你自己了。好好加油学英语啊，这玩意儿简单，考个雅思托福高分一点都不难。另外就是要好好研究语法和语音，你的学生们会因此感激你一辈子的。至于摄影，我一窍不通。祝你好运呀！如何主动拓展社交圈奶爸你好，最近经常面临会有一些不太熟的同学因为同在一个地方约出来玩。本人之前比较内向的那种，只和熟悉的同学见面，现在觉得可能也要适当扩展一下朋友圈。请问奶爸和朋友们，和不太熟的同学出去玩有没有什么比较好的相处技巧还有维持联系的方法，谢谢奶爸。答：综合这个提问来看，题主，以及很多人，对社交的认识都是错误的。1，社交不是为了玩，而是为了有用，2，朋友圈扩展没有任何必要，且会带来不恰当的麻烦，3，如果你经常和一些人出来玩，而不是主动单独约某一个人，说明你在浪费自己的人生。下面说一下正确的社交认知：1，群体性的游玩活动基本没有什么价值，众人皆虚伪戴着假面具，很难深入了解，建立的关系都是泛泛之交一丁点都不牢固。2，自我圈层带来的自然活动产生的社交关系，才具备价值，比如：公司聚会，团建，招待客户的聚会，供应商经销商年会，老板带着陪同，自己参加的兴趣活动，线下聚会，某次会议，行会等等。3，如果你的大学一流，那么你应该多见见各种不同的同学。如果你的大学普通，那么同学对你来说不仅没用，浪费时间，而且还可能成为你的拖累。普通大学里最忌讳和各种不同的同学出来玩，好朋友只需要1-2个即可。4，群体聚会的价值，远不如私下单对单邀约，因为可以建立深层次的关系。5，非友谊，非金钱，非利益，而是虚拟的，个人经验方法才是最有价值，真正最值得探索追求的，多约不同厉害的人，多听听他们的心得体会经验方法，这才是社交中有用的地方，而不是什么互相利用。6，群体社交不需要钱，或者花费很低，比如公司聚会，年会，自己参加的线下活动等等，基本AA或者不用钱，价值也最低，无法建立深入链接，也基本听不到真话。私下单独邀约最有价值，但是谁邀约谁买单，因此需要钱，大量的钱。因此需要谨慎的筛别，只约有价值的人。秉持着主动邀约，主动买单的原则，会让你把高效社交做到极致。" }, { "title": "英语语法新思维-1.走进语法", "url": "/posts/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%96%B0%E6%80%9D%E7%BB%B4-1-%E8%B5%B0%E8%BF%9B%E8%AF%AD%E6%B3%95/", "categories": "语法, 新思维", "tags": "语法, 英语", "date": "2022-09-04 08:49:00 +0800", "snippet": "序言英语语法新思维的体系graph RL;subgraph 初级语法 Aendsubgraph 中级语法 Bendsubgraph 高级语法 CendA[如何构造简单句:如何使用简单的谓语动词]--&gt;B[如何构造复合句:如何使用复杂的谓语];B--&gt;C[复合句与简单句的转化:如何运行非谓语来简化 从句]; 初级： 以名词短语和动词作为两大主线...", "content": "序言英语语法新思维的体系graph RL;subgraph 初级语法 Aendsubgraph 中级语法 Bendsubgraph 高级语法 CendA[如何构造简单句:如何使用简单的谓语动词]--&gt;B[如何构造复合句:如何使用复杂的谓语];B--&gt;C[复合句与简单句的转化:如何运行非谓语来简化 从句]; 初级： 以名词短语和动词作为两大主线。 在名词短语篇中，首先建立起“名词短语”概念，以便于学习剩下各章，包括名词、限定词和形容词。 有了“名词短语”这个概念，读者就能够很好地了解名词、限定词和形容词这三者之间的关系，从而慢慢地建立起英语语法体系。 初级分册中的动词内容主要讨论了英语五种基本句型，为分析从句打好基础。此外，详尽分析了一般时态和进行时态的思维用法，这些用法尤其适用于口语交际中。 中级： 以从句和谓语动词作为两大主线。 中级分册中的从句内容主要是介绍 如何将两个简单句合并成为三大从句，即名词从句、定语从句和状语从句。 中级分册中的动词内容详尽分析了完成时态、完成进行时态、虚拟语气和情态动词等比较复杂的谓语形式，这些灵活多变的谓语形式尤其适用于口语交际中。 高级： 以从句和非谓语动词作为两大主线。 高级分册中的从句内容主要是帮助读者分析和构造复杂的难句，以便于轻松应对各类国内外考试中的阅读理解及写作。相当于英语从句的提高篇。 高级分册中的动词内容详尽分析了英语中的三大非谓语：不定式、动名词和分词，并且在最后一章将三大从句与三大非谓语联系起来，考查二者之间的内在联系及相互转化的问题，使得读者不再是孤立地、僵化地看待各个部分的语法规则，而是在构造句子时能够对规则的使用应付自如。 绪论 名词短语0.1 引言世界七大奇迹,中文可以说1 世界最著名的七大奇迹2 最著名的世界七大奇迹3 七大世界最著名的奇迹用英文可以表达1 the world’s most famous seven wonders2 the most famous Seven Wonders of the World3 the seven world most famous wonders4 the world’s seven most famous wonders那么以上哪个是正确的?必须要搞清楚”名词短语”的构造规律0.2 名词短语语言的构造级别 词（word） 短语（phrase） 句子（sentence） 段落（paragraph） 篇章（discourse）造句要从短语开始短语的种类有动词短语（如have been doing）、介词短语（如for you）、名词短语（如my best friend）等等。其中名词短语最重要,因为是造句中不可缺少的部分0.2.1 名词短语的功能名词短语的定义名词与它的修饰语一起即构成名词短语。名词短语是英语造句中不可或缺的元素。比如简单句的主语、宾语或表语通常由名词短语来充当。 There are some red roses on that small table. 名词短语some red roses在句中充当主语；名词短语that small table在句中充当介词on的宾语。 英文中的介词不能单独使用，其后面必须接宾语，所接的宾语也往往是名词短语0.2.2 名词短语的构造——“左二右六”的定语规律一般来讲，名词前面有两种修饰语。其一是限定词，用来限定名词所指的范围，对名词起泛指或特指、定量或不定量等的限定修饰作用。如these, three, a, the, my和that。对于这些限定词的用法，将在第二和第三章中详细讨论。其二是形容词，是用来表示名词的性质和特征的。比如上文中的red, close, new, best和small。在复杂的名词短语中，更常见的是后置修饰语。一个名词可以带的后置修饰语的种类很多，包括定语从句、同位语从句、分词短语、不定式、介词短语、形容词短语和副词短语等等，而且还有这些不同的后置定语复式出现的情况。名词定语公式\\[限定词 + 形容词 + 中心名词(headword) + 六类右置定语\\begin{cases}介词短语 \\\\分词短语 \\\\不定式短语 \\\\形容词短语\\\\定语从句 \\\\ 同位语从句 \\\\\\end{cases}\\]前置定语位置要求严格,必须限定词在形容词左边$限定词 + 形容词 + 名词$本篇中，只讨论名词短语中的前置修饰成分，如形容词和限定词。后置修饰成分将在《英语语法新思维中级教程——通悟语法》和《英语语法新思维高级教程——驾驭语法》中讨论。0.3 英语句子五成分论常见的句子成分主谓宾定状补为什么说定语不算真正句子成分有名词才有定语,定语是用来修饰名词的因此定语算名词短语的构成成分,暂时称为”短语成分”又因为 语言层次分为 词、短语、句子、段落和篇章主语、谓语、宾语、补语和状语 都是在句子层级定语应该降一档,算到短语里0.4 本篇内容的逻辑安排第一章 名词第二章 限定词（一）：冠词第三章 限定词（二）：数量限定词与个体限定词第四章 形容词第一章 名词1.1 名词的定义与分类1.1.1 名词的定义名词是用来表示人、事物、地点以及抽象事物的名称人：John, sister, father事物：water, air, sun, computer地点：London, theater抽象事物：love, happiness, imagination, hope1.1.2 名词的分类一般来讲，英语中的名词通常分为两大类：专有名词（proper noun）和普通名词（common noun）专有名词包括 人名及头衔 比如：Winston Churchill, the Queen of England, the President of the United States, Doctor Mathews, Professor Samuels等。 著作名称 比如： War and Peace（《战争与和平》） The Merchant of Venice（《威尼斯商人》） Pride and Prejudice（《傲慢与偏见》） 月份 一年中12个月份的名称：January, February, March, April, May, June, July, August, September, October, November, December。 不知道读者意识到没有：中英文对月份的取名方式是不一样的。英语是采用专有名称来称谓每一个月，比如“1月”是January，“2月”是February，“3月”是March等等。而中文则是简单地用数字来标记“1月”、“2月”、“3月”等等。要注意，这些都是公历或太阳历，用英文说就是the solar calendar。另外，我们中国还用阴历或月历，用英文说就是the lunar calendar。因为上面这些月份的英语名称都指的是阳历，因此如果说到我们汉语中的阴历几月就不能用上面的月份名称了，而要用序数词来表达。比如“阴历二月”就不能说February，而是the second month on the lunar calendar或者简单地说成the second lunar month。比如我们中国的“情人节”是“七夕”，就是在“农历七月初七”。如果要告诉外国朋友，你就不能说the seventh of July，而要说成the seventh of the seventh lunar month。我们的中秋节是在“农历八月十五日”，用英文说应该是the fifteenth of the eighth lunar month，而不是the fifteenth of August。中国的春节是在“农历一月初一”，用英文说应该是the first of the first lunar month，而不能说the first of January*。因此，谈到中国的农历传统节日，我们都得采用类似的表达，而不能用上面的专有名称月份来表达。对此，读者不妨注意一下。 星期、四季 一周七天是：Sunday, Monday, Tuesday, Wednesday,Thursday, Friday, Saturday。 一年四季是：winter, summer, spring, autumn。 节日 比如：Christmas, Easter, New Year’s Day, Mother’s Day,Thanksgiving Day等。 地理名称 国家及大洲的名称 如：America, Africa, Europe, Asia, England, Scotland, China,Peru, Albania等。 地区、城市的名称 如：Rome, Vancouver, Beijing, Florence, California, Florida等。 江、河、湖泊的名称 如：the Atlantic, the Dead Sea, the Pacific, Lake Victoria, Lake Michigan, the Rhine, the Thames, the Nile等。 山脉、沙漠的名称 如：the Himalayas, the Alps, the Sahara等。 普通名词可以根据是否可数分为可数名词,不可数名词可数与否涉及很多问题,可数名词变复数的问题（见1.3小节），限定词修饰名词的问题（见第三章），还有是一个名词用作可数与用作不可数，意义上有差别（见1.2小节）简单名词和复合名词复合名词就是由若干单词组合而成构成的名词 比如girlfriend, roommate和mother-in-law（岳母／婆婆）等等1.2 名词的数（一）：可数与不可数“数”概念两个角度来讨论一是名词可数性，即区分可数单词（countable noun，在词典中标注为［C］侧重于名词的意义方面而不是构成形式方面；二是名词的单数与复数形式，这一角度侧重于名词的构成形式方面。这两个角度分别是从意义（meaning）与形式（form）两个方面来讨论名词形式是由意义决定的，是为意义的表达而服务的.另一方面，特定的意义是通过相应的形式来传递的。首先从意义的角度来考察可数名词与不可数名词，然后从形式构成的角度来考察名词的单复数变化规则讨论可数性过程中,重点放在不可数名词的讨论.讨论单复数问题,主要涉及可数名词1.2.1 常用作不可数的名词不可数名词有以下规律，笔者这里将其分为五组： 第一组：对于一些无法分割的名词，我们将其看作一个整体，因而作为不可数名词，没有复数变化（nouns that have nodistinct, separate parts, we look as the whole）。这样的名词主要是一些物质名词 或者可以按气体、液体和固体来作出如下分类： 气体：air, fog, oxygen, smoke等。 液体：beer, blood, coffee, cream, gasoline, honey, juice, milk,oil, tea, water, wine等。 固体：bread, butter, cheese, ice, ice cream, meat, beef（牛肉）,chicken（鸡肉）, fish（鱼肉）, chalk, copper, cotton, glass, gold,iron, paper等 第二组：一些因其组成部分太小而不易数的名词（nouns thathave parts that are too small or insignificant to count）用作不可数名词。这主要也是一些物质名词。 第三组：表示总称的名词通常不可数（nouns that are classesor categories of things）。这些名词侧重于表示某类事物的总的概念，而不是具体的事物。如果要具体指出该总称概念下的具体事物，则要用其他不同的名词。 第一栏的名词都是表示一个总称的概念，是不可数名词，而第二栏则是表示在这个概念下的具体事物，大部分都是可数的。 第一栏的名词都是表示一个总称的概念，是不可数名词，而第二栏则是表示在这个概念下的具体事物，都是可数的。对于上面这些不可数名词，英语的初学者常常不注意，误以为是可数名词，因而在词尾加-s character 翻译为特点时不可数,翻译为方块字或人物时可数 第四组: 抽象的名词一般是不可数的（nouns that areabstractions）。 上面这些名词可以有其他不同的意思，因而可以转化为可数名词。关于这一点，我们将在接下来的1.2.2小节中详细讨论。 第五组：表示研究学科（subjects of study），一般作为不可数名词。 1.2.2 可数与不可数的“相对论”一个名词是可数还是不可数关键在于它所表达的意义,而不是形式 Read the labels on food products. This information will tellyou how nutritious the foods are. the修饰一个复数名词时必然表示特指，即上文出现过的内容“不可数名词”转化为“可数名词”规律 规律一：对于物质名词或总称的名词，若是表示不同的种类，或者因为特定的意思，或者是液体表示“几杯”或“几瓶”这样的数量，则转化为可数名词。 They are found in fruits and vegetables, and in bread, rice, pasta,and other foods made from grains. Protein and fat are found in foods like milk, cheese, meat, fish,and eggs. food，它属于第三组Group C里面的名词，即表示“食物”这个总称概念时是不可数名词。但若是在表示具体的、不同种类的食物的时候，则作为可数名词 I like cake, not hamburger. My mother is making a cake in the kitchen. cake用作不可数名词，表示“蛋糕”这类物质的总称，cake用作可数名词，表示具体的“一块蛋糕”。 I don’t like milk. Yogurt contains a higher percentage of lactic acid than other fermented milks. milk这个物质名词（属于第一组Group A），我们是无法数出“牛奶”的个数的，通常作为不可数名词。但是，如果表示不同种类的“奶制品（milk products）”，则作为可数名词。以上的例子词义没有改变或改变不大,下面讨论因为意思不同导致可数性不同 I need some paper to write a letter on. I have a term paper to write on weekends. I bought a paper. 1中，paper是表示供写字用的“纸”，不可数。在例句2中，paper的意思是“论文”，可数。在例句3中，paper相当于newspaper，表示“报纸”，可数。由不可数转化为可数的名词，意思变化较大的是表示肉类的名词。 1) There is lamb on the menu today. 2) The lambs were eating quietly. 例句1）中，lamb是表示供人们食用的“羔羊肉”，不可数。在例句2）中，lamb的意思是“羔羊”，是一种动物，可数。 Glass does not rust or rot. She drank two glasses of wine. glass表示“玻璃”时不可数，但表示“玻璃杯”时则可数。 二、规律二：对于抽象名词，若是具体化了，则转化为可数名词。并且，此时往往伴随着词义上或大或小的改变。art（艺术）／an art（一项技术，一门特定的艺术）；beauty（美丽）／a beauty（一个美人）；youth（青春）／a youth（一个年轻人）。 三、规律三: 从更广泛的意义上来说，当一个名词表示抽象的、总称的概念（abstract or generic concept）时，一般作为不可数名词来用。而当它表示具体的、特定的事物（concrete or particular things）时，则通常用作可数名词。 这就是为什么词典中对于某个单词的某一词义，后面标注的既是可数，也是不可数。此时关键要看如何使用这个词义，如果是当作具体的事物来看，则是可数；如果是当作一个概念来看，则是不可数。 room 为不可数时,表示空间. room 可数时,表示房间 husband and wife. 看起来单数情况,但前面没有不定冠词a,表示的是夫妻的概念,而不是具体的某人,是作为不可数名词 boyfriend and girlfriend.类似 area 面积,地区时 可数 作为整体概念”面积”时,不可数 总的来说，当名词表示抽象、总称的意义时，一般作为不可数名词来用；而当它们表示具体、特定的意义时，则通常用作可数名词。1.2.3 不能按汉语的思维理解英文名词的可数与不可数汉语中,家具,钱都是可数的,但在英语中,这些统称的名词都是不可数遇到名词，若对其可数性不敢肯定，可以查词典。词典中标有［C］的表示可数，标有［U］的表示不可数。1.2.4 不可数名词的度量一、不可数名词与量词不可数名词不能通过具体的数字,但可以跟量词表示量的概念,不同类型的不可数名词所使用的量词也不一样 常用piece修饰以下抽象名词和物质名词比如这些名词：advice, bread, baggage, chalk, equipment,furniture, information, jewelry, luggage, music和news等。 例如：a piece of news（一条消息） two pieces of news（两条消息） several pieces of furniture（几件家具） three pieces of luggage（三件行李） 用bottle, cup, drop和glass修饰液态物质比如这些名词：beer, blood, coffee, milk, tea, water和wine等。 例如：several drops of blood（几滴血） a glass of milk（一杯牛奶） two glasses of wine（两杯葡萄酒） two cups of coffee（两杯咖啡） 其他的量词还有其他的量词修饰关系， 比如： a loaf of bread（一长条面包） a tube of toothpaste（一筒牙膏） a slice of meat（一片肉） 二、不可数名词不能被a（n）修饰除了能被量词修饰以外，不可数名词一般不能直接被不定冠词a/an修饰。比如“一条消息”不能说成a news，“一个建议”不能说成an advice，“一个好天气”不能说成a nice weather，“一件家具”不能说成a furniture等等。三、不可数名词不能被基数词修饰可数名词因为可以数出具体的数目，因而可以被基数词修饰，比如说one book或two books等。不可数名词因为不能数出具体的数目，因而不可以被基数词修饰，比如“两条消息”不能说成two news，“五件家具”不能说成five furnitures等等。关于可数名词与不可数名词被限定词修饰的搭配关系，我们将在第二章和第三章中详细讨论。1.3 名词的数（二）：单数与复数1.3.1 英语名词的单数与复数的概念英语语言要区分名词的单数（singular，词典中一般缩写成sg.）和复数（plural，词典中一般缩写成pl.）英语只是把“一以上”算作复数1 one half day 半天（单数）2 one day 一天（单数）3 one and a half days 一天半（复数）英语中也有“双数”的概念，比如限定词both, either和neither都只能用来指“二”，不能指“二以上”的复数概念。关于它们的用法，详见第三章。还有each可以指“二或二以上”的复数概念，而every只能指“三或三以上”的复数概念。1.3.2 只用作单数的名词在英语中，只用作单数的名词主要包括不可数名词与专有名词。这两类名词一般没有复数的变化形式。它们作主语时，谓语要用单数第三人称形式。1.3.3 只用作复数的名词这些名词没有词形的变化，但都是当作复数名词来用。它们作主语时，谓语要用复数形式。一、“二合一”的复数名词这些名词表示由相等的两个部分合在一起构成的工具、仪器或服装。最常见的这种“二合一”的名词有： 工具和仪器 glasses（眼镜） spectacles（眼镜） binocular（双筒望远镜，双目显微镜） scales（天平） clippers（理发剪，指甲刀） forceps（钳子，镊子〈尤指外科医生用的镊子〉） pincers（铁钳，钳子〈比如家用的老虎钳〉） tongs（钳子，夹子，镊子〈比如火钳子〉） tweezers（小钳〈比如女用的夹眉毛的小钳子〉） scissors（剪刀） shears（大剪刀） 服装 jeans（牛仔裤） trousers（长裤） shorts（短裤） trunks（男士泳裤） briefs（内裤） pants（短裤） slacks（休闲裤） pajamas（睡衣） 对于这些名词，要说明数量，我们往往要用pair（如a pair of）表示。 比如： That’s a nice pair of pants. 那是一条漂亮的短裤。 As I’m shortsighted I always carry two pairs of glasses. 因为 我近视，所以我总是随身携带两副眼镜。 Both pairs of scissors need sharpening. 两把剪刀都该磨磨了。既然是复数名词，所以要用复数的代词来指代，这点不同于汉语。在汉语中，这些名词往往是单数概念的 比如我们问： A：我的眼镜在哪里？ B：它不就在你的鼻子上戴着嘛！ 这里，我们不会说“它们”，但在英语中却要用they来指代，二、“单形复义”的名词有些名词虽然没有复数的标记，但用作复数，即形式上是单数但是表达复数的意义。具体包括： people :人们,人民 相当于person的复数 :民族,部族 普通名词,可以有复数(-s) cattle 牛群 作主语时谓语用复数形式 police 警察部队,警方 集体名词 谓语动词用复数 表示个别,具体的”警官” a police officer/ a policeman(policewoman) 复数形式是police officers/policemen/policewomen poultry 家禽 如鸡、鸭、鹅 指这些活体的动物时，要当作复数名词来用。 表示家禽的肉，则要当作单数名词来用 livestock “农场里饲养的牲畜”，是一个集体名词，当作复数名词，用复数谓语。 三、“the＋形容词”——表示一类人的复数名词在英文中，“the＋形容词”表示一类人，此时当作复数名词，作主语时，谓语要用复数。四、复数专有名词在英文中，有些专有名词只用作复数。 比如： 22 the Alps 阿尔卑斯山脉 23 The Himalayas are the roof of the world. 喜马拉雅山脉是世界屋脊。 24 The Great Lakes are a series of five lakes between the USAand Canada. 五大湖是位于美国和加拿大之间的五个湖。 25 The Niagara Falls are the falls on the Niagara River. 尼亚加拉瀑布是位于尼亚加拉河上的一个瀑布群。1.3.4 规则的复数名词一、一般在词尾加-s二、以-s, -x, -ch, -sh结尾的名词加-es 比如：class/classes, box/boxes, match/matches, bush/bushes等。 特别注意：以-ch结尾的名词，若-ch发/k/音，则加-s，例如：stomach/stomachs。三、以“辅音字母＋y”结尾的名词，变-y为-i，再加-es；而以“元音字母＋y”结尾的名词，则加-s 比如：country/countries, family/families, baby/babies,lady/ladies; play/plays, boy/boys, guy/guys, donkey/donkeys,monkey/monkeys, key/keys等。四、有关以-o结尾的名词这类名词的单数变复数稍微有些复杂，因为有的是加-es，有的是加-s，而有的是加-es或-s均可。1．一般加-es的名词有： tomato/tomatoes（西红柿） hero/heroes（英雄） Negro/Negroes（黑人） veto/vetoes（否决） 这些一般是以“辅音字母＋-o”结尾的名词。2．一般加-s的名词有： dynamo/dynamos（发电机） kilo/kilos（千克） kimono/kimonos（和服） memo/memos（备忘录） piano/pianos（钢琴） photo/photos（照片） soprano/sopranos（女高音歌手） solo/solos（独奏曲） tobacco/tobaccos（烟叶） 以上这些一般是以“辅音字母＋-o”结尾的外来词或缩写词。 另外还有以“元音字母＋-o”结尾的名词变复数也是加-s的： bamboo/bamboos（竹子） cuckoo/cuckoos（布谷鸟，杜鹃鸟） radio/radios（收音机） studio/studios（工作室，演播室） zoo/zoos（动物园）3．少数名词后加-s或加-es均可： memento/memento(e)s（纪念品） motto/motto(e)s（座右铭） volcano/volcano(e)s（火山） manifesto/manifesto(e)s（宣言）五、有关以-f或-fe结尾的名词1．一般变f, fe为v，再加-es的词有下面12个： calf/calves（小牛） half/halves（一半） knife/knives（小刀） leaf/leaves（树叶） life/lives（生命） loaf/loaves（一条，一只） self/selves（自身） sheaf/sheaves（一捆，一束） shelf/shelves（架子） thief/thieves（贼） wife/wives（妻子） wolf/wolves（狼）2．一般直接加-s的名词有： belief/beliefs（信仰） chief/chiefs（首领） cliff/cliffs（悬崖） proof/proofs（证据） reef/reefs（暗礁） roof/roofs（屋顶） safe/safes（保险箱）3．少数名词后加-s或变f, fe为v加-es均可： dwarf/dwarfs/dwarves（矮人） handkerchief/handkerchiefs/handkerchieves（手帕） hoof/hoofs/hooves（蹄） scarf/scarfs/scarves（围巾） wharf/wharfs/wharves（码头） 另外要注意：beef（牛肉）／beefs（牢骚，抱怨）／ beeves（菜牛，＝beef cattle）。1.3.5 不规则的复数名词一、以-a结尾的拉丁语名词，词尾变为-ae或-as（少数词）。 例如： alga/algae（海藻） alumna/alumnae（女校友／女毕业生） antenna/antennae/antennas（天线） formula/formulae/formulas（公式） larva/larvae/larvas（幼虫）二、以-ex或-ix结尾的拉丁语名词，在词尾直接加-es，或把-ex和-ix变为-ices。 例如： apex/apexes/apices（顶点，最高点） appendix/appendixes/appendices（附录，阑尾） index/indexes/indices（索引）三、以-is结尾的希腊语名词，变-is为-es。 例如： analysis/analyses（分析） basis/bases（基础） crisis/crises（危机） diagnosis/diagnoses（诊断） thesis/theses（论文）四、以-on或-um结尾的名词，变-on或-um为-a，有的可在词尾直接加-s。 例如： bacterium/bacteria（细菌） criterion/criteria/criterions（标准） datum/data（数据） erratum/errata（错误，错字勘误表） medium/media/mediums（媒介，介质） memorandum/memoranda/memorandums（备忘录） phenomenon/phenomena（现象）五、变-oo-为-ee-。 例如： foot/feet（脚） tooth/teeth（牙齿） goose/geese（鹅）六、变-ouse为-ice。 例如： mouse/mice（老鼠） louse/lice（虱子）七、以-us结尾的拉丁语名词，变-us为-i，有的可在词尾直接加-es。 例如： alumnus/alumni（男校友） bacillus/bacilli（杆菌） cactus/cacti/cactuses（仙人掌） fungus/fungi/funguses（真菌） genius/genii/geniuses（天才） nucleus/nuclei/nucleuses（原子核） stimulus/stimuli（刺激物） 1.3.6 复合名词变复数一、“man/woman＋名词”构成的复合名词由“man/woman＋名词”构成的复合名词，两个词均须变为复数。 例如： man teacher/men teachers（男老师） man doctor/men doctors（男医生） man servant/men servants（男仆） woman pilot/women pilots（女飞行员） woman journalist/women journalists（女记者）二、以-man/-woman/-child结尾的复合名词以-man/-woman/-child结尾的复合名词变复数时，将-man/-woman/-child变为复数。 例如： fireman/firemen（消防员） chairwoman/chairwomen（女主席） horseman/horsemen（骑兵） grandchild/grandchildren（孙子／女） policeman/policemen（警察） Englishman/Englishmen（英国人） Frenchman/Frenchmen（法国人） 但是German不是一个合成词，所以其复数形式是在词尾直接加-s，即Germans。三、“名词＋介词或介词短语”构成的复合名词“名词＋介词或介词短语”构成的复合名词变复数时，将主体名词（或者说中心名词）变为复数。 例如：comrade-in-arms/comrades-in-arms（战友） 注意：不是comrades-in-arm*。这里的arms要用复数形式。 （详见1.3.8小节） passer-by/passers-by（过路人） runner-up/runners-up（亚军） looker-on/lookers-on（旁观者） mother-in-law/mothers-in-law（岳母／婆婆） editor-in-chief/editors-in-chief（总编辑） bride-to-be/brides-to-be（即将成为新娘的人，准新娘）四、由短语动词演变成的复合名词由动词短语演变成的由动词短语演变成的复合名词，一般没有主体名词，变复数时在词尾加-s。 例如：forget-me-not/forget-me-nots（勿忘我） go-between/go-betweens（中间人） grown-up/grown-ups（成年人） take-off/take-offs（起飞） assistant director/assistant directors（助理导演） babysitter/babysitters（保姆） breakdown/breakdowns（崩溃，衰落） close-up/close-ups（特写镜头） grown-up/grown-ups（成年人） takeover/takeovers（接管） sit-in/sit-ins（静坐抗议） stand-by/stand-bys（可以信任的人）五、“名词＋形容词”构成的复合名词“名词＋形容词”构成的复合名词变复数时，变名词为复数。 例如： notary public/notaries public（公证员） secretary general/secretaries general（秘书长） Attorney General/Attorneys General（［美］司法部长，大法 官／［英］总检察长） consul general/consuls general（总领事）1.3.7 单复数同形的名词（零复数名词）一类是动物名称，另一类是国籍名称。一、动物名称1．永远用作零复数 sheep（绵羊）从来没有sheeps*这个词形。 deer（鹿）从来没有deers*这个词形。2．通常用作零复数 bison（北美野牛）a bison/two bison grouse（松鸡）a grouse/two grouse quail（鹌鹑）a quail/two quail salmon（三文鱼，大马哈鱼）a salmon/two salmon cod（鳕鱼，也叫做codfish。在英国，满大街的快餐Fish and Chips〈炸鱼和炸薯条〉就是常用这种鱼做的。）a cod/two cod3．零复数和规则复数均可 antelope（羚羊）复数可以是antelope，或者是antelopes。 reindeer（驯鹿）复数可以是reindeer，或者是reindeers。圣诞节前夜，圣诞老人骑的就是这种鹿。 fish（鱼）复数可以是fish，或者是fishes。 flounder（比目鱼）复数可以是flounder，或者是flounders。 herring（鲱鱼）复数可以是herring，或者是herrings。还要注意，有一个常用的俚语red herring（遮眼法，转移注意力的东西），表示提出不相干的事实或论点，以分散对主题的注意力。 shrimp（虾）复数可以是shrimp，或者是shrimps。对于这些名词，用零复数往往是把那些动物当作整体来看，而采用规则复数则表示不同的个体及种类。二、国籍名称以-ese结尾的国籍名词常用零复数。 常见的这类名词有： Chinese（中国人）这是每个中国的英语学习者都应该知道的。“一个中国人”是one Chinese，“13亿中国人”是1.3 billion Chinese。这里的复数还是用Chinese，而不是Chineses*。其他的词还有： Japanese（日本人）one Japanese/ten Japanese Lebanese（黎巴嫩人）one Lebanese/ten Lebanese Portuguese（葡萄牙人）one Portuguese/ten Portuguese Vietnamese（越南人）one Vietnamese/ten Vietnamese Swiss（瑞士人）one Swiss/ten Swiss British（英国人）one British/ten British 注意，这类名词不同于不变形的不可数名词（如music），不可数名词是永远用作单数的，没有复数。这类名词也不同于不变形的复数可数名词（如people），复数可数名词是永远用作复数的，没有单数。而我们这里讨论的单复数同形的名词（如sheep），是既可以用作单数，也可以用作复数的，只是没有形式的变化。因此，没有形式变化的名词有三类： 第一类是不可数名词，如music，它们没有词形的变化，只能用作单数。 第二类是复数可数名词，如people，它们没有词形的变化，只能用作复数。 第三类是单复数同形的名词，如sheep，它们没有词形的变化，但既可以用作单数，也可以用作复数。请读者注意区分这三类名词，大家不妨记住这里的三个名词：music, people和sheep，通过这三个例子来帮助我们记住它们背后的用法规则。1.3.8 有新词义的复数名词在英文中，有些名词在变成复数的时候，词义会有所变化；或者说当这些名词用于某个特定的意思时，通常用其复数形式。1 l) arm（手臂）2) arms（＝weapons 武器，军事）2 1) custom（风俗）2) customs（海关）3 1) damage（损坏，损失）2) damages（赔偿金）4 1) letter（信）2) letters（文学）5 1) minute（分钟）2) minutes（会议记录）6 1) spirit（精神）1) spirits（烈酒）7 1) premise（前提）1) premises（房屋，营业场所）8 1) security（安全）2) securities（证券）9 1) line（行）2) lines（台词）这类名词在英文中很多，大家在今后的英语学习过程中要注意勤查词典，并注意积累。扑克牌里有四种花色，汉语分别叫做“红桃”、“黑桃”、“梅花”和“方片”，在英语中则用四个大家非常熟悉的词heart（心脏）、spade（铁铲）、club（俱乐部）和diamond（钻石）来表示，但是要用它们的复数形式，即hearts（红桃）、spades（黑桃）、clubs（梅花）和diamonds（方片），比如“梅花尖”，英文要说the ace of clubs；“红桃勾”，英文要说the jack of hearts等等。我们的“收入”要用复数名词说成earnings，而不是earning；我们的“储蓄存款”要用复数名词说成savings，而不是saving。甚至是作定语时也要用复数，比如a savings bank（储蓄银行）；asavings account（储蓄账户）若是要“祝贺”别人，就要用复数说成congratulations，而不说congratulation。就连最简单而常见的“谢谢”，你也要说成Many thanks. 或Thanks a lot. 或Thanks. 而从不说Thank a lot.或Thank.*1.4 名词的格（一）：’s所有格的构成及逻辑语义关系对于名词所有格，我们首先介绍它的构成，然后讨论它的逻辑语义关系。此外涉及名词所有格修饰的名词被省去的情况。1.4.1 ‘s所有格的构成首先要明确的是，名词所有格“’s”主要用来表示有生命的名词的所属关系。所以它通常用在姓名、人称、不定代词、集体名词和高等动物等这样的名词后面。 比如： 姓名（names）：Mary’s brother, Jones’s car 人称（personal nouns）：my brother’s car, the lawyer’s office,children’s reading, women’s wear 不定代词（indefinite pronouns）：nobody’s fault, everyone’sresponsibility 集体名词（collective nouns）：the party’s decision, thecommittee’s decision, the company’s accounts 高等动物（animals）：the horse’s mouth, the horse’sstable（马棚）, a bird’s nest（鸟窝）一、单数名词单数名词的所有格，在词尾加“’s”。 比如： 1 my sister’s boyfriend 我姐姐的男朋友 2 the people’s choice 人民的选择 3 a woman’s intuition 女人的直觉 4 the actress’s boyfriend 这个女演员的男朋友 注意，对于像actress这样以-s结尾的单数名词，其所有格同样是在词尾加“’s”二、复数名词对于复数名词的所有格的构成，要分下面两种情况：一是，不以-s或-es结尾的特殊变化的复数名词，在词尾加's。 比如： 5 the Children’s Day 儿童节 6 the children’s books 儿童读物 7 women’s wear 女装 8 Tom and John are men’s names. “汤姆”和“约翰”都是男子名。二是，以-s结尾的复数名词，在词尾加'构成所有格。 比如： 9 her friends’ money 她朋友的钱 10 The stars’ concert was a sell-out. 这些明星们的音乐会门票已售完。三、复合名词复合名词的所有格，在最后一个词的词尾加's构成。 比如： 11 my father-in-law’s company 我岳父的公司 12 everyone else’s viewpoints 其他人的看法 13 Henry the Eighth’s wives 亨利八世的妻子们 14 the Prince of Charles’s car 查尔斯王子的车 15 the President of America’s secretary 美国总统的秘书 16 My brother-in-law’s cousin is a singer. 我姐夫的表弟是一位歌手。四、并列名词对于由and连接的并列名词，当表示“共有”的情况下，只需在最后一个名词的词尾加“’s”；若表示“各自所有”，则须在每个名词的词尾加“’s”。 比如： 17 John and his wife’s bank savings 约翰和他妻子的共有存款 18 John’s and his wife’s bank savings 约翰和他妻子各自的存款 19 Clint and John’s bedroom 克林特和约翰共有的房间 20 Clint’s and John’s bedrooms 克林特和约翰各自的房间 21 Rachel: I’m Carol’s ex-husband’s sister’s roommate. Doctor: I’m your roommate’s brother’s ex-wife’s obstetrician. 二人都用了相当复杂的名词所有格。雷切尔这么做显然是为了和这位大帅哥套近乎。雷切尔与罗斯的妹妹莫尼卡（Monica）是室友关系，罗斯的前妻是凯萝尔，于是她说自己是“凯萝尔的前夫的妹妹的室友”。如此复杂的“远方”关系，雷切尔用了多个名词所有格方能表达清楚。1.4.2 ‘s所有格的逻辑语义关系名词所有格，顾名思义，主要就是用来表示“所属关系”。不过，除此以外，名词所有格还可以表达其他的逻辑语义关系。一、所属关系所谓“所属关系”，就是指某人所拥有的人或物。在以上讨论的例子中，“’s”主要是用来表示所属关系。除了表示所属关系之外，名词所有格还可以表示下列逻辑语义关系，包括主谓关系、动宾关系和同位关系等二、主谓关系 How will Bhutto’s death affect the world?名词短语Bhutto's death相当于说Bhutto died，表示“布托死了”，即相当于一个主谓关系。所谓“主谓关系”，是指所有格名词（如Bhutto）相当于主语，而被修饰的名词（如death）相当于一个谓语。此时，这个被修饰的名词通常都是由一个动词转化过来的，比如death对应的动词die。 the visitor’s departure＝the visitor departed the teacher’s request（此处的request是名词）＝the teacher request…（此处的request是动词） Britain’s decision＝Britain decided…三、动宾关系 Bhutto’s assassination rocks Pakistan.这里的名词短语Bhutto's assassination相当于说assassinate Bhutto，表示“刺杀布托”，即相当于一个动宾关系。显然，这里的Bhutto's assassination不是上面所说的主谓关系，即不是表示“布托刺杀别人”。由上可知,所谓“动宾关系”，是指被修饰的名词（如assassination）相当于一个谓语，且是及物动词（如assassinate）。而所有格名词（如Bhutto）相当于这个及物动词的宾语。此时，这个被修饰的名词通常都是由一个动词转化过来的，比如assassination是由动词assassinate转化而来。 the children’s education＝(somebody) educated the children the boy’s punishment＝(somebody) punished the boy四、同位关系 For Washington, Bhutto’s loss is incalculable.名词短语Bhutto's loss相当于the loss of Bhutto，表示“失去了布托这一损失”或“损失了布托”。这里loss是中心词，表示“损失”，而Bhutto’s是用来详述具体损失了什么东西，补充说明loss，即相当于一个同位语。显然，这里的Bhutto’s loss既不是上面所说的主谓关系来表示“布托失去了（什么东西）”，也不是动宾关系来表示“某人弄丢了布托”。五、表示时间或距离所有格“’s”用在表示时间的名词后面。 比如： 16 today’s newspaper 今天的报纸 17 tomorrow’s weather 明天的天气 18 tonight’s TV 今晚的电视节目 19 last night’s storm 昨夜的暴风雨 20 a hard day’s work 一整天的辛勤劳动 21 a week’s holiday 一周的假期 22 a month’s salary 一个月的薪水 23 three hours’ delay 三小时的耽搁 24 I am very tired after a hard day’s work. 苦工作了一天之 后，我感到非常疲惫。 25 My birthday is in two weeks’ time. 我的生日是在两周之后。 26 Let’s have ten minutes’ break. 我们休息10分钟吧。 27 My college is fifteen minu 28 Each morning, people swarm into the offices and factories of America, seeking a day’s work for a day’s pay. 每天早晨，人们涌进美国的办公室工厂，来寻找日薪工作。六、表示重量或价值等度量所有格“’s”用在表示度量的名词后面 比如： 29 two pounds’ weight 两磅重 30 a ton’s weight 一吨重 31 a ton’s steel 一吨钢材 32 two dollars’ worth of sugar 两块钱的白糖 33 ten dollars’ worth of meat 10块钱的肉七、表示国家、城市、国际组织或地理名词等 34 China’s population 中国的人口 35 China’s industrial development 中国的工业发展 36 China’s exports and imports in January 中国1月份的进出口额 37 America’s West Coast 美国的西海岸 38 Jinmao Tower, Shanghai’s tallest building 金茂大厦，上海的第一高楼 39 the city’s weather 这个城市的天气 40 the European Union’s exports 欧盟的出口额 41 the world’s three most famous tenors 世界最著名的三大男高音 42 the world’s seven wonders 世界七大奇迹 43 the earth’s surface 地球的表面 44 the sea’s depth 海洋的深度 45 the moon’s shadow 月球的阴影 46 the sun’s ray 太阳的光线八、用于交通工具及其部件的所属关系 47 the car’s exhaust 汽车的排气管 48 the plane’s engine 飞机的发动机 49 the yacht’s mast 游艇的桅杆 50 the ship’s boiler 轮船上的锅炉1.4.3 名词所有格修饰的名词被省去三种情况下,名词所有格所修饰的名词被省去一、避免名词重复具体来说，若名词所有格所修饰的名词已经出现过，则在第二次出现的所有格后面的名词可以省去，以避免重复。 1 This bike is mine, not Michael’s (＝Michael’s bike). 这辆自行车是我的，不是迈克尔的。 2 This is my room and that is my sister’s (＝my sister’s room).这是我的房间，那是我姐姐的房间。 3 I don’t know her name, but I can tell you her husband’s (＝ her husband’s name). 我不知道她的名字，但是我可以告诉你她丈夫的名字。二、表示店铺或教堂具体来说，在一些表示店铺或教堂的名词的所有格后面可省去名词，此时所有格表示相应的场所，且一般要在所有格名词前加定冠词the。 例如： 4 at the baker’s (＝baker’s shop) 在面包店 5 at the butcher’s (＝butcher’s shop) 在肉铺 6 at the chemist’s (＝chemist’s store) 在药店 7 at the florist’s (＝florist’s shop) 在花店 8 at the dentist’s (＝dentist’s clinic) 在牙医诊所 9 at the doctor’s (＝doctor’s clinic) 在医生的诊所 10 I’m going to the dentist’s tomorrow afternoon (＝dentist’sclinic). 明天下午我要去看牙医。 11 I want to pay a visit to the St. Paul’s (＝St. Paul’sCathedral). 我想去拜访一下圣保罗大教堂。三、表示某人的住宅具体来说，在人名后的所有格省去名词时，表示某人的住宅。 比如： 12 go to my sister’s (＝my sister’s home) 去我姐姐家 13 I called at my uncle’s yesterday (＝my uncle’s home). 我昨天拜访了我叔叔家。1.5 名词的格（二）：of属格的构成及逻辑语义关系首先介绍它的构成，然后讨论它的逻辑语义关系1.5.1 of属格的构成其基本构成是：N1＋of＋N2。这里N1表示第一个名词，N2表示第二个名词。一般来说，of属格主要用于以下两种情形：一是，表示无生命物体的名词的所有关系。 比如： 1 the roof of the church 教堂的屋顶 2 the name of the song 歌曲的名字 3 the title of the book 书名 4 the leg of the table 桌子腿总体来说，’s所有格主要是用于有生命的名词，而of属格主要是用于无生命的名词。二是，当有生命的名词后面接短语或从句修饰时，也用of属格。 比如： 5 What is the name of the boy sitting next to her? boy被分词短语sitting next to her所修饰，此时要表示“这个男孩的名字”就不能用’s所有格，说成What is the boy sitting next to her’s name?*而是要借助of属格来表达。如果没有这个分词短语修饰boy，我们则可以直接用’s所有格这么说：What is the boy’s name?” 6 The mother of the boy in a red suit is president of our company. 这里同样不能用’s所有格说成The boy in a red suit’s mother is president of our company. 如果没有介词短语in a red suit修饰boy，则可以直接说the boy’s mother。1.5.2 of属格的逻辑语义关系最熟悉的应该是它表示的“所有关系”，译成“……的”一、主谓关系：从右往左翻译基本结构是N1＋of＋N2，这里N1是由不及物动词变化过来的名词，表示某个行为，这一行为是由N2来发出的。或者说，N2是N1行为的执行者。 2 the arrival of my mother 这里第一个名词arrival是由不及物动词arrive变化过来的，它表示一个行为；而第二个名词my mother则是这个行为的执行者，即相当于说my mother arrived。 我妈妈到了 3 the emergence of a strong center party 一个强大的中间党派的出现 4 the rise of the U. S. Superpower 超级大国美国的兴起我们看到，在以上这些例子中，第一个名词（如emergence和rise）都是由不及物动词变化过来的，此时只能是表示主谓关系，翻译时从右往左理解。 5 the arrival of the train 火车到达 6 the growth of agriculture 农业增长二、动宾关系：从左往右翻译其基本结构是N1＋of＋N2，这里N1是由及物动词变化过来的名词，与上述“主谓关系”相反，N2是N1行为的承受者，而不是执行者。 7 America’s invasion of Iraq invasion是由及物动词invade变化过来的，这个短语相当于说America invaded Iraq，即第二个名词Iraq是该动作的承受者。 8 William’s conquest of England = William conquered England，即动宾关系。 9 a statement of the facts = someone stated the facts，即动宾关系 一个名词（如conquest,statement和discussion）都是由及物动词变化过来的，此时一般表示动宾关系，翻译时从左往右理解。 从以上的讨论我们看到，若动词是不及物动词，则必作主谓关系理解，如the arrival of the train。但如果动词既可作及物又可作不及物动词使用，则会产生麻烦。 11 the shooting of the rebels 这里的动词shoot既可作及物又可作不及物动词，因此，theshooting of the rebels既可以理解成动宾关系，即“Someone shootsthe rebels”，也可以理解为主谓关系“The rebels were shooting”。具体如何理解，就需要根据上下文来确定。 主谓关系：叛乱者开枪扫射 动宾关系：开枪打死这些叛乱者 12 The reminiscences of the Prime Minister were very amusing. 我们就不知道是“这位总理在回忆”还是“别人在回忆这位总理”。对于这种情况下，我们一般的原则是： 凡是可以理解为动宾关系的of短语，就不妨这样理解，除非有相反的证明。如the examination of the fireman我们就作为动宾关系理解为“某人正在检查消防队员”。同样，the scrutiny of the tenants作为动宾关系理解为“在调查房客”。尽管对于上述短语，我们倒过来理解也是完全合理的，如分别理解成the firemen’s examination或the tenants’scrutiny。事实上，对某些词项来说，倒转过来理解更为可取，如the examination of the experts（专家们来检查）。 综上所述，对于不及物动词，则必然是从右往左按主谓关系翻译。而对于既可作及物又可作不及物的动词，则一般按动宾关系从左往右翻译，除非上下文语境有相反的证明。三、同位关系其结构是N1＋of＋N2，这里N2表示N1的具体内容，二者互为同位说明。 the city of Rome Rome is a city或者说The city that I mean is Rome. 这与the people of Rome中的of表达的逻辑关系显然是不同的。第二章 限定词（一）：冠词限定词与名词的关系最为密切，因为它必然是修饰某个名词，以限定名词所指的范围，对名词起泛指或特指、定量或不定量等限定修饰作用。 英文中的限定词包括： 冠词：the, an和a； 基数词和序数词：one/first, two/second, three/third等； 指示限定词：this, that, these和those； 物主限定词：my, your, his, her, our和their； 数量限定词：a few, a little, much, many, a lot of, some, any,enough, several, most和all等； 个体限定词：each, every, either, neither和both等； 名词属格：Mary’s, John’s和his father’s等。2.1 引言：Story-telling在英语中，man如果表示“成年男子（anadult male human being）”时，一般要加冠词a来修饰，比如说aman。如果表示“全人类（the human race, mankind）”，则不需要用冠词a修饰。out of the question表示“不可能”，而out ofquestion才表示“毫无疑问”。2.2 冠词的位置与读音英语中的冠词有三个，其中两个是不定冠词a和an，一个是定冠词the。但若从语音的角度来说，英语中的冠词应该有四个：除了两个不定冠词a和an外，定冠词the也有两个。一个是用在辅音前（before the consonant）的the，读成［ðə］；一个是用在元音前（before the vowel）的the，读成［ði］。此外，不定冠词a用在以辅音音素（并非辅音字母）开头的名词前；不定冠词an用在以元音音素（并非元音字母）开头的名词前。所以，从上述读音的角度来看，定冠词the如同不定冠词a（n）一样，在元音和辅音之前的读音是有区别的，尽管拼写上都是the。 2 1) a university, a unique person 2) an unkind old lady 这里的三个词university, unique和unkind虽然都是以字母u开头的单词，但是前两个u读成［ju］，是辅音，所以用不定冠词a；而unkind中的u读成［ʌ］，是元音，所以用不定冠词an。 3 1) an hour 2) an honor 这里的hour和honor两个词虽然是以辅音字母h开头，但因为h不发音，两个单词都是读成元音，所以冠词用an。 2.3 冠词的用法概述对于冠词的学习要时刻注意以下四个特点：一、冠词的用法必须与名词结合起来讨论正确划分英语名词的可数与不可数对掌握冠词的用法至关重要。将普通名词划分为可数名词和不可数名词是正确运用冠词的前提。对于冠词的用法，关注三类名词：不可数名词、单数名词和复数名词。二、区分特指与泛指对于冠词的学习，除了要结合名词以外，还要搞清楚特指（specific reference）和泛指（generic reference）这两个关键的概念。所谓泛指，也叫类指，顾名思义，是表示一类事物，或某类事物的总称。所谓特指，是表示某类事物中的具体的某一个或某一些。 1 1) The lion is a dangerous animal. 2) The lion escaped from the zoo. 在例句1）中，the lion是表示“狮子”这类动物，而不是指具体的某头狮子。在例句2）中，the lion是指具体的一头狮子，即就是这个动物园里的某头狮子。对于the来说，就是特指和泛指。定冠词主要是表示特指的用法，其次才是表示泛指的用法。但对于不定冠词a/an来说，不能表示特指，主要是用来表示泛指。三、结合篇章和语境此外，对于冠词用法的讨论有时不能仅局限于单个句子的层面，而要从篇章、语境以及文化背景等角度来分析。关于这一点，我们在2.5节中将会有详细讨论。四、与其他问题相结合最后，冠词的用法有时还会涉及其他问题。比如讨论数量限定词few/a few和little/a little等的结构的时候，有没有冠词意思上会有区别。讨论主谓一致时也会涉及冠词，比如：a number ofpeople are…/the number of people is…。2.4 英语中四种泛指的表达模式名词可以分为不可数名词、复数名词和单数名词。冠词与这三类名词的不同搭配，就会产生冠词的特指概念和泛指概念。具体来说就是：不可数名词不加冠词表示泛指；复数名词不加冠词表示泛指；单数名词与定冠词the连用可以表示泛指；单数名词与不定冠词a/an连用可以表示泛指。2.4.1 不可数名词不加冠词表示泛指不可数名词在表示泛指时，不可与定冠词the连用。如果与the连用，此时不可数名词是表示特指。 Life is hard sometimes. I am studying the life of Beethoven.2.4.2 复数名词不加冠词表示泛指复数名词同不可数名词一样，在表示泛指时，不可与定冠词the连用。如果与the连用，此时复数名词是表示特指。 Books become more and more expensive. Move the books off that chair and sit down.该句的意思是泛指一切书都在涨价，即这里的books是表示泛指，所以不能说The books become more and moreexpensive.* 这里的books是专指“椅子上的那些书”，所以是特指，要说成the books。一般来说，“the＋复数名词”不能用作泛指，而只能表示特指。有两种特殊的表示复数名词概念的结构，是与the连用的，却可以表示泛指：一是 the＋国籍名词，二是the＋形容词。一、the＋国籍名词该结构是指一个国籍的、一个种族集团的人。 The Chinese are a great people.不是所有的国籍名词都可以这样用，比如我们不能说theGerman are…*。这样用的国籍名词只限于以-ese, -sh和-ch结尾的词 具体的包括： 以-ese结尾的国籍名词：Chinese, Japanese 以-sh结尾的国籍名词：British, Cornish, Danish, English, Irish,Spanish, Turkish, Welsh 以-ch结尾的国籍名词：Dutch, French.二、the＋形容词“the＋形容词”表示一类人，是泛指，相当于在形容词的后面省去了people，所以被看作是复数名词，作主语时，谓语要用复数。 The poor are causing the nation’s leaders great concern. 这里的the poor是复数的概念，表示“穷人们”这类人，即是一个泛指的概念，而不是专指某些穷人。2.4.3 单数名词与定冠词the连用可以表示泛指之前谈的是不可数名词和复数名词在表示泛指时的用法，即均不能与the连用。定冠词the与单数名词连用时，可以表示泛指。在语气上显得比较正式或文雅 The tiger is becoming almost extinct. The tiger is sleeping in the cage. 例句1）中，我们想到的是“老虎”这类动物，并不是特定的一只只老虎。在例句2）中，我们心里想的是“老虎”这类动物中特定的一只，比如就指眼前所看到的这只老虎。对于“the＋单数名词”，到底是表示泛指还是表示特指，一定是要根据上下文的语境来判断的。正因为“the＋单数名词”既可以表示泛指也可以表示特指，所以，在特指还是泛指的理解上有时会出现模棱两可的现象。当man表示“人类”而不是“男人”时，相当于mankind，不用冠词，表示泛指。 Man is a social animal. 人是社会的动物2.4.4 单数名词与不定冠词a/an连用可以表示泛指一、单数名词与不定冠词a/an连用可以表示泛指a/an＋单数可数名词可以表示泛指，不定冠词a/an的泛指用法指的是某一类事物中任何一个具有代表性的成员，所以我们可以用any来替换a/an。1) A tiger is a dangerous animal.2) The tiger is a dangerous animal.3) Tigers are dangerous animals.其中例句2）和例句3）都是我们上面讨论过的，分别是单数名词tiger与the连用表示泛指，以及复数名词tigers不与the连用表示泛指。在例句1）中，我们采用单数名词tiger与不定冠词a连用也可以表示泛指。所以，对于这三个例句，我们想到的都是“老虎”这类动物，而不是特定的一只只老虎。因此，这三句的译文都一样，表示“老虎是比较危险的动物”。二、关于a（n）的泛指用法的深入讨论不定冠词a/an的泛指用法指的是某一类事物中任何一个具有代表性的成员，所以我们可以用any来替换a/an。a/an与单数名词连用表示泛指，这主要是限于用在主语的位置，如果是处在其他位置则不表示泛指。甚至即使是在主语位置，也不一定都是表示泛指的概念。2.5 定冠词the的特指用法 1 Have you fed the cat? 比如这句话发生的场景是在家里，听话者知道说话者这里说的cat就是特指自家的宠物猫，而不是别处的猫，更不是泛指所有的猫。这里的the就是表示在“家里”这样的特定情景下的特指。 I went to New York City last week. The traffic is awful. 显然，这句话里的the traffic不是泛指所有的交通，而是专指纽约市的交通。这里the的指代关系就是通过上下文来建立起来的，是属于上下文共指（textual co-reference）。定冠词the的意义在于它所修饰的名词是某一具体所指物，并且说话者和听话者都可以依靠某种信息来确定或者说“还原”这一具体所指物。这些信息来源包括情景、文化、上下文以及句子结构。2.5.1 情景／文化特指（situational/cultural reference）这一类特指，必须依赖于说话者和听话者双方共有的知识。是否需要加冠词the，要看该句用在什么语境下，或者说用在什么样的文化背景下。说话者有或者没有相关的背景知识，就决定了他用或者不用the来特指。显然有冠词the与没有冠词the的意思完全不同。如果是出名的人,就用the,如果是不出名的人就用a去修饰情景／文化背景知识是有不同的大小范围的。比如对于保罗·麦卡特尼，英美人都知道，但绝大多数中国人都不知道。再比如对于“太阳（sun）”这个天体，那是全人类都知道的。因此，根据说话者与听话者共有知识的范围大小，“情景／文化特指”这一类特指用法又可以进一步分类。具体阐述如下：一、一般常识（general knowledge）／较大情景指的就是说话者与听话者共同具有的较大情景的知识。由于这样的一般常识，因而定冠词the所指的对象究竟是什么，这对双方来说都是不言而喻的。比如说到太阳（sun），我们要用the来定指，因为说话者与听话者双方都知道这个所指物，这是不言而喻的。 17 the North Pole 北极 18 the Equator 赤道 19 the earth 地球 20 the moon 月亮 21 the sky 天空 22 the universe 宇宙 23 the Renaissance （欧洲14至16世纪的）文艺复兴 24 the Pope 罗马教皇二、具体知识（specific knowledge）／局部情景（local use）说话者与听话者共有的知识只是局限在一个特定的较小的范围内，比如对于同一个家庭或村庄的成员来说是独一无二的。三、即时情景用法（immediate situation）在说话的时刻，所指为双方唯一看到或听到的。此时，定冠词the的所指是从语言以外的实境（the extralinguistic situation）中推知的。 The roses are very beautiful. 这句话是在花园里说的，指的是眼前看到的这些玫瑰花。2.5.2 上下文共指（textual co-reference）上下文共指，就是指听话者或读者可以根据上下文找到所指。它可分为前指（anaphoric reference）和后指（cataphoricreference）。前指又可分为直接前指（direct anaphora）和间接前指（indirect anaphora）。graph LR;E[上下文公指] --&gt; A;A[前指]--&gt;B[直接前指];A ---&gt; C[间接前指];D[后指]E ---&gt; D;一、直接前指前文中已经提过的信息使后文中的某个名词短语特指某个事物，这即是前指。直接前指是指前面提到的某个事物，在后文中再次提到，这样前后两个名词短语是一种共指关系（co-reference），指代同一个事物。由于第一次提到的物体通常是不定指的，所以常用不定冠词a/an来限定。可是一旦那个物体在话语中已经谈到过，就可以把它看作“从上文中已得知的东西”，此后再提到它时就要用定冠词。这就是传统语法书上所说的，“第一次提到的单数可数名词前面用不定冠词a或an，这一名词再次出现时则要用定冠词the”。 I had a banana and an apple. I ate the banana and gave the apple to Clint.二、间接前指／话题与定冠词the间接前指，表示所指的对象间接地成为听话者知识的一部分。这种知识不是通过上面讨论的那样的直接谈及而获得，而是从已经谈到的事物中推断得到的。此时，在上文中往往会提到的一个与下文有紧密联系的概念或谈论的话题，然后下文围绕这个话题展开讨论。 John bought a bicycle, but when he rode it one of the wheelscame off. 首先，根据普通常识，我们了解bicycles是有wheels的；其次，因为a bicycle已提及，所以，这句中的the wheels可以理所当然地认为是属于the bicycle的，因而用the来限定下文的wheels。三、后指／结构特指后指，也叫结构特指（structural reference），往往出现在带有后置定语的名词短语中。一般来说，被某个后置定语所修饰的名词的前面要用定冠词the。 The brick house on the corner is mine. 这里的名词短语brick house被介词短语on the corner修饰，所以有the来限定brick house，说成the brick house。 What makes us different from women of past decades is ourrange of choices. 这里的名词women被介词短语of past decades修饰，但并没有the来限定women，没有说成the women。 决定一个名词的前面是否要有the来限定，并不完全是看该名词的后面是否有后置定语修饰，主要还是看这个被后置定语修饰的名词是表达一个泛指概念还是特指概念。具体来说，得分成两种情况：如果被后置定语修饰的名词是表达一个没有限制的、广泛的、不可预知的人或事物，此时名词的前面依然不用the来限定；如果被后置定语修饰的名词是表达某个被限定的、特殊的、听者或读者（listener/reader）可以断定很熟悉或可以明白与之有关的人或事物，此时名词的前面需要用the来限定。1) People who drink and drive should go to prison.2) The people who made this mess should be ashamed ofthemselves.在例句1）中，这里的people说的是任何醉酒驾车的人，具体是哪些人并不重要，即是一个泛指概念，因此这里没有the来限定people。在例句2）中，这里的people表达的是一个明确的、特殊的群体，即是那些把这弄得一团糟的人，是一个特指概念。作为读者的你是熟悉这些people的，因此这里有the来限定people。2.6 不定冠词a/an的用法2.6.1 不定冠词的泛指与非泛指用法在三类名词（即单数名词、复数名词和不可数名词）当中，不定冠词仅用于限定单数可数名词。当根据说话者和听话者的共有知识不能统一确认所指事物的时候，我们就会用a/an来修饰一个名词。在2.4节中，我们讨论了a/an表示泛指的用法，此用法一般仅限于处在主语位置的a/an＋单数名词。一、用在主语中，具有泛指功能 A tiger is a dangerous animal. 老虎是一种非常危险的动物。二、用在补足语中，表示分类，具有描述功能在英语中，单数可数名词在作表语时，通常需要一个冠词。如果用不定冠词a/an，则具有描述的功能，而没有所指功能。 Bill is an engineer. 比尔是一名工程师 Bill is engineer.*三、用在宾语中，具有所指功能不定冠词用于泛指（generic reference）也是它的所指功能（referring role）的一种。为了分析清楚不定冠词a/an在宾语位置的所指功能，我们有必要搞清楚冠词所指的确定性（specific or nonspecific）与说话者或听话者之间的关系。我们可以通过下列表格给出两者之间的四种关系 Student: How did I do on the test? Teacher: Well, actually you didn’t do very well. Don’t you have a tutor? Student: Yes. Mary’s been tutoring me for two weeks now. It’s been difficult to meet though, because I don’t have a car. Mary does have a small Toyota, but it isn’t always reliable.对于the test，显然说话者（这里是学生）与听话者（这里是老师）都明白这一测验的具体所指，所以用定冠词the修饰test，说成the test。由此可见，对说话者与听话者都是定指的概念，需要用the，这就是我们前面讨论的特指用法。对于a tutor，说话者问“你不是有辅导老师吗？”说话者并不知道听话者的辅导老师是谁，比如他只是因为知道每个新生都配有辅导老师这样一个学校规定而知道该学生应该是有辅导老师的，所以对于说话者——这位老师来说，a tutor是不定指，但对于听话者——这个学生来说，他当然知道自己的辅导老师是谁（He has a particular teacher in his mind.），所以对于听话者来说atutor是定指的。如果老师知道该学生的辅导老师是谁，他就会问成Don’t you have the tutor? 因为“这个辅导老师（the tutor）”是“说话双方共享的信息”，所以该用the。对于a car，这里相当于any car，表示的是“汽车”这类交通工具，而不是指具体某一辆汽车，所以对双方来说都是非定指。对于a small Toyota，说话者自然知道具体是指哪一辆汽车，但听话者并不知道。所以对说话者来说是定指，对听话者来说是不定指。翻译学生：我上次考试考得怎么样？老师：噢，实际上你考得不太好。你不是有辅导老师吗？学生：是有，玛丽一直在辅导我，有两个星期了。不过我们见面很困难，因为我没有汽车，而她虽然有辆丰田，但经常坏。只有当被限定的名词对说话者与听话者双方来说都是定指的（speaker—specific, listener—specific），我们才可以用定冠词the。综上所述，不定冠词a/an仅用于单数名词的前面。具体用法如下： 用于主语位置，表示泛指（generic usage）。比如：Atiger is a large cat. 用于补语位置，表示分类。比如：He is a teacher. 用于宾语位置，会产生歧义，即用于定指与不定指意义不同。比如：I read a great book last week. 这对于说话者来说是定指，但对于听话者来说是不定指。再比如：I don’t have a car. 这对说话者和听话者都是不定指。关于“特指”、“泛指”、“定指／不定指”这几个概念之间的相互关系：特指是对于说话双方来说都是定指的（speaker—specific, listener—specific）；泛指是对于说话双方来说都是不定指的（speaker—nonspecific, listener—nonspecific）。在特指与泛指这两个极端情形之间存在着两类过渡的指代状态，即对于说话者或听话者某一方来说是定指而对于另一方是不定指，具体来说就是：对说话者来说是不定指／对听话者来说是定指或对说话者来说是定指／对听话者来说是不定指。对于the来说，就是特指和泛指。定冠词主要是表示特指的用法，其次才是表示泛指的用法。但对于不定冠词a/an来说，不能表示特指，而主要是用来表示泛指以及两种不同的定指／不定指的指代关系。2.6.2 不定冠词a/an与不可数名词在三类名词（即单数名词、复数名词和不可数名词）当中，不定冠词仅用于限定单数可数名词，不可数名词的前面通常不用a/an。但是，出于特定的意义表达的需要，就要用a/an来限定不可数名词。在下列三种情况下，a/an可以与不可数名词连用：一、很多不可数名词与a/an连用，是表示“一种”或“一类”。A cheese that I like is Camembert.二、对于饮料类的不可数名词，与a/an连用时，是表示“一杯”这样的饮料。I’d like a beer, please. 我要一杯啤酒三、有些不可数名词，当它们与a/an连用时，会有特别的意思，或者说意思会发生改变。glass表示“玻璃”这种物质，但a glass则是表示“一个玻璃杯”。同样，iron表示“铁”这种物质，但an iron表示“一个电熨斗”等等。2.6.3 不定冠词a/an与数词one不定冠词在历史上起源于非重读形式的one，在当代英语的许多语境中，不定冠词的这种数词功能仍是非常主要的。所以，在下列并列结构中，one可作为a的强调形式的等同词而替代a。1) a mile or two2) one or two miles分别讨论三种宜用one的情况以及三种不宜用one的情况一、强调数量“一”时用one当我们想加强口吻或引人注意的时候，我们用one强调“只有一个／不超过一个（one only/not more than one）”的意思，而a/an则没有这个意思，它显得比较平淡、中性。也就是说，one比a/an更强调数量。二、因为one强调数量，所以常用于准确的对照数字用one，我们仅考虑到有关数字的方面，或只想强调只是一个而不是两个或三个。所以，当我们想准确地对照数字时，我们就要用one。三、讲故事中用one在讲故事或讲述某种经历时，我们常用one来强调人或事物，作为我们将要讲到的一个重要话题。 注意，one day还可以表示“将来的某一天（at some futuredate）”：四、表示类指意义的a/an不能换成one1) A shotgun is no good.2) One shotgun is no good.在例句1）中，a shotgun是表示类指意义，意思是说“猎枪这种武器”不合适，需要别的武器。在例句2）中，one shotgun是强调数量，意思是说“一支猎枪”不够，需要两支或更多的猎枪。五、表示度量的a/an不能换成one我们可以用a/an来表示度量，以表示价格、速度或比率等概念。这时的a/an相当于per（每，每一），不能换成one。1) The rent is $100 a week.2) The rent is $100 one week.*这里的不定冠词a是表示度量，所以不能用one，故例句2）不对。六、表示数量的固定搭配中的a不能换成one各种数量词中也含有不定冠词a，此时不能换成one，比如：afew, a little, a great many以及a large number of等等。因为这些是固定短语，所以不能把其中的a替换成one，比如不能说：one few或one little等。2.6.4 不定冠词a/an与this在口头叙述中，当说话者想强调某个人、某个地方或某件事，并使他们变得更加生动时，就可以用this代替a。这个用法在讲笑话时尤为常见。但请注意，在正式的口语或书面语形式中不能使用这种说法。2.7 用／不用冠词的意义区别（the hospital/hospital）有一类表示家居生活和社会事业机构的名词，如hospital（医院）等，在有冠词修饰（如the hospital）和没有冠词修饰（如hospital）的两种不同情况下，意思往往是不同的。当我们不用冠词时，表示的是人们去这些地方做在这些地方应该做的事，或者说做的事情与这些地方密切相关。比如：inhospital（在医院）就是因为“生病”，in prison（在监狱）就是因为“犯罪”，go to church（去教堂）就是为了“礼拜祷告”，go totemple（去庙里）就是为了“拜佛求签”等等。此时这些名词只表示一种抽象的概念，说话人并非特指具体的、实际的建筑物或地点，而主要是强调在该处所的活动。另一方面，当我们使用冠词时，则表示人们去这些地方不是要做与该处所密切相关的事，而是由于其他原因。比如：in thehospital（在医院）不是因为“生病”，而是因为照顾病人或者是其他原因；in the prison（在监狱）不是因为“犯罪”，而是要放火烧监狱；go to the church（去教堂）不是为了“礼拜祷告”，而是为了放火烧教堂；go to the temple（去庙里）不是为了“拜佛求签”，而是为了放火烧庙等等。此时这些名词是表示具体的、实际的建筑物或地点，即强调的是处所，而不是活动。简言之，对于表示处所或社会事业机构类的名词（如prison,church和college等），使用冠词the，是强调处所，指的是实际的建筑物或地点；不用冠词the，是强调活动，不是指实际的建筑物或地点，而是指与它们相关的社会事业机构列举常见名词一、家居生活类名词1) at table2) at the table例1）中，在“餐桌边”的主要活动就是“就餐”，所以at table表示“吃饭，进餐”。在例2）中，at the table表示“在桌子边”，但不是在就餐，而是干别的。1) go to bed2) go to the bed1）上床睡觉2）到床边l) go to bed2) lie down on the bed1）上床睡觉（不是要干别的）2）躺在床上（不是为了睡觉，而是为了休息等等）1) in bed2) in the bed1）在睡觉2）卧在床上二、处所、建筑物或社会事业机构1) go to hospital (as patients)2) redecorate the hospital1）生病住院2）重新装修这个医院1) in hospital2) in the hospital1）住院2）（因事）在医院里1) come out of hospital2) come out of the hospital1）（病愈）出院2）（因事）从医院出来1) go to prison2) walk around the prison1）犯罪入狱2）绕着这个监狱走1) be in/at church (to pray)2) admire the church1）在教堂做礼拜（强调活动）2）非常欣赏这座教堂（指具体的建筑物）1) go to/be in town2) The town is very old.1）去／在城里2）这个小城很破旧。三、关于上学（class, school, college和university等）1) go to school2) go to the school1）上学2）（因事）去学校1) in school2) in the school1）在校念书2）在学校里1) go to class2) The class works hard.1）去上课2）全班同学学习认真。1) in class2) in the class1）在上课2）在这个班级1) go to college2) the gates of the college1）上大学2）这个学院的大门1) at desk2) at the desk1）在读书，做作业2）在课桌边，在课桌旁四、关于sea的表达1) go to sea (as sailors)2) go to the sea1）当水手，做海员；出海航行，出航（以水手的身份）2）去海边，去海滨1) be at sea (as passengers or crew)2) be at the sea1）在海上航行；茫然，迷惑2）在海边1) by sea2) by the sea1）乘船2）在海边有冠词与没有冠词的意义差别的区分规律是：一般来讲，没有冠词修饰的名词，这个名词往往具有一种抽象意义或者总称意义；有冠词修饰的名词，此时的名词都是具体特指某个事物或其他意思。1) in office2) in the office1）在职；上台执政2）在办公室里1) out of office2) out of the office1）离职；下台，在野，不执政2）离开办公室1) behind time2) behind the time(s)1）晚点，迟了2）过时，落伍，落后于时代1) in red2) in the red1）穿着红色的衣裳2）负债，亏损1) by day2) by the day1）白天2）按日计算，论日1) in secret2) in the secret1）秘密地，私下地2）参与秘密，参与阴谋1) in front of2) in the front of1）在……（外部）的前面2）在……（内部）的前部1) take place2) take the place1）发生2）代替1) out of question2) out of the question1）毫无疑问，没有问题2）完全不可能1) men of age2) men of an age1）成年人2）同龄人1) keep house2) keep the house1) keep house2) keep the house1）管理家务2）守在家里1) with child2) with a (the) child1）怀孕2）带着孩子／和这个小孩在一起2.8 其他使用冠词的场合一、形容词或副词的最高级、序数词以及only用作形容词加名词连用时，它们的前面一般要用the。二、在乐器、乐团、合唱团及流行音乐团体前加the三、定冠词the与姓氏连用我们可以把定冠词the与姓氏连用，然后要在姓氏的后面添加复数-s。 比如：7 the Smiths 这个短语要表达的意思主要有两种：一是表示夫妇两人（husband and wife），二是可以表示全家人，即包括孩子在内（including children）。所以，the Smiths可以表示“史密斯夫妇”，也可以表示“史密斯一家人”。具体的意思可依据上下文而定。此外，如果是名门望族的姓氏，则除了表示上述两个意思之外，往往还表示整个家族。 比如： the Kennedys四、表示强调时，会用the2.9 其他不用冠词的场合一、关于职业、身份或头衔表示某人的职业，一般是用不定冠词a/an。表示独一无二的身份或职务的名称在句中所出现的位置，它们通常是出现在补足语的位置（包括主语补足语、宾语补足语以及系动词后的表语位置）和同位语位置，此时尤其会省去the。若是出现在其他位置，如宾语位置或主语位置，则需要加the。省去the的两个条件是：一是要表示独一无二的职务头衔，二是要出现在句子的补足语或同位语的位置。1．独一无二的头衔出现在表语位置2．独一无二的头衔出现在主语补足语的位置3．独一无二的头衔出现在宾语补足语的位置4．独一无二的头衔出现在同位语的位置二、关于球类、棋类运动表示球类、棋类运动项目的名词前面不加冠词。三、关于其他限定词与冠词下面这些限定词彼此排斥，不能同时出现在名词的前面。 1．冠词：the，an，a 2．物主形容词：my，your，his，her，our，their 3．指示形容词：this，that，these，those 4．名词属格：Tom’s，John’s所以下面这些表达都是错误的： 19 the my book* 20 Tom’s the book* 21 my the money* 22 our the problems*如果一个名词的前面已经有了物主词、指示词或名词所有格，则不能再有冠词修饰它了但要注意的是，所有格本身可以有冠词。比如我们可以说： 23 the boss’s wife 老板的妻子三、特殊名词在下列这些特殊名词前不加the：1．nature：泛指自然界（动植物及无生命的物质的世界），不加冠词。比如“在大自然中”要说成in nature，而不nature*。2．society：泛指我们在其中生活的这个社会，一般不加冠词。比如“在社会中”要说成in society，而不是in the society*。3．space：泛指星球之间的空间，不加冠词。比如“在宇宙太空中”要说成in space，而不是in the space*。4．man：泛指整个人类时，不加冠词。5．history：泛指人类的整个历史时，不用冠词。比如“在历史上”要说成in history，而不是in the history*。四、关于星期表示星期几的名词前面一般是不加冠词的，而是直接用介词on加上一个星期的名称，即“on＋星期名称”。比如：on Monday, on Tuesday或on Wednesday等等。五、关于四季指一般的四季而不是具体指某年的某一段时间时，通常不加冠词。 比如：in spring（在春天） in summer（在夏天） in autumn（在秋天） in winter（在冬天）六、关于昼夜的各段时间表示昼夜的各段时间的名词主要有： dawn/daybreak（黎明／破晓） sunrise（日出） sunset（日落） noon（正午） dusk/twilight（黄昏） night（夜晚） midnight（午夜） 以上这些名词尤其是当它们出现在at，by，after和before之后 时，往往不加冠词。比如（以at为例）： at dawn（在黎明时） at daybreak（在破晓时） at sunrise（在日出时） at sunset（在日落时） at noon（在正午时） at dusk/twilight（在黄昏时） at night（在夜晚） at midnight（在午夜） 如果是用在其他介词之后，或者是在其他场合，这些名词前 则往往要加冠词。比如： watch the dawn（看黎明到来） The sunrise was splendid. （日出很壮观。） We admired the sunset. （我们欣赏日落。） see nothing in the dusk（在黄昏时什么也没看见） wake up in the night（在夜里醒来） all through the night（整整一夜）若是表示特定的某一天的某个时间段，往往用不定冠词，并且用介词on，此时这些名词的前面通常都会有形容词修饰。 on a rainy morning 在一个下雨的早晨七、关于进餐指一般日常惯例的用餐时，通常不加冠词。 have rice for dinner 晚餐吃米饭 for breakfast/lunch（早餐／午餐吃……） stay for breakfast（留下来吃早餐） before lunch（午餐前） after dinner（晚餐后）如果指需要特别提出的某一次用餐，则常用the来强调。 The dinner after his retirement party was quite lavish.八、关于交通工具的名词接在by之后的交通工具名词，其前面不加冠词。但是这些名词在其他场合要加冠词。 1) by bicycle 2) take the bicycle 1) by bus 2) be on the bus 1) by car 2) be in the car 1) by boat 2) take the boat 1) by train 2) take the train 1) by plane 2) be on the plane若用在介词in或者on后，以及用在动词后，这些名词的前面一般都须用冠词限定。需要提醒大家注意的是，“步行”是on foot，而不用其他介词。九、关于通讯工具的名词接在by之后的通讯工具名词，其前面不加冠词。但是这些名词在其他场合要加冠词。 1) by radio 2) a talk on the radio 1) by telephone 2) John is on the telephone. 1) by post 2) put a letter in the post 1) by mail 2) send the letter through the mail 1) by satellite 2) The satellite is replacing cable TV.十、平行结构如果两个名词一起放在同一平行结构里，即使是单数可数名词，也通常不加冠词。 62 face to face 面对面；当着面 63 back to back 背对背 64 arm in arm 手挽着手 65 hand in hand 手牵手 66 eye to eye/eyeball to eyeball 面对面地，针锋相对地 67 toe to toe 脚尖挨脚尖，摩肩接踵 68 shoulder to shoulder/side by side 并肩地 69 inch by inch 逐渐地，一步一步地 70 day after day (＝day by day) 日复一日 71 dentist after dentist 一个牙医接着一个牙医 72 from person to person 挨个地 73 from door to door 挨家挨户 74 from top to toe 从头到脚，完完全全 75 from father to son 从父亲到儿子上面带有重复名词的短语,这样的短语往往具有副词的功能，在句中用作状语，修饰动词。第三章 限定词（二）：数量限定词与个体限定词3.1 数量限定词（一）：a few，few/a little，little一、与名词的搭配关系从与名词的搭配来看，a few和few的后面只能接复数名词，而a little和little的后面只能接不可数名词。 1 a few days, few boys 2 a little water, little money二、肯定／否定之别从肯定及否定的角度来看，a few和a little的意思是肯定的，相当于some，表示“有一些”的意思。而few和little的意思是否定的，表示“很少，几乎没有”。 His theory is rather difficult; few people understand it. ＝His theory is rather difficult; almost no people understand it. 他的理论很深奥，没什么人能够理解。 His theory is rather difficult, but a few people understand it. 他的理论很深奥，但有一些人能够理解。 I have little interest in English, so I am very poor at it. 我对英文没什么兴趣，所以学得很不好。 I have a little interest in English, so I like learning it. 我对英文有些兴趣，所以我喜欢学。三、与only或very的搭配关系我们只能说：only a little或only a few，而不能说：only few或only little。但为了强调否定意义，我们可说：very few或very little。3.2 数量限定词（二）：some/any一、与名词的搭配关系some和any均可以与不可数名词及可数名词复数连用，表示“一些”。some一般用在肯定句中，而any一般用在否定句中。除了上述与不可数名词及复数名词搭配外，some和any都可以与单数名词搭配，此时均有特殊的含义和用法。具体详述如下。二、特殊用法一：any与单数名词搭配当any的后面接单数名词时，它的意思是 “无论哪一个，任何一个” ，此时可用于任何类型的句子。比如用于下面的肯定句中：三、特殊用法二：some与单数名词搭配some可与单数可数名词连用，这时的some表示不确定的 “某一个” 的意思。some的这一特殊用法可表示强烈的感情色彩，它往往暗示缺乏兴趣，甚至是蔑视的态度。 I don’t want to spend my life in some lonely little village. 我可不想把自己的一生消磨在一个偏僻的小山村里四、特殊用法三：some与数词连用在限定复数名词时，some的后面还可以先接一个数词，然后再接名词，此时some表示“大约”的意思。这一用法常常暗指这是一个给人以深刻印象的很大的数字。\\[some(大约) + 数词 + 名词\\]3.3 个体限定词（一）：each/every一、与名词的搭配关系从与名词的搭配来看，each和every的后面都只能接单数可数名词，这就是为什么要称它们为“个体”限定词的原因。它们不能修饰不可数名词和复数名词。比如我们说：every/each boy，而不说：every/each boys*。此时若作主语，句子的谓语动词显然要用单数。二、二者用法上的差异1．二者在词性上的差别each不仅用作限定词，而且也可用作代词；而every只能用作限定词。因此，each用作代词可以单独使用，而every只能与名词连用，不能单独使用。 Each has a gift. 却不能说： Every has a gilt.*each用作代词，后面加of短语。此时of的后面须加限定词，然后再接复数名词。不能说：each of boys*，而要说：each ofthese/the/my boys。但谓语依然用单数，因为each是主语核心词。 Each of the boys has a gift.each用作代词，可跟在主语后面，作主语的同位语，但此时的谓语动词用复数，因为复数名词（如这里的boys）是主语核心词。 The boys each have a gift.2．二者在意思上有两点区别首先，each可以用来指两个或两个以上的事物。而every却总是指三个或三个以上的事物，不能指两个。尽管each和every都可作“每一个”讲，但两者的意思并不完全一样。every强调整体，相当于all的意思；而each则表示个别的概念。当我们用each时，我们强调的是一个一个不同的人或事物。 We want every student to succeed in the exam. 这里用every是强调整体，即表示希望“所有的学生”都能通过考试。 Each student has his own personal dream in his mind. 用each是强调个体差别，因为每个人的梦想必然是不同的。3．与数词的搭配关系each不与数词连用，而every可与数词连用，然后再加复数名词。 every two days 每两天／每隔一天可以用“every＋序数词＋单数名词”这个结构，来表示同样的意思。3.4 个体限定词（二）：another/other一、与名词的搭配关系another 不能修饰不可数名词及复数名词，只能与单数可数名词连用，表示不确定的“另一个”，“再一个”。然而，other可与单数名词、复数名词以及不可数名词连用，表示不确定的“另外的”，“其余的”人或物。二、与数词的搭配关系二者都可以与数词连用，但在语序和意思上都不相同。数词要置于another的后面，但要放在other的前面。具体来说就是采用下面的结构： another ＋ 数词 ＋ 复数名词 数词 ＋ other ＋ 复数名词 another three days 另外三天 three other days 另外三天从语义上来看，两种结构所表达的意思完全不同。another＋数词＋名词复数这一结构的基本意思是“在原有基础上的一个延续”。数词＋other＋复数名词并不像“another＋数词＋复数名词”结构那样具有一种“累加延续”的效果，而只是单纯地表示“其他的，另外的”。与another＋数词＋名词复数这一结构意思相同的另一种结构是：数词＋more＋复数名词。 1) another three days 2) three more days 3) three other days 1）还有三天 2）还有三天 3）其他三天三、other本身的其他用法1．other之前可以有其他限定词修饰常见的置于other前面的限定词包括：some，any，every，enough，one/two/three…，no，many和his/my/their等。 every other day＝every two days 每隔一天2．other/others词尾不带-s的other只能作限定词来用，其后面必须接名词，而不能单独使用。3．other/the otherother＋名词表示不确定的“其他的，另外的”。若有了定冠词the限定，the other＋名词则表示特定范围内的“剩下其余的”。other表示不确定的，the other表示确定的。这一区别同样适用于others/the others3.5 个体限定词（三）：either/neither一、与名词的搭配关系二者都是与单数可数名词连用，谓语动词用单数。 1 Either day is OK. （不说：…are OK.） 两天中的哪一天都行。〔两者中〕任一个; 2 Neither day is OK. （不说：…are OK.） 两天中的哪一天都不行。 两者都不（的）;作限定词的用法。此时，二者均不能再与其他的限定词（如冠词、物主代词或指示形容词等）连用。二、二者用作代词二者不直接接名词，而是单独使用或接of短语。 Come over on Saturday or Sunday. Either is OK. 你周六或周日过来，哪天都行。 Either of the answers is right. 两个答案都对。 Neither of my children has done that. 我的两个孩子都没做那件事。 Either of the answers is right. 两个答案都对。结构中有三点须注意： 名词前面必须有限定词。比如我们不说：either of answers,neither of children。 名词必须用复数。比如我们不说：either of the answer, neitherof my child。 谓语动词通常用单数。 比如不说Either of the answers are* right.三、词义差别either有两个意思。首先，either的基本意思是两个当中的任何一个，这个或那个（one or the other）。另外，either有时候也指两个中的每一个（each of two），特别是在与end和side连用时。neither只有一个意思，即“两者都不（not one and not theother）”。四、either…not相当于neither3.6 限定词总结（一）：限定词中的“二”与“三”一、都：both vs. all在英文中，both只表示“两者都”，而all表示“三个或三个以上都”。二、都不：neither vs. none在英文中，neither只表示“两者都不”，而none表示“三者或三者以上都不”。三、另外一个：the other vs. anotherthe other是表示“确定的另外一个”，常用来表示“两个中的另外一个”。因为总共就只有两个，所以若确定其中一个，则另外一个也就随之确定了。因此，常常构成这样的搭配：one…the otheranother是表示“不确定的另外一个”，必然是指“三个或三个以上的另一个”。因为总共有三个或三个以上，所以即使确定了其中一个，剩下的依然是不确定的。四、每一个：each vs. everyeach表示两个或两个以上的“每一个”，而every表示从三个算起的“每一个”。3.7 限定词总结（二）：限定词与可数／不可数名词一、只与单数可数名词搭配的限定词这样的限定词有： a，an，each，every，either，neither，another和one等等。二、只与复数可数名词搭配的限定词这样的限定词有：both，few，a few，fewer，a number of，many，several，these，those，two及two以上的基数词等等。三、只与不可数名词搭配的限定词这样的限定词有：little，a little，less，much，a bit of和agreat amount/deal of等等。四、既可以与不可数名词也可以与复数可数名词搭配的限定词这样的限定词有：a lot of，lots of，plenty of，more，most和all等等。五、同时与单数可数名词、复数可数名词和不可数名词均可搭配的限定词这样的限定词有：any，some，no，the，物主限定词（如your和my等），名词属格（如Tom’s和my mother’s）等等。3.8 限定词总结（三）：限定词与of短语有很多数量或个体限定词同时还可以用作代词，此时它们的后面可以接of短语连用。结构是\\[数量或个体词＋of＋特指限定词＋复数名词或不可数名词\\] of的后面必须有一个“特指限定词”，然后才能接名词，否则就是错误的。“特指限定词”主要有下列四类：一是，指示限定词，如this，that，these和those；二是，物主限定词，如my，your，his，her，its，their和our。三是，名词所有格，如Mike’s，Mary’s和the teacher’s等。四是，定冠词the。注意，这四类限定词不能没有，也不能同时出现两个或以上。具体用法如下一、all/most/some/any of＋特指限定词＋复数可数或不可数名词二、many/a few/few/several/both/two/three of＋特指限定词＋复数可数名词三、much/a little/little of＋特指限定词＋不可数名词其他本身就带有of的数量词如a lot of，lots of，acouple of，plenty of，a number of和a great deal of等，则必须直接与名词连用，名词的前面不需要加特指限定词修饰。四、特别关注：all和both数量限定词中，all（指“三个或三个以上都”）与both（指“两个都”）的用法较为特殊。 1) All students are smart. 2) All of my students are smart. 3) All my students are smart. （all的独特用法） 不正确 All of students are smart.* 1) Both students are smart. 2) Both of my students are smart. 3) Both my students are smart. （both的独特用法） 不正确 Both of students are smart.*五、特别关注：不定代词与of短语不定代词none，someone，anyone以及everyone，都是两个词合起来写成的一个词。它们还分别有分开写的形式：no one，some one，any one以及every one，都是两个词构成的不定代词。它们与of短语的搭配关系不同。一是，合起来写的someone，anyone和everyone的后面不能接of短语。但是，分开写的no one不能接of短语。二是，分开写的some one，any one和every one的后面必须接of短语。但是，合起来写的none要接of短语。3.9 限定词总结（四）：限定词之间的位置关系限定词分为三类：前位限定词、中位限定词和后位限定词一、前位限定词 种类前位限定词主要是用来说明名词的数量，主要有三种：1）表示倍数关系的数量形容词。 例如： 3 half my salary 我工资的一半 4 twice my salary 我工资的两倍 5 double my salary 我工资的两倍 6 three times my salary 我工资的三倍2）表示几分之几的数词。 例如： 7 one third my salary 我工资的三分之一 8 two-thirds my salary 我工资的三分之二3）个体形容词：all和both。 例如： 9 all my salary 我全部的工资 10 both my salaries 我的两份工资 共存性前位限定词一般互相排斥，不能共存。 比如不能说： 11 all half my salary* 12 half double her income*二、中位限定词 种类1）冠词：the，an和a。 13 all the book 所有的书 14 half an hour 半小时 15 twice the size 两倍的号码2）物主形容词：my，your，his，her，our和their。 16 all my money 我所有的钱 17 all his money 他所有的钱3）指示形容词：this，that，these和those。 18 all these problems 所有这些问题 19 twice that size 那个号码的两倍 20 four times this amount 这个数量的四倍4）名词属格：John’s和his father’s等。 21 all John’s money 约翰所有的钱 由此可知，中位限定词就是我们前面说的“四分之一”。 共存性中位限定词亦彼此排斥，不能同时出现。 比如不能说： 22 my the money* 23 our these problems*三、后位限定词 种类1）基数词或序数词：one/first，two/second，three/third和four/fourth等。 例如： 24 the two children 那两个孩子 25 his fourth birthday 他的四岁生日2）一般序数词：next，last，past，previous，subsequent，other和another等。 例如： 26 my next plan 我的下一个计划 27 our last meeting 我的最后一次会议 28 your previous mistakes 你从前的错误 29 her subsequent response 她接下来的反应3）数量限定词：few，many，several，little，less和more等。 例如： 30 my many friends 我的许多朋友 31 our several achievements 我们的几项成就 32 the few friends that I have 我的几个朋友 共存性不同于相互排斥的前位和中位限定词，后位限定词可以同时出现在名词前。 例如： 33 my next two plans 我的下面两个计划 34 several other people 其他几个人但也有先后顺序问题，一般采用如下顺序：1）序数词／一般序数词＋基数词。 例如： 35 the first two weeks 前两个星期 36 during the next 50 years 在接下来的50年里2）序数词／一般序数词＋数量限定词。 例如： 37 during the past few years 在过去的几年里3）一般序数词与基数词的位置关系基数词／数量限定词一般置于other的前面，如：two other people和many other people。基数词一般置于another的后面，如：another ten minutes（又过了10分钟）。3.10 限定词与形容词的区别一、限定词用以限定名词所指的范围，对名词起泛指或特指、定量或不定量等限定修饰作用；而形容词则是用来表示名词的性质、特征的。 1 many/few/his children 许多／几乎没有／他的孩子 2 naughty/lovely/clever children 淘气的／可爱的／聪明的孩子二、限定词一般不用作表语（少数表示数量的限定词few，many和much除外），而绝大多数形容词都可用作表语。除了few，little，many和much外，限定词没有比较级和最高级形式，而大多数形容词有比较级和最高级形式。限定词总是位于名词之前，而形容词作定语时有的可置于被修饰词之后。第四章 形容词4.1 形容词在名词短语中的位置4.1.1 前置修饰名词一、单个形容词在名词短语中的位置若是单个形容词作定语修饰一个名词,结构通常是\\[限定词＋形容词＋名词\\]修饰something，anything，nothing，everything，somebody/someone，anybody/anyone，nobody/no one和everybody/everyone等不定代词的形容词要后置 I have something important to say. 我有一些重要的事情要说。二、多个形容词修饰名词时的词序排列一个中心名词若有多个形容词修饰，此时这些形容词先后的位置关系要遵循一定的规则。规则一般是\\[观点形容词（opinion adjective）＋描绘形容词（descriptiveadjective）\\]“观点形容词”，即完全是表述个人主观上对事物的看法的形容词。如：good，lovely，beautiful，handsome，comfortable等。“描绘形容词”，又称为描述事实形容词（factadjective），即用来描述事物本身固有特征的形容词，是对事物进行客观上的表述，如事物的颜色（blue，yellow，dark，white）、事物的形状（round，square）等。描绘形容词又有以下进一步的分类限定词（my, the, three, this）—观点形容词（beautiful,famous）—尺寸大小（large, small, long）—形状（round, square）—新旧（new, old, ancient）—颜色（white, yellow）—国籍、出处或产地—质地材料—中心名词。4.1.2 后置修饰名词形容词短语作定语，一般只能置于被修饰名词的后面，即充当后置定语。形容词短语的构成主要可以有两类一类是形容词＋补足语构成的形容词短语，即在一个形容词的后面接一个介词短语或一个非谓语动词短语作它的补足语。非谓语动词有两种,不定式或动名词三小类“形容词＋介词短语” a jacket similar to yours“形容词＋不定式短语” parents eager to support their children's efforts“形容词＋动名词短语” a waiter busy serving the guests有时候构成形容词短语的中心形容词与其补足语之间也可能会插入其他成分，因而造成形容词与其补足语被分隔。还有一种不同于上述形容词短语分隔的情况，即是把单个的形容词提到名词前，而把形容词的补足语留在名词的后面。另一类是多个形容词并列使用，从而也构成形容词短语。两个或两个以上的形容词（短语）并列作定语，一般是放在被修饰词的后面，而且还用逗号将形容词与句子的其他部分隔开。这时，作定语的形容词通常是对所修饰词作补充性的说明或解释。 He bought a set of furniture, simple and beautiful.有时，这样的并列形容词不是修饰名词，而是修饰动词或整个句子，此时具有状语的意味。 A man approached the official, timid and hesitant. 这里的timid and hesitant就是一个并列的形容词，作状语4.2 形容词的比较级和最高级的构成形式形容词（以及副词）具有原级、比较级和最高级这样的三个等级比较。构成形容词的比较级和最高级有两种方式：一种是在词尾加-er构成比较级，加-est构成最高级；另一种方式是在形容词的前面加more构成比较级，加most构成最高级。这两种构成方式与形容词的音节数目有关。4.2.1 单音节词一、一般直接在词尾加-er和-est，分别构成比较级和最高级二、以-e结尾的词，直接在词尾加-r和-st，分别构成比较级和最高级三、以-y结尾的词应先变y为i，再加-er和-est分别构成比较级和最高级四、以“一个元音＋辅音”结尾的词，要先双写词尾的辅音字母，然后再加-er和-est分别构成比较级和最高级4.2.2 双音节词一、以-y结尾的双音节形容词，要先变y为i，再加-er和-est分别构成比较级和最高级像slowly这样的副词中的-ly，不同于像early这样的形容词中的-ly。前者是后缀-ly（slow＋-ly→slowly），而后者是该词不可缺少的组成部分（并不是ear＋-ly→early）。这种以后缀-ly结尾的副词（尽管是以-y结尾的双音节词）通常是分别在词前加more和most来构成比较级和最高级。所以，slowly在构成比较级和最高级时，应为more slowly和most slowly。再比如：strongly—more strongly—most strongly。二、其他绝大多数双音节词是分别在词前加more和most构成比较级和最高级三、少数几个双音节词则分别可以用上述两种基本方法来构成比较级和最高级常见的这样的双音节词有：common，cruel，friendly，funny，handsome，mature，noisy，pleasant，polite，quiet，stupid和tired；以-ow结尾的词有：hollow，narrow和shallow；以-er结尾的词有：clever和tender；以-le结尾的词有：feeble，gentle和noble等等。此外，值得一提的是，在英文中，几乎所有的双音节形容词（除了以-y结尾的词外），都可以在其前面加more和most来分别构成比较级和最高级。4.2.3 多音节词一、三个或更多音节的词都是分别在其前面加more和most来构成比较级和最高级二、特殊形式的比较级和最高级少数词的比较级和最高级的变化是不规则的 farther (farthest)/further (furthest)这四个词都可以指实际的距离,further/furthest可用于抽象意义，表示“进一步的，更多的，更深入的”，常与抽象名词连用。 17 further discussion（继续讨论） 18 further debate（继续争论） 19 further delays（继续拖延／耽搁） 20 further demands（进一步的要求） 21 further information（更多的信息） 22 further study（深入研究） older (oldest)/elder (eldest)elder和eldest主要是用来表示家庭成员之间的长幼关系，而并非指年龄的大小。 24 my elder brother/sister（我的哥哥／姐姐） 25 his eldest son/daughter（他的长子／长女）有than的比较级的句子中一般不用elder，而要用older。 I am seven years older than Rex. （不用elder）我比雷克斯大七岁。 later，latter，latest，lastlater：一般用来表示时间上“较迟的”。latter：则是表示顺序上的“后者”，与former（前者）相对应。latest：意思是“最近的，最新的”，主要用来指新近的事物。last：主要有两个意思，一是指“在目前之前的一个（the oneor ones before the present one）”，或者指“一系列事物中的最后一个（after all others）”。4.2.4 不具有等级的形容词表示绝对的含义，因此没有比较级和最高级形式。常见的这些词包括：absolute（完全的，绝对的），alone（单独的，独一无二的），dead（死的，无感觉的），empty（空的，空洞的），equal（平等的），eternal（永恒的，不变的），final（最终的，决定性的），horizontal（水平的），perfect（完美的），primary（第一位的），pregnant（怀孕的，富有的），round（圆的，球形的），single（单一的），square（正方形的），straight（直的），supreme（最高的，至高的），unique（唯一的，独特的）和unanimous（意见一致的，无异议的）。尽管没有“等级差别”，但我们还是可以用下面一些表示“接近的”副词来修饰。比如：nearly, almost, the most closely和more nearly等等。4.3 形容词的比较级和最高级的用法4.3.1 形容词比较级的用法一、than的比较级句型首先需要明确以下几点第一，在than的前面必须有形容词或副词的比较级形式；第二，被比较的两个对象应该是同类事物，即“事物的可比性”。1．常见的句型是：A＋比较级＋than＋B。A，B一般是两个同类的、彼此独立的人或事物。2．也可以不是两个同类事物的比较，而是某一事物自身相比。此时句子的结构为：A＋比较级＋情形1＋than＋情形2。3．若被比较的对象不是彼此独立的人或事物，而是具有“一事物包含另一事物”这样的所属关系，此时我们要用other或else将其与整体区别开来，以免造成逻辑上的矛盾。 Iron is more useful than any other metal. 铁比其他任何金属都有用。二、比较级与the比较级的前面一般不需加定冠词the，但在有介词短语of the two出现在比较级句中的时候，比较级的前面必须加定冠词the。 I think this painting is the more interesting of the two.三、more and more句型用more and more双重比较来表示事物持续不断的变化，相当于汉语中的“越来越”。 The city is becoming more and more beautiful. 这座城市变得越来越美丽了。more and more不可用在单音节词前。如不说：more and more fat*。在more and more结构中，不能重复使用形容词或副词。如不能说：more beautiful and more beautiful*。四、可以修饰比较级的词比较级前可以用以下表示程度的词或短语来进行修饰：a bit，a little bit，a little，a lot，a great deal，any，even，far，by far（还可用在最高级的前面），much，very much，no，rather，still和slightly等等。这些词一般不用来修饰比较级：very，many，quite和fairly等。 My girlfriend is very older than me.*五、否定意义的词＋比较级否定意义的词＋比较级 表达一个最高级的意思。这样的词有：few，nothing，never和not等。 It couldn’t be worse.never与比较级连用，是在对这个比较级的词进行强调，意思也相当于这个词的最高级，且要用在完成时的句子中。4.3.2 形容词最高级的用法最高级用于两者以上的事物之间进行比较一般的结构是：the＋形容词／副词的最高级＋比较范围。最高级的句型有一、the＋最高级＋in＋地方 It is the most expensive car in the world.二、the＋序数词＋最高级＋in＋地方 The Yangtze River is the longest river in China, but it is the third longest river in the world.三、the＋形容词／副词的最高级＋of＋所属范围 The youngest of the family is most successful. 全家年龄最小的那位最有成就。四、最高级前面的定冠词the加与不加1．形容词的最高级修饰名词用在名词之前，一般要加the。 This is the most interesting book of all. 这是所有的书里最有趣的一本。2．most有时用在形容词前，并非表示最高级，而是表示“非常，很”之意，相当于very，very much。此时，most的前面一般不用定冠词the。 The story is most interesting. 这个故事非常有趣 4.4 Interesting or interested? 4.4.1 -ing形容词与-ed形容词的特点interesting往往是与事物联系在一起的，而interested往往是与人联系在一起的。1．-ing形容词主要是用来描述引起人某种感觉的事物，因此，句子的主语通常是事物或作定语修饰事物（用于修饰人的情况较少）；2．-ed形容词主要是用来描述人的感觉，表示“人对事物产生某种感觉”，句子的主语通常是人或有情绪的动物，或用来修饰人或有情绪的动物（一般不指事物）。这个规律可以打破4.4.2 -ing形容词可以修饰“人”一般来说，用-ing形容词修饰人，是说明这个人能够引起的某种情绪 a boring man a bored man 一个烦人的人 一个烦闷的人 4.4.3 -ed形容词可以修饰“物”实际修饰的是人第五章 动词分类（一）：实义动词与（情态）助动词动词的词义和在谓语中的作用，我们可以把动词分为实义动词（notional verb）、助动词（auxiliary verb）和情态助动词（modal verb）。5.1 实义动词（notional verb）特点: 从词义来看,具备完整的词汇意义 从在谓语中的作用来看,实义动词能单独充当句子的谓语,除助动词和情态2动词外,其他均是实义动词5.2 助动词（auxiliary verb）5.2.1 助动词be，do和have特点: 从词义来看,不具备词汇意义 在谓语中的作用来看,不能单独充当句子的谓语,必须和实义动词相连,帮助构成各种时态,语态,语气,否定和疑问be do have 各自的变化形式 1．be: am, is, are, was, were, been, being 2．do: does, did 3．have: has, had, having5.2.2 用作实义动词的be，do和have不要混淆be作为系动词和助动词、do作为实义动词和助动词以及have作为实义动词和助动词。5.3 情态助动词（modal verb）特点: 从词义来看,有其自身的词汇意义,如表示可能、建议、愿望、必要、允许、能力、怀疑等等，以表示说话者对某种行为或状态的看法或态度。 从谓语动词的角度来看,不能单独做句子谓语,和实义动词一起构成复合谓语情态动词有哪些?can/could, may/might, shall/should, will/would, must和had better be able to（与can类似） be going to（与will类似） ought to, be supposed to（与should类似） have to, have got to（与must类似） 此外，need和dare既可以用作情态动词，也可以用作实义动词 5.4 陈述句的否定陈述句的否定构成有两种：谓语中含有be动词或情态动词的，以及谓语是实义动词的5.4.1 谓语中含有be动词或情态动词的否定be动词或情态动词的后面加否定词not即构成否定句5.4.2 谓语动词是实义动词的否定陈述句的否定要借助助动词do及其各种变形来完成。如果是一般现在时的句子，谓语则是do＋not＋动词原形结构；若句子的主语是单数第三人称，谓语则用does＋not＋动词原形。如果是一般过去时的句子，则用did＋not＋动词原形。5.4.3 否定的缩写助动词或情态动词可以与not缩写5.5 一般疑问句一般疑问句的构成有两种：谓语中含有be动词或情态动词的，以及谓语是实义动词的5.5.1 谓语动词中含有be动词或情态动词的提问构成一般疑问句，只需将be动词或情态动词移到句首一般疑问句的回答方式：肯定回答用yes，否定回答用no5.5.2 谓语动词是实义动词的提问句子是一般现在时，要借助助动词do或does，将do或does放在句首句子是一般过去时，则是将did放在句首，谓语动词变回动词原形5.6 特殊疑问句特殊疑问句是在一般疑问句的基础上变化而来的句式为\\[特殊疑问词 + 一般疑问句 + ?\\]特殊疑问词有who，what，which，when，where，why和how等5.6.1 不与名词连用的疑问词一、对人提问——who1) He can sing in English.2) Who can sing in English?1) I saw him at the party last night.2) Who did you see at the party last night?二、对事物或所做的事情提问——what1) I like English.2) What do you like?1) I am studying English grammar.2) What are you doing?1) I am studying English grammar.2) What are you studying?三、对时间提问——when1) I was born in 1980.2) When were you born?四、对地点提问——where1) He lives in Beijing.2) Where does he live?五、对方式提问——how1) He goes to school by bus.2) How does he go to school?六、对原因提问——why1) I often study at the library because it's quiet.2) Why do you often study at the library?5.6.2 要与名词连用的疑问词一、which 当说话者提供多种选项对象供对方选择时，我们就要用which来提问。此时，which的后面通常要接一名词，意思是“哪一个什么东西” A: Could you lend me your pen? B: Sure. I have two pens. This pen has black ink. That pen hasred ink. Which pen/Which one/Which do you want? A: That red one. Thanks. which的后面也可不接名词，此时which用作代词二、whose Whose的后面必须接名词连用，表示“谁的什么东西”。 1) This is his book. 2) Whose book is this?5.6.3 how的用法详解一、how可以单独使用 how单独使用时，此时how是对动作的方式进行提问。 A: How do you go to work? B1: I drive./By car. B2: I take a taxi./By taxi. B3: I take a bus./By bus. B4: I take a subway./By subway. B5: I walk./On foot.二、how还常与形容词或副词连用How old are you? 你多大岁数？How tall is he? 他身高多少？How well does he speak English? 他英语说得怎么样？How quickly can you get here? 你多快能到这里？三、对动作发生的频率提问——how often/how many times…?1) I write to my parents once a month.2) How often do you write to your parents?第六章 动词分类（二）：英语的五种基本句型实义动词决定了一个句子是否有宾语、有几个宾语以及其他的句子成分。6.1 引言：“人咬狗”是条新闻英语这门语言的词序比较严格，词与词之间先后位置的改变往往会使句子的意思也发生变化，所以，英文被称为“固定词序语言”英文句子和我们汉语句子的词序排列不一样,按汉语语序写英语句子就会出问题6.2 五种基本句型概述6.2.1 主语＋谓语一是，以代词、名词或名词短语开头，来表明我们要陈述的对象，这就是句子的主语。二是，在主语的后面紧接动词，来说明主语做什么，或描述主语的状况。动词及其后面的成分，我们称之为谓语部分。6.2.2 五种基本句型概述6.3 句型一：主语＋系动词＋表语谓语动词是系动词（如be或其他系动词），又叫联系动词（linking verb），顾名思义，这种动词并不表示具体的动作，而只是起连接主语和后面成分的作用。这种动词后面所接的成分是用来说明主语的特点，表明主语的性质特征的，因此我们称之为主语补足语，或表语（能表示主语特征的成分）英文中最常见的系动词是be动词，其具体的形式有：am (Iam), is (he is, she is, it is), are (you are, we are, they are)。其他的系动词还有：look（看起来是）sound（听起来是）smell（闻起来是）taste（尝起来是）feel（感觉是）seem（似乎是）appear（似乎是）become（变为）turn（转变为）6.4 句型二：主语＋谓语谓语动词是不及物动词（intransitive verb），所表示的动作没有作用对象，其本身的意思完整，其后不需带宾语。在词典中表示为vi. He died. He works hard. The sun sets in the west. 这种句型中的谓语动词的后面虽然不接宾语，但通常会接副词（如hard）或介词短语（如in the west）来说明动作的方式、地点或时间等等。 They shouted loudly. 副词loudly表示动作的方式，叫做方式状语 He died at home. 介词短语at home表示动作的地点，叫做地点状语 He died in 2007. 介词短语in 2007表示动作的时间，叫做时间状语 区分“主系表”和“主谓状”两种句型1) He shouted loudly.2) He looks happy. shouted是不及物动词，副词loudly修饰动作shouted，作状语。在例句2）中，looks是系动词，没有具体的动作。形容词happy不是修饰looks的，而是补充说明主语he的特征，作表语。6.5 句型三：主语＋谓语＋宾语谓语动词是及物动词（transitive verb），这种动词告诉我们由主语发出的动作所作用的对象是什么，这里所作用的对象就是我们通常称之为宾语的，即宾语是主语动作的承受对象，因此这类动词是带有宾语的。英文中的绝大多数动词都是及物动词，在词典中标为vt. These children are playing football. 英语中大多数动词都像play一样，既可以用作及物动词，又可以用作不及物动词，但意思和用法都不一样。这些句子后面也可以跟状语6.6 句型四：主语＋谓语＋间接宾语＋直接宾语谓语动词是双宾动词（dative verb），这种动词的后面所接成分有“人”又有“物”。一般来讲，这里的“人”表示动作的接受者，称作间接宾语（indirect object）。“物”表示动作作用的对象，是动作的承受者，称作直接宾语（direct object）。间接宾语和直接宾语合起来叫做双宾语。 l gave him my book. 我把我的书给他了6.7 句型五：主语＋谓语＋宾语＋宾语补足语谓语动词是宾补动词（factitive verb），这种动词的后面接宾语，而此宾语的后面又接补充说明宾语的补足语（object complement）。宾语和宾语补足语合起来叫做复合宾语。 I found this answer wrong. 我发现这个答案是错误的。区分双宾语和复合宾语在宾语的后面加上be动词，若能构成一个语义通顺的句子，则是补足语。而间接宾语与直接宾语之间就没有这样的语义关系，所以，添上be之后，自然就不能构成一个语义通顺的句子。 1) I made John our chairman. 2) I made John a cake.第七章 英文时态（一）：一般时态7.1 引言：一个时态错误就是一个政策问题一般现在时的本质思维特征是：表示从过去到现在直至将来的一段时间内发生的动作（action）或存在的状态（state）。也就是说，这些动作或状态的发生不限于某个特定的时间，它们可发生于任何时间，包括现在、过去和将来，这一段时间到底有多长，我们不知道。它可以是近乎无限长（如表示客观真理），也可以是人们生活中的一段时间（如人们的习惯活动）。一般现在时态通常被描述为有两种基本用法：表示客观真理，以及表示习惯活动具体1．不受时间限制的科学事实、客观真理、谚语格言，以及用于概括、结论、观点等（关于这一用法见7.3.1小节）；2．或者表示人们日常的生活习惯及重复活动（关于这一用法见7.3.2小节）7.2 英文时态体系概述对于英语时态，我们首先要正确掌握各种时态的形式构成，然后着重掌握不同时态形式背后的意义表达。7.2.1 英文时态的构成：四时四态时态（tense and aspect），在英语中其实反映的是两个不同的概念，即tense（时）和aspect（态或体）。与时间相联系的“时”，以及与动作的内在结构相关的“体”或“态”，一、tense（时）用来规定事物发生的时间的。在英文中主要有四种不同的时间标识1．现在时（present）2．过去时（past）3．将来时（future）4．过去将来时（past future）二、aspect（态）用来规定动作完成的程度，反映说话者对事物的态度的。这种动作方面的规定有四种：1．简单体（simple，或者称为“零”体态）2．进行体（continuous）3．完成体（perfect）4．完成进行体（perfect continuous）当我们谈到“时（tense）”的时候，我们关心的是这个动作发生的时间，即是在现在、过去还是将来发生的。当我们谈到“态（aspect）”的时候，我们关心的则是这个动作是固定不变的还是动态变化的（fixed or changing），这个动作是完成了的还是在延续的（complete or ongoing），这个动作持续的时间是很短还是很长（lasting for only a moment or for a long time）等等动词worked为例三 谓语的万能公式 Tense (Modal) (Perfect) (Continuous) Verb PAST or PRESENT (WILL) (HAVE + -ED) (BE + ING) VERB 第一，tense表示“时”，主要有两种最基本的“时”：现在（present）和过去（past）,“时”也是英语谓语的必不可少的组成部分。第二，modal表示英语谓语中的“情态”，这里以will作为代表。其中括号“（）”表示它是一个备选项，即可以被省去。由tense加modal就可以构成上面说过的英语中的另外两种“时”：将来时（will）和过去将来时（would）第三，perfect表示“完成体”，这里以have＋-ed来表示。其中括号“（）”表示它是一个备选项，即可以被省去。第四，continuous表示“进行体”，这里以be＋-ing来表示。其中括号“（）”表示它是一个备选项，即可以被省去。第五，verb表示英语的谓语动词，它没有用括号，表示谓语动词不是备选项，而是必不可少的。最基本的就是时 和 基础动词 这也是一般时态的基本构成四、一般时态的构成“一般时态”只有“时”的变化，而没有“态”的变化。因此，我们把“一般时态”称为“零”体动作。 Tense (Modal) Verb PAST or PRESENT (WILL) VERB 上面这个公式分别表示出一般现在时、一般过去时和一般将来时的谓语构成形式一般现在时:do一般过去时:did一般将来时:will do五、进行时态的构成总的谓语公式只要保留“进行体”去掉“完成体” Tense (Modal) (Continuous) Verb PAST or PRESENT (WILL) BE + ING VERB 六、完成时态的构成总的谓语公式只要保留“完成体”同时去掉“进行体” Tense (Modal) Perfect Verb PAST or PRESENT (WILL) HAVE + -ED VERB 七、完成进行时态的构成总的谓语公式只要把“完成体”和“进行体”的括号全部去掉，表示都是必选项，即可变成完成进行时态的谓语公式 Tense (Modal) Perfect Continuous Verb PAST or PRESENT (WILL) HAVE + -ED BE + ING VERB 基础阶段只涉及“简单体”及“进行体”与三个时间（现在、过去、将来）组合而成的六个时态7.2.2 时态学习技巧一、时态的形式、意义和用法关于时态的用法的讲解和学习，必须结合语境，给出具体的、真实的说话语境，这样才便于读者真正地理解一种时态所要表达的意义及用法。二、深入理解每一种体态动作的核心意义每一种时态的核心意义，就是它最基本、最稳定的中心意义。简单体的核心意义是，被概念化的整体事件，这些事件是无法继续发展的。简言之，一般时态具有完整和不变的核心意义，这种体态与进行体相对。进行体表示不完整的或未完成的，其相关的事件或状态被看作是一个整体的某个部分，往往还有继续发展或变化的余地。 1) John lives in Beijing. 2) John is living in Beijing. 例句1）中，采用的是一般现在时态，把“约翰住在北京”这个情况作为一个整体事件来描述，没有任何进一步发展和变化的可能。在例句2）中，现在进行时表示约翰在北京的居住可能是暂时的，存在发生变化的可能。三、以“体态（aspect）”为学习时态的基础首先，学习时态重在深刻地理解“体（aspect）”的内涵。因为同一“体”的动作有着本质上相通的特点，区别只是说话人的“时间视角”不同罢了。其次，在以表示动作规定方面的“体”为逻辑主线的前提下，分析比较不同时间规定下的同一“体”的动作以及其他各种时态之间的区别（如现在完成时态与一般过去时态的区别）四、动词与时态表达有关对于上述“体（aspect）”方面的属性，英语通过两方面来表达，这也就是英语中的两类体：一类是“语法体（grammatical aspect）”，就是读者熟悉的“进行体（continuous）”和“完成体（perfect）”；另一类是“动词体（lexical aspect）”，这是用来标示动词词义本身所固有的特点（the inherent properties of the verb’s meaning）的。在这方面，英语把动词分为“状态”和“动作”（state and action），又把动作分为“短暂动作”和“延续动作”（punctual and durative）等等。graph LR;A[体]--&gt;B[语法体];A --&gt;C[动词体];动词 --&gt; D[状态];动词 --&gt; E[动作];E --&gt;F[短暂动作];E --&gt;G[延续动作];“体”有广义和狭义之分：广义的“体”包括“语法体”和“动词体”；狭义的“体”就是指“语法体”。要意识到，“语法体（grammaticalaspect）”和“动词体（lexical aspect）”这两方面是相互作用的，二者的共同作用不仅影响到时态的正确使用，同时也深刻地影响着对句子意思的理解7.3 一般现在时态——并非表示现在一般现在时本质的思维特征是：表示从过去到现在直至将来的一段时间内发生的动作（action）或存在的状态（state）一般现在时来表示：1．不受时间限制的科学事实、客观真理、谚语格言，以及用于概括、结论、观点等；2．表示人们日常生活习惯及重复活动。7.3.1 用法一：表示普遍的事实或真理（expressing a general truth）表示不受时间限制的科学事实、客观真理、谚语格言，以及用于概括、结论、观点等。此时，这些动作或状态的发生不限于某个特定的时间，也即它们可发生于任何时间，包括现在、过去和将来。7.3.2 用法二：表示重复活动（expressing a regularly occurring event）表示经常发生的、习惯性的动作（action）或者是存在的状态（state）。动作是瞬间发生的,状态是可以持续的一、表示习惯的动作He often goes to the gym. 他经常去健身房。I go to the gym twice a week. 我每周去两次健身房。二、表示习惯的状态I like rice for dinner.我晚餐喜欢吃米饭。这一用法常和一些表示动作频率的时间副词连用1．表示肯定的频度副词有：always，frequently，usually，sometimes，generally，occasionally和often等等。2．表示否定的频度副词有：never，seldom和rarely。3．表示频度的副词短语有：once a week，twice a year和onalternate days等等。使用以上副词需要注意1．它在句子中的位置通常是：在be动词后、实义动词前。 He is always late. 他总是迟到 He always goes to school by bike. 他总是骑自行车上学2．上述否定副词不能再与否定助动词（如don’t等）连用 He doesn’t seldom come late.*（一般不这么说） He seldom comes late. 他几乎从不迟到3．这些副词一般放在否定助动词前，always除外。 The history lectures sometimes aren’t interesting. 关于历史的讲座有时很没意思。 He doesn’t always leave before 6 o’clock. Sometimes heworks until 7 o’clock.7.3.3 用法比较：表示重复活动的一般现在时态和现在完成进行时态1) I swim 1,000 meters every afternoon.2) I have been swimming 1,000 meters every afternoon.一般现在时swim，我们是指昨天以前是swim 1,000meters，今天也是swim 1,000 meters，明天以后还是swim 1,000meters。至于何时开始swim 1,000 meters或何时将结束swim 1,000 meters，则并不是一般现在时能够表达的出来的，即一般现在时态无法向我们展示一个明确具体的时间段。不同于一般现在时，完成进行时是能够表示明确的时间段概念的，这个时间段就是“从过去一直目前为止”。所以这句话要理解成“到目前为止，我是每天下午游1,000米”。也许“我”打算以后改变一下游泳锻炼的计划，比如说“我”决定再游得更长些一般现在时是在泛泛地谈时间，并没有时间段的概念；而完成进行时表示说话人的脑子里会有一个“到目前为止”的时间段的概念，甚至是给出像for about four years这样一个明确的时间段。7.3.4 用法三：一般现在时表示正在发生的动作一、一般现在时态用在以there或here开头的句子中，表示目前的短暂动作 Here comes your wife. There goes our bus; we’ll have to wait for the next one.二、表示现在瞬间的动作（instant actions）瞬间动作是说话人在说话的同时即刻发生的。这只适用于表达动作的动词，表示对一些动作的解说，比如：球赛解说、剧情介绍、解释自己正在做的事情、给别人一边说一边做的示范动作等等。7.3.5 用法四：一般现在时表示将来发生的动作在某些特定的场合，一般现在时态有时可表示将来发生的动作一、用在条件状语从句和时间状语从句中主要用在条件状语从句（if和unless）和时间状语从句（when，as soon as，before和after等）中，表示将来的动作。Please let me know when he comes back. 他回来时请告诉我。What are you going to do when you leave school? 你毕业以后想要干些什么？从句中的动作come和see均是将在未来发生的，但要用一般现在时表示将来。不过若从句的动作含有“意愿”的意思，则从句中可用will。If you will give me a hand with these books, I’ll appreciate it.如果你愿意帮我拿这些书，我将非常感激。二、在谈到未来的计划和时间安排表的时候，表示将来的动作此时句中的动词往往是表示短暂性动作的动词，如go，come，leave，start和move等等。The train starts at 2 o’clock.火车两点钟开。We move next week. 我们下周搬家。三、在从句中表示将来的动作，此时主句往往用了一个将来时I will reward the person who finds my lost kitten. 我将酬谢找到我的猫的人。7.3.6 用法五：一般现在时表示过去发生的动作在某些特定的场合，一般现在时还可表示过去发生的动作。一、表示死者的理论、著作等因为这些理论、著作到现在仍有效；或表示一些名人名言。Francis Bacon says, “Reading makes a full man; conference aready man; and writing an exact man.”二、引用书刊、报纸、通知或新近收到的信件的内容时The newspaper reads, “The criminal who killed eight womenhas been executed.”7.3.7 用法六：一般现在时代指现在完成时在口语中，可以用一般现在时代指现在完成时。能这样使用的动词不多，通常有：hear，find，see，learn，tell和read等等。I am (＝have been) informed that you have been there. 有人告诉我，你到过那里。I hear (＝have heard) that he has left Beijing. 我听说他已经离开北京了。7.4 被遗忘了的一般过去时态7.4.1 引言7.4.2 基本用法一：过去发生的短暂动作或状态常表示在过去某一个特定的时间所发生的动作或存在的状态，此时常和表示过去的特定的时间状语连用。这些时间状语有：yesterday，yesterday evening，last night，the nightbefore last（前天晚上），last year，last spring（去年春天）以及three days/months/years ago等等。注意，这些时间状语之前不需加介词，比如不能说：at last night，in last year或in three yearsago*等等。表示过去发生的动作 I saw him in the library yesterday morning. 我昨天早上在图书馆看到他了。 I bought this computer three years ago. 我三年以前买的这台电脑表示过去存在的状态He was late for school this morning. 他今天早上上学迟到了。一般过去时态常表示在过去时间所发生的动作或存在的状态，常和表示过去的特定的时间状语连用，或过去时间由上下文及说话的场合暗示出来7.4.3 基本用法二：过去发生的重复或延续活动除了上述表示短暂动作之外，一般过去时还可以表示过去的一段时间内延续或重复的动作,现在已经结束 表示过去延续的活动 I lived in the country for ten years. 我在农村生活了10年。 表示过去重复发生的活动 I wrote a letter once a week to my family when I was in my first college year.7.4.4 用法比较：一般过去时和现在完成时用于“for＋时间段”的区别 误解:认为一般过去时态不能与“for＋时间段”连用，认为“for＋时间段”只能与现在完成时态连用。 I slept for eight hours last night. 我昨晚睡了八个小时。 She lived in our town for three years, but now she is living inBeijing.她在我们这个小镇生活了三年，不过她现在住在北京。两种时态用于“for＋时间段”有何区别呢？一般过去时表示的延续动作图示如下：现在完成时表示的延续动作图示如下：一般过去时与“for＋时间段”连用，表示动作在过去已经结束，并没有延续到现在；而现在完成时与“for＋时间段”连用，则表明动作延续到现在，并且还有可能延续下去。 1) She lived in our town for three years. 2) She has lived in our town for three years. 例句1）中，一般过去时lived表示在过去的某一段时间内持续的动作，但这一动作现在已经结束，即“她现在不再住在这里”。在例句2）中，现在完成时has lived表示动作一直延续到了现在，即“现在她还住在这里”，而且往往还可能延续下去。7.4.5 口语用法一：“我不知道”——”I don’t know” or “I didn’t know”?A说“I didn’t know”的时候其实他已经知道了，因为B已经告诉他，也就是说，他的真正意思应该是“我刚才不知道”7.4.6 口语用法二：“我忘记了”——”I forget” or “I forgot”?“我忘记了这个单词的意思”和“我忘记把你的随身听带来”，这两个“忘记”在汉语中丝毫没有区别，但在英文中却是大不相同，即它们发生的时间不一样。“我忘记了这个单词的意思”是“我“现在还不知道；而“我忘记把你的随身听带来”是当“我“想起来之后说的一句话，“忘记”已成为过去。在我们汉语中说“我忘记做某事”，英文一般都是说成I forgot to do…，因为这一定是当你想起来之后才能说的一句话，“忘记”已成为过去，否则你不可能说出这句话。7.4.7 口语用法三：“我以为”——”I think” or “I thought”?thought是强调“我刚才这么想”，而现实情况往往不同（如上句的I really thought I’d win the match，即“我本来以为我会赢”，但实际没有赢）。而I think则相当于I have an opinion（我这么认为），表示自己的观点。因此，两者的意思可谓是大相径庭。7.4.8 口语用法四：根据上下文的语境灵活地使用一般过去时7.4.9 口语用法五：礼貌表达在口语中，一般过去时（也可用过去进行时）可以表示语气委婉，此时的过去时丝毫没有过去的意味，而谈的是现在的情况。 Could you give me a hand? 你能帮我一下吗？7.5 一般将来时态——预测、计划和意愿7.5.1 引言严格意义上来说，英文里是没有“将来时态”的，而只有现在时态和过去时态这两种时态首先，从时态形式的构成上来看。现在时态的构成是用动词原形，或遇到单数第三人称主语，谓语动词加-s。过去时态的构成则是动词变为过去式（如加-ed或其他特殊变形）。因此，对于现在时态和过去时态，都是在谓语动词的词尾上进行变形。但对于将来时态，在动词的词尾却没有任何变形。表达将来要发生的事情时,有很多种方法,比如使用情态动词will和be going to，比如使用现在进行时（be doing）表示将来的动作，以及采用其他的句型结构，如be to do或者be about to do等will用来表示很有把握的预测（prediction），但不是对事实的叙述或报告。may和might同样可以表示对将来事情的预测，只不过肯定程度是递减的——will比may的把握性大，may比might的把握性大将来时态三大含义1．预测（prediction）：表示说话人认为将来会发生某件事；2．事先计划（future plan）：表示说话人在头脑里已经做出决定将来要做某件事；3．意愿（willingness）：表示说话人既不是预计某事将会发生，也不是预先经过考虑决定将做某事，而是在说话的时刻立即做出决断表明他将去做某事。7.5.2 will表示将来——预测7.5.3 be going to表示将来——预测比较will和be going to一、表示“预测”，be going to比will有更多的证据支持，而且事件发生的时间更近由于be going to是一个现在时态的形式（如am/is/are goingto），因此，它所表示的对将来行为的预测往往暗示与“现在”有联系，而且是在说话后不久就将发生的will 具有较远的或不确定的将来这样的意味所以当有现在的证据可以支持预测时，或者说根据目前的明显迹象来推断某件事将要发生时，我们就要用be going to，而不宜用will。 You look very pale. I am sure you are going to get sick. The figures suggest that we are going to make a good profitthis year. 上面表达“预测”的例句都具有“现在的证据支持预测”这个特点be going to还往往表示当前已有迹象表明说话者无力控制的（uncontrollable）即将发生的行为。 Help! I’m going to fall! The traffic is terrible. We’re going to be late.相比较而言，will则只是表明说话人认为或相信某件事将要发生。 There will be a lot of rainfall next spring.或者will用于“在某种条件下某事才会发生”的情况。所以，在带有条件或时间状语从句的主句中，我们通常用will表示预测，而不用be going to。 You’ll feel better when you take this medicine. 吃完这些药，你就会感觉好些的。1) I’m going to be sick.2) I will be sick.例句1）中，说话人相当于说：I’m going to be sick（because I feel terrible now）．意思是“我感觉要生病了，因为我现在很不舒服”，即有目前的迹象表明要生病了。在例句2）中，说话人相当于说：I will be sick (if I eat any more of this ice cream).意思是“我不能再吃冰淇淋了，再吃就要生病了”。这种预测是附带在另一条件之上的。二、表示“预测”时，will的语气比be going to显得正式will比较正式，be going to更为不正式，常用于私人谈话中，所以在口语中很常用，而且be going to 在口语交流中常被读成be gonna。7.5.4 be going to表示“计划”与will表示“意愿”一、be going to表示计划，需要用“人”作主语用人称 + be going to 表示 计划/推测非人称 + be going to 表示推测 Look at those black clouds! It’s going to rain.人称 + be going to 表示计划还是推测要根据上下文语境在表示“预测”时，我们并不要求主语一定是人称，因为此时是暗含“说话人”在做“预测”的意思，已经是“人”在做预测了，所以这时与句子的主语是否是人称无关。但是，在表示“打算”时，是句子的主语在做打算，因而此时句子的主语必须是人称。二、be going to可以表示“决心”，具有强烈的感情色彩 We’re going to become the world’s leading forwarding company.三、will表示“意愿”，一个当机立断的决定关于will表示“意愿”的情况要注意以下几点第一，will表示“预测”时，句子的主语往往是无生命的事物，与此不同的是，当will表示“意愿”时，句子的主语通常是有生命的“人”。不过，若用“物”作主语则具有拟人的意味，此时说话人往往是在抱怨，而且通常用否定形式的won’t。 The closet door won’t open. Will you try it?第二，will这种表示“意愿”的意义，若用于第二人称（you）的一般疑问句（Will you?）中，则可以用来提出“请求” Will you help me to mail these letters? Will you marry me?第三，关于will的否定1) Paul won’t come, because he is too busy.2) Paul won’t come, because he doesn’t want to.在例句1）中，will作为“推测”的用法，否定词not是重点否定主要的谓语动词come，相当于predict NOT to come。因此，例句1）我们可译成“我想保罗恐怕来不了，因为他太忙了”。在例句2）中，will作为“意愿”的用法，否定词not是重点否定情态动词will，相当于NOT willing to come。因此，例句2）我们可译成“保罗不愿意来，因为他不想来。”否定形式的won’t在句中会有歧义。不过，一般来讲，我们通常把won't do等同于refuse to do来理解，即表示“不愿意”，而用won't be doing来表达说话人的预测。四、比较：will表示“意愿”和be going to表示“打算”1．be going to表示说话人对未来行动的计划或打算，通常是经过事先考虑并含有已经为这一行动做了某些准备的意思。2．will表示意愿，表示在说话的时刻立即做出决定将去做某事，事先并没有经过考虑，更没有为这一活动做出事先的准备。7.5.5 现在进行时表示将来现在进行时可以表示对最近的将来做出计划或安排。 I am flying to Beijing next Monday.用现在进行时表示将来的动作要注意以下几点一、必须带有表示将来的时间状语用现在进行时表示将来的动作，动作发生的时间必须指出或在前文中已经指出，否则就可能会造成现在进行动作与一般将来动作相混淆。二、必须是人称主语通常是表示说话人已计划安排好的活动，如果不是，则不能这样用。三、与一般现在时表示将来的区别1．一般现在时要比现在进行时听起来更正式，个人主观色彩要淡些。 1) I am leaving tonight. 2) I leave tonight.2．如果是一系列预定的将来的安排，比如旅游行程安排，用进行时态显得较累赘，而用一般时态则较简洁。 We leave Beijing at 9:00 tomorrow morning, arrive inKunming around 12:00 and then we tour the World Horti-ExpoGarden.四、用be going to表示计划与进行时态表示的计划区别be doing表达的将来计划要比be going to的计划更确定 1) I’m taking my holiday in April. 2) I’m going to take my holiday in April. am taking表示比am going to take更确定的将来计划，可以这样来解释：在例句1）中，说话人已经得到公司批准的假期了或已经和旅行社订好了行程。所以，我们可以把它译成比较确定的汉语，比如我四月份要休假了。在例句2）中，说话人只是表达自己的一个打算或想法意图（intention），但目前并没有得到公司的准假，更没有和旅行社订好行程。这句话相当于汉语说我打算四月份休假，这就没有“我四月份要休假了”听起来确定。7.5.6 一般现在时表示将来 I begin to work at the Swan Laundry on Monday.一般现在时begin表示将来的动作，句中的on Monday是表示将来的时间。7.5.7 其他表示将来的句型结构一、be to do1．表示已安排好要在将来发生的事，是比较正式的用法 They are to go on a strike on July 8th. 他们定于7月8日举行罢工。2．表示强烈的命令，相当于must，should，如：父母对孩子、上级对下级或法律条文中的规定等 You are to finish your homework before you go to play. 出去玩之前一定要把作业完成了二、be about to do这一结构用来表示即将发生的动作（比如通常在5分钟之内就会发生），意思是“正要，马上就要”。 The train is about to leave. 火车马上就要开了。三、be on the point/verge/brink/eve of doing这一结构与be about to do的意思差不多，但其动作发生的时间比be about to do还要快一些。 He was on the point of killing himself when she stepped into his room. 她走进房间时，看见他正要自杀。第八章 英文时态（二）：进行时态8.1 引言8.1.1 进行时态的构成进行时态的构成是be＋doing。注意这里be动词不是系动词，而是助动词，没有“是”的意思。可以通过对助动词be的变形来反映人称和时间的变化。三种不同时间下的进行时态8.1.2 进行时态的意义进行时态最典型的一个意义——表示正在发生的动作。具体来说，进行时是强调在某个特定的（现在、过去或将来）时间点，某项活动正在发生。进行时态往往和某一特定的时间点连用，来表示某一个活动在该时刻正在进行。这个特定的时刻可以是直接给出具体的时间，也可以是另一具体的活动。 I was watching CCTV news when he arrived yesterday. 他昨天到的时候，我正在看中央电视台的新闻。一、直接给出具体的时间 I am listening to the English program right now. 我现在正在收听英文节目。二、通过另一活动表达这一特定时刻 I was watching CCTV news when he arrived. 他到的时候，我正在看中央电视台的新闻。8.1.3 进行时态的使用语境进行时态因为往往强调在说话的时刻某活动正在发生，所以常用进行时态表达生动、具体的场景。而进行时态因为其表现生动，所以在口语中出现的频率远远高于书面语。8.2 现在进行时——不一定正在进行8.2.1 用法一：说话时刻正在进行的动作（action happening exactly now）8.2.2 用法二：在目前一段时期内持续的一种暂时的情况（action happening around now）进行时态的这种用法表示目前的一种短暂的情况，所以它有时含有一种“今昔对比”之意。 I am taking the bus to work this week, because my car is inthe garage.这些句子中的进行时态都是表示现阶段在延续的一般活动，而不是正在发生的活动。但它们也并不是恒久的或是规律性的活动（not permanent or habitual），否则就要用一般现在时态了。8.2.3 用法三：用于表示“改变”的动词，强调“逐渐变化”的过程若是用于表示“改变”的动词，则强调“逐渐变化”的过程。常见的表示“改变”的动词有：change, come, get, become, grow和deteriorate（恶化）等。 this neighborhood is really booming. It’s notreally a suburb any more. it is getting crowded. booming和getting用于进行时态显然都是表示“逐渐改变”的意思，所以分别译成“越来越繁荣”和“越来越（拥挤）”8.2.4 用法四：用于强烈的感情色彩的表达此时说话人用进行时态，并非是要强调某个正在进行的动作，而是要表达自己强烈的情感。 You are asking too much! 你的要求太过分了！进行时态的这种表示强烈感情的用法，读者在看美国电影时可以注意体会，并可以在口语中模仿使用。8.2.5 用法五：表示将来确定的安排现在进行时在口语中还经常用来表示将来的动作，此时现在进行时是表示在说话之前就确定的、计划好的将来的安排 What are you doing for New Year’s Eve?进行时态are doing则不表示正在进行的动作，而是表示一个确定的、计划好的将来的活动，意思是“你除夕夜有何节目？有什么活动？”注意加上时间状语,如果不加时间状语就会和正在发生的动作混淆be doing和be going to do都可以表示将来的计划，区别在于?现在进行时强调事先已经做好的安排，是比较确定要发生的；而be going to着重表现说话者的计划和意图，并不是确定的安排。 1) I’m staying at Beijing. 2) I’m going to stay at Beijing. 1）我会待在北京。 2）我打算待在北京。对于静态的动词和无生命的主语，不可能使用现在进行时来表示将来。但可以用于be going to，这时表示预测。如不能把belong to用于进行时态8.2.6 用法六：与always等连用，表示多次重复，且含有感情色彩常与always, forever, continually和constantly等连用，表示多次重复的行为。这种反复的行为可以是积极的、让人喜欢的事情。但也往往表示让说话者厌烦、感觉不合情理或使人不愉快的事，即通常具有负面的、消极的含义。8.3 过去进行时——回顾过去讲故事8.3.1 常见用法：用来设置故事的背景进行时态往往表示一个在持续的活动场景，所以用过去进行时来铺垫故事的背景，往往会给读者一种身临其境的感觉。多见于文学作品中日常生活的叙事中，我们更多的是把“过去进行时”和“一般过去时”配合使用。此时，过去进行时通常表示一个历时较长的体现“背景”的动作或状态；而一般过去时则表示在此“背景”下发生的一个短暂的动作或状态。简言之，长动作用过去进行时，短动作用一般过去时，以此表示在过去进行时的动作的持续期间，发生了另一个短暂动作。这两个动作之间用when或while连接 一、动作长短的相对性及其与时态的关系 I was watching TV when the telephone rang. 动作的长短是指具体句子里的两个动作的相对长短。相对短的动作用一般过去时，相对长的动作用过去进行时。若时态用错，句意可能就要发生改变。 1) I was telephoning Harry when she arrived. 2) I telephoned Harry when she arrived. 3) 例句1）中，telephone是一个延续动作，arrive是短暂动作。用进行时telephoning是表明在“我”打电话的过程中，她到了，即先telephone，后arrive。在例句2）中，telephone和arrive都用一般过去时，都变成了短暂动作。此时，是表明“我”打电话是发生在她回来之后，即先arrive，后telephone。 二、when和while的区别 when的后面接短动作，用一般过去时（when＋short action,simple past tense），或者接长动作，用过去进行时（when＋longaction, past continuous tense）； while的后面只能接长动作，用过去进行时（while＋longaction, past continuous tense）。8.3.2 少见用法：两个过去同时在持续的动作若句中是两个长动作，则都要用过去进行时，表示两个过去同时在持续的动作。最后附带说明的是，如果是两个短动作，则都用一般过去时态。1．句中有一个长动作和一个短动作：长动作用过去进行时，短动作用一般过去时；2．句中两个动作都是长动作：都用过去进行时；3．句中两个动作都是短动作：都用一般过去时。8.3.3 典型用法：描述一个过去的特定时刻正在发生的事情过去进行时还可以用来描述一个在过去的特定时刻正在发生的事情，这是各种进行时的典型用法。8.3.4 口语用法：表示委婉的请求或提建议这时并不表示过去时间的动作。这尤其适用于表示态度的动词，如w onder，hope和think等，这些动词用过去进行时（was wondering）或现在进行时（is wondering），均表示现在的一种愿望或态度，给人一种探询式的、犹豫不决的印象，因而显得很礼貌。8.4 将来进行时——想象未来8.4.1 典型用法：将来某一特定时刻正在持续的事想象自己或其他人在将来某一特定时刻（at a particular time in future）正在做某事。8.4.2 口语用法：将来计划好的事在日常的口语中，我们常用will be doing来谈一个将来计划好的事情。现在进行时态be doing也可以表示计划好的事。两者的区别不是很大。因此，表示将来安排好的事情，两种时态可以换用。8.4.3 少见用法：表示背景动作——提供另外一个短动作发生的事件背景8.4.4 难点用法1：用在疑问句中，表示客气地询问8.4.5 难点用法2：用来表示客观的将来，以避免与表示“意愿”的will do混淆8.5 难点：深入分析进行时的思维特征8.5.1 进行时态的核心含义（grammatical aspect）8.5.2 进行时态与动词体（lexical aspect）附录 答案解析结语" }, { "title": "JVM 学习", "url": "/posts/jvm-%E5%AD%A6%E4%B9%A0/", "categories": "", "tags": "", "date": "2022-09-03 10:08:00 +0800", "snippet": "第1篇-字节码篇1.01-课程内容介绍1.02-JVM的概述内容如何理解JVM跨平台语言Java发展的几个重大事件现在的JMC就是之前JRockit提供的监控工具dk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）jdk1.9 默认...", "content": "第1篇-字节码篇1.01-课程内容介绍1.02-JVM的概述内容如何理解JVM跨平台语言Java发展的几个重大事件现在的JMC就是之前JRockit提供的监控工具dk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）jdk1.9 默认垃圾收集器G1CMS在14中被彻底干掉ZGC是未来,目前还不是默认的垃圾回收器说说你认识的JVMGraal VM是虚拟机未来安卓使用的事Dalvik VMJVM的生命周期Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initialclass)来完成的，这个类是由虚拟机的具体实现指定的。重点说下HotSpotSUN的]DK版本从1.3.1开始运用HotSpot虚拟机，2006年底开源，主要使用C++实现，JNI接口部分用C实现。HotSpot,是较新的]ava虚拟机，使用JIT(Just in Time)编译器，可以大大提高Java运行的性能。]ava原先是把源代码编译为字节码在虚拟机执行，这样执行速度较慢。而HotSpot将常用的部分代码编译为本地(原生，native)代码，这样显着提高了性能。HotSpot JVM参数可以分为规则参数(standard options)和非规则参数(non-standard options).规则参数相对稳定，在]DK未来的版本里不会有太天的改动。非规则参数则有因升级]DK而改动的可能。画出JVM架构图务必画出来程序计数器,本地方法栈,虚拟机栈 线程私有方法区,堆 多个线程共享注意这是HotSpot JVMJRockit,J9 没有涉及方法区概念执行引擎就是一方面解释运行,另一方面就是JIT编译器对热点代码进行编译缓存上图还有更详细版本这个架构可以分成三层看： 最上层：javac编译器将编译好的字节码class文件，通过java类装载器执行机制，把对象或class文件存放在jvm划分内存区域。 中间层：称为Runtime Data Area,主要是在Java代码运行时用于存放数据的，从左至右为方法区（永久代、元数据区）、堆(共享，GC回收对象区域)、栈、程序计数器、寄存器、本地方法栈（私有）。 最下层：解释器、JIT(just in time)编译器和GC(Garbage Collection,垃圾回收器)JVM有哪几块知识脉络graph TD; A[class文件结构]--&gt;B[类的加载]; B--&gt;C[内存的结构与分配]; G[执行引擎] --&gt; C; C--&gt;D[垃圾回收算法与垃圾回收器]; D --&gt;E[性能监控命令行可视化工具]; E --&gt; F[性能优化];1.03-字节码文件的概述资金码文件是跨平台的吗?Java虚拟机主要识别的字节码文件,已经不和编程语言耦合字节码文件里面是什么?字节码是一种二进制的类文件,内容是JVM指令前端编译器种类Java源代码的编译结果是字节码， 那么肯定需要有 一种编译器能够将]ava源码编译为字节码， 承担这个重要责任的就是配置在path环境变量中的javac编译器。 javac是一种能够将]ava源码编译为字节码的前端编译器在Java的前端编译器领域，除了javac之外，还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的ECJ(Eclipse Compiler for Java)编译器。和]avac的全量式编译不同，ECJ是一种增量式编译器。默认情况下，Intel1i)IDEA使用javac编译置(还可以自己设置为Aspect]编译器ajc)前端编译器的任务前端编译器的主要任务就是负责将符合]ava语法规范的]ava代码转换为符合JVM规范的字节码文件目前前端编译器的局限性？前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的]IT编译器负责。哪些类型对应有Class的对象？(1)class: 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类(2)interface:接口(3)[]:数组(4)enum:枚举(5)annotation:注解@interface(6)primitive type:基本数据类型(7)voidint[] a = new int [10];int[] b = new int[100];Class c10 = a.getclass（）;Class c11 = b.getclass（）;//只要元素类型与维度一样，就是同一个C1assSystem.out.println(c10 = c11);1.04-跟字节码使用相关的几个面试代码题什么是字节码指令？Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。一个字节说明情况不会超过256种@Testpublic void test2() { int i 10; i=i++; System.out.println(i);//}局部变量放在栈中的局部变量表一个不清楚结果的代码就需要看字节码进行分析1.05-class文件结构的分析可以在IDEA里面安装jclasslib Bytecode viewer可以在IDEA里的View界面去寻找Class文件的总体结构如下: 魔数 cafebabe class文件版本 常量池 访问标识（或标志） 类索引，父类索引，接口索引集合 字段表集合 方法表集合 属性表集合1.06-相关的字节码指令字节码指令按用途分类·加载与存储指令·算术指令·类型转换指令·对象的创建与访问指令·方法调用与返回指令·操作数栈管理指令·控制转移指令·异常处理指令·同步控制指令分清哪些是往操作数栈存放 push哪些是往局部变量表里存取 store load第2篇-类的加载篇1.07-类的加载概述_loading的阶段类加载分为哪三步?加载,链接,初始化链接分为哪三步验证,准备,解析谁需要加载基本数据类型由虚拟机预先定义,引用数据类型则需要进行类加载2.01-链接环节的执行2.02-类的初始化_主动使用与被动使用2.03-类的使用与类的卸载2.04-类的加载器的分类2.05-ClassLoader的源码分析2.06-自定义类的加载器2.07-双亲委派机制2.08-Tomcat的类加载机制第3篇-运行时内存篇2.09-程序计数器的理解2.10-栈的理解3.01-局部变量表的说明3.02-操作数栈3.03-动态链接(指向运行时常量池中该方法的引用）3.04-方法返回地址3.05-栈总结的5个面试问题3.06-本地方法栈的说明3.07-堆空间大小的设置3.08-新生代与老年代的参数设置3.09-对象分配过程3.10-MinorGC、MajorGC、FullGC3.11-方法区的设置_演进4.01-小结第4篇-对象内存布局4.02-对象的创建方式4.03-创建的对象的内存分配过程4.04-对象的内存布局4.05-对象的访问定位第5篇：执行引擎篇4.06-解释器与JIT编译器4.07-JIT针对何种代码进行提前编译4.08-两种不同的编译器C1和C2第6篇-垃圾回收篇4.09-GC的基本概念4.10-引用技术算法的理解4.11-可达性分析算法4.12-垃圾标记和清除环节的算法4.13-System.gc()与finalize()的说明4.14-内存溢出和内存泄漏问题4.15-安全点与安全区域_并行与并发5.01-5种引用的说明5.02-GC评价指标5.03-GC的组合关系5.04-SerialGC5.05-ParNewGC5.06-ParallelGC5.07-CMSGC5.08-G1GC5.09-GC日志分析5.10-案例一：堆溢出5.11-案例二：元空间溢出5.12-案例三：GC overhead limit exceeded5.13-案例四：创建线程15.14-案例四：创建线程2第7篇-VM性能监控篇第8篇-VM性能调优案例篇6.01-调优的基本问题6.02-调优的步骤6.03-Jmeter的配置6.04-优化案例1：调整堆大小提升服务的吞吐量6.05-优化案例2：逃逸分析之栈上分配6.06-优化案例2：逃逸分析之标量替换、锁消除6.07-优化案例3：合理配置堆内存6.08-如何计算YGC发生频率6.09-UseAdaptiveSizePolicy的使用6.10-优化案例4：CPU占用很高的排查方案6.11-优化案例5：G1并发GC线程数对性能的影响6.12-优化案例6：调整垃圾回收器对吞吐量的影响6.13-优化案例7：日均百万订单如何设置JVM参数6.14-多种命令行工具的使用6.15-Arthas的基本使用6.16-课程结束" }, { "title": "设计模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/", "categories": "", "tags": "", "date": "2022-09-03 08:58:00 +0800", "snippet": "01 -导论什么是 GOF?在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发...", "content": "01 -导论什么是 GOF?在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。对接口编程而不是对实现编程。优先使用对象组合而不是继承。什么是对实现编程?B在使用A的方法,经常使用的是其实现类,而不是接口定义的抽象方法设计模式的基石是什么? 面向对象的三大特性 封装, 零散的内容封装在一起 继承, 通过类的继承关系不断进行功能扩展 多态, 传入A1调A1,传入A2调A2 设计模式总览 创建型模式（Creational Patterns） 单例（Singleton）模式 原型（Prototype）模式 工厂方法（FactoryMethod）模式 抽象工厂（AbstractFactory）模式 建造者（Builder）模式 结构型模式（Structural Patterns） 代理（Proxy）模式 适配器（Adapter）模式 桥接（Bridge）模式 装饰（Decorator）模式 外观（Facade）模式 享元（Flyweight）模式 组合（Composite）模式 过滤器模式（Filter Pattern） 行为型模式（Behavioral Patterns） 模板方法（Template Method）模式 策略（Strategy）模式 命令（Command）模式 职责链（Chain of Responsibility）模式 状态（State）模式 观察者（Observer）模式 中介者（Mediator）模式 迭代器（Iterator）模式 访问者（Visitor）模式 备忘录（Memento）模式 解释器（Interpreter）模式 为什么要分为这三种类型?要完成一个功能,第一步要定义一个类,要有什么属性和方法第二步,我们要创建类的对象,才能干活第三步,最后调用类对象的相关方法,让类完成相应的功能2实际上设计模式是混用的设计模式复杂的联动也是框架的核心,当你扒清他的内结构发现清楚他的方法调用以后所有的框架对你来说都是非常easy的设计的七大原则这是我们做设计时需要考虑的原则,但不是必须的原则,如果采用后导致系统复杂度上升一个数量级,就没必要使用这个 开闭原则（Open Closed Principle，OCP） 软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification） 合成复用原则、里氏替换原则相辅相成，都是开闭原则的具体实现规范 扩展新类而不是修改旧类 一个功能的新增,修改最好通过增加类的方式解决 里氏替换原则（Liskov Substitution Principle，LSP） 继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects） 继承父类而不去改变父类 子类不去重写父类已经定义好的方法,而是重写父类留给拓展的方法,那么在定义父类的时候就要注意,如果方法是会变动的,就留下扩展的方法定义 依赖倒置原则（Dependence Inversion Principle，DIP） 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions） 面向接口编程，而不是面向实现类 A,B是抽象类 a1,b1分别是其实现类,是细节 A里面不应该出现b1的引用,a1依赖b1,不能引用b1,而应该是B 单一职责原则（Single Responsibility Principle，SRP） 一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change） 每个类只负责自己的事情，而不是变成万能 接口隔离原则（Interface Segregation Principle，ISP） 一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。 各个类建立自己的专用接口，而不是建立万能接口 迪米特法则（Law of Demeter，LoD） 最少知识原则（Least Knowledge Principle，LKP) 只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers） 无需直接交互的两个类，如果需要交互，使用中间者 过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低 合成复用原则（Composite Reuse Principle，CRP） 又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP） 软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现 优先组合，其次继承 组合指的是作为一个对象放到属性中,继承指的是继承所有属性 02 -创建型模式-为什么使用创建型模式单例(Singleton)模式原型(Prototype)模式工厂方法(FactoryMethod)模式抽象工厂(AbstractFactory)模式 工厂方法和抽象工厂可以统一叫工厂模式建造者(Builder)模式 创建型设计模式关注点”怎样创建出对象” “对象的创建和使用分离” 降低系统的耦合度 使用者无需关注对象的创建细节 对象的创建由相关的工厂来完成:(各种工厂模式) 使用者不关注细节 对象的创建由一个建造者来完成(建造者模式) 使用者关注创建过程中的一些细节 对象的创建由原来对象克隆完成 (原型模式) 对象再系统中只有一个实例 (单例模式) 03 -创建型模式-单例的演示 一个单一的类,负责创建自己的对象,同时确保系统中只有单个对象被创建单例特点 某个类只能有一个实例；（构造器私有） 它必须自行创建这个实例；（自己编写实例化逻辑） 它必须自行向整个系统提供这个实例；（对外提供实例化方法）04 -创建型模式-单例的应用场景 什么场景用到？ 多线程中的线程池 数据库的连接池 系统环境信息 上下文(ServletContext) 面试问题 系统环境信息(System.getProperties（）)? Spring中怎么保持组件单例的？ ServletContext是什么？是单例吗？怎么保证？ ApplicationContext:tomcat:一个应用会有一个应用上下文 ApplicationContext:Spring:：表示整个I0C容器(怎么保证单例)。ioc容器中有很多组件(怎么保证单例) ApplicationContext是什么？是单例吗？怎么保证？ 数据库连接池一般怎么创建出来的，怎么保证单实例？ 05 -创建型模式-原型模式创建重复对象,同时能保证性能1、GuiguMyBatis:操作数据库，从数据库里面查出很多记录(70%改变很少)2、每次查数据库，查到以后把所有数据都封装一个对象，返回。10000 thread:查一个记录：new User(“zhangsan”,18);每次创建一个对象封装并返回系统里面就会有10000个User:浪费内存3、解决：缓存；查过的保存。如果再查就返回从缓存中直接拿容易读到别的进程修改后的内容,因此不能直接给希望能快速得到克隆体就需要原型模式实现Cloneable接口,重写克隆方法 什么场景用到？ 资源优化 性能和安全要求 一个对象多个修改者的场景。 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时可以考虑使用原型模式拷贝多个对象供调用者使用。 06 -创建型模式-工厂-简单工厂模式工厂模式(Factory Pattern)提供了一种创建对象的最佳方式。我们不必关心对象的创建细节，只需要根据不同情况获取不同产品即可从易到难graph LR;工厂 --&gt;产品A[\"简单工厂(Simple Factory)\"]--&gt;B[\"工厂方法(Factory Method)多态工厂\"]--&gt; C[\"抽象工厂(Abstract Factory)\"]简单工厂呢产品数量有限,只需要if 判断就能解决更多的产品就违反开闭原则classDiagram class AbstractCar { +String engine; +run() } &lt;&lt;abstract&gt;&gt; AbstractCar AbstractCar --|&gt; VanCar class VanCar { +VanCar() +run() }AbstractCar --|&gt; MiniCarclass MiniCar { +MiniCar() +run()} %% 简单工厂适用于产品类型少,使用if else 来判断即可classDiagramclass WuLinSimpleFactory { +newCar(type) AbstractCar}%% 如果太多的产品,不符合开闭07 -创建型模式-工厂-工厂方法模式classDiagram class AbstractCar { +String engine; +run() } &lt;&lt;abstract&gt;&gt; AbstractCar AbstractCar --|&gt; VanCar class VanCar { +VanCar() +run() }AbstractCar --|&gt; MiniCarclass MiniCar { +MiniCar() +run()} 怎么把一个功能提升一个层次：定义抽象(抽象类，接口)%% 简单工厂适用于产品类型少,使用if else 来判断即可classDiagramclass AbstractCarFactory { +newCar() AbstractCar}class WulinMinCarFactoy { +newCar() AbstractCar(MiniCar)}AbstractCarFactory --|&gt; WulinMinCarFactoyclass WuliRacingCarFactoy { +newCar() AbstractCar(RacingCar)}AbstractCarFactory --|&gt; WuliRacingCarFactoy之前是一个工厂生产多种车,现在变成一个工厂生产一类车,四种产品 Product 抽象产品 Abstract Car ConcreteProduct 具体产品 MiniCar VanCar Factory 抽象工厂 定义能干什么 AbstractCarFactory ConcreteFactory 具体工厂 生产什么东西方法一多以后就又会变复杂,上面的例子产品都是汽车,如果想生产其他产品,就会出现问题08 -创建型模式-工厂-抽象工厂模式产品等级 和 产品族同一种产品的不同类型就是产品等级(小米/华为)产品族是指由同一个工厂生产的classDiagram class AbstractCar { +String engine; +run() } &lt;&lt;abstract&gt;&gt; AbstractCar AbstractCar --|&gt; VanCar class VanCar { +VanCar() +run() }AbstractCar --|&gt; MiniCarclass MiniCar { +MiniCar() +run()} classDiagramclass AbstractMask { Integer price +protectedMe() } &lt;&lt;abstract&gt;&gt; AbstractMaskclass N95Mask { +N95() +protectedMe() }AbstractMask --|&gt; N95Maskclass CommonMask { +CommonMask() +protectedMe()}AbstractMask --|&gt; CommonMaskclassDiagramclass WulinFactory{ newCar()* AbstractCar newMask()* AbstractMask}&lt;&lt;abstract&gt;&gt; WulinFactory%% 抽象出来一个总的工厂,定义能干什么活%% 只为生产汽车,别的返回空即可class WulinRacingCarFactory{ +newCar() AbstractCar(Racing) +newMask() null}WulinFactory --|&gt; WulinRacingCarFactoryclass WulinWuhanMaskFactory{ +newCar() null +newMask() AbstractMask(N95Mask)}WulinFactory --|&gt; WulinWuhanMaskFactory%% 可以有更多的何时用接口,何时用抽象类如果只是方法,可以用接口如果有一些属性需要向下传递,则需要抽象类09 -创建型模式-工厂-工厂模式的思考如果只有一个产品,抽象工厂退化为工厂方法模式,如果一个产品下面类型数量不多,退化为简单工厂10 -创建型模式-建造者构建细节复杂,但是必须暴露给使用者屏蔽过程,但不屏蔽细节classDiagram %% 要生产的手机,不暴露set方法,但是属性还是要看%% #表示同包可以访问class Phone { #String cpu #String mem #String disk #String cam +getCpu() +getMem() +getDisk() +getCam()}class AbstractBuild { Phone phone coutomCpu(String cpu)* void coutomMem(String mem)* void coutomDisk(String disk)* void coutomCam(String cam)* void getProduct() Phone}&lt;&lt;abstract&gt;&gt; AbstractBuildclass XiaomiBuilder { XiaomiBuilder() coutomCpu(String cpu) void coutomMem(String mem) void coutomDisk(String disk) void coutomCam(String cam) void }AbstractBuild --|&gt; XiaomiBuilder11 -结构型模式-适配器 结构型模式关注点“怎样组合对象/类？”所以我们关注下类的组合关系 类结构型模式关心类的组合，由多个类可以组合成一个更大的（继承） 对象结构型模式关心类与对象的组合，通过关联关系在一个类中定义另一个类的实例对象（组合） 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。 适配器模式(Adapter Pattern):两个不兼容接口之间适配的桥梁 桥接模式(Bridge Pattern):相同功能抽象化与实现化解耦，抽象与实现可以独立升级。 过滤器模式(Filter、Criteria Pattern):使用不同的标准来过滤一组对象 组合模式(Composite Pattern)：相似对象进行组合，形成树形结构 装饰器模式(Decorator Pattern):向一个现有的对象添加新的功能，同时又不改变其结构 外观模式(Facade Pattern)：向现有的系统添加一个接口，客户端访问此接口来隐藏系统的复杂性。 享元模式(Flyweight Pattern):尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象 代理模式(Proxy Pattern):一个类代表另一个类的功能将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，适配器模式分为类结构型模式（继承）和对象结构型模式（组合）两种，前者（继承）类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。别名也可以是Wrapper,包装器classDiagram class Translator { &lt;&lt;interface&gt;&gt; translate(String content) String}class Player { &lt;&lt;interface&gt;&gt; play() String} Player ..|&gt; MoviePlayer%% 之前只能正常的播放字幕,需要一个适配器翻译成日文 class MoviePlayer { play() }%% 有两种方法引入翻译机制,继承或新增对象,继承在play方法里调用translate方法 Player ..|&gt; JPMovieAdapter Translator --|&gt; JPMovieAdapter class JPMovieAdapter { -Player target -Translator translator +JPMovieAdapter(Player player) play() }12 -结构型模式-适配器一些场景Tomcat如何将Request流转为标准Request;·tomcat.Request接口 ·serv et.Request:接口 tomcat===CoyoteAdapte ===ServletRequestSpring AOP中的AdvisorAdapter是什么Spring MVC中经典的HandlerAdapter是什么SpringBoot中WebMvcConfi gurer Adapter为什么存在又取消13 -结构型模式-桥接模式系统设计期间，如果这个类里面的一些东西，会扩展很多，这个东西就应该分离出来抽象化(Abstraction)角色：定义抽象类，并包含一个对实现化对象的引用。扩展抽象化(Refined Abstraction)角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法实现化(Implementor)角色：定义实现化角色的接口，供扩展抽象化角色调用。适配器是在用的过程中,需要添加的,桥接是在设计阶段就要添加的classDiagramclass AbstractSale { &lt;&lt;abstract&gt;&gt; -String type -Integer price +AbstractSale(String type,Integer price) getSaleInfo() String}AbstractSale --|&gt; OfflineSaleclass OfflineSale { +OfflineSale(String type,Integer price)}AbstractSale --|&gt; OnlineSaleclass OnlineSale { +OnlineSale(String type,Integer price)}classDiagramclass Phone { String info String price}class AbstractPhone { AbstractSale sale getPhone()* String +setSale(AbstractSale sale)}AbstractPhone --|&gt; IPhoneAbstractPhone --|&gt; MiPhoneclass IPhone {getPhone()}class MiPhone{getPhone()}桥接节省了类的创建真正会引起此类变化的一个维度直接抽取出来,通过组合的方式接起来14 -结构型模式-理解适配器与装饰器都可以称为Wrapper适配器是连接两个类,可以增强一个类装饰器是增强一个类15 -结构型模式-装饰器%% 抽象构建classDiagramclass ManTikTok { &lt;&lt;interface&gt;&gt; tiktok() void}ManTikTok ..&gt; LeiTikTok%% 原始的直播,被装饰对象class LeiTikTok { +tiktok()}ManTikTok --|&gt; TiktokDecorator%% 抖音直播装饰器%% 抽象装饰器class TiktokDecorator { &lt;&lt;interface&gt;&gt; tiktok() void enable()}TiktokDecorator ..&gt; MeiYanDecorator%% 美颜装饰器%% 在tiktok里面先调用enable方法,然后再调用传入的manTikTok的tiktok方法class MeiYanDecorator {+ManTikTok mantiktokMeiYanDecorator(ManTikTok manTikTok)tiktok() voidenable() void}调用别人的美颜功能就是适配器,调用自己写的美颜就是装饰器已存在的类,在某一天发现功能不够,就可以用装饰器SpringSessiont中如何进行session与redis关联？HttpRequestWrapperMyBatisPlus提取了QueryWrapper,这是什么？Spr ing中的BeanWrapper是做什么？Spring Webflux中的WebHandlerDecorator?16 -结构型模式-代理模式-静态代理代理模式(Proxy Pattern),给某一个对象提供一个代理，并由代理对象控制对原对象的引用，对象结构型模式。这种也是静态代理静态代理和装饰器一摸一样classDiagram%% 抽象主题,被代理角色class ManTikTok { &lt;&lt;interface&gt;&gt; tiktok() void}ManTikTok ..&gt; LeiTikTok%% 主体,当前class LeiTikTok { +tiktok()}ManTikTok ..&gt; TiktokPrroxy%% 代理,和被代理对象,属于同一个接口%% 把代理对象传进去%% 在tiktok中调用被代理对象的tiktok ,可以增强,也可以替换class TiktokPrroxy { -ManTikTok manTikTok +TiktokProxy(ManTikTok manTikTok) +tiktok()}静态代理就是装饰器装饰器模式是代理模式的一种17 -结构型模式-代理模式-jdk动态代理静态代理 不同的代理对象,要创建不同的静态代理类classDiagramclass ManTikTok { &lt;&lt;interface&gt;&gt; tiktok() void}ManTikTok ..&gt; LeiTikTok%% 主体,当前class LeiTikTok { +tiktok()}JDK动态代理,代理对象和目标对象的共同点在于都是同一个接口public class JdkTiktokProxy&lt;T&gt; implements InvocationHandler { public static&lt;T&gt; T getProxy(T t) { private T target; JdkTiktokProxy (T target) { this.target=target; } // 想要获取代理对象,可以调用Proxy的方法,创建代理对象的实例 // 传入当前被代理对象的类加载器, // 当前被代理对象的接口, // 执行处理器,当前被代理对象执行目标方法的时候我们使用 Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) Proxy.newProxyInstance(t.getClass().getClassLoader(), t.getClass().getinterfaces(), new JdkTiktokProxy(t)) // 实现了invokationHandler接口,可以重写invoke方法 // 定义目标方法的拦截逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //添加增强功能 // 反射执行 Object invode = method.invoke(target, args); return invode; } }}只能代理接口的方法,自己的方法不能被代理,JDK缺点就是一定要实现接口CGlib可以解决这个问题18 -结构型模式-代理模式-cglibpublic class CglibProxy { public static&lt;T&gt; T createProxy(T t){ // 1.创建一个增强器 Enhancer enhancer = new Enhancer(); // 2.设置要增强哪个类的功能,增强器为这个类动态创建一个子类 enhancer.setSuperclass(t.getClass); //3. 设置回调,参数是一个接口Callback,叫做Methodintercepter,拦截父类的所有方法 enhancer.setCallback( new MethodInterceptor() { @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy){ // 编写拦截逻辑,写增强逻辑 // 目标方法进行执行 Object invoke = proxy.invokeSuper(obj,args); // 注意不要调invoke方法,自己调自己会递归 } } ) Object o = enhancer.create(); return (T)o; }}19 -结构型模式-代理模式-场景20 -结构型模式-外观模式又称门面模式,为复杂子系统提供一致的接口,使得子系统更容易被访问分布式系统的网关,将很多东西统一对外暴露20 -结构型模式-组合模式组合模式基本上一直在使用21 -结构型模式-享元模式当有大量的对象一个人用完以后,另一个人还要用,这时候要怎么处理就是”池技术”享元模式就需要考虑什么可以共享,什么不能共享享元模式一般和简单工厂搭配,因为产品就一个Connect享元和原型的区别?享元返回的是本人原型返回的是克隆22 -行为模式-模板模式行为型模式分为类行为模式和对象行为模式类型为模式:通过继承来得到行为对象行为模式:组合来得到行为行为型模式有哪些?模板方法(Template Method)模式：父类定义算法骨架，某些实现放在子类策略(Strategy)模式：每种算法独立封装，根据不同情况使用不同算法策略状态(State)模式：每种状态独立封装，不同状态内部封装了不同行为命令(Command)模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开职责链(Chain of Responsibility)模式：所有处理者封装为链式结构，依次调用备忘录(Memento)模式：把核心信息抽取出来，可以进行保存解释器(Interpreter)模式：定义语法解析规则观察者(Observer)模式：维护多个观察者依赖，状态变化通知所有观察者中介者(Mediator)模式：取消类/对象的直接调用关系，使用中介者维护迭代器(Iterator)模式：定义集合数据的遍历规则访问者(Visitor)模式：分离对象结构，与元素的执行算法除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式模板方法,定义抽象类,类里面可以实现某些步骤,关键步骤可以留给子类实现总体还是按照父类的23 -行为模式-策略模式定义了一系列算法,把每个算法封装起来,可以相互替换,算法的变化不会影响到客户定义一个算法接口,再具体策略里面实现方法目前对策略模式的理解还是在重写方法,24 -行为模式-状态模式把有状态的对象,把复杂的”判断逻辑”提取到不同的状态对象中,允许状态对象在其内部状态变化时改变其行为状态模式和策略模式的区别?状态模式多了一个状态流转的方法可以给外界设置状态的方法或直接next流转到下一个状态25 -行为模式-中介者模式把网状交互关系,换成星状交互关系之前一个状态变化,需要把其他相关所有都遍历一边,如果用中介者26 -行为模式-观察者模式观察者又叫发布订阅模式挨个通知28 -行为模式-备忘录模式29 -行为模式-解释器模式30 -行为模式-命令模式31 -行为模式-迭代器模式32 -行为模式-访问者模式33 -行为模式-访问者模式-幸好很少34 -行为模式-简单责任链模式35 -行为模式-完整责任链模式36 -小总结Spring源码分析-01-gradle急速安装与配置入门Spring源码分析-02-源码环境搭建" }, { "title": "Redis 课程学习", "url": "/posts/redis-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/", "categories": "", "tags": "", "date": "2022-08-31 20:14:00 +0800", "snippet": "第1章 课程介绍1-1 课程介绍 (2)为什么学Redis? 高性能 底层C语言编写，内存数据库，通讯采用epoll非阻塞I/O多路复用机制 线程安全 Redis操作是单线程的,保证原子性 多线程体现在网络协议解析和同步数据上 功能丰富 数据结构 基本:String...", "content": "第1章 课程介绍1-1 课程介绍 (2)为什么学Redis? 高性能 底层C语言编写，内存数据库，通讯采用epoll非阻塞I/O多路复用机制 线程安全 Redis操作是单线程的,保证原子性 多线程体现在网络协议解析和同步数据上 功能丰富 数据结构 基本:String List HashSet SortedSet 高阶:GEO BitMap HyperLogLog 持久化机制 RDB 持久化 AOF 持久化 RDB-AOF 混合持久化(4.0引入) 主从模式 解决并发问题 哨兵 解决主节点挂时的问题 使用CT,哨兵监控主节点,主节点故障自动完成主从切换 集群 数据越来越多,存储成为问题,就需要通过cluster集群,使用分片存储解决 模块化 自定义实现项目中的一些个性化需求 项目从单节点-&gt;主从-&gt;哨兵-&gt;集群第2章 Redis快速入门2-2 Redis介绍以及为什么能支撑10W+QPS为什么最好用奇数个哨兵因为奇数个进行判断的时候可以少数服从多数,避免因为网络波动导致判断失误为什么分布式项目不建议使用Ehcache?因为不能很好解决分布式项目之间的缓存同步共享问题为什么不建议使用Memcached?数据类型单一Redis单线程的原因? 不需要各种锁的性能消耗 单线程多进程集群方案 CPU消耗Redis单线程的好处 代码更清晰，处理逻辑更简单 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 不存在多进程或者多线程导致的切换而消耗CPURedis单线程弊端无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善2-3 Redis的安装与多种启动方式详解1.Redis2.61)键的过期时间支持毫秒。2)从节点支持只读功能。2.Redis2.81)可以用bind命令绑定多个P地址。2)发布订阅添加了pub/sub.3)Redis Sentinel第二版，相比于Redis2.6的Redis Sentinel,此版本已经变成生产可用。…如果是低版本CentOS可能装不了最新版Redis,需要升级GCC如何改为后台启动?打开redis.conf文件找到daemonize 改为 yes指定配置文件启动./redis-server ./redis.confRedis 开启到开机自启中?vim /etc/systemd/system/redis.service# 写入以下内容[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target# 重载系统服务systemctl daemon-reload# 测试并加入开机自启关闭redis-server `systemctl stop redis.service`开启redis-server `systemctl start redis.service`查看redis-server状态 `systemctl status redis.service`开机自启 `systemctl enable redis.service`protected-mode 保护模式 如果打开,意味着需要 bind IP,密码,身份认证的方式取访问2-4 Redis配置文件讲解及GUI客户端工具连接 daemonize默认情况下，redis不是在后台运行的，如果需要在后台运行，把该项的值更改为yes. bind指定Redis只接收来自于该IP地址的请求。 port监听端口，默认为6379. databasesi设置数据库的个数，默认使用的数据库是0. save设置Redis进行数据库镜像的频率。 dbfilename镜像备份文件的文件名。 di数据库镜像备份的文件放置的路径。 requirepassi设置客户端连接后进行任何其他指定前需要使用的密码。 maxclients限制同时连接的客户数量。 maxmemoryi设置redis能够使用的最大内存。2-5 Redis自带的客户端的基本命令操作自带客户端连接./redis-cli -h xxx.xxx.xxx.xxx -p 6379 -a 123456-h 是指定主机IP-p 是执行主机端口-a 指定密码# 如果IP就是本机则可以省略,如果端口就是6379,则端口省略# 基本读取和存储stringset username zhnagsanget username# 插入数据默认在0号库# 切换到2号库select 2# 此时可以插入重复的key# redis中可以层级存储,当作表理解set imooc:users:1 zhangsanget imooc:users:1# 查看当前库中所有keykeys *# 查看CPU 使用率info CPU# 各种信息info # 清空所有数据(慎重)FLUSHALL2-6 Redis的Java客户端及性能优化 Jedis在实现上是直接连接的redis server,如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个Jedis实例增加物理连接，官方推荐。 Lettuce的连接是基于Netty的，连接实例(StatefulRedisConnection)可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例(StatefulRedisConnection)就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。 在SpringBoot Data Redis1.X之前默认使用的是Jedis,但目前最新版的修改成了Lettuce.。之前公司使用Jedis,居多，Lettuce近两年在逐步上升，总的来讲Jedis的性能会优于Lettuce(因为它是直接操作Redis)。2-7 SpringBoot集成Redis2-8 美食社交APP需求分析与数据库表结构设计2-9 项目架构与微服务搭建第3章 Redis基础数据类型与基本使用3-1 Redis基本数据类型3-2 Redis之Sorted Set底层算法分析3-3 认证中心需求分析3-4 公共项目环境搭建3-5 Redis保存授权中心令牌3-6 重构认证授权中心增强令牌返回结果3-7 食客服务登录业务完善3-8 读取Redis登录用户信息和清空Redis用户信息3-9 网关登录校验 - 验证Redis中心令牌是否有效3-10 认证授权中心业务时序图总结3-11 Redis保存手机短信验证码3-12 用户注册功能第4章 Redis高阶类型与高级应用4-1 Redis应用之抢购代金券4-2 压力测试4-3 Redis解决超卖问题4-4 Redis原生实现分布式锁4-5 Redis分布式锁限制一人一单4-6 Redisson分布式锁的应用4-7 Redis应用之好友功能_关注_取关4-8 Redis应用之好友功能_共同关注列表4-9 Redis应用之Feed功能_添加Feed4-10 Redis应用之Feed功能_删除Feed4-11 Redis应用之Feed功能_变更Feed4-12 Redis应用之Feed功能_查询Feed4-13 Bitmap高阶数据类型详解及签到功能需求分析4-14 用户签到及统计连续签到次数4-15 根据月份统计用户签到次数4-16 获取用户签到情况方便前端日历控件显示4-17 积分功能实现新增积分接口4-18 MySQL实现TOPN积分排行榜4-19 Redis实现TOPN积分排行榜4-20 GEO操作指令讲解及附近的人功能需求分析4-21 GEO更新用户地理位置4-22 GEO获取附近的人4-23 缓存及分布式缓存概念讲解4-24 餐厅热点数据缓存及餐厅缓存数据读取4-25 餐厅评论添加及餐厅最新评论获取4-26 缓存异常解决方案及淘汰策略选择4-27 Redis应用总结4-28 Redis性能优化及bigkey搜索与删除第5章 Redis持久化5-1 Redis数据持久化导读5-2 Redis的RDB持久化详细讲解5-3 Redis的AOF持久化详细讲解5-4 Redis持久化RBD与AOF的选择及容灾备份5-5 Reids数据持久化的优化方案第6章 主从复制和读写分离6-1 第五章主从复制读写分离导读6-2 主从复制读写分离概念知识讲解6-3 主从复制读写分离环境搭建6-4 主从复制原理剖析6-5 主从复制故障分析及解决方案讲解第7章 哨兵监控7-1 第七章章节导读7-2 哨兵监控架构讲解7-3 哨兵监控环境搭建7-4 哨兵工作原理详解7-5 故障转移演示及故障日志详解7-6 自动故障迁移流程总结7-7 节点管理动态添加或者删除节点7-8 故障迁移一致性和TILT模式讲解7-9 美食社交APP项目改造升级为主从哨兵模式第8章 集群搭建8-1 Redis集群分片导读8-2 集群基本概念介绍8-3 Redis集群架构讲解8-4 数据分区方式讲解8-5 RedisCluster集群环境搭建8-6 检查集群状态_分析主从日志_查看集群与节点信息8-7 RedisCluster集群环境测试8-8 Redis单节点与集群模式的性能测试8-9 RedisCluster集群原理讲解8-10 美食社交APP项目改造升级为RedisCluster模式第9章 集群高可用9-1 Redis集群高可用导读9-2 节点管理之添加主节点并重新分配槽9-3 节点管理之添加从节点并构成主从关系9-4 节点管理之删除从节点9-5 节点管理之删除主节点并重新分配槽9-6 MOVED转向讲解及解决方案9-7 ASK转向讲解及解决方案9-8 自动故障转移演示及日志流程分析9-10 集群备份迁移之手动迁移9-11 集群备份迁移之Redis-Shark_数据检查RedisFullCheck" }, { "title": "《Java8实战》读书笔记", "url": "/posts/java8%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "读书笔记, Java", "date": "2022-08-31 19:13:00 +0800", "snippet": "第一部分 基础知识第1章　为什么要关心Java 8　　1.1　Java怎么还在变　　1.1.1　Java在编程语言生态系统中的位置　　1.1.2　流处理　　1.1.3　用行为参数化把代码传递给方法　　1.1.4　并行与共享的可变数据　　1.1.5　Java需要演变　　1.2　Java中的函数　　1.2.1　方法和Lambda作为一等公民　　1.2.2　传递代码：一个例子　　1.2.3　从传递...", "content": "第一部分 基础知识第1章　为什么要关心Java 8　　1.1　Java怎么还在变　　1.1.1　Java在编程语言生态系统中的位置　　1.1.2　流处理　　1.1.3　用行为参数化把代码传递给方法　　1.1.4　并行与共享的可变数据　　1.1.5　Java需要演变　　1.2　Java中的函数　　1.2.1　方法和Lambda作为一等公民　　1.2.2　传递代码：一个例子　　1.2.3　从传递方法到Lambda　　1.3　流　　1.4　默认方法　　1.5　来自函数式编程的其他好思想　　1.6　小结　　第2章　通过行为参数化传递代码　　2.1　应对不断变化的需求　　2.1.1　初试牛刀：筛选绿苹果　　2.1.2　再展身手：把颜色作为参数　　2.1.3　第三次尝试：对你能想到的每个属性做筛选　　2.2　行为参数化　　2.3　对付啰嗦　　2.3.1　匿名类　　2.3.2　第五次尝试：使用匿名类　　2.3.3　第六次尝试：使用Lambda表达式　　2.3.4　第七次尝试：将List类型抽象化　　2.4　真实的例子　　2.4.1　用Comparator来排序　　2.4.2　用Runnable执行代码块　　2.4.3　GUI事件处理　　2.5　小结　　第3章　Lambda表达式　　3.1　Lambda管中窥豹　　3.2　在哪里以及如何使用Lambda　　3.2.1　函数式接口　　3.2.2　函数描述符　　3.3　把Lambda付诸实践：环绕执行模式　　3.3.1　第1步记得行为参数化　　3.3.2　第2步：使用函数式接口来传递行为　　3.3.3　第3步：执行一个行为　　3.3.4　第4步：传递Lambda　　3.4　使用函数式接口　　3.4.1　Predicate　　3.4.2　Consumer　　3.4.3　Function　　3.5　类型检查、类型推断以及限制　　3.5.1　类型检查　　3.5.2　同样的Lambda，不同的函数式接口　　3.5.3　类型推断　　3.5.4　使用局部变量　　3.6　方法引用　　3.6.1　管中窥豹　　3.6.2　构造函数引用　　3.7　Lambda和方法引用实战　　3.7.1　第1步：传递代码　　3.7.2　第2步：使用匿名类　　3.7.3　第3步：使用Lambda表达式　　3.7.4　第4步：使用方法引用　　3.8　复合Lambda表达式的有用方法　　3.8.1　比较器复合　　3.8.2　谓词复合　　3.8.3　函数复合　　3.9　数学中的类似思想　　3.9.1　积分　　3.9.2　与Java 8的Lambda联系起来　　3.10　小结　　第二部分 函数式数据处理第4章　引入流　　4.1　流是什么　　4.2　流简介　　4.3　流与集合　　4.3.1　只能遍历一次　　4.3.2　外部迭代与内部迭代　　4.4　流操作　　4.4.1　中间操作　　4.4.2　终端操作　　4.4.3　使用流　　4.5　小结　　第5章　使用流　　5.1　筛选和切片　　5.1.1　用谓词筛选　　5.1.2　筛选各异的元素　　5.1.3　截短流　　5.1.4　跳过元素　　5.2　映射　　5.2.1　对流中每一个元素应用函数　　5.2.2　流的扁平化　　5.3　查找和匹配　　5.3.1　检查谓词是否至少匹配一个元素　　5.3.2　检查谓词是否匹配所有元素　　5.3.3　查找元素　　5.3.4　查找第一个元素　　5.4　归约　　5.4.1　元素求和　　5.4.2　最大值和最小值　　5.5　付诸实践　　5.5.1　领域：交易员和交易　　5.5.2　解答　　5.6　数值流　　5.6.1　原始类型流特化　　5.6.2　数值范围　　5.6.3　数值流应用：勾股数　　5.7　构建流　　5.7.1　由值创建流　　5.7.2　由数组创建流　　5.7.3　由文件生成流　　5.7.4　由函数生成流：创建无限流　　5.8　小结　　第6章　用流收集数据　　6.1　收集器简介　　6.1.1　收集器用作高级归约　　6.1.2　预定义收集器　　6.2　归约和汇总　　6.2.1　查找流中的最大值和最小值　　6.2.2　汇总　　6.2.3　连接字符串　　6.2.4　广义的归约汇总　　6.3　分组　　6.3.1　多级分组　　6.3.2　按子组收集数据　　6.4　分区　　6.4.1　分区的优势　　6.4.2　将数字按质数和非质数分区　　6.5　收集器接口　　6.5.1　理解Collector接口声明的方法　　6.5.2　全部融合到一起　　6.6　开发你自己的收集器以获得更好的性能　　6.6.1　仅用质数做除数　　6.6.2　比较收集器的性能　　6.7　小结　　第7章　并行数据处理与性能　　7.1　并行流　　7.1.1　将顺序流转换为并行流　　7.1.2　测量流性能　　7.1.3　正确使用并行流　　7.1.4　高效使用并行流　　7.2　分支/合并框架　　7.2.1　使用RecursiveTask　　7.2.2　使用分支/合并框架的最佳做法　　7.2.3　工作窃取　　7.3　Spliterator　　7.3.1　拆分过程　　7.3.2　实现你自己的Spliterator　　7.4　小结　　第三部分 高效Java 8编程第8章　重构、测试和调试　　8.1　为改善可读性和灵活性重构代码　　8.1.1　改善代码的可读性　　8.1.2　从匿名类到Lambda表达式的转换　　8.1.3　从Lambda表达式到方法引用的转换　　8.1.4　从命令式的数据处理切换到Stream　　8.1.5　增加代码的灵活性　　8.2　使用Lambda重构面向对象的设计模式　　8.2.1　策略模式　　8.2.2　模板方法　　8.2.3　观察者模式　　8.2.4　责任链模式　　8.2.5　工厂模式　　8.3　测试Lambda表达式　　8.3.1　测试可见Lambda函数的行为　　8.3.2　测试使用Lambda的方法的行为　　8.3.3　将复杂的Lambda表达式分到不同的方法　　8.3.4　高阶函数的测试　　8.4　调试　　8.4.1　查看栈跟踪　　8.4.2　使用日志调试　　8.5　小结　　第9章　默认方法　　9.1　不断演进的API　　9.1.1　初始版本的API　　9.1.2　第二版API　　9.2　概述默认方法　　9.3　默认方法的使用模式　　9.3.1　可选方法　　9.3.2　行为的多继承　　9.4　解决冲突的规则　　9.4.1　解决问题的三条规则　　9.4.2　选择提供了最具体实现的默认方法的接口　　9.4.3　冲突及如何显式地消除歧义　　9.4.4　菱形继承问题　　9.5　小结　　第10章　用Optional取代null　　10.1　如何为缺失的值建模　　10.1.1　采用防御式检查减少Null-PointerException　　10.1.2　null带来的种种问题　　10.1.3　其他语言中null的替代品　　10.2　Optional类入门　　10.3　应用Optional的几种模式　　10.3.1　创建Optional对象　　10.3.2　使用map从Optional对象中提取和转换值　　10.3.3　使用flatMap链接Optional对象　　10.3.4　默认行为及解引用Optional对象　　10.3.5　两个Optional对象的组合　　10.3.6　使用filter剔除特定的值　　10.4　使用Optional的实战示例　　10.4.1　用Optional封装可能为null的值　　10.4.2　异常与Optional的对比　　10.4.3　把所有内容整合起来　　10.5　小结　　第11章　CompletableFuture：组合式异步编程　　11.1　Future接口　　11.1.1　Future接口的局限性　　11.1.2　使用CompletableFuture构建异步应用　　11.2　实现异步API　　11.2.1　将同步方法转换为异步方法　　11.2.2　错误处理　　11.3　让你的代码免受阻塞之苦　　11.3.1　使用并行流对请求进行并行操作　　11.3.2　使用CompletableFuture发起异步请求　　11.3.3　寻找更好的方案　　11.3.4　使用定制的执行器　　11.4　对多个异步任务进行流水线操作　　11.4.1　实现折扣服务　　11.4.2　使用Discount服务　　11.4.3　构造同步和异步操作　　11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　11.4.5　对Future和Completable-Future的回顾　　11.5　响应CompletableFuture的completion事件　　11.5.1　对最佳价格查询器应用的优化　　11.5.2　付诸实践　　11.6　小结　　第12章　新的日期和时间API　　12.1　LocalDate、LocalTime、Instant、Duration以及Period　　12.1.1　使用LocalDate和LocalTime　　12.1.2　合并日期和时间　　12.1.3　机器的日期和时间格式　　12.1.4　定义Duration或Period　　12.2　操纵、解析和格式化日期　　12.2.1　使用TemporalAdjuster　　12.2.2　打印输出及解析日期－时间对象　　12.3　处理不同的时区和历法　　12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　12.3.2　使用别的日历系统　　12.4　小结　　第四部分 超越Java第13章　函数式的思考　　13.1　实现和维护系统　　13.1.1　共享的可变数据　　13.1.2　声明式编程　　13.1.3　为什么要采用函数式编程　　13.2　什么是函数式编程　　13.2.1　函数式Java编程　　13.2.2　引用透明性　　13.2.3　面向对象的编程和函数式编程的对比　　13.2.4　函数式编程实战　　13.3　递归和迭代　　13.4　小结　　第14章　函数式编程的技巧　　14.1　无处不在的函数　　14.1.1　高阶函数　　14.1.2　科里化　　14.2　持久化数据结构　　14.2.1　破坏式更新和函数式更新的比较　　14.2.2　另一个使用Tree的例子　　14.2.3　采用函数式的方法　　14.3　Stream的延迟计算　　14.3.1　自定义的Stream　　14.3.2　创建你自己的延迟列表　　14.4　模式匹配　　14.4.1　访问者设计模式　　14.4.2　用模式匹配力挽狂澜　　14.5　杂项　　14.5.1　缓存或记忆表　　14.5.2　“返回同样的对象”意味着什么　　14.5.3　结合器　　14.6　小结　　第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　15.1　Scala简介　　15.1.1　你好，啤酒　　15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　15.2　函数　　15.2.1　Scala中的一等函数　　15.2.2　匿名函数和闭包　　15.2.3　科里化　　15.3　类和trait　　15.3.1　更加简洁的Scala类　　15.3.2　Scala的trait与Java 8的接口对比　　15.4　小结　　第16章　结论以及Java的未来　　16.1　回顾Java 8的语言特性　　16.1.1　行为参数化（Lambda 以及方法引用）　　16.1.2　流　　16.1.3　CompletableFuture　　16.1.4　Optional　　16.1.5　默认方法　　16.2　Java 的未来　　16.2.1　集合　　16.2.2　类型系统的改进　　16.2.3　模式匹配　　16.2.4　更加丰富的泛型形式　　16.2.5　对不变性的更深层支持　　16.2.6　值类型　　16.3　写在最后的话　　附录A　其他语言特性的更新　　附录B　类库的更新　　附录C　如何以并发方式在同一个流上执行多种操作　　附录D　Lambda表达式和JVM 字节码　　" }, { "title": "第3节 二分、复杂度、动态数组、哈希表", "url": "/posts/%E7%AC%AC3%E8%8A%82-%E4%BA%8C%E5%88%86-%E5%A4%8D%E6%9D%82%E5%BA%A6-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%93%88%E5%B8%8C%E8%A1%A8/", "categories": "算法, 左神新手班", "tags": "左神, 算法, 新手班", "date": "2022-08-30 18:46:00 +0800", "snippet": "二分法(找到停止)使用二分法解决不同的题目看下方的题目时间复杂度只关心最高阶是什么动态数组按值传递、按引用传递哈希表有序表题目：有序数组中找到num\t// arr保证从小到大有序\tpublic static boolean find(int[] arr, int num) {\t\tif (arr == null || arr.length == 0) {\t\t\treturn false;\t\t} ...", "content": "二分法(找到停止)使用二分法解决不同的题目看下方的题目时间复杂度只关心最高阶是什么动态数组按值传递、按引用传递哈希表有序表题目：有序数组中找到num\t// arr保证从小到大有序\tpublic static boolean find(int[] arr, int num) {\t\tif (arr == null || arr.length == 0) {\t\t\treturn false;\t\t} // 最开始是在整个范围上找值,所以取的是左右最大值\t\tint L = 0;\t\tint R = arr.length - 1; // L &lt;= R是有效的范围,一旦 L &gt; R 无效,不再进行后续处理\t\twhile (L &lt;= R) {\t\t\tint mid = (L + R) / 2;\t\t\tif (arr[mid] == num) {\t\t\t\treturn true;\t\t\t} else if (arr[mid] &lt; num) {\t\t\t\tL = mid + 1;\t\t\t} else {\t\t\t\tR = mid - 1;\t\t\t}\t\t}\t\treturn false;\t}有序数组中找到&gt;=num最左的位置 // 最左就是二分不断进行处理,而不是找到一个值相等就不进行剩余操作\t// arr有序的，&gt;=num 最左\tpublic static int mostLeftNoLessNumIndex(int[] arr, int num) {\t\tif (arr == null || arr.length == 0) {\t\t\treturn -1;\t\t}\t\tint L = 0;\t\tint R = arr.length - 1; // 记录里面最小的值为-1\t\tint ans = -1;\t\twhile (L &lt;= R) { // 取结果的整数,去掉余数\t\t\tint mid = (L + R) / 2; // 这个和上面的区别就是不再是找某个具体值,而是对比值的情况\t\t\tif (arr[mid] &gt;= num) {\t\t\t\tans = mid;\t\t\t\tR = mid - 1;\t\t\t} else {\t\t\t\tL = mid + 1;\t\t\t}\t\t}\t\treturn ans;\t}有序数组中找到&lt;=num最右的位置\t// 在arr上，找满足&lt;=value的最右位置\tpublic static int nearestIndex(int[] arr, int value) {\t\tint L = 0;\t\tint R = arr.length - 1;\t\tint index = -1; // 记录最右的对号\t\twhile (L &lt;= R) {\t\t\tint mid = L + ((R - L) &gt;&gt; 1);\t\t\tif (arr[mid] &lt;= value) {\t\t\t\tindex = mid;\t\t\t\tL = mid + 1;\t\t\t} else {\t\t\t\tR = mid - 1;\t\t\t}\t\t}\t\treturn index;\t}局部最小值问题// arr 无序 任意两个相邻的数不相等！// 局部最小定义 // [0] &lt; [1] 此时0称为局部最小,因为0的左边没有值了 // [N - 2] &gt; [N - 1] 此时N-1称为局部最小,因为右边没值了 // 左 &gt; [i] &lt; 右 此时i位置称为局部最小,因为左右都比i值大// 本题要求返回任意一个局部最小值\tpublic static int oneMinIndex(int[] arr) { // 此时没有数\t\tif (arr == null || arr.length == 0) {\t\t\treturn -1;\t\t}\t\tint N = arr.length;\t\tif (N == 1) {\t\t\treturn 0;\t\t} // 下面这几行同时也处理了只有两三个值的情况\t\tif (arr[0] &lt; arr[1]) {\t\t\treturn 0;\t\t}\t\tif (arr[N - 1] &lt; arr[N - 2]) {\t\t\treturn N - 1;\t\t}\t\tint L = 0;\t\tint R = N - 1; // 从之前走到这一步说明 // 0的位置一定比1的位置大 // n-1的位置一定比n-2的位置大 // 此时两边都是局部最大,中间一定存在局部最小值\t\t// L...R 肯定有局部最小 // 直接从中间那个点去看,存在四种可能 // 左 &gt; i &gt; 右 I i . 砍掉左边,往右边找 // 左 &lt; i &lt; 右 . i I 砍掉右边,往左边找 // 左 &gt; i &lt; 右 I i I 此时的i就是局部最小 // 左 &lt; i &gt; 右 . i . 此时两边都大于i 完全抛弃右边,只看左边的值 // 只要比左边大,就把右边砍掉,因为题目只让返回一个 \t\twhile (L &lt; R - 1) { // 注意这个边界是R - 1 和L &lt;= R有着不一样的情况 // 我们希望算出的mid - 1和 mid +1的值还在L,R范围内 // 但有时只有L,R两个数,此时算出的mid值为L等于0,这时再去算mid-1就会导致小于L,超过边界 // 此时改为R - 1,保证一定右三个数,两个数的情况下再接着下一步判断处理\t\t\tint mid = (L + R) / 2; // 同时小\t\t\tif (arr[mid] &lt; arr[mid - 1] &amp;&amp; arr[mid] &lt; arr[mid + 1]) {\t\t\t\treturn mid;\t\t\t} else { // 并不同时小,此时有三种情况 // 1左&gt;我 我&gt;右 I i . // 2左&lt;我 我&lt;右 . i I // 3左&lt;我 我&gt;右 . i . // 中间大于左侧 . i 对应两种情况 2,3,此时只看左侧\t\t\t\tif (arr[mid] &gt; arr[mid - 1]) {\t\t\t\t\tR = mid - 1;\t\t\t\t} else { // 走到这步说明.中间小于等于 左边的值 I i // 对应情况1\t\t\t\t\tL = mid + 1;\t\t\t\t}\t\t\t}\t\t}\t\treturn arr[L] &lt; arr[R] ? L : R;\t}哈希表使用的code讲解有序表使用的code讲解" }, { "title": "英语音标 英语", "url": "/posts/%E8%8B%B1%E8%AF%AD%E9%9F%B3%E6%A0%87/", "categories": "", "tags": "英语", "date": "2022-08-18 20:49:00 +0800", "snippet": "01.元音(1) - [i]、[3]、[_]、[u] 上下牙齿微微分开，嘴巴尽量向两边咧开，露出尽量多的牙齿，发音 亿 cheese 嘴巴微微张开，嘴唇微微厥起，把舌头在口腔内向上卷起来，然后发音 二 bird 把口腔充分打开，下巴下沉，嘴唇微微厥起，变成一个竖着的椭圆形，舌头后移，在口腔里留出一个空间，就像含着一个小球 傲 ball ...", "content": "01.元音(1) - [i]、[3]、[_]、[u] 上下牙齿微微分开，嘴巴尽量向两边咧开，露出尽量多的牙齿，发音 亿 cheese 嘴巴微微张开，嘴唇微微厥起，把舌头在口腔内向上卷起来，然后发音 二 bird 把口腔充分打开，下巴下沉，嘴唇微微厥起，变成一个竖着的椭圆形，舌头后移，在口腔里留出一个空间，就像含着一个小球 傲 ball 嘴唇顾起来，就像要接吻一样，然后舌头平放，舌头后部隆起，发音。 雾 food 02.元音（2）- [ɪ]、[ɑ]、[ʊ] 把上下牙齿打开到一个小指肚的宽度，舌头平放，嘴唇放松，发音 有点像教官在喊”一二一”的”一”,或者说是”耶” hit 嘴巴张大，想象一下去医院，医生用压舌板压住你舌头，让你说的口型，发音 啊 (四声) father 嘴唇噘成一个小喇叭，舌头后隆起，发音。 o饿 cook 03.元音（3）－[ə] [ʌ]、[ɛ]、[æ] 嘴巴舌头牙齿都放松，轻轻放下下巴，发音 饿阿 肚子被拳头打了一拳 这两个在美式英语里发音是一摸一样的 A这个往往出现在重读音节,例如hut e这个往往出现在非重读音节,例如China 嘴巴舌头牙齿都放松，轻轻放下下巴，发音 挨 bed 嘴巴张到最开，舌尖顶着下牙内侧，从正面露出舌头表面，发音 哎 hat 04.元音（4）－[e]、[aɪ]、[ɔɪ]、[aʊ]、[o]之前的课程都是单元音,今天开始讲双元音双元音就是两个单元音拼到一起双元音发音注意饱满前长后短前强后弱流畅滑动 想象自己从字母向字母E过渡，嘴巴先打开然后微微合上，咧开嘴角呈现字母E的发音； 欸 cake 先把嘴巴张大再微微合上，饱满地发音； I like 先把嘴巴嚼成一个竖着的椭圆形，然后微微合上，饱满地发音； 澳矮 boy 先把嘴巴张大，再嚼成要亲嘴的样子，饱满地发音； 傲呜 out 先把嘴巴向前噘起，发出○的音，然后把嘴巴缩紧，过渡到似乎要亲嘴的样子，饱满地发音。 藕雾 open 05.元音（5）－[ɪr]、[ɛr]、[ʊr] 先把嘴巴微微分开发出I，然后把舌头在口腔内向上卷发出r，流畅滑动； 逸儿 ear 先把嘴巴微微分开发出,然后把舌头在口腔内向上卷发出r，流畅滑动； 矮儿 air 先把嘴巴微微嚼起，似乎要亲嘴的样子，发出u,然后把舌头在口腔内向上卷发出r，流畅滑动。 雾儿 tour 06.辅音（1）－[p]和[b]、[t]和[d]、[k]和[g]声带振动爆破音,爆破音无法延长 上下嘴唇咬在一起，然后释放发音，注意[p]不需要声带振动，但[b]需要声带振动： map pub 舌尖轻轻抵住上牙内侧，释放发音，注意[t]不需要声带振动，但[d]需要声带振动； hit bird 舌头后部轻轻抵住上颚，释放发音，注意[k]不需要声带振动，但[g]需要声带振动； kick pig 07.辅音（2）－[f]和[v]、[s]和[z]、[∫]和[ʒ]摩擦音,摩擦音可以延长 微微噘嘴，上牙轻轻咬住下唇，然后送气，通过气流摩擦发音，注意[f]不需要声带振动，但[v]需要声带振动 knife live [s]和[z]：嘴唇咧开，牙齿露出，舌尖抵住下牙内侧，然后送气，气流从牙缝中送出，摩擦发出声音，注意[s]不需要声带振动，但[z]需要声带振动； ice buzz 嘴唇噘起来，舌头在口腔内向上卷，然后送气，通过气流摩擦发音，注意[∫]不需要声带振动，但[3]需要声带振动。 师 cash beige 08.辅音（3）－[θ]和[ð]、[h]咬舌音 用牙齿轻轻咬住舌尖，然后送气，通过气流摩擦发出声音，声带不振动； 嘶 face 用牙齿轻轻咬住舌尖，然后送气，通过气流摩擦发出声音，声带振动； breath 嘴巴微微张开，舌头后抬起，制造一股气流发音，不用特别用力，就像轻轻的一阵风。 哈 09.辅音（4）－[t∫]和[dʒ]、[tr]和[dr]、[ts]和[dz] [t∫和[3]：噘嘴，用舌尖轻轻抵住上牙龈，然后，用舌头下切，用一瞬间的气流发出声音，注意[t∫不需要声带振动，但[d3需要声带振动； 嗤/只 church judge [tr]和[dr]:嚼嘴，用舌尖轻轻抵住上牙龈，然后，用舌头下切，用一瞬间的气流发出声音，注意[tr]不需要声带振动，但[dr]需要声带振动； 吃/只 try dry 上下牙齿留出一条细缝，舌尖抵住牙齿内侧，然后，用舌头下切，用一瞬间的气流发出声音，注意[ts]不需要声带振动，但[dz]需要声带振动。 呲/资 boats beds10.辅音（5）－[m]、[n]、[ŋ]鼻音 嘴唇闭合，然后声带振动，发出鼻音； mom 舌尖贴着上颚的牙龈，嘴唇微张，牙齿微微分开，然后声带振动发出鼻音； noon 嘴唇微张，牙齿微微分开，舌尖往后移，舌头后部接触上颚，然后声带振动发出鼻音。 thing 11.辅音（6）－[l]和[r]舌侧音 嘴唇微微噘起，舌尖轻轻抵住上牙后部，震动声带发音： 尔儿 wall 嘴唇向前嚼起，舌头在口腔内向上卷，声带振动发音。 儿 car 12.辅音（7）－[w]和[j]半元音:与元音有些地方很相似,但又起到了辅音的效果 嘴唇向前噘起，做出要亲嘴的样子，舌头也向前，整个口腔都向前，然后震动声带发音； 污 wet 嘴唇微嚼，舌头中部向上抬起，抵住上题，声带震动，产生发音。 一 yellow 13.松元音和紧元音（1） [i]和[l]的区别根本就不在长短，而是唇形根本不一样！[i]是紧元音，[l]是松元音； 紧元音[i]的舌位是紧绷的，要龇牙咧嘴，露出尽可能多的牙齿才能发音； 松元音[l]的舌位是放松的，嘴巴微微张开，留出一个小拇指肚的缝隙，口腔整体放松，发音； 长元音和短元音的区别，并不是长和短，而是紧和松。 14.松元音和紧元音（2） [ε]是松元音，[æ]是紧元音； bed bad [ə]是松元音，[α]是紧元音； 饿 阿 shut shot 美音中[ə]和[A]的发音一模一样； 长元音和短元音的区别，并不是长和短，而是紧和松。 15.中国人搞不定的双元音 双元音发音决窍：前长后短，前强后弱，流畅滑动： 双元音[e]：这个元音的发音是从字母A向字母E过渡： plane/rain 双元音[aI]:这个元音的发音是从元音[a]过渡到元音[I]: 双元音[au]:这个元音的发音是从元音[a]过渡到元音[u]: 双元音[o]小：发音的时候，先把嘴巴向前噘起，发出○的音，然后把嘴巴缩紧，过渡到似乎要亲嘴的样子。16.画蛇添足——尾音的错读 词尾的辅音在发音的时候，千万不能在后面加上不存在的元音，而是应该只发出标准的铺音； 爆破音只是一个释放的音，不要加上不存在的元音； 摩擦音在词尾的时候，不要加上不存在的元音； 鼻音在词尾的时候，千万不要加上不存在的元音。 17.[v]和[w]，[f]和[h] 发音训练的关键是嘴巴，而不是耳朵； [v]是有咬唇动作的，千万不要混淆成[w]; [f]也是有咬唇动作的，千万不要混淆成[h]。 18.th的发音和连读 咬舌音th在发音时，保持特舌尖的紧张度，只做十分快速急剧的小运动，每次发声时舌头轻触上齿,然后快速收回来，这样可以准确快速的发出th音了； 当th音和卷舌音r连在一起的时候，先咬住舌尖，然后迅速抽出来并且向上卷； 当th音和其他辅音连读时，同样要注意舌尖和牙齿的正却位置，保证清晰准确的发音。 19.川湘鄂的[n][l]不分 [n]是鼻音，舌头封住上颚： [l]是舌侧音，舌尖抵住上颚； 无论是英语发音还是普通话，千万不要带有方言乡音。 20.常被忽略的[m]和[n] -[m]是嘴唇闭合，而[n]是嘴巴张开，舌头封住上颚； 当它们在词尾的时候虽然听起来微不足道，但是千万不要混淆。 21.南方人崩溃的前后鼻音 [n]是嘴巴微微张开，舌头封住上颚，声带振动发音； [ŋ]是舌尖往后移，舌头后部抵住上颚，声带振动发音 22.中国人总是忘的[l]、[rl] 只要单词中含有字母L,需要发辅音山[l] 辅音[l]的发音舌位是嘴唇微嚼，舌头在口腔内抬起来，舌尖靠近上颚； 辅音[r]的发音是嚼嘴，卷舌；辅音川是嚼嘴，抬舌，两个舌位动作连续完成，舌头始终不能放下来 23.[ʃ]的家族 辅音[ʃ]听上去特别像汉语拼音中的“sh”，但是要橛嘴并发出摩擦的感觉； 辅音[ʒ]听上去特别像汉语拼音中的“r”，但是要撅嘴并发出摩擦的感觉； 辅音[tʃ]听上去特别像汉语拼音中的“ch”，但是要撅嘴。要有舌头下切的动作，并发出摩擦且爆破的感觉； 辅音[dʒ]听上去特别像汉语拼音中的“zh”，”之”但是要撅嘴，要有舌头下切的动作，并发出摩擦且爆破的感觉。24.[ts]和[dz] 辅音[ts]听上去特别像汉语拼音中的“c”，”呲”但是要有舌头下切的动作，并发出摩擦且爆破的感觉； 辅音[z]听上去特别像汉语拼音中的“z”，”“但是要有舌头下切的动作，并发出摩擦且爆破的感觉。25.清晰的音节 英语发音的基本单元是音节，不是单词； 音节，指一个元音以及附着在它上面的辅音，发出来的完整声音； 英文中的辅音都是附着在紧跟其后的元音 一个元音就标志着一个音节； 英语词汇根据音节的数量分为单音节词(小词)、双音节词、三音节词、多音节词。 单音节词(小词) sit 双音节词 candy better 三音节词 ambition 多音节词(大词) international 26.单词的重音 英语单词中会有一个音节读得特别长而清晰，叫做重读音节，或者单词重音； 第1条规则：2个音节的单词，重读在第一音节上； baby carry 第2条规则：2个音节的单词，如果含有前缀，则重读在第二音节上； inform unknown present 第3条规则：3个划以上音节的单词，重读在倒数第三个音节上； `family de`mocracy phi`losophy 第4条规则：带有后缀的单词，重读在后缀前，但是除去这些后缀：-ed, -es,-er,-est,-or,-ary,-ory,-ment,-ous,-cy,-ry,-ty,-al,-ure,-ute,-ble,-ar,-ly,-less,-ness,-ful,-ing; poli`tician mu`sician 第5条规则：有些后缀会将重读吸引至其本身变成重读音节，这些后缀是：-ain,-ee,-eer,-ier,-ade,-ival,-itis,-zation,-mental(-ental); emplo`yee refu`gee 第6条规则：双音节词在分别作为动词和名词时，名词重读在第一个音节，而动词重读在第二个音节。 `increase 名词 in`crease 动词 以上规测不除例外情况，一切以权威字典为准。27.单词的弱读和击穿 在句子中不表达实际意思，仅为了语法严谨性而存在的单词，往往在自然语流中被读为弱读式，它们中的元音，在大部分情况下，会被弱读成元音[ə]； 当辅音[h]前面有辅音后面有元音的时候，会被直接省略不读，这种现象叫做击穿。 him her he his hers tell him → tell-im give her → give-er 28.辅元连读 英语的发音基本单位是音节，不是单词； 音节是一个元音，以及附着在它上面的辅音，发出来的完整声音； take a look at it ta ka loo ka tit I love it I lo vit check it out che cki tout 在连读的语流中，中所有的辅音，都附着在紧跟其后的元音上。29.元元连读 元音就是发音过程中，气流通过口腔而不受阻碍发出的音； 辅音指的是气流在口腔或咽头，受到阻碍而形成的音； 两个元音碰到一起,容易混淆,就需要加一个辅音,方便分隔开 当元音和元音连读的时候，如果口腔位置靠前，在中间加辅音[j]： Can you see it? Can you see-ye-it? 当元音和元音连读的时候，如果口腔位置靠后，在中间加辅音[w]。 how are you? How [w]are you 30.辅半元连读 半元音 [w][j] 辅音[j]的前面是辅音[t],那么它们连读就会发生化学反应，变成辅音[tʃ]chi：[t]+[ʃ]=[tʃ]； Don`t you? [dont ju] [dontʃu] Won`t you? [wont ju] [wontʃu] 辅音[j]的前面是辅音[d],那么它们连读就会发生化学反应，变成辅音[dʒ]zhi:[d]+[j]=[dʒ]。 Could you? [kʊdʒu] Would you? [wʊdʒu] 31.成对辅音的清化与浊化 辅音中有一类辅音,不同在于声带震不震动[p]/[b] [k]/[g] [d]/[t] [f]/[v] [s]/[z] [ʃ]/[ʒ] … 不震动的叫做清辅音,振动叫做浊辅音 当单词中 字母s + 清辅音 + 元音 的时候，清辅音就会自动变成和它成对的浊辅音； stop [stap] –&gt; [sdap] school [skul] –&gt; [sgul] speak [spik] –&gt; [sbik] street [strit] –&gt; [sdrit] 爆破音的清辅音前后都是元音,且不是重音,发生浊化 water –&gt; wader 注意italian 仍是t的发音,因为重音在t上 当 浊辅音 出现在一个完整意思的结尾，则去掉声带振动，发成一个类似清辅音的板本。 It`s cold [d] 注意仍是发出d,只不过较轻 It`s cold outside 不会有清化现象 d会和后面的au连读 32.失去爆破 爆破音:[p]和[b]、[t]和[d]、[k]和[g] 这六个音都是爆破音 两个爆破音紧密相邻的时候，第一个爆破音就会失去爆破； sit down [si down] stop talking p 和 t 失去爆破的具体操作：形成阻碍，保持，然后发出第二个爆破音的发音。 可能出现在单词中间也可能出现在单词内部33.不完全爆破 爆破音之后紧跟着摩擦音，爆破音只释放分气流，不完全爆破： breakfast 爆破音之后紧跟着破擦音，爆破音只释放部分气流，不完全爆破； picture 爆破音之后紧跟着鼻音，爆破音只释放部分气流，不完全爆破； good morning 爆破音之后紧跟着舌侧音，爆破音只释放部分气流，不完全爆破。 舌侧音:[l] [r] friendly [d] 34.鼻腔爆破 爆破音[t]、[d]和鼻音[n]相邻，在单词末尾，必须通过鼻腔爆破，成为鼻腔音； garden 噶儿嗯 certain 丝儿嗯 hidden 嘿嗯 button 扒嗯 如果爆破音在在单词中部，则形成不完全爆破，而非鼻腔爆破。 35.ed和s都怎么读？ 当一个单词的结尾是清辅音，ed的发音也是清辅音[t]; jumped –&gt; jumpt walked –&gt; walkt 当一个单词的结尾是不是清辅音，ed的发音也是有声带振动的辅音[d]; rubbed –&gt; rubbd cleaned –&gt; cleand 当一个单词的结尾字母是t或者d的时候，ed组合的发音为[Id]; gifted –&gt; gift欸的 headed –&gt; head欸的 当一个单词的结尾是清辅音，s的发音也是清辅音[s]； books 正常发音books laughs 当一个单词的结尾是浊辅音，s的发音也是有声带振动的辅音[z]; feels –&gt; feelz lives –&gt; livez bees –&gt; beez bags –&gt; bagz 当一个单词的结尾是元音的时候，s的发音为[z]; eyes –&gt; eyez bees –&gt; beez 当一个单词的结尾是[s]、[z]、[ʃ]、[ʒ]、[tʃ]、[dʒ]的时候，s的发音为[Iz]。 [Iz] 读作is buses –&gt; busez bushes –&gt; bushez 36.美式闪音 英式英语更加优雅端庄，美式英语更加慵懒放松； 当一个单词中的字母t不是首字母，不是重音，而且后面紧跟元音时，会根据美式口音发成接近辅音[d]的闪音。 talent 不能发闪音 bet 不能闪音 title 不能闪音 37.梅花音 在很多英式英语发[a]或者发[e]的情况下，美式口音会发[æ]; 梅花音需要你把下巴降到最低，从正面完全露出舌头的表面，从咽喉深处发出这个音； 学习英语一定要注意口音的一致性，如果你选择了美式口音，那么从用词到发音者都要完全遵守美式英语的特征和规侧。 class 克拉啊似(英式) 克莱似(美式) dance 荡似(英式) 蛋安似(美式) status s得A特s (英式) s呆特s(美式) 平时需要积累38.卷舌音 卷舌音[r]是美式发音的一大特点； 美式卷舌音的正确发音动作：嘴唇微微噘起，舌头在口腔内向上卷； 美式卷舌音的发音规则：单词中只要有字母，就需要卷舌。 water international party不要乱加卷舌 idea because 39.口语中的偷懒现象 wanna = want to; gonna = going to; gotta = (have) got a /(have) got to; 美式英语中存在大量偷懒词，平时请注意积累。 40.美语中的怪词 英语是一门国际语言，掺杂了非常多的外来语料； 在发音之前，一定要查字典确定了解这个单词的正确发音和标准意思。 41.句子中的重音 只要在句子中意思有排他性的单词，我们都需要重读； 它们包括名词、形容词、数词、实义动词、副词、指示代词和反身代词、疑问词； 一句正常的话里不可能有太多单词重读，有2到3处重读已经很多了； 具体重读哪些单词要结合具体的情境，不可能百分百没有例外。 实词重读,虚词略读 42.意群和断句 意群，就是一群连续的、共同表达一个完整意思的单词； 意群之间要断句，意群之内要连读。 英语发音单元有两个层级 第一层级是意群,而不是句子 第二层级是音节,而不是单词 43.语调和情感色彩 语调的基本单位是意群； 升调往往用来表达不太确定的信息； 平调表示中性的客观陈述； 降调表示结论和强调。 44.美国人的语速 演讲视频的语速往往过慢； 英语新闻的语速往往过快； 美国电视脱口秀节目的明星访谈环节是理想的学习素材； 对字幕进行遮挡并且反复观看才能获得学习效果。第一遍遮住双语字幕第二遍遮住双语字幕第三遍遮住英文字幕留下中文字幕第四遍遮住英文字幕留下中文字幕第五遍遮住英文字幕留下中文字幕45.结课复习在这段英文中，我会把之前讲解过的所有知识点融入其中，带你做一个完整的复习，希望你跟我大声地念出来，仔细观察我的唇形活位，并且听我的讲解，查漏补缺，看看自己的学习结果到底如何。一、元音（一）前元音：[i:] [i] [e] [æ]（二）中元音：[ʌ] [ǝ:] [ǝ]（三）后元音：[ɑ:] [ɔ] [ɔ:] [u] [u:]（四）双元音：[ei] [ai] [ɔi] [ǝu] [au] [iǝ] [uǝ] [Ɛǝ]二、辅音（一）爆破辅音：[p] [b] [t] [d] [k] [g]（二）摩擦辅音：[f] [v] [s] [z] [ʃ] [Ʒ] [Ɵ] [ð]（三）摩擦音[h] [r] [j] [w]及舌侧音 [l]（四）破擦音：[tr] [dr] [ʧ] [ʤ] [ʦ] [ʣ]（五）鼻（辅）音：[m] [n] [ŋ]" }, { "title": "学习之道读书笔记", "url": "/posts/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "读书笔记", "date": "2022-08-14 19:31:00 +0800", "snippet": "第1章 开启大门第2章 放松点专注思维和发散思维当初读某个章节或部分,涉及数学概念时?先宏观浏览一遍,不只是看表,公式或图片,还有小节标题,总结,甚至如果章节末尾有思考问题,最好也看看用一两分钟预先翻阅,再深度思考,会创造小挂钩,把思维靠上去,把握概念变得更加轻松专注模式：一台排布紧凑的弹球机为什么数学和科学知识会更难对付发散模式：一台间距松散的弹球机为什么要有两种思考模式想要学习数学和科学...", "content": "第1章 开启大门第2章 放松点专注思维和发散思维当初读某个章节或部分,涉及数学概念时?先宏观浏览一遍,不只是看表,公式或图片,还有小节标题,总结,甚至如果章节末尾有思考问题,最好也看看用一两分钟预先翻阅,再深度思考,会创造小挂钩,把思维靠上去,把握概念变得更加轻松专注模式：一台排布紧凑的弹球机为什么数学和科学知识会更难对付发散模式：一台间距松散的弹球机为什么要有两种思考模式想要学习数学和科学，而且保持创造力，两种思维模式都会被用到，对它们的强化训练缺一不可。拖延的前奏如果拖延，你就没有时间供专注模式稳扎稳打，只够走马观花地过上一遍。增大压力,神经模型模糊暗淡,残缺不全,思维基础七零八落记牢概念,搞懂难题,建立知识结构图,哪种神经模式都需要时间 如果经常拖延可以试试关掉手机,或任何其他会发出提示音或闪烁的干扰源,计时器设定25分钟,25分钟内.全神贯注于一项任务,不用担心能不能完成,专心去做就好25分钟后,奖励下自己,看看网页,翻一下手机,做任何你想做的事情专注于任务本身,而非在意任务能否达成 升级版 ,入睡前回顾一天中完成的最重要的任务,想到的那个任务写下来,这天内,试着用最少三个25分钟,来处理你想到的最重要的一个或几个任务当工作真正完结后,看看自己在待做清单上划掉了什么,这会就可以尽情享受成就感了,把明天的关键事项写下来,有助于发散模式预热思考明天完成哪些任务本章小结 我们的大脑有两种截然不同的思维模式——专注模式和发散模式。你会在两种模式之间转换，择一而用。 如果我们开始就用专注模式处理新的概念和陌生的问题，很容易止步不前。 想要发掘新点子，解决问题，不仅需要最初的专注，接着也需要给注意力放个假，让它从眼前的问题上溜开一会儿。 定式效应就是说因死盯着有瑕疵的方法不放，而在解决问题时陷入僵局。切换到发散模式可以帮助我们从中解脱出来。记住这一点，有时候你的思考得灵活点。想要解决问题，理解概念，你可能需要在不同的概念之间转换。最初的想法反而可能是误导。 第3章 学习即创造专注模式和发散模式之间的转换只要你放下手中的工作，停下来喘口气，发散模式就会乘虚而入，上蹿下跳，高屋建瓴地搜寻解决方案创造力就是对自身能力的驾驭和拓展两种模式间的切换帮你掌握新知识只要不在专注模式,那么发散模式就在起作用,不能只靠发散模式学习,还是需要专注和发散的来回切换开启发散模式的方法● 去健身房● 参加运动，如踢足球或打篮球● 慢跑、散步或游泳● 跳舞● 开车兜风（或者搭个顺风车）● 绘画或者涂鸦● 淋个浴或是泡个澡● 听音乐，尤其是纯音乐● 用乐器演奏熟悉的歌曲● 冥想或者祷告● 睡觉别怕落在同学后面避开思维定式（愚公移山未必是个好办法）不要着急认同自己的第一个想法,有碍于另觅佳径虽然有时候是在纵览全局寻找办法,但自己的大脑还是执着于最初的走法想要学的好,就要在两个专注学习期之间空出时间,让神经模型得以巩固当感觉不断增加的挫败感是个有益的信号,这是在暗示你,是时候转换到发散模式了当你真的被难住的时候该怎么办向同学,同龄人,老师进行请教,让他们提供不同的视角工作记忆和长期记忆下次在解决肌肉问题,先努力做上几分钟,一旦做不下去,转去另一个任务,发散模式继续在后台处理如何进入小睡状态减缓呼吸,不去想一定要睡着,注意力集中在呼吸上,保证房间光线暗下来睡眠对学习的重要性如果学习中的你感到疲倦，最好的办法就是直接去睡觉。第二天起个大早，再用以逸待劳的大脑完成阅读。缺觉的大脑根本无法保证在正常思考活动中一如既往地进行思维联结。所以，考前通宵意味着即使你准备得再完美，思维也不会正常运转。本章小结 遇到数学或科学上的概念和难题，首先要让专注模式打头阵。它完成第一轮战斗后，就轮到发散模式了。 放松一下，做点别的！一旦工作期间出现了挫败感，转移注意力就该随之出现，让隐藏在后台的发散模式运转起来。 学好数学和科学最好的办法就是“每天进步一点点”。 让两种模式有足够的时间各行其是，你才能理解自己所学的知识。牢固的神经结构就是这样建立起来的。如果你有拖延问题，试着计时25分钟来一心一意地投入工作，别让发短信、上网或其他分心的事物上门打扰。 主要的记忆系统有两类： ■ 工作记忆——只能一次扔四个球的杂耍演员； ■ 长期记忆——能储存大量知识的仓库，不过要靠定期回访保持对其中内容的新鲜感。 间隔性重复有助于把信息从工作记忆转移到长期记忆。 同时，睡眠也是学习过程中的一个重要部分。它会帮助你： ■ 构造一般性思维活动所需的神经联结——这也是为什么考前一晚的睡眠很重要； ■ 攻克难题，真正理解所学的知识； ■ 巩固复习重点知识，修剪旁枝末节。 第4章 组块构建与避免能力错觉聚精会神的时候，大脑在做什么组块是什么？所罗门的组块难题要熟练地掌握数学和科学知识，就要创造一些概念组块——这是通过意义将分散的信息碎片组合起来的过程构成组块的基本步骤 进行组块的第一步，就是把注意力集中在需要组块的信息上。开着电视当背景音，或是几分钟就查查手机电脑上的信息回复一下，你就别想构建组块了。因为你的大脑根本没有真正专注于此。着手开始学习新东西，既要创造新的神经模型，也要把新模型和遍布大脑各处的既有模型联结在一起。要是你走神，章鱼触手可就抓不紧了。 组块活动的第二步是理解（understanding）。要把基本概念打包成组块，首先要理解这个基本概念。不管这个概念是大陆漂移、力与质量的比例关系，或是经济学的供求原则，又或是某种数学难题。暂时只要求基本理解，即合成信息得出关键要义就好。如果他们按照所讲，进行专注和发散模式的交替思考，总能理清头绪，把握概念。理解力就像强力胶，能把基础的记忆痕迹黏合在一起。它铺展出各种各样的痕迹路径，将记忆痕迹联结起来。所以说，没有理解在先，你还能创造新的组块吗？一定要说，倒也不是不可以，但是与其他学习材料不匹配的组块，又有什么用呢？还有一件重要的事，仅仅理解某问题的解决方法，不足以创造日后能随时回想的组块。别以为理解问题时“灵光一现”的小突破，就是扎实的真本事了！（课堂上老师一讲你就掌握了概念，但课后如果不赶快复习，等到考前才复习，概念似乎又变得难以理解了。这个经历你肯定不陌生。）合上书本后再找些问题来测验一下新学到的解题方法，会提高你在本阶段的学习效率。 组块的第三步，是获取背景信息。你所看到的将不仅是如何进行组块，还有何时何地使用它们。背景信息意味着跳出初始问题，用更宽广的视角看问题。在相关或不相关的问题上反复推敲、练习，使你不仅能了解组块的用武之地，也能清楚它何时派不上用场。这将有助于你在更大的宏观图景中定位新组块。当然了，就算你的百宝箱中无所不有，但你要是不知道能用在哪儿，它也只能寂寞地待着，而派不上用场。还有，练习可以增加神经元网络的带宽，这样连接到组块的神经线路不仅稳固，而且“条条大路通组块”，它会成为多条痕迹路径上的一站。有些组块同时与概念和流程相关，相辅相成。如果你解决了许多数学题，就会进一步认识到解题步骤的原理，或是为何有效。一旦理解了基础概念，就算出错也更容易找出问题所在。（的确，你会犯错，但这没坏处。）理解基础概念，也让人更易于把知识用到新问题上，这种现象叫作迁移。后面我们会谈到更多有关迁移的内容。 能力错觉与回想的重要性常练不忘到书桌外的世界回忆材料：散步的意义穿插学习法，解决混杂交错的各种问题，而非在同一个问题上过度学习第5章 预防拖延拖延与不安大脑是如何拖延的第6章 小恶魔无处不在驾驭习惯（“小恶魔”），为你所用通过关注过程而非结果进入思绪分解工作量才能细嚼慢咽：专注而简短地工作第7章 搭建组块对抗发懵如何搭建强有力的组块遭遇瓶颈：突然间你的知识结构就要崩塌让一切井然有序：梳理你的学习材料测试是一种强效的学习经历：时常给自己来场小测验第8章 工具、建议和小技巧自我实验：让自己变得更好的关键终极小恶魔联盟：行动日志——你的个人实验记录册科技小贴士：最好用的学习应用和程序第9章 拖延的小恶魔总结篇长期在“高压区”工作的利弊明智的等待拖延问答第10章 增强你的记忆力还记得餐桌在哪儿吗？你自带的超大视觉空间记忆助记的视觉图像记忆宫殿法第11章 记忆技巧多多益善间隔重复有助于向记忆存储概念创建意群编故事肌肉记忆真正的肌肉记忆记忆诀窍帮你更快成为高手第12章 学会自我欣赏不必羡慕天才第13章 塑造你的大脑改变思维，改变生活搭建深层组块第14章 借方程的诗歌打开心灵之眼简化学习内容并对其拟人迁移：把所学的知识运用到新背景中第15章 学习的复兴好老师的价值另一个自学的理由：古怪的试题提防智力“狙击手”第16章 避免自负避免过度自信集思广益的价值第17章 参加考试由难入简法考试中出现焦虑的原因及对策考前的最后把关第18章 释放无限潜力" }, { "title": "《代码之丑》阅读笔记", "url": "/posts/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2022-08-11 20:56:00 +0800", "snippet": "01 | 缺乏业务含义的命名：如何精准命名？例如这样一段代码：public void processChapter(long chapterId) { Chapter chapter = this.repository.findByChapterId(chapterId); if (chapter == null) { throw new IllegalArgumentExcept...", "content": "01 | 缺乏业务含义的命名：如何精准命名？例如这样一段代码：public void processChapter(long chapterId) { Chapter chapter = this.repository.findByChapterId(chapterId); if (chapter == null) { throw new IllegalArgumentException(\"Unknown chapter [\" + chapterId + \"]\"); } chapter.setTranslationState(TranslationState.TRANSLATING); this.repository.save(chapter);}经过阅读我们发现，这段代码做的就是把一个章节的翻译状态改成翻译中，但是我们需要读完代码的细节才知道这段代码的意思。 data、info、flag、process、handle、build、maintain、manage、modify等等。这些名字都属于典型的过于宽泛的名字processChapter（处理章节）的命名过于宽泛，不能精准描述，这是很多代码在命名上存在的严重问题，也是代码难以理解的根源所在。1.命名要能够描述出这段代码在做的事情。 这段代码在做的事情就是“将章节修改为翻译中”。那是不是它就应该叫 changeChapterToTranslating呢？2.一个好的名字应该描述意图，而非细节。 就这段代码而言， 我们为什么要把翻译状态修改成翻译中，这一定是有原因的，也就是意图。具体到这里的业务，我们把翻译状态修改成翻译中，是因为我们在这里开启了一个翻译的过程。所以，这段函数应该命名 startTranslation最终修改为：public void startTranslation(long chapterId) { Chapter chapter = this.repository.findByChapterId(chapterId); if (chapter == null) { throw new IllegalArgumentException(\"Unknown chapter [\" + chapterId + \"]\"); } chapter.setTranslationState(TranslationState.TRANSLATING); this.repository.save(chapter);}3.不要用技术术语命名例如： List&lt;Book&gt; bookList = service.getBooks();这个 bookList 变量之所以叫 bookList，原因就是它声明的类型是 List。 比如，如果我发现，我现在需要的是一个不重复的作品集合，也就是说，我需要把这个变量的类型从 List 改成 Set。变量类型你一定会改，但变量名你会改吗？这还真不一定，一旦出现遗忘，就会出现一个奇特的现象，一个叫 bookList 的变量，它的类型是一个 Set。这样，一个新的混淆就此产生了。因为接口是稳定的，而实现是易变的。 我们需要一个更面向意图的名字。其实，我们在这段代码里真正要表达的是拿到了一堆书，所以，这个名字可以命名成 books List&lt;Book&gt; books = service.getBooks();虽然这里我们只是以变量为例说明了以技术术语命名存在的问题，事实上，在实际的代码中，技术名词的出现，往往就代表着它缺少了一个应有的模型。在一个技术类的项目中，这些技术术语其实就是它的业务语言。但对于业务项目，这个说法就必须重新审视了。4.用业务语言写代码编写可维护的代码要使用业务语言，例如以下一段代码public void approveChapter(long chapterId, long userId) { ...} 这个函数的意图是，确认章节内容审核通过。这里有一个问题，chapterId 是审核章节的 ID，这个没问题，但 userId 是什么呢？了解了一下背景，我们才知道，之所以这里要有一个 userId，是因为这里需要记录一下审核人的信息，这个 userId 就是审核人的 userId。你看，通过业务的分析，我们会发现，这个 userId 并不是一个好的命名，因为它还需要更多的解释，更好的命名是 reviewerUserId，之所以起这个名字，因为这个用户在这个场景下扮演的角色是审核人（Reviewer）。public void approveChapter(long chapterId, long reviewerUserId) { ...}从某种意义上来说，这个坏味道也是一种不精准的命名，但它不是那种一眼可见的坏味道，而是需要在业务层面上再进行讨论 ，所以，它是一种更高级的坏味道。总结好的命名要体现出这段代码在做的事情，而无需展开代码了解其中的细节，这是最低的要求。再进一步，好的命名要准确地体现意图，而不是实现细节。更高的要求是，用业务语言写代码。如果今天的内容你只能记住一件事，那请记住：好的命名，是体现业务含义的命名 。02 | 乱用英语：站在中国人的视角来看英文命名现在主流的程序设计语言都是以英语为基础的，且不说欧美人设计的各种语言，就连日本人设计的 Ruby、巴西人设计的Lua，各种语法采用的也全都是英语。所以，想要成为一个优秀的程序员，会用英语写代码是必要的。这里并不是说，程序员的英语一定要多好，但最低限度的要求是写出来的代码要像是在用英语表达。1.违反语法规则的命名一般来说，常见的命名规则是：类名是一个名词，表示一个对象，而方法名则是一个动词，或者是动宾短语，表示一个动作。例如：public void completedTranslate(final List&lt;ChapterId&gt; chapterIds) {} 这段代码要做的是将一些章节的信息标记为翻译完成，似乎函数名也能反映这个意思，但仔细一看你就会发现问题。作者想表达的是“完成翻译”，因为是已经翻译完了，所以，他用了完成时的 completed，而翻译是 translate。这个函数名就成了completedTranslate。由此，你可以看到，作者已经很用心了，但遗憾的是，这个名字还是起错了。completedTranslate 并不是一个有效的动宾结构。如果把这个名字改成动宾结构，只要把“完成”译为 complete，“翻译”用成它的名词形式 translation 就可以了。所以，这个函数名可以改成 completeTranslation又例如：一个函数名是 retranslation，其表达的意图是重新翻译，但作为函数名，它应该是一个动词，所以，正确的命名应该是 retranslate。2.不准确的英语词汇在这种情况下，最好的解决方案还是建立起一个业务词汇表，千万不要臆想。建立词汇表的另一个关键点就是，用集体智慧，而非个体智慧。3.英语单词拼写错误例如：public class QuerySort { private final SortBy sortBy; private final SortFiled sortFiled; ...}sortFiled 是啥？排序文件吗？为啥用的还是过去式？归档？原来是同时拼错了，应该是排序的字段，是 field4.使用拼音进行命名；5.使用不恰当的单词简写（比如，多个单词的首字母，或者写单词其中的一部分）。我们还讨论了如何从实践层面上更好地规避这些坏味道：制定代码规范，比如 类名要用名词，函数名要用动词或动宾短语； 要建立团队的词汇表； 要经常进行代码评审。03 | 重复代码：简单需求到处修改，怎么办？1.不要直接复制粘贴 复制粘贴是最容易产生重复代码的地方，所以，一个最直白的建议就是，不要使用复制粘贴。真正应该做的是，先提取出函数，然后，在需要的地方调用这个函数。2.重复的结构先看以下代码@Taskpublic void sendBook() { try { this.service.sendBook(); } catch (Throwable t) { this.notification.send(new SendFailure(t))); throw t; }}@Taskpublic void sendChapter() { try { this.service.sendChapter(); } catch (Throwable t) { this.notification.send(new SendFailure(t))); throw t; }}@Taskpublic void startTranslation() { try { this.service.startTranslation(); } catch (Throwable t) { this.notification.send(new SendFailure(t))); throw t; }}这三段函数业务的背景是：一个系统要把作品的相关信息发送给翻译引擎。所以，结合着代码，我们就不难理解它们的含义，sendBook 是把作品信息发出去，sendChapter 就是把章节发送出去，而 startTranslation 则是启动翻译。这几个业务都是以后台的方式在执行，所以，它们的函数签名上增加了一个 Task 的 Annotation，表明它们是任务调度的入口。然后，实际的代码执行放到了对应的业务方法上，也就是 service 里面的方法。这三个函数可能在许多人看来已经写得很简洁了，但是，这段代码的结构上却是有重复的，请把注意力放到 catch 语句里。之所以要做一次捕获（catch），是为了防止系统出问题无人发觉。捕获到异常后，我们把出错的信息通过即时通讯工具发给相关人等，代码里的 notification.send 就是发通知的入口。相比于原来的业务逻辑，这个逻辑是后来加上的，所以，这段代码的作者不厌其烦地在每一处修改了代码。我们可以看到，虽然这三个函数调用的业务代码不同，但它们的结构是一致的，其基本流程可以理解为： 调用业务函数； 如果出错，发通知。当你能够发现结构上的重复，我们就可以把这个结构提取出来。从面向对象的设计来说，就是提出一个接口，就像下面这样：private void executeTask(final Runnable runnable) { try { runnable.run(); } catch (Throwable t) { this.notification.send(new SendFailure(t))); throw t; }}接下来提取相同结构后就可以这样写@Taskpublic void sendBook() { executeTask(this.service::sendBook);}3.做真正的选择首先上例子if (user.isEditor()) { service.editChapter(chapterId, title, content, true);} else { service.editChapter(chapterId, title, content, false);} 相信你和我一样，第一眼看到这段代码的感觉一定是，if 选择的一定是两段不同的业务处理。但只要你稍微看一下，就会发现， if 和 else两段代码几乎是一模一样的。在经过仔细地“找茬”之后，才能发现，原来是最后一个参数不一样。只有参数不同，是不是和前面说的重复代码是如出一辙的？没错，这其实也是一种重复代码。因为作者在写这段代码时，脑子只想到 if 语句判断之后要做什么，而没有想到这个 if 语句判断的到底是什么。但这段代码客观上也造就了重复。写代码要有表达性。把意图准确地表达出来，是写代码过程中非常重要的一环。显然，这里的 if 判断区分的是参数，而非动作。所以，我们可以把这段代码稍微调整一下，会让代码看上去更容易理解：boolean approved = user.isEditor();service.editChapter(chapterId, title, content, approved);请注意，这里我把 user.isEditor() 判断的结果赋值给了一个 approved 的变量，而不是直接作为一个参数传给 editChapter，这么做也是为了提高这段代码的可读性。因为 editChapter 最后一个参数表示的是这个章节是否审核通过。通过引入 approved 变量，我们可以清楚地看到，一个章节审核是否通过的判断条件是“用户是否是一个编辑”，这种写法会让代码更清晰。只要你看到 if 语句出现，而且 if 和 else 的代码块长得又比较像，多半就是出现了这个坏味道。同时这里还可以做一个优化 如果将来审核通过的条件改变了，变化的点全都在 approved的这个变量的赋值上面。如果你追求更有表达性的做法，甚至可以提取一个函数出来，这样，就把变化都放到这个函数里了，就像下面这样：boolean approved = isApproved(user);service.editChapter(chapterId, title, content, approved);private boolean isApproved(final User user) { return user.isEditor();}能够发现重复，是一个很重要的能力，请记住：不要重复自己，不要复制粘贴。04 | 长函数：为什么你总是不可避免地写出长函数？1.多长的函数才算“长”？对于函数长度容忍度高，这是导致长函数产生的关键点。 如果一个人认为 100 行代码不算长，那在他眼中，很多代码根本就是没有问题的，也就更谈不上看到更多问题了，这其实是一个观察尺度的问题。这就好比，没有电子显微镜之前，人们很难理解疾病的原理，因为看不到病毒，就不可能理解病毒可以致病这个道理。回到具体的工作中，“越小越好”是一个追求的目标，不过，没有一个具体的数字，就没办法约束所有人的行为。所以，通常情况下，我们还是要定义出一个代码行数的上限，以保证所有人都可以按照这个标准执行。在实际的项目中，可能不是每个人都能做到这一点，所以，我给了一个更为宽松的限制，在自己的标准上翻了番，也就是 20 行（ps：我感觉我目前做不到这点 o(╥﹏╥)o ，因为对于某些代码逻辑复杂的地方，还是无法缩这么短）。2.长函数的产生 限制函数长度，是一种简单粗暴的解决方案。最重要的是你要知道，长函数本身是一个结果，如果不理解长函数产生的原因，还是很难写出整洁的代码。接下来，我们就来看看长函数是怎么产生的。2.1 以性能为由在很多人看来，把函数写长是为了所谓性能。不过，这个观点在今天是站不住的。性能优化不应该是写代码的第一考量。一方面，一门有活力的程序设计语言本身是不断优化的，无论是编译器，还是运行时，性能都会越来越好；另一方面，可维护性比性能优化要优先考虑，当性能不足以满足需要时，我们再来做相应的测量，找到焦点，进行特定的优化。这比在写代码时就考虑所谓性能要更能锁定焦点，优化才是有意义的。2.2 平铺直叙除了以性能为由把代码写长，还有一种最常见的原因也会把代码写长，那就是写代码平铺直叙，把自己想到的一点点罗列出来。比如下面这段代码（如果你不想仔细阅读，可以直接跳到后面）：public void executeTask() { ObjectMapper mapper = new ObjectMapper(); CloseableHttpClient client = HttpClients.createDefault(); List&lt;Chapter&gt; chapters = this.chapterService.getUntranslatedChapters(); for (Chapter chapter : chapters) { // Send Chapter SendChapterRequest sendChapterRequest = new SendChapterRequest(); sendChapterRequest.setTitle(chapter.getTitle()); sendChapterRequest.setContent(chapter.getContent()); HttpPost sendChapterPost = new HttpPost(sendChapterUrl); CloseableHttpResponse sendChapterHttpResponse = null; String chapterId = null; try { String sendChapterRequestText = mapper.writeValueAsString(sendChapterRequest); sendChapterPost.setEntity(new StringEntity(sendChapterRequestText)); sendChapterHttpResponse = client.execute(sendChapterPost); HttpEntity sendChapterEntity = sendChapterPost.getEntity(); SendChapterResponse sendChapterResponse = mapper.readValue(sendChapterEntity.getContent(), SendChapterResponse.class); chapterId = sendChapterResponse.getChapterId(); } catch (IOException e) { throw new RuntimeException(e); } finally { try { if (sendChapterHttpResponse != null) { sendChapterHttpResponse.close(); } } catch (IOException e) { // ignore } } // Translate Chapter HttpPost translateChapterPost = new HttpPost(translateChapterUrl); CloseableHttpResponse translateChapterHttpResponse = null; try { TranslateChapterRequest translateChapterRequest = new TranslateChapterRequest(); translateChapterRequest.setChapterId(chapterId); String translateChapterRequestText = mapper.writeValueAsString(translateChapterRequest); translateChapterPost.setEntity(new StringEntity(translateChapterRequestText)); translateChapterHttpResponse = client.execute(translateChapterPost); HttpEntity translateChapterEntity = translateChapterHttpResponse.getEntity(); TranslateChapterResponse translateChapterResponse = mapper.readValue(translateChapterEntity.getContent(), TranslateChapterResponse.class); if (!translateChapterResponse.isSuccess()) { logger.warn(\"Fail to start translate: {}\", chapterId); } } catch (IOException e) { throw new RuntimeException(e); } finally { if (translateChapterHttpResponse != null) { try { translateChapterHttpResponse.close(); } catch (IOException e) { // ignore } } } }这段代码的逻辑是，把没有翻译过的章节发到翻译引擎，然后，启动翻译过程。在这里翻译引擎是另外一个服务，需要通过 HTTP 的形式向它发送请求。相对而言，这段代码还算直白，当你知道了我上面所说的逻辑，你是很容易看懂这段代码的。这段代码之所以很长，主要原因就是把前面所说的逻辑全部平铺直叙地摆在那里了，这里既有业务处理的逻辑，比如，把章节发送给翻译引擎，然后，启动翻译过程；又有处理的细节，比如，把对象转成 JSON，然后，通过 HTTP 客户端发送出去。从这段代码中，我们可以看到平铺直叙的代码存在的两个典型问题： 把多个业务处理流程放在一个函数里实现； 把不同层面的细节放到一个函数里实现这里发送章节和启动翻译是两个过程，显然，这是可以放到两个不同的函数中去实现的，所以，我们只要做一下提取函数，就可以把这个看似庞大的函数拆开，而拆出来的几个函数规模都会小很多，像下面这样public void executeTask() { ObjectMapper mapper = new ObjectMapper(); CloseableHttpClient client = HttpClients.createDefault(); List&lt;Chapter&gt; chapters = this.chapterService.getUntranslatedChapters(); for (Chapter chapter : chapters) { String chapterId = sendChapter(mapper, client, chapter); translateChapter(mapper, client, chapterId); }}拆出来的部分，实际上就是把对象打包发送的过程，我们以发送章节为例，先来看拆出来的发送章节部分：private String sendChapter(final ObjectMapper mapper, final CloseableHttpClient client, final Chapter chapter) { SendChapterRequest request = asSendChapterRequest(chapter); CloseableHttpResponse response = null; String chapterId = null; try { HttpPost post = sendChapterRequest(mapper, request); response = client.execute(post); chapterId = asChapterId(mapper, post); } catch (IOException e) { throw new RuntimeException(e); } finally { try { if (response != null) { response.close(); } } catch (IOException e) { // ignore } } return chapterId;}private HttpPost sendChapterRequest(final ObjectMapper mapper, final SendChapterRequest sendChapterRequest) throws JsonProcessingException, UnsupportedEncodingException { HttpPost post = new HttpPost(sendChapterUrl); String requestText = mapper.writeValueAsString(sendChapterRequest); post.setEntity(new StringEntity(requestText)); return post;}private String asChapterId(final ObjectMapper mapper, final HttpPost sendChapterPost) throws IOException { String chapterId; HttpEntity entity = sendChapterPost.getEntity(); SendChapterResponse response = mapper.readValue(entity.getContent(), SendChapterResponse.class); chapterId = response.getChapterId(); return chapterId;}private SendChapterRequest asSendChapterRequest(final Chapter chapter) { SendChapterRequest request = new SendChapterRequest(); request.setTitle(chapter.getTitle()); request.setContent(chapter.getContent()); return request}我们只用了最简单的提取函数这个重构手法，就把一个大函数拆分成了若干的小函数。长函数往往还隐含着一个命名问题。如果你看修改后的 sendChapter，其中的变量命名明显比之前要短，理解的成本也相应地会降低。因为变量都是在这个短小的上下文里，也就不会产生那么多的命名冲突，变量名当然就可以写短一些。平铺直叙的代码，一个关键点就是没有把不同的东西分解出来。如果我们用设计的眼光衡量这段代码，这就是“分离关注点”没有做好，把不同层面的东西混在了一起，既有不同业务混在一起，也有不同层次的处理混在了一起。关注点越多越好，粒度越小越好。2.3 一次加一点有时，一段代码一开始的时候并不长，就像下面这段代码，它根据返回的错误进行相应地错误处理：if (code == 400 || code == 401) { // 做一些错误处理}然后，新的需求来了，增加了新的错误码，它就变成了这个样子：if (code == 400 || code == 401 || code == 402) { // 做一些错误处理}你知道，一个有生命力的项目经常会延续很长时间，于是，这段代码有很多次被修改的机会，日积月累，它就成了让人不忍直视的代码，比如：if (code == 400 || code == 401 || code == 402 || ... || code == 500 || ... || ... || code == 10000 || ...) { // 做一些错误处理}任何代码都经不起这种无意识的累积，每个人都没做错，但最终的结果很糟糕。 对抗这种逐渐糟糕腐坏的代码，我们需要知道“童子军军规”： 让营地比你来时更干净。—— 童子军军规Robert Martin 把它借鉴到了编程领域，简言之，我们应该看看自己对于代码的改动是不是让原有的代码变得更糟糕了，如果是，那就改进它。 但这一切的前提是，你要能看出自己的代码是不是让原有的代码变得糟糕了，所以，学习代码的坏味道还是很有必要的。05——大类：如何避免写出难以理解的大类？一听到大类，估计你的眼前已经浮现出一片无边无际的代码了。类之所以成为了大类，一种表现形式就是我们上节课讲到的长函数，一个类只要有几个长函数，那它就肯定是一眼望不到边了。大类还有一种表现形式，类里面有特别多的字段和函数，也许，每个函数都不大，但架不住数量众多啊，这也足以让这个类在大类中占有一席之地。这一讲，我们就主要来说说这种形式的大类。1.分模块的程序 为什么不把所有的代码都写到一个文件里？事实是，把代码写到一个文件里，一方面，相同的功能模块没有办法复用；另一方面，也是更关键的，把代码都写到一个文件里，其复杂度会超出一个人能够掌握的认知范围。简言之，一个人理解的东西是有限的，没有人能同时面对所有细节。 人类面对复杂事物给出的解决方案是分而治之。所以，我们看到几乎各种程序设计语言都有自己的模块划分方案，从最初的按照文件划分，到后来，使用面向对象方案按照类进行划分，本质上，它们都是一种模块划分的方式。这样，人们面对的就不再是细节，而是模块，模块的数量显然会比细节数量少，人们的理解成本就降低了。如果一个类里面的内容太多，它就会超过一个人的理解范畴，顾此失彼就在所难免了。2.大类的产生2.1 职责不单一最容易产生大类的原因在于职责的不单一。我们先来看一段代码：public class User { private long userId; private String name; private String nickname; private String email; private String phoneNumber; //作者类型 表示作者是签约作者还是普通作者，签约作者可以设置作品的付费信息，而普通作者不能 private AuthorType authorType; //作者审核状态 作者成为签约作者，需要有一个申请审核的过程，这个状态就是审核的状态 private ReviewStatus authorReviewStatus; //编辑类型 编辑可以是主编，也可以是小编，他们的权限是不一样的 private EditorType editorType; ...}首先，普通的用户既不是作者，也不是编辑。作者和编辑这些相关的字段，对普通用户来说，都是没有意义的。其次，对于那些成为了作者的用户，编辑的信息意义也不大，因为作者是不能成为编辑的，反之亦然，编辑也不会成为作者，作者信息对成为编辑的用户也是没有意义的。在这个类的设计里面，总有一些信息对一部分人是没有意义，但这些信息对于另一部分人来说又是必需的。之所以会出现这样的状况，关键点就在于，这里只有“一个”用户类。普通用户、作者、编辑，这是三种不同角色，来自不同诉求的业务方关心的是不同的内容。只是因为它们都是这个系统的用户，就把它们都放到用户类里，造成的结果就是，任何业务方的需求变动，都会让这个类反复修改。这种做法实际上是违反了单一职责原则。普通用户、作者、编辑，这是三种不同角色，来自不同诉求的业务方关心的是不同的内容。只是因为它们都是这个系统的用户，就把它们都放到用户类里，造成的结果就是，任何业务方的需求变动，都会让这个类反复修改。这种做法实际上是违反了单一职责原则。而想要破解“大类”的谜题，关键就是能够把不同的职责拆分开来。回到我们这个类上，其实，我们前面已经分析了，虽然这是一个类，但其实，它把不同角色关心的东西都放在了一起，所以，它变得如此庞大。我们只要把不同的信息拆分开来，问题也就迎刃而解了。下面就是把不同角色拆分出来的结果：public class User { private long userId; private String name; private String nickname; private String email; private String phoneNumber; ...}public class Author { private long userId; private AuthorType authorType; private ReviewStatus authorReviewStatus; ...}public class Editor { private long userId; private EditorType editorType; ...}这里，我们拆分出了 Author 和 Editor 两个类，把与作者和编辑相关的字段分别移到了这两个类里面。在这两个类里面分别有一个 userId 字段，用以识别这个角色是和哪个用户相关。这个大 User 类就这样被分解了。2.2 字段未分组有时候，我们会觉得有一些字段确实都是属于某个类，结果就是，这个类还是很大。比如，我们看一下上面拆分的结果，那个新的 User 类：public class User { private long userId; private String name; private String nickname; private String email; private String phoneNumber; ...}前面我们分析过，这些字段应该都算用户信息的一部分。但是，即便相比于原来的 User 类小了许多，这个类依然也不算是一个小类，原因就是，这个类里面的字段并不属于同一种类型的信息。比如，userId、name、nickname 几项，算是用户的基本信息，而 email、phoneNumber 这些则属于用户的联系方式。从需求上看，基本信息是那种一旦确定就不怎么会改变的内容，而联系方式则会根据实际情况调整，比如，绑定各种社交媒体的账号。所以，如果我们把这些信息都放到一个类里面，这个类的稳定程度就要差一些。所以，我们可以根据这个理解，把 User 类的字段分个组，把不同的信息放到不同的类里面。public class User { private long userId; private String name; private String nickname; private Contact contact; ...}public class Contact { private String email; private String phoneNumber; ...}这里我们引入了一个 Contact 类（也就是联系方式），把 email 和 phoneNumber 放了进去，后面再有任何关于联系方式的调整就都可以放在这个类里面。经过这次调整，我们把不同的信息重新组合了一下，但每个类都比原来要小。对比一下，如果说前后两次拆分有什么不同，那就是：前面是根据职责，拆分出了不同的实体，后面是将字段做了分组，用类把不同的信息分别做了封装所谓的将大类拆解成小类，本质上在做的工作是一个设计工作另外，如果你还想有些极致的追求，我给你推荐《ThoughtWorks 文集》这本书里“对象健身操”这一篇，这里提到一个要求：每个类不超过 2 个字段。（个人感觉：我觉得这样会导致类太多，业务处理更加复杂）如果今天的内容你只能记住一件事，那请记住：把类写小，越小越好。06 | 长参数列表：如何处理不同类型的长参数？从程序设计语言发展的过程中，我们也可以看到，取消全局变量已经成为了大势所趋。 但函数之间还是要传递信息的，既然不能用全局变量，参数就成了最好的选择，于是乎，只要你想到有什么信息要传给一个函数，就自然而然地把它加到参数列表中，参数列表也就越来越长了。1.聚沙成塔public void createBook(final String title, final String introduction, final URL coverUrl, final BookType type, final BookChannel channel, final String protagonists, final String tags, final boolean completed) { ... Book book = Book.builder .title(title) .introduction(introduction) .coverUrl(coverUrl) .type(type) .channel(channel) .protagonists(protagonists) .tags(tags) .completed(completed) .build(); this.repository.save(book);}我们就会看到这里面的问题：这个函数的参数列表太长了。 如果你现在要在作品里增加一项信息，表明这部作品是否是签约作品，也就是这部作品是否可以收费，那你该怎么办？顺着前面的思路，我们很自然地就会想到给这个函数增加一个参数。但正如我在讲“长函数”那节课里说到的，很多问题都是这样，每次只增加一点点，累积起来，便不忍直视了。如何解决呢？这里所有的参数其实都是和作品相关的，也就是说，所有的参数都是创建作品所必需的。所以，我们可以做的就是将这些参数封装成一个类，一个创建作品的参数类：public class NewBookParamters { private String title; private String introduction; private URL coverUrl; private BookType type; private BookChannel channel; private String protagonists; private String tags; private boolean completed; ...}这样一来，这个函数参数列表就只剩下一个参数了，一个长参数列表就消除了：public void createBook(final NewBookParamters parameters) { ...}这里你看到了一个典型的消除长参数列表的重构手法：将参数列表封装成对象。或许你还有个疑问，只是把一个参数列表封装成一个类，然后，用到这些参数的时候，还需要把它们一个个取出来，这会不会是多此一举呢？就像这样：public void createBook(final NewBookParamters parameters) { ... Book book = Book.builder .title(parameters.getTitle()) .introduction(parameters.getIntroduction()) .coverUrl(parameters.getCoverUrl()) .type(parameters.getType()) .channel(parameters.getChannel()) .protagonists(parameters.getProtagonists()) .tags(parameters.getTags()) .completed(parameters.isCompleted()) .build(); this.repository.save(book);}我们并不是简单地把参数封装成类，站在设计的角度，我们这里引入的是一个新的模型。我在《软件设计之美》讨论模型封装的时候曾经说过，一个模型的封装应该是以行为为基础的。之前没有这个模型，所以，我们想不到它应该有什么行为，现在模型产生了，它就应该有自己配套的行为，那这个模型的行为是什么呢？从上面的代码我们不难看出，它的行为应该是构建一个作品对象出来。你理解了这一点，我们的代码就可以进一步调整了：public class NewBookParamters { private String title; private String introduction; private URL coverUrl; private BookType type; private BookChannel channel; private String protagonists; private String tags; private boolean completed; public Book newBook() { return Book.builder .title(title) .introduction(introduction) .coverUrl(coverUrl) .type(type) .channel(channel) .protagonists(protagonists) .tags(tags) .completed(completed) .build(); }}创建作品的函数就得到了极大的简化：public void createBook(final NewBookParamters parameters) { ... Book book = parameters.newBook(); this.repository.save(book);}2.动静分离把长参数列表封装成一个类，这能解决大部分的长参数列表，但并不等于所有的长参数列表都应该用这种方式解决，因为不是所有情况下，参数都属于一个类。我们再来看一段代码：public void getChapters(final long bookId, final HttpClient httpClient, final ChapterProcessor processor) { HttpUriRequest request = createChapterRequest(bookId); HttpResponse response = httpClient.execute(request); List&lt;Chapter&gt; chapters = toChapters(response); processor.process(chapters);}在这几个参数里面，每次传进来的 bookId 都是不一样的，是随着请求的不同而改变的。但 httpClient 和 processor 两个参数都是一样的，因为它们都有相同的逻辑，没有什么变化。换言之，bookId 的变化频率同 httpClient 和 processor 这两个参数的变化频率是不同的。一边是每次都变，另一边是不变的。具体到这个场景下，静态不变的数据完全可以成为这个函数所在类的一个字段，而只将每次变动的东西作为参数传递就可以了。按照这个思路，代码可以改成这个样子：public void getChapters(final long bookId) { HttpUriRequest request = createChapterRequest(bookId); HttpResponse response = this.httpClient.execute(request); List&lt;Chapter&gt; chapters = toChapters(response); this.processor.process(chapters);}这个例子也给了我们一个提示，长参数列表固然可以用一个类进行封装，但能够封装出这个类的前提条件是：这些参数属于一个类，有相同的变化原因。如果函数的参数有不同的变化频率，就要视情况而定了。对于静态的部分，我们前面已经看到了，它可以成为软件结构的一部分，而如果有多个变化频率，我们还可以封装出多个参数类来。3.告别标记我们再来看一个例子：public void editChapter(final long chapterId, final String title, final String content, final boolean apporved) { ...}使用标记参数，是程序员初学编程时常用的一种手法，不过，正是因为这种手法实在是太好用了，造成的结果就是代码里面彩旗（flag）飘飘，各种标记满天飞。不仅变量里有标记，参数里也有。很多长参数列表其中就包含了各种标记参数。这也是很多代码产生混乱的一个重要原因。在实际的代码中，我们必须小心翼翼地判断各个标记当前的值，才能做好处理。解决标记参数，一种简单的方式就是，将标记参数代表的不同路径拆分出来。回到这段代码上，这里的一个函数可以拆分成两个函数，一个函数负责“普通的编辑”，另一个负责“可以直接审核通过的编辑”。// 普通的编辑，需要审核public void editChapter(final long chapterId, final String title, final String content) { ...}// 直接审核通过的编辑public void editChapterWithApproval(final long chapterId, final String title, final String content) { ...}标记参数在代码中存在的形式很多，有的是布尔值的形式，有的是以枚举值的形式，还有的就是直接的字符串或者整数。无论哪种形式，我们都可以通过拆分函数的方式将它们拆开。在重构中，这种手法叫做移除标记参数（Remove Flag Argument）。如果今天的内容你只能记住一件事，那请记住：减小参数列表，越小越好。07 | 滥用控制语句：出现控制结构，多半是错误的提示这个坏味道就是滥用控制语句，也就是你熟悉的 if、for 等等，这个坏味道非常典型，但很多人每天都用它们，却对问题毫无感知。今天我们就先从一个你容易接受的坏味道开始，说一说使用控制语句时，问题到底出在哪。1.嵌套的代码考虑到篇幅，我就不用这么震撼的代码做案例了，我们还是从规模小一点的代码开始讨论：public void distributeEpubs(final long bookId) { List&lt;Epub&gt; epubs = this.getEpubsByBookId(bookId); for (Epub epub : epubs) { if (epub.isValid()) { boolean registered = this.registerIsbn(epub); if (registered) { this.sendEpub(epub); } } }}这是一段做 EPUB 分发的代码，EPUB 是一种电子书格式。在这里，我们根据作品 ID 找到要分发的 EPUB，然后检查 EPUB 的有效性。对于有效的 EPUB，我们要为它注册 ISBN 信息，注册成功之后，将这个 EPUB 发送出去。代码逻辑并不是特别复杂，只不过，在这段代码中，我们看到了多层的缩进，for 循环一层，里面有两个 if ，又多加了两层。即便不是特别复杂的代码，也有这么多的缩进，可想而知，如果逻辑再复杂一点，缩进会成什么样子这段代码之所以会写成这个样子，其实就是我在讲“长函数”那节课里所说的：“平铺直叙地写代码”。这段代码的作者只是按照需求一步一步地把代码实现出来了。从实现功能的角度来说，这段代码肯定没错，但问题在于，在把功能实现之后，他停了下来，而没有把代码重新整理一下。那我们就来替这段代码作者将它整理成应有的样子。既然我们不喜欢缩进特别多的代码，那我们就要消除缩进。具体到这段代码，一个着手点是 for 循环，因为通常来说，for 循环处理的是一个集合，而循环里面处理的是这个集合中的一个元素。所以，我们可以把循环中的内容提取成一个函数，让这个函数只处理一个元素，就像下面这样：public void distributeEpubs(final long bookId) { List&lt;Epub&gt; epubs = this.getEpubsByBookId(bookId); for (Epub epub : epubs) { this.distributeEpub(epub)； }}private void distributeEpub(final Epub epub) { if (epub.isValid()) { boolean registered = this.registerIsbn(epub); if (registered) { this.sendEpub(epub); } }}这里我们已经有了一次拆分，分解出来 distributeEpub 函数每次只处理一个元素。拆分出来的两个函数在缩进的问题上，就改善了一点。第一个函数 distributeEpubs 只有一层缩进，这是一个正常函数应有的样子，不过，第二个函数 distributeEpub 则还有多层缩进，我们可以继续处理一下。2.if 和 else在 distributeEpub 里，造成缩进的原因是 if 语句。通常来说，if 语句造成的缩进，很多时候都是在检查某个先决条件，只有条件通过时，才继续执行后续的代码。这样的代码可以使用卫语句（guard clause）来解决，也就是设置单独的检查条件，不满足这个检查条件时，立刻从函数中返回。这是一种典型的重构手法 ：以卫语句取代嵌套的条件表达式（Replace Nested Conditional with Guard Clauses）。我们来看看改进后的 distributeEpub 函数：private void distributeEpub(final Epub epub) { if (!epub.isValid()) { return; } boolean registered = this.registerIsbn(epub); if (!registered) { return; } this.sendEpub(epub);}改造后的 distributeEpub 就没有了嵌套，也就没有那么多层的缩进了。你可能已经发现了，经过我们改造之后，代码里只有一层的缩进。当代码里只有一层缩进时，代码的复杂度就大大降低了，理解成本和出现问题之后定位的成本也随之大幅度降低。函数至多有一层缩进，这是“对象健身操（《ThoughtWorks 文集》书里的一篇）”里的一个规则。前面讲“大类”的时候，我曾经提到过“对象健身操”这篇文章，其中给出了九条编程规则，下面我们再来讲其中的一条：不要使用 else 关键字。没错，else 也是一种坏味道，这是挑战很多程序员认知的。在大多数人印象中，if 和 else 是亲如一家的整体，它们几乎是比翼齐飞的。那么，else 可以不写吗？可以。我们来看看下面的代码：public double getEpubPrice(final boolean highQuality, final int chapterSequence) { double price = 0; if (highQuality &amp;&amp; chapterSequence &gt; START_CHARGING_SEQUENCE) { price = 4.99; } else if (sequenceNumber &gt; START_CHARGING_SEQUENCE &amp;&amp; sequenceNumber &lt;= FURTHER_CHARGING_SEQUENCE) { price = 1.99; } else if (sequenceNumber &gt; FURTHER_CHARGING_SEQUENCE) { price = 2.99; } else { price = 0.99; } return price;}这是一个根据 EPUB 信息进行定价的函数，它的定价逻辑正如代码中所示。 如果是高品质书，而且要是章节序号超过起始付费章节，就定价 4.99； 对一般的书而言，超过起始付费章节，就定价 1.99； 超过进一步付费章节，就定价 2.99。 缺省情况下，定价 0.99。就这段代码而言，如果想不使用 else，一个简单的处理手法就是让每个逻辑提前返回，这和我们前面提到的卫语句的解决方案如出一辙：public double getEpubPrice(final boolean highQuality, final int chapterSequence) { if (highQuality &amp;&amp; chapterSequence &gt; START_CHARGING_SEQUENCE) { return 4.99; } if (sequenceNumber &gt; START_CHARGING_SEQUENCE &amp;&amp; sequenceNumber &lt;= FURTHER_CHARGING_SEQUENCE) { return 1.99; } if (sequenceNumber &gt; FURTHER_CHARGING_SEQUENCE) { return 2.99; } return 0.99;}对于这种逻辑上还比较简单的代码，这么改造还是比较容易的，而对于一些更为复杂的代码，也许就要用到多态来改进代码了。不过在实际项目中，大部分代码逻辑都是逐渐变得复杂的，所以，最好在它还比较简单时，就把坏味道消灭掉。这才是最理想的做法。3.重复的 Switch通过前面内容的介绍，你会发现，循环和选择语句这些你最熟悉的东西，其实都是坏味道出现的高风险地带，必须小心翼翼地使用它们。接下来，还有一个你从编程之初就熟悉的东西，也是另一个坏味道的高风险地带。我们来看两段代码：public double getBookPrice(final User user, final Book book) { double price = book.getPrice(); switch (user.getLevel()) { case UserLevel.SILVER: return price * 0.9; case UserLevel.GOLD: return price * 0.8; case UserLevel.PLATINUM: return price * 0.75; default: return price; }}public double getEpubPrice(final User user, final Epub epub) { double price = epub.getPrice(); switch (user.getLevel()) { case UserLevel.SILVER: return price * 0.95; case UserLevel.GOLD: return price * 0.85; case UserLevel.PLATINUM: return price * 0.8; default: return price; }}这两段代码，分别计算了用户在网站上购买作品在线阅读所支付的价格，以及购买 EPUB 格式电子书所支付的价格。其中，用户实际支付的价格会根据用户在系统中的用户级别有所差异，级别越高，折扣就越高。显然，这两个函数里出现了类似的代码，其中最类似的部分就是 switch，都是根据用户级别进行判断。事实上，这并不是仅有的根据用户级别进行判断的代码，各种需要区分用户级别的场景中都有类似的代码，而这也是一种典型的坏味道： 重复的 switch（Repeated Switch）。之所以会出现重复的 switch，通常都是缺少了一个模型。所以，应对这种坏味道，重构的手法是：以多态取代条件表达式（Relace Conditional with Polymorphism）。具体到这里的代码，我们可以引入一个 UserLevel 的模型，将 switch 消除掉：interface UserLevel { double getBookPrice(Book book); double getEpubPrice(Epub epub);}class RegularUserLevel implements UserLevel { public double getBookPrice(final Book book) { return book.getPrice(); } public double getEpubPrice(final Epub epub) { return epub.getPrice();}class GoldUserLevel implements UserLevel { public double getBookPrice(final Book book) { return book.getPrice() * 0.8; } public double getEpubPrice(final Epub epub) { return epub.getPrice() * 0.85; }}class SilverUserLevel implements UserLevel { public double getBookPrice(final Book book) { return book.getPrice() * 0.9; } public double getEpubPrice(final Epub epub) { return epub.getPrice() * 0.85; }}class PlatinumUserLevel implements UserLevel { public double getBookPrice(final Book book) { return book.getPrice() * 0.75; } public double getEpubPrice(final Epub epub) { return epub.getPrice() * 0.8; }}有了这个基础，前面的代码就可以把 switch 去掉了：public double getBookPrice(final User user, final Book book) { UserLevel level = user.getUserLevel() return level.getBookPrice(book);}public double getEpubPrice(final User user, final Epub epub) { UserLevel level = user.getUserLevel() return level.getEpubPrice(epub);}我们都知道，switch 其实就是一堆“ if…else” 的简化写法，二者是等价的，所以，这个重构手法，以多态取代的是条件表达式，而不仅仅是取代 switch。08 | 缺乏封装：如何应对火车代码和基本类型偏执问题？在程序设计中，一个重要的观念就是封装，将零散的代码封装成一个又一个可复用的模块。任何一个程序员都会认同封装的价值，但是，具体到写代码时，每个人对于封装的理解程度却天差地别，造成的结果就是：写代码的人认为自己提供了封装，但实际上，我们还是看到许多的代码散落在那里。1.火车残骸String name = book.getAuthor().getName();这段代码表达的是“获得一部作品作者的名字”。作品里有作者信息，想要获得作者的名字，通过“作者”找到“作者姓名”，这就是很多人凭借直觉写出的代码，不过它是有问题的。你可以想一想，如果你想写出上面这段代码，是不是必须得先了解 Book 和 Author 这两个类的实现细节？也就是说，我们必须得知道，作者的姓名是存储在作品的作者字段里的。这时你就要注意了：当你必须得先了解一个类的细节，才能写出代码时，这只能说明一件事，这个封装是失败的。解决这种代码的重构手法叫隐藏委托关系（Hide Delegate），说得更直白一些就是，把这种调用封装起来：class Book { ... public String getAuthorName() { return this.author.getName(); } ...}String name = book.getAuthorName();火车残骸这种坏味道的产生是缺乏对于封装的理解，因为封装这件事并不是很多程序员编码习惯的一部分，他们对封装的理解停留在数据结构加算法的层面上。比如说，有人编写一个新的类，第一步是写出这个类要用到的字段，然后，就是给这些字段生成相应的 getter，也就是各种 getXXX。很多语言或框架提供的约定就是基于这种 getter 的，就像 Java 里的 JavaBean，所以相应的配套工具也很方便。现在写出一个 getter 往往是 IDE 中一个快捷键的操作，甚至不需要自己手工敲代码。要想摆脱初级程序员的水平，就要先从少暴露细节开始。 声明完一个类的字段之后，请停下生成 getter 的手，转而让大脑开始工作，思考这个类应该提供的行为。在软件行业中，有一个编程的指导原则几乎就是针对这个坏味道的，叫做迪米特法则（Law of Demeter），这个原则是这样说的： 每个单元对其它单元只拥有有限的知识，而且这些单元是与当前单元有紧密联系的； 每个单元只能与其朋友交谈，不与陌生人交谈； 只与自己最直接的朋友交谈。这个原则需要我们思考，哪些算是直接的朋友，哪些算是陌生人。火车残骸般的代码显然就是没有考虑这些问题而直接写出来的代码。2.基本类型偏执public double getEpubPrice(final boolean highQuality, final int chapterSequence) { ...}这是我们上一讲用过的一个函数声明，根据章节信息获取 EPUB（一种电子书的格式） 的价格。也许你会问，这是一个看上去非常清晰的代码，难道这里也有坏味道吗？没错，有。问题就出在返回值的类型上，也就是价格的类型上。那么，我们在数据库中存储价格的时候，就是用一个浮点数，这里用 double 可以保证计算的精度，这样的设计有什么问题吗？确实，这就是很多人使用基本类型（Primitive）作为变量类型思考的角度。但实际上，这种采用基本类型的设计缺少了一个模型。虽然价格本身是用浮点数在存储，但价格和浮点数本身并不是同一个概念，有着不同的行为需求。比如，一般情况下，我们要求商品价格是大于 0 的，但 double 类型本身是没有这种限制的。就以“价格大于 0”这个需求为例，如果使用 double 类型你会怎么限制呢？我们通常会这样写：if (price &lt;= 0) { throw new IllegalArgumentException(\"Price should be positive\");}问题是，如果使用 double 作为类型，那我们要在使用的地方都保证价格的正确性，像这样的价格校验就应该是使用的地方到处写的。如果补齐这里缺失的模型，我们可以引入一个 Price 类型，这样的校验就可以放在初始化时进行：class Price { private long price; public Price(final double price) { if (price &lt;= 0) { throw new IllegalArgumentException(\"Price should be positive\"); } this.price = price; }}这种引入一个模型封装基本类型的重构手法，叫做以对象取代基本类型（Replace Primitive with Object）。一旦有了这个模型，我们还可以再进一步，比如，如果我们想要让价格在对外呈现时只有两位，在没有 Price 类的时候，这样的逻辑就会散落代码的各处，事实上，代码里很多重复的逻辑就是这样产生的。而现在我们可以在 Price 类里提供一个方法：public double getDisplayPrice() { BigDecimal decimal = new BigDecimal(this.price)； return decimal.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();}其实，使用基本类型和使用继承出现的问题是异曲同工的。大部分程序员都学过这样一个设计原则：组合优于继承，也就是说，我们不要写出这样的代码：public Books extends List&lt;Book&gt; { ...}而应该写成组合的样子，也就是：public Books { private List&lt;Book&gt; books; ...}之所以有人把 Books 写成了继承，因为在代码作者眼中，Books 就是一个书的集合；而有人用 double 做价格的类型，因为在他看来，价格就是一个 double。这里的误区就在于，一些程序员只看到了模型的相同之处，却忽略了差异的地方。 Books 可能不需要提供 List 的所有方法，价格的取值范围与 double 也有所差异但是，Books 的问题相对来说容易规避，因为产生了一个新的模型，有通用的设计原则帮助我们判断这个模型构建得是否恰当，而价格的问题却不容易规避，因为这里没有产生新的模型，也就不容易发现这里潜藏着问题。这种以基本类型为模型的坏味道称为基本类型偏执（Primitive Obsession）。这里说的基本类型，不限于程序设计语言提供的各种基本类型，像字符串也是一个产生这种坏味道的地方。这里我稍微延伸一下，有很多人对于集合类型（比如数组、List、Map 等等）的使用也属于这种坏味道。之前课程里我提到过“对象健身操（出自《ThoughtWorks 文集》）”这篇文章，里面有两个与此相关的条款，你可以作为参考： 封装所有的基本类型和字符串； 使用一流的集合。封装之所以有难度，主要在于它是一个构建模型的过程， 而很多程序员写程序，只是用着极其粗粒度的理解写着完成功能的代码，根本没有构建模型的意识；还有一些人以为划分了模块就叫封装，所以，我们才会看到这些坏味道的滋生。如果今天的内容你只能记住一件事，那请记住：构建模型，封装散落的代码。09 | 可变的数据：不要让你的代码“失控”对于程序，最朴素的一种认知是“程序 = 数据结构 + 算法”，所以，数据几乎是软件开发最核心的一个组成部分。在一些人的认知中，所谓做软件，就是一系列的 CRUD 操作，也就是对数据进行增删改查。再具体一点，写代码就把各种数据拿来，然后改来改去。我们学习编程时，首先学会的，也是给变量赋值，写出类似 a = b + 1之类的代码。改数据，几乎已经成了很多程序员写代码的标准做法。然而，这种做法也带来了很多的问题。这一讲，我们还是从一段问题代码开始。1.满天飞的 Setterpublic void approve(final long bookId) { ... book.setReviewStatus(ReviewStatus.APPROVED); ...}这是一段对作品进行审核的代码，通过 bookId，找到对应的作品，接下来，将审核状态设置成了审核通过。我当时之所以注意到这段代码，就是因为这里用了 setter。setter 往往是缺乏封装的一种做法。对于缺乏封装的坏味道，我们上节课已经用了一讲的篇幅在说，我提到，很多人在写代码时，写完字段就会利用 IDE 生成 getter，实际情况往往是，生成 getter 的同时，setter 也生成了出来。setter 同 getter 一样，反映的都是对细节的暴露。这就意味着，你不仅可以读到一个对象的数据，还可以修改一个对象的数据。相比于读数据，修改是一个更危险的操作。可变的数据是可怕，但是，比可变的数据更可怕的是，不可控的变化，而暴露 setter 就是这种不可控的变化。把各种实现细节完全交给对这个类不了解的使用者去修改，没有人会知道他会怎么改，所以，这种修改完全是不可控的。缺乏封装再加上不可控的变化，在我个人心目中，setter 几乎是排名第一的坏味道。在开篇词里，我们针对代码给出的调整方案是，用一个函数替代了 setter，也就是把它用行为封装了起来：public void approve(final long bookId) { ... book.approve(); ...}通过在 Book 类里引入了一个 approve 函数，我们将审核状态封装了起来class Book { public void approve() { this.reviewStatus = ReviewStatus.APPROVED; }}setter 破坏了封装，相信你对这点已经有了一定的理解。不过，有时候你会说，我这个 setter 只是用在初始化过程中，而并不需要在使用的过程去调用，就像下面这样：Book book = new Book();book.setBookId(bookId);book.setTitle(title);book.setIntroduction(introduction);实际上，对于这种只在初始化中使用的代码，压根没有必要以 setter 的形式存在，真正需要的是一个有参数的构造函数：Book book = new Book(bookId, title, introduction);消除 setter ，有一种专门的重构手法，叫做移除设值函数（Remove Setting Method）。总而言之，setter 是完全没有必要存在的。在今天的软件开发中，人们为了简化代码的编写做出了各种努力，用 IDE 生成的代码是一种，还有一种常见的做法就是，通过工具和框架生成相应代码的。在 Java 世界中，Lombok 就是这样的一种程序库，它可以在编译的过程中生成相应的代码，而我们需要做的，只是在代码上加上对应的 Annotation。它最大的优点是不碍眼，也就是不会产生大量可以看见的代码。因为它的代码是在编译阶段生成的，所以，那些生成的代码在源码级别上是不存在的。下面就是一个例子：@Getter@Setterclass Book { private BookId bookId; private String title; private String introduction;}不过，我想说的是，不写 setter 的代码并不代表没有 setter。因为 @Setter 的存在，其它代码还是可以调用这个类的 setter，存在的问题并不会改变。所以，一个更好的做法是禁用 @Setter。下面是 lombok.config 的配置，通过它，我们就可以禁用 @Setter 了：lombok.setter.flagUsage = errorlombok.data.flagUsage = error你或许注意到了，这里除了 @Setter，我还禁用了 @Data，这是 Lombok 中另外一个 Annotation，表示的是同时生成 getter 和 setter。既然我们禁用 @Setter 是为了防止生成 setter，当然也要禁用 @Data 了2.可变的数据我们反对使用 setter，一个重要的原因就是它暴露了数据，我们前面说过，暴露数据造成的问题就在于数据的修改，进而导致出现难以预料的 Bug。在上面的代码中，我们把 setter 封装成一个个的函数，实际上是把不可控的修改限制在一个有限的范围内。那么，这个思路再进一步的话，如果我们的数据压根不让修改，犯下各种低级错误的机会就进一步降低了。没错，在这种思路下，可变数据（Mutable Data）就成了一种坏味道，这是 Martin Fowler 在新版《重构》里增加的坏味道，它反映着整个行业对于编程的新理解。解决可变数据，还有一个解决方案是编写不变类。函数式编程的不变性，其中的关键点就是设计不变类。Java 中的 String 类就是一个不变类，比如，如果我们把字符串中的一个字符替换成另一个字符，String 类给出的函数签名是这样的：String replace(char oldChar, char newChar);其含义是，这里的替换并不是在原有字符串上进行修改，而是产生了一个新的字符串。那么，在实际工作中，我们怎么设计不变类呢？要做到以下三点：所有的字段只在构造函数中初始化；所有的方法都是纯函数；如果需要有改变，返回一个新的对象，而不是修改已有字段。回过头来看我们之前改动的“用构造函数消除 setter”的代码，其实就是朝着这个方向在迈进。如果按照这个思路改造我们前面提到的 approve 函数，同样也可以：class Book { public Book approve() { return new Book(..., ReviewStatus.APPROVED, ...); }}这里，我们创建出了一个“其它参数和原有 book 对象一模一样，只是审核状态变成了 APPROVED ”的对象。在 JDK 的演化中，我们可以看到一个很明显的趋势，新增的类越来越多地采用了不变类的设计，比如，用来表示时间的类。原来的 Date 类里面还有各种 setter，而新增的 LocalDateTime 则一旦初始化就不会再修改了。如果要操作这个对象，则会产生一个新的对象：LocalDateTime twoDaysLater = now.plusDays(2);就目前的开发状态而言，想要完全消除可变数据是很难做到的，但我们可以尽可能地编写一些不变类。一个更实用的做法是，区分类的性质。我《软件设计之美》中讲 DDD 的战术设计时提到过，我们最核心要识别的对象分成两种，实体和值对象 。实体对象要限制数据变化，而值对象就要设计成不变类。如果你还想进一步提升自己对于不变性的理解，我们可以回到函数式编程这个编程范式的本质，它其实是对程序中的赋值进行了约束。基于这样的理解，连赋值本身其实都会被归入到坏味道的提示，这才是真正挑战很多人编程习惯的一点。Martin Fowler 在《重构》中还提到一个与数据相关的坏味道：全局数据（Global Data）。如果你能够理解可变数据是一种坏味道，全局数据也就很容易理解了，它们处理手法基本上是类似的，这里我就不再做过多的阐述了。10 | 变量声明与赋值分离：普通的变量声明，怎么也有坏味道？诚然，变量声明是写程序不可或缺的一部分，我并不打算让你戒掉变量声明，严格地说，我们是要把变量初始化这件事做好。1. 变量的初始化我们先来看一段代码：EpubStatus status = null;CreateEpubResponse response = createEpub(request);if (response.getCode() == 201) { status = EpubStatus.CREATED;} else { status = EpubStatus.TO_CREATE;}这段代码在做的事情是向另外一个服务发请求创建 EPUB（一种电子书格式），如果创建成功，返回值是 HTTP 的 201，也就表示创建成功，然后就把状态置为 CREATED；而如果没有成功，则把状态置为 TO_CREATE。后面对于 TO_CREATE 状态的作品，还需要再次尝试创建这里，我们暂且把是否要写 else 放下，这是我们在前面已经讨论过的一个坏味道。我们这次的重点在 status 这个变量上，虽然 status 这个变量在声明的时候，就赋上了一个 null 值，但实际上，这个值并没有起到任何作用，因为 status 的变量值，其实是在经过后续处理之后，才有了真正的值。换言之，从语义上说，第一行的变量初始化其实是没有用的，这是一次假的初始化按照我们通常的理解，一个变量的初始化是分成了声明和赋值两个部分，而我这里要说的就是，变量初始化最好一次性完成。这段代码里的变量赋值是在声明很久之后才完成的，也就是说，变量初始化没有一次性完成这种代码真正的问题就是不清晰，变量初始化与业务处理混在在一起。 通常来说，这种代码后面紧接着就是一大堆更复杂的业务处理。当代码混在一起的时候，我们必须小心翼翼地从一堆业务逻辑里抽丝剥茧，才能把逻辑理清，知道变量到底是怎么初始化的。很多代码难读，一个重要的原因就是把不同层面的代码混在了一起。这种代码在实际的代码库中出现的频率非常高，只不过，它会以各种变形的方式呈现出来。有的变量甚至是在相隔很远的地方才做了真正的赋值，完成了初始化，这中间已经夹杂了很多的业务代码在其中，进一步增加了理解的复杂度。所以，我们编程时要有一个基本原则：变量一次性完成初始化。有了这个理解，我们可以这样来修改上面这段代码：final CreateEpubResponse response = createEpub(request);final EpubStatus status = toEpubStatus(response);private EpubStatus toEpubStatus(final CreateEpubResponse response) { if (response.getCode() == 201) { return EpubStatus.CREATED; } return EpubStatus.TO_CREATE;}在这段改进的代码中，我们提取出了一个函数，将 response 转成对应的内部的 EPUB 状态。其实，很多人之所以这样写代码，一个重要的原因是很多人的编程习惯是从 C 语言来的。C 语言在早期的版本中，一个函数用到的变量必须在整个函数的一开始就声明出来。在 C 语言诞生的年代，当时计算机能力有限内存小，编译器技术也处于刚刚起步的阶段，把变量放在前面声明出来，有助于减小编译器编写的难度。到了 C++ 产生的年代，这个限制就逐步放开了，所以，C++ 程序是支持变量随用随声明的。对于今天的大多数程序设计语言来说，这个限制早就不存在了，但很多人的编程习惯却留在了那个古老的年代还有一点不知道你注意到了没有，在新的变量声明中，我加上了 final，在 Java 的语义中，一个变量加上了 final，也就意味着这个变量不能再次赋值。对，我们需要的正是这样的限制。上一讲，我们讲了可变的数据会带来怎样的影响，其中的一个结论是，尽可能编写不变的代码。这里其实是这个话题的延伸，尽可能使用不变的量。如果我们能够按照使用场景做一个区分，把变量初始化与业务处理分开，你会发现，在很多情况下，变量只在初始化完成之后赋值，就足以满足我们的需求了，在一段代码中，需要使用可变量的场景并不多。这个原则其实可以推广一下，在能够使用 final 的地方尽量使用 final，限制变量的赋值。这里说的“能够使用”，不仅包括普通的变量声明，还包含参数声明，还有类字段的声明，甚至还可以包括类和方法的声明。当然，我们这里改进的考量主要还是在变量上。你可以尝试着调整自己现有的代码，给变量声明都加上 final，你就会发现许多值得改进的代码。对于 Java 程序员来说，还有一个特殊的场景，就是异常处理的场景，强迫你把变量的声明与初始化分开，就像下面这段代码：InputStream is = null;try { is = new FileInputStream(...); ...} catch (IOException e) { ...} finally { if (is != null) { is.close(); }}之所以要把 InputStream 变量 is 单独声明，是为了能够在 finanlly 块里面访问到。其实，这段代码写成这样，一个重要的原因是 Java 早期的版本只能写成这样，而如果采用 Java 7 之后的版本，采用 try-with-resource 的写法，代码就可以更简洁了：try (InputStream is = new FileInputStream(...)) { ...}这样一来，InputStream 变量的初始化就一次性完成了，我们的原则就统一了，不需要在这种特殊的场景下纠结了。2.集合初始化接下来，我们在来看一段代码：List&lt;Permission&gt; permissions = new ArrayList&lt;&gt;();permissions.add(Permission.BOOK_READ);permissions.add(Permission.BOOK_WRITE);check.grantTo(Role.AUTHOR, permissions);这是一段给作者赋予作品读写权限的代码，逻辑比较简单，但这段代码中也存在一些坏味道。我们把注意力放在 permissions 这个集合上。之所以要声明这样一个 List，是因为 grantTo 方法要用到一个 List 作为参数。我们来看这个 List 是怎样生成的。这里先给 permission 初始化成了一个 ArrayList，这个时候，permissions 虽然存在了，但我们并不会把它传给 grantTo 方法，它还不能直接使用，因为它还缺少必要的信息。然后，我们将 BOOK_READ 和 BOOK_WRITE 两个枚举对象添加了进去，这样，这个 permissions 对象才是我们真正需要的那个对象。我们不难发现，其实 permissions 对象一开始的变量声明，并没有完成这个集合真正的初始化，只有当集合所需的对象添加完毕之后，这个集合才是它应有的样子。换言之，只有添加了元素的集合才是我们需要的。这样解释这段代码，你是不是就发现了，这和我们前面所说的变量先声明后赋值，本质上是一回事，都是从一个变量的声明到初始化成一个可用的状态，中间隔了太远的距离。之所以很多人习惯这么写，一个原因就是在早期的 Java 版本中，没有提供很好的集合初始化的方法。像这种代码，也是很多动态语言的支持者调侃 Java 啰嗦的一个靶子。现如今，Java 在这方面早已经改进了许多，各种程序库已经提供了一步到位的写法，我们先来看看 Java 9 之后的写法：List&lt;Permission&gt; permissions = List.of( Permission.BOOK_READ, Permission.BOOK_WRITE);check.grantTo(Role.AUTHOR, permissions);如果你的项目还没有升级 Java 9 之后的版本，使用 Guava（Google 提供的一个 Java 库）也是可以做成类似的效果：List&lt;Permission&gt; permissions = ImmutableList.of( Permission.BOOK_READ, Permission.BOOK_WRITE);check.grantTo(Role.AUTHOR, permissions);不知道你注意到没有，第二段代码里的 List 用的是一个 ImmutableList，也就是一个不可变的 List，实际上，你查看第一段代码的实现就会发现，它也是一个不变的 List。这是什么意思呢？也就是说，这个 List 一旦创建好了，就是不能修改了，对应的实现就是各种添加、删除之类的方法全部都禁用了。初看起来，这是限制了我们的能力，但我们对比一下代码就不难发现，很多时候，我们对于一个集合的使用，除了声明时添加元素之外，后续就只是把它当作一个只读的集合。所以，在很多情况下，一个不变集合对我们来说就够用了。其实，这段代码，相对来说还是比较清晰的，稍微再复杂一些的，集合的声明和添加元素之间隔了很远，不注意的话，甚至不觉得它们是在完成一次初始化。private static Map&lt;Locale, String&gt; CODE_MAPPING = new HashMap&lt;&gt;();...static { CODE_MAPPING.put(LOCALE.ENGLISH, \"EN\"); CODE_MAPPING.put(LOCALE.CHINESE, \"CH\");}这是一个传输时的映射方案，将不同的语言版本映射为不同的代码。这里 CODE_MAPPING 是一个类的 static 变量，而这个类的声明里还有其它一些变量。所以，隔了很远之后，才有一个 static 块向这个集合添加元素。如果我们能够用一次性声明的方式，这个单独的 static 块就是不需要的：private static Map&lt;Locale, String&gt; CODE_MAPPING = ImmutableMap.of( LOCALE.ENGLISH, \"EN\", LOCALE.CHINESE, \"CH\");对比我们改造前后的代码，二者之间还有一个更关键的区别：前面的代码是命令式的代码，而后面的代码是声明式的代码。命令式的代码，就是告诉你“怎么做”的代码，就像改造前的代码，声明一个集合，然后添加一个元素，再添加一个元素。而声明式的代码，是告诉你“做什么”的代码，改造后就是，我要一个包含了这两个元素的集合。所以，用声明式的标准来看代码，是一个发现代码坏味道的重要参考。回想一下今天讲的坏味道，无论是变量的声明与赋值分离，还是初始化一个集合的分步骤，其实反映的都是不同时代编程风格的烙印。变量的声明是 C 早期的编程风格，异常处理是 Java 早期的风格，而集合声明也体现出不同版本 Java 的影子。我们学习编程不仅仅是要学习实现功能，编程的风格也要与时俱进。如果今天的内容你只能记住一件事，那请记住：一次性完成变量的初始化。" }, { "title": "第2节 数据结构、前缀和、对数器", "url": "/posts/2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%AF%B9%E6%95%B0%E5%99%A8/", "categories": "算法, 左神新手班", "tags": "左神, 算法, 新手班", "date": "2022-08-09 23:14:00 +0800", "snippet": "什么是数据结构、组成各种数据结构最基本的元件数据结构分为两大类连续的数组类型跳转的链表类型链表结构方便删数据,不方便寻址数组方便寻址,不方便删数据前缀和数组问题引入:计算一个数组,某个范围内的累加和[3 4 2 1 6 7 8]算(2 -5) (1 - 3) (1 -6)累加和这种累加和计算很频繁有两种设计思路,都是预处理 设计一个二维表二维表下方表示的范围无意义例如寻找(2 - 5)的和...", "content": "什么是数据结构、组成各种数据结构最基本的元件数据结构分为两大类连续的数组类型跳转的链表类型链表结构方便删数据,不方便寻址数组方便寻址,不方便删数据前缀和数组问题引入:计算一个数组,某个范围内的累加和[3 4 2 1 6 7 8]算(2 -5) (1 - 3) (1 -6)累加和这种累加和计算很频繁有两种设计思路,都是预处理 设计一个二维表二维表下方表示的范围无意义例如寻找(2 - 5)的和,只需要查找L为2,R为5的值复杂度为$\\frac{n^2}{2}$ 因为一半的空间没有使用 用前缀和一维数组达到类似的效果[3 2 -1 6 7 2 -2 ]生成一个新数组,新数组里每一位代表从0到i位置的和[3 5 4 10 17 19 17]当查询(3-7)新数组的new_arr[7] -new_arr[2] L - R,当L = 0时,取值为 new_arr[R] 当L ≠ 0时,取值为 new_arr[R] - new_arr[L - 1]两种方案,各有优劣,当查询量很大时,可以忽略创建时间,方案一,直接返回值更快,方案二还需要计算public class Code01_PreSum {\tpublic static class RangeSum1 {\t\tprivate int[] arr;\t\tpublic RangeSum1(int[] array) {\t\t\tarr = array;\t\t}\t\tpublic int rangeSum(int L, int R) {\t\t\tint sum = 0;\t\t\tfor (int i = L; i &lt;= R; i++) {\t\t\t\tsum += arr[i];\t\t\t}\t\t\treturn sum;\t\t}\t}\tpublic static class RangeSum2 {\t\tprivate int[] preSum;\t\tpublic RangeSum2(int[] array) {\t\t\tint N = array.length;\t\t\tpreSum = new int[N];\t\t\tpreSum[0] = array[0];\t\t\tfor (int i = 1; i &lt; N; i++) {\t\t\t\tpreSum[i] = preSum[i - 1] + array[i];\t\t\t}\t\t}\t\tpublic int rangeSum(int L, int R) {\t\t\treturn L == 0 ? preSum[R] : preSum[R] - preSum[L - 1];\t\t}\t}}随机函数public class Code02_RandToRand { // Math.random() 默认返回的时Double类型的[0,1)\t// 此函数只能用，不能修改\t// 等概率返回1~5\tpublic static int f() {\t\treturn (int) (Math.random() * 5) + 1;\t}\t// 等概率得到0和1\tpublic static int a() {\t\tint ans = 0;\t\tdo {\t\t\tans = f();\t\t} while (ans == 3);\t\treturn ans &lt; 3 ? 0 : 1;\t}\t// 等概率返回0~6\t// 这个本质上就是看一想要的最大值是几位二进制组成的,每一位上等概率返回01\t// 第一次调用返回的是第三位上的值,所以要左移两位\tpublic static int b() {\t\tint ans = 0;\t\tdo {\t\t\tans = (a() &lt;&lt; 2) + (a() &lt;&lt; 1) + a();\t\t} while (ans == 7);\t\treturn ans;\t}\t// 等概率返回1~7\tpublic static int c() {\t\treturn b() + 1;\t}\t// 这个结构是唯一的随机机制\t// 你只能初始化并使用，不可修改\tpublic static class RandomBox {\t\tprivate final int min;\t\tprivate final int max;\t\t// 初始化时请一定不要让mi==ma\t\tpublic RandomBox(int mi, int ma) {\t\t\tmin = mi;\t\t\tmax = ma;\t\t}\t\t// 13 ~ 17\t\t// 13 + [0,4]\t\tpublic int random() {\t\t\treturn min + (int) (Math.random() * (max - min + 1));\t\t}\t\tpublic int min() {\t\t\treturn min;\t\t}\t\tpublic int max() {\t\t\treturn max;\t\t}\t}\t// 利用条件RandomBox，如何等概率返回0和1\tpublic static int rand01(RandomBox randomBox) {\t\tint min = randomBox.min();\t\tint max = randomBox.max();\t\t// min ~ max\t\tint size = max - min + 1;\t\t// size是不是奇数，odd 奇数\t\tboolean odd = (size &amp; 1) != 0;\t\tint mid = size / 2;\t\tint ans = 0;\t\tdo {\t\t\tans = randomBox.random() - min;\t\t} while (odd &amp;&amp; ans == mid);\t\treturn ans &lt; mid ? 0 : 1;\t}\t// 给你一个RandomBox，这是唯一能借助的随机机制\t// 等概率返回from~to范围上任何一个数\t// 要求from&lt;=to\tpublic static int random(RandomBox randomBox, int from, int to) {\t\tif (from == to) {\t\t\treturn from;\t\t}\t\t// 3 ~ 9\t\t// 0 ~ 6\t\t// 0 ~ range\t\tint range = to - from;\t\tint num = 1;\t\t// 求0～range需要几个2进制位\t\twhile ((1 &lt;&lt; num) - 1 &lt; range) {\t\t\tnum++;\t\t}\t\t// 我们一共需要num位\t\t// 最终的累加和，首先+0位上是1还是0，1位上是1还是0，2位上是1还是0...\t\tint ans = 0;\t\tdo {\t\t\tans = 0;\t\t\tfor (int i = 0; i &lt; num; i++) {\t\t\t\tans |= (rand01(randomBox) &lt;&lt; i);\t\t\t}\t\t} while (ans &gt; range);\t\treturn ans + from;\t}\tpublic static void main(String[] args) {\t\tSystem.out.println(\"测试开始\");\t\t// Math.random() -&gt; double -&gt; [0,1)\t\t//\t\tint testTimes = 10000000;\t\tint count = 0;\t\tfor (int i = 0; i &lt; testTimes; i++) {\t\t\tif (Math.random() &lt; 0.75) {\t\t\t\tcount++;\t\t\t}\t\t}\t\tSystem.out.println((double) count / (double) testTimes);\t\tSystem.out.println(\"=========\");\t\t// [0,1) -&gt; [0,8)\t\tcount = 0;\t\tfor (int i = 0; i &lt; testTimes; i++) {\t\t\tif (Math.random() * 8 &lt; 5) {\t\t\t\tcount++;\t\t\t}\t\t}\t\tSystem.out.println((double) count / (double) testTimes);\t\tSystem.out.println((double) 5 / (double) 8);\t\tint K = 9;\t\t// [0,K) -&gt; [0,8]\t\tint[] counts = new int[9];\t\tfor (int i = 0; i &lt; testTimes; i++) {\t\t\tint ans = (int) (Math.random() * K); // [0,K-1]\t\t\tcounts[ans]++;\t\t}\t\tfor (int i = 0; i &lt; K; i++) {\t\t\tSystem.out.println(i + \"这个数，出现了 \" + counts[i] + \" 次\");\t\t}\t\tSystem.out.println(\"=========\");\t\tcount = 0;\t\tdouble x = 0.17;\t\tfor (int i = 0; i &lt; testTimes; i++) {\t\t\tif (xToXPower2() &lt; x) {\t\t\t\tcount++;\t\t\t}\t\t}\t\tSystem.out.println((double) count / (double) testTimes);\t\tSystem.out.println((double) 1 - Math.pow((double) 1 - x, 2));\t\tSystem.out.println(\"==========\");\t\tcount = 0;\t\tfor (int i = 0; i &lt; testTimes; i++) {\t\t\tif (f2() == 0) {\t\t\t\tcount++;\t\t\t}\t\t}\t\tSystem.out.println((double) count / (double) testTimes);\t\tSystem.out.println(\"==========\");\t\tcounts = new int[8];\t\tfor (int i = 0; i &lt; testTimes; i++) {\t\t\tint num = g();\t\t\tcounts[num]++;\t\t}\t\tfor (int i = 0; i &lt; 8; i++) {\t\t\tSystem.out.println(i + \"这个数，出现了 \" + counts[i] + \" 次\");\t\t}\t}\t// 返回[0,1)的一个小数\t// 任意的x，x属于[0,1)，[0,x)范围上的数出现概率由原来的x调整成x平方\tpublic static double xToXPower2() {\t\treturn Math.min(Math.random(), Math.random());\t}\t// lib里的，不能改！\tpublic static int f1() {\t\treturn (int) (Math.random() * 5) + 1;\t}\t// 随机机制，只能用f1，\t// 等概率返回0和1\tpublic static int f2() {\t\tint ans = 0;\t\tdo {\t\t\tans = f1();\t\t} while (ans == 3);\t\treturn ans &lt; 3 ? 0 : 1;\t}\t// 得到000 ~ 111 做到等概率 0 ~ 7等概率返回一个\tpublic static int f3() {\t\treturn (f2() &lt;&lt; 2) + (f2() &lt;&lt; 1) + f2();\t}\t// 0 ~ 6等概率返回一个\tpublic static int f4() {\t\tint ans = 0;\t\tdo {\t\t\tans = f3();\t\t} while (ans == 7);\t\treturn ans;\t}\tpublic static int g() {\t\treturn f4() + 1;\t}\t// 你只能知道，x会以固定概率返回0和1，但是x的内容，你看不到！\tpublic static int x() {\t\treturn Math.random() &lt; 0.84 ? 0 : 1;\t}\t// 等概率返回0和1\tpublic static int y() {\t\tint ans = 0;\t\tdo {\t\t\tans = x();\t\t} while (ans == x());\t\treturn ans;\t}}对数器的使用题目：实现前缀和数组如何用1~5的随机函数加工出1~7的随机函数如何用a~b的随机函数加工出c~d的随机函数展示对数器的使用如何把不等概率随机函数变成等概率随机函数" }, { "title": "计算机网络面试核心", "url": "/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/", "categories": "面试, JAVA面试茶话会", "tags": "面试, 计算机网络", "date": "2022-08-01 20:17:00 +0800", "snippet": "网络基础知识讲解开放系统互联参考模型OSI7层第一层:物理层首先解决两台机器之间的通信,a往b发送比特流,b能接收到比特流网卡工作在这一层第二层:数据链路层物理层在传输过程中可能会错传,数据不完整为了解决这个问题,就要在数据链路层定义如何格式化数据,错误检测和纠正,保证传输可靠性本层将比特流组成帧,交换机工作在这一层对帧解码,根据其中信息发送给正确的接受方第三层:网络层随着节点的增加,消息会...", "content": "网络基础知识讲解开放系统互联参考模型OSI7层第一层:物理层首先解决两台机器之间的通信,a往b发送比特流,b能接收到比特流网卡工作在这一层第二层:数据链路层物理层在传输过程中可能会错传,数据不完整为了解决这个问题,就要在数据链路层定义如何格式化数据,错误检测和纠正,保证传输可靠性本层将比特流组成帧,交换机工作在这一层对帧解码,根据其中信息发送给正确的接受方第三层:网络层随着节点的增加,消息会通过多个节点到达另一个节点这时就需要选择最佳路径,于是出现网络层主要功能就是将网络地址翻译为物理地址,并决定如何将数据从发送方路由到接受方网络层通过综合考虑发送优先权,网络阻塞程度,以及可选路由的花费,来决定一个网络节点b的最佳路径路由器连接各个网段,工作在网络层此时的数据称为数据包本层有IP协议第四层:传输层随着传输大量数据过程中,存在网络中断问题,解决办法就是将数据进行切分,切成一个一个段落,即Segment发送,发送过程中某个Segment丢失,不按顺序到达,要怎么处理,就是传输层要考虑的事情传输层解决了传输质量的问题,是OSI传输过程中最重要的一层传输层需要关注的协议有TCP协议和UDP协议以太网内无法接收大于1500字节的数据包第五层:会话层有了传输层以后,存在一个问题,就是每次TCP连接都要自己去切分,调用IP去找路由,太麻烦,于是有了会话层,建立和管理应用程序之间的通信第六层:表示层有了会话层后存在一个问题,不同类型的操作系统之间的通信语法不同,就需要按照网络能理解的方案进行格式化第七层:应用层有了表示层,此时存在一个问题,格式化后的数据,发送方能明白但接受方还不知道,此时就需要应用层,规定发送方和接收方必须使用一个固定长度的消息头,而且消息头里必须记录消息体的长度等一系列信息以方便接收方能够正确的解析这一层需要重点关注 HTTP 协议OSI和TCP/IP的对比tcp ip泛指这些协议 有时也称tcpip为网际协议群TCP/IP协议处理数据流程TCP的三次握手_1IP协议是无连接的通信协议因此不会占用两个正在通信的计算机之间的通信,降低了对网络线路的需求IP负责将每个包路由到目的地,但没有做任何事情去确认数据包是否按顺序发送,或者包被破坏所以IP数据包不可靠TCP 英文名称 transmission control protocol是一种面向连接的可靠的基于字节流的传输层通信协议数据传输时应用层向TCP发送数据流然后TCP把数据流分割成适当长度的报文段报文段的长度通常受该计算机连接的网络的数据流程最大传输单元即MTU的限制之后结果穿给IP层,通过网络将包传送给目标节点的TCP层TCP为了保证不丢包,给每个包一个序号即 sequence number序号也保证传送到目标节点的包的按序处理接收端实体对已成功收到的包发回一个相应的确认,即ACK确认如果在合理的往返时延即RTT内未收到确认,那么对应数据包假设已丢失,会进行重传TCP用奇偶校验函数来检验数据是否有错误,发送和接受都要计算校验和TCP报文的头部第一行 source port和destination port 分别表示原端口和目的端口TCP与UDP都不包含IP信息的,因为是IP层的事TCP的三次握手_2TCP的四次挥手TCP和UDP的区别TCP的滑窗HTTP相关HTTP相关_2HTTP和HTTPS的区别socket相关网络知识总结" }, { "title": "Python基础", "url": "/posts/python%E5%9F%BA%E7%A1%80/", "categories": "", "tags": "Python, AI", "date": "2022-07-31 11:14:00 +0800", "snippet": "第1章 计算机组成原理1-1 计算机原理01 计算机组成02 Python简介第2章 python基础语法2-1 课程介绍03 课程介绍2-2 注释04 注释2-3 变量05 变量的作用06 定义变量07 使用变量2-4 bug认识08 认识bug09 Debug工具2-5 数据类型10 认识数据类型2-6 输出11 输出 认识格式化符号12 输出 格式化符号基础使用方法13 输出 格式化符...", "content": "第1章 计算机组成原理1-1 计算机原理01 计算机组成02 Python简介第2章 python基础语法2-1 课程介绍03 课程介绍2-2 注释04 注释2-3 变量05 变量的作用06 定义变量07 使用变量2-4 bug认识08 认识bug09 Debug工具2-5 数据类型10 认识数据类型2-6 输出11 输出 认识格式化符号12 输出 格式化符号基础使用方法13 输出 格式化符号高级使用方法14 输出 拓展格式化字符串15 输出 f-格式化字符串16 输出 转义字符17 输出 print结束符2-7 输入01 了解输入02 输入功能实现2-8 数据类型转换03 体验数据类型转换04 数据类型转换函数2-9 运算符05 运算符的分类06 算数运算符07 赋值运算符08 复合赋值运算符09 复合赋值注意点10 比较运算符11 逻辑运算符第3章 判断语句3-1 判断语句介绍12 if的作用和语法3-2 if基本格式13 体验if14 网吧上网（进阶版）15 网吧上网（简单版）3-3 if…elif…else格式16 if else17 if语句执行流程18 多重判断的作用和语法19 体验多重判断20 elif的执行流程3-4 if嵌套21 if嵌套的作用和语法22 if嵌套案例-判断能否上车23 if嵌套案例-判断是否能坐下3-5 案例猜拳游戏24 猜拳游戏的步骤分析25 猜拳游戏功能实现(1)25 猜拳游戏功能实现26 随机数27 猜拳游戏-随机数28 三目运算符第4章 循环语句4-1 循环语句介绍01 了解循环4-2 while循环02 while的语法和体验03 计数器书写习惯04 循环的执行流程4-3 循环应用05 循环应用 1-100累加06 循环应用 1-100偶数累加和方法107 循环应用 1-100偶数累加和方法208 循环的注意事项4-4 break和continue09 了解break和continue10 break11 continue4-5 while循环嵌套及应用12 while循环嵌套的作用和语法13 while循环嵌套快速体验14 循环的执行流程15 while循环嵌套应用之打印星号（正方形）16 while循环嵌套应用之打印星号（三角形）17 while循环嵌套应用之九九乘法表4-6 for循环18 for循环语法和体验19 break退出for循环20 continue退出for循环4-7 循环else应用21 循环的else简介22 while else23 while else之break24 while else之continue25 for else第5章 字符串5-1 字符串介绍27 认识字符串5-2 输入输出28 字符串输出29 字符串输入5-3 切片01 字符串下标02 切片简介03 体验切片5-4 字符串操作方法04 字符串常用操作方法之查找05 字符串常用操作方法之修改06 字符串常用操作方法之修改之大小写转换07 字符串常用操作方法之修改之删除空白字符08 字符串常用操作方法之修改之字符串对齐09 字符串常用操作方法之判断开头或结尾10 字符串常用操作方法之判断第6章 列表6-1 列表相关操作11 下标12 查找函数13 判断是否存在14 体验案例-判断是否存在15 列表增加数据之append16 列表增加数据之extend17 列表增加数据之insert18 列表删除数据19 列表修改数据20 列表复制数据6-2 列表循环遍历21 列表的遍历之while22 列表的遍历之for6-3 列表嵌套23 列表嵌套24 随机分配办公室的步骤分析25 随机分配办公室的实现代码第7章 元组7-1 元组相关操作26 体验元组27 定义元组28 元组常见操作之查找29 元组数据的修改操作第8章 字典8-1 字典介绍01 字典的应用场景8-2 字典的常见操作02 创建字典的语法03 字典常用操作之新增04 字典常用操作之删除05 字典常用操作之修改06 字典常用操作之查找8-3 字典遍历07 字典的循环遍历之key08 字典的循环遍历之value09 字典的循环遍历之键值对10 字典的循环遍历之键值对（拆包）第9章 集合9-1 集合的相关操作11 创建集合12 集合常见操作之增加数据13 集合常见操作之删除数据14 集合常见操作之查找数据第10章 公共方法10-1 公共方法15 公共操作之运算符加号16 公共操作之运算符乘号17 公共操作之运算符判断数据是否存在18 公共方法之len19 公共方法之del20 公共方法之max和min21 公共方法之range22 公共方法之enumerate23 容器类型转换24 while循环创建有规律的列表25 for循环创建有规律的列表10-2 推导式26 体验列表推导式27 带if的列表推导式28 多for实现列表推导式29 体验字典推导式30 合并两个列表为字典31 提取字典中目标数据32 集合第11章 函数11-1 函数介绍01 函数的使用步骤02 快速体验函数03 函数的注意事项11-2 函数参数104 函数的参数的作用11-3 函数返回值105 体验函数返回值06 return的特点07 函数返回值的应用11-4 函数文档说明08 函数的说明文档11-5 函数嵌套09 函数嵌套调用10 函数嵌套调用应用之打印横线图形0111 函数嵌套调用应用之打印横线图形0212 函数嵌套调用应用之函数计算0113 函数嵌套调用应用之函数计算0211-6 局部变量14 局部变量11-7 全局变量15 访问全局变量16 修改全局变量11-8 函数执行流程17 多函数执行流程11-9 函数返回值218 返回值作为参数传递19 函数的返回值11-10 函数参数220 函数参数之位置参数21 关键字参数22 缺省参数23 不定长参数之位置参数24 不定长参数之关键字参数11-11 拆包,交换变量25 元组拆包26 字典拆包27 交换变量的值之方法一28 交换变量的值之方法二11-12 引用29 了解引用之不可变类型30 了解引用之可变类型31 引用当做实参传入32 可变和不可变类型第12章 函数强化12-1 函数应用学员管理系统01 学员管理系统需求和步骤分析02 学员管理系统框架搭建03 代码调优04 学员管理系统数据形式的分析05 添加学员功能分析06 添加学员之用户输入07 添加学员之新增数据08 添加学员之重名提示09 删除学员思路分析10 删除学员代码实现12-2 课后练习(学员管理系统)课后学习-11 修改学员思路分析课后学习-12 修改学员代码实现课后学习-13 查询学员思路分析课后学习-14 查询学员代码实现课后学习-15 显示所有学员信息课后学习-16 退出系统12-3 递归函数17 了解递归18 递归之回顾函数返回值19 递归代码实现20 递归的执行流程21 递归出口问题12-4 匿名函数22 了解lambda23 体验lambda24 lambda实例之计算两个数字累加和25 lambda参数之无参数26 lambda参数之一个参数27 lambda参数之默认参数28 lambda参数之args29 lambda参数之kwargs30 lambda应用之带判断的lambda12-5 高阶函数31 列表内字典数据排序32 abs和round33 体验高阶函数的思路分析34 体验高阶函数的代码实现35 内置高阶函数之map36 内置高阶函数之reduce37 内置高阶函数之filter第13章 文件操作13-1 文件操作介绍01 了解文件操作13-2 文件读写操作02 体验文件操作步骤03 访问模式特点0104 读取函数之read05 读取函数之readlines06 读取函数之readline07 访问模式特点0208 访问模式特点02之代码测试09 seek函数13-3 案例 文件备份10 文件备份思路分析11 文件备份之接收用户输入12 文件备份之规划文件名13 文件备份之数据写入13-4 文件及文件夹的相关操作15 文件操作函数16 文件夹操作函数之创建和删除17 文件夹操作函数之路径相关函数17-2 文件夹操作函数之rename18 批量重命名之添加字符串19 批量重命名之添加和删除字符串第14章 面向对象14-1 面向对象介绍20 了解面向对象21 了解类和对象的关系14-2 类和对象22 类和对象的语法23 体验类和对象24 类里面的self25 一个类创建多个对象14-3 对象属性操作26 类外面添加对象属性27 类外面获取对象属性28 类里面获取对象属性14-4 魔法方法01 体验魔法方法init02 带参数的init代码书写03 魔法方法str04 魔法方法del14-5 案例 烤地瓜05 了解烤地瓜案例需求06 烤地瓜案例步骤分析07 烤地瓜init方法08 烤地瓜方法cook09 烤地瓜案例魔法方法str10 创建对象测试属性和方法11 烤地瓜添加调料14-6 案例 搬家具12 搬家具需求和步骤分析13 搬家具之家具类14 搬家具之房屋类15 搬家具之添加容纳家具思路分析16 搬家具之容纳家具函数17 面向对象基础部分总结14-7 继承18 体验继承19 单继承20 多继承14-8 子类重写父类属性和方法21 子类重写父类同名属性和方法22 拓展-mro顺序23 子类调用父类同名方法和属性之思路分析24 子类调用父类同名方法和属性之代码实现14-9 super方法使用25 多层继承26 super()方法作用27 super方法写法14-10 私有属性和方法28 定义私有属性和方法29 获取和修改私有属性值14-11 多态01 了解多态02 体验多态思路分析03 代码实现多态14-12 类属性及相关方法04 设置和访问类属性05 修改类属性06 类方法07 静态方法第15章 异常15-1 异常介绍08 了解异常09 体验异常10 了解异常类型15-2 捕获异常11 捕获指定异常类型12 捕获多个指定异常类型13 捕获异常描述信息14 捕获所有异常15 异常的else16 异常的finally17 拓展命令提示符运行py文件15-3 异常传递18 异常传递的思路分析19 异常传递的代码实现15-4 自定义异常20 自定义异常的作用21 自定义异常思路分析22 自定义异常代码实现之异常类23 自定义异常代码实现之捕获异常第16章 模块16-1 模块介绍01 了解模块02 导入模块之方法一03 导入模块之方法二03 导入模块之方法二.pcwlenv04 导入模块之方法三05 定义别名16-2 模块制作06 了解制作模块07 制作模块之定义模块08 制作模块之测试和调用模块09 了解模块定位顺序10 模块定位顺序之注意点111 模块定位顺序之注意点212 拓展-名字重复的严重性13 all列表16-3 python中的包14 了解包15 制作包16 导入包之方法一17 导入包之方法二第17章 学生管理系统(面向对象版)17-1 学生管理系统(面向对象)18 介绍系统需求19 准备程序文件20 定义学员类21 了解管理系统的需求22 定义管理系统类23 管理系统框架需求和步骤24 管理系统框架之程序入口函数25 管理系统框架之定义系统功能函数26 程序入口文件功能实现27 添加学员功能课后学习-28 删除学员功能课后学习-29 修改学员信息课后学习-30 查询学员信息课后学习-31 显示所有学员信息课后学习-32 保存学员信息需求和注意事项课后学习-33 拓展-dict课后学习-34 保存学员信息课后学习-35 加载学员信息思路课后学习-36 加载学员信息" }, { "title": "JUC并发编程与源码分析", "url": "/posts/juc%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/", "categories": "", "tags": "JUC, 并发编程", "date": "2022-07-30 15:06:00 +0800", "snippet": "一、线程基础1、Java多线程相关概念1、进程是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。进程具有的特征： 动态性：进程是程序的一次执行过程，是临时的，有生命期...", "content": "一、线程基础1、Java多线程相关概念1、进程是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。进程具有的特征： 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的 并发性：任何进程都可以同其他进行一起并发执行 独立性：进程是系统进行资源分配和调度的一个独立单位 结构性：进程由程序，数据和进程控制块三部分组成我们经常使用windows系统，经常会看见.exe后缀的文件，双击这个.exe文件的时候，这个文件中的指令就会被系统加载，那么我们就能得到一个关于这个.exe程序的进程。进程是“活”的，或者说是正在被执行的。2、线程在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程 ⼀个进程会有1个或多个线程的线程是轻量级的进程，是程序执行的最小单元，使用多线程而不是多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。3、进程与线程的一个简单解释进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。4.一个车间里，可以有很多工人。他们协同完成一个任务。5.线程就好比车间里的工人。一个进程可以包括多个线程。6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。11.操作系统的设计，因此可以归结为三点：（1）以多进程形式，允许多个任务同时运行；（2）以多线程形式，允许单个任务分成不同的部分运行；（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。4、管程Monitor(监视器)，也就是我们平时所说的锁// Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。// JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，Object o = new Object();new Thread(() -&gt; { synchronized (o) { }},\"t1\").start();// Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。5、线程状态？// Thread.Statepublic enum State { NEW,(新建) RUNNABLE,（准备就绪） BLOCKED,（阻塞） WAITING,（不见不散） TIMED_WAITING,（过时不候） TERMINATED;(终结)}线程几个状态的介绍： New：表示刚刚创建的线程，这种线程还没有开始执行 RUNNABLE：运行状态，线程的start()方法调用后，线程会处于这种状态 BLOCKED：阻塞状态。当线程在执行的过程中遇到了synchronized同步块，但这个同步块被其他线程已获取还未释放时，当前线程将进入阻塞状态，会暂停执行，直到获取到锁。当线程获取到锁之后，又会进入到运行状态（RUNNABLE） WAITING：等待状态。和TIME_WAITING都表示等待状态，区别是WAITING会进入一个无时间限制的等，而TIME_WAITING会进入一个有限的时间等待，那么等待的线程究竟在等什么呢？一般来说，WAITING的线程正式在等待一些特殊的事件，比如，通过wait()方法等待的线程在等待notify()方法，而通过join()方法等待的线程则会等待目标线程的终止。一旦等到期望的事件，线程就会再次进入RUNNABLE运行状态。 TERMINATED：表示结束状态，线程执行完毕之后进入结束状态。注意：从NEW状态出发后，线程不能在回到NEW状态，同理，处理TERMINATED状态的线程也不能在回到RUNNABLE状态6、wait/sleep的区别？功能都是当前线程暂停，有什么区别？wait放开手去睡，放开手里的锁sleep握紧手去睡，醒了手里还有锁2、线程的基本操作1、新建线程新建线程很简单。只需要使用new关键字创建一个线程对象，然后调用它的start()启动线程即可。Thread thread1 = new Thread1();t1.start();那么线程start()之后，会干什么呢？线程有个run()方法，start()会创建一个新的线程并让这个线程执行run()方法。这里需要注意，下面代码也能通过编译，也能正常执行。但是，却不能新建一个线程，而是在当前线程中调用run()方法，将run方法只是作为一个普通的方法调用。Thread thread = new Thread1();thread1.run();所以，希望大家注意，调用start方法和直接调用run方法的区别。start方法是启动一个线程，run方法只会在垫钱线程中串行的执行run方法中的代码。默认情况下， 线程的run方法什么都没有，启动一个线程之后马上就结束了，所以如果你需要线程做点什么，需要把您的代码写到run方法中，所以必须重写run方法。Thread thread1 = new Thread() { @Override public void run() { System.out.println(\"hello,我是一个线程!\"); }};thread1.start();上面是使用匿名内部类实现的，重写了Thread的run方法，并且打印了一条信息。 我们可以通过继承Thread类，然后重写run方法，来自定义一个线程。 但考虑java是单继承的，从扩展性上来说，我们实现一个接口来自定义一个线程更好一些，java中刚好提供了Runnable接口来自定义一个线程。@FunctionalInterfacepublic interface Runnable { public abstract void run();}Thread类有一个非常重要的构造方法：public Thread(Runnable target)我们在看一下Thread的run方法：public void run() { if (target != null) { target.run(); }}当我们启动线程的start方法之后，线程会执行run方法，run方法中会调用Thread构造方法传入的target的run方法。实现Runnable接口是比较常见的做法，也是推荐的做法。2、终止线程一般来说线程执行完毕就会结束，无需手动关闭。但是如果我们想关闭一个正在运行的线程，有什么方法呢？可以看一下Thread类中提供了一个stop()方法，调用这个方法，就可以立即将一个线程终止，非常方便。import lombok.extern.slf4j.Slf4j;import java.util.concurrent.TimeUnit;@Slf4jpublic class Demo01 { public static void main(String[] args) throws InterruptedException { Thread thread1 = new Thread() { @Override public void run() { log.info(\"start\"); boolean flag = true; while (flag) { ; } log.info(\"end\"); } }; thread1.setName(\"thread1\"); thread1.start(); //当前线程休眠1秒 TimeUnit.SECONDS.sleep(1); //关闭线程thread1 thread1.stop(); //输出线程thread1的状态 log.info(\"{}\", thread1.getState()); //当前线程休眠1秒 TimeUnit.SECONDS.sleep(1); //输出线程thread1的状态 log.info(\"{}\", thread1.getState()); }}运行代码，输出：18:02:15.312 [thread1] INFO com.itsoku.chat01.Demo01 - start18:02:16.311 [main] INFO com.itsoku.chat01.Demo01 - RUNNABLE18:02:17.313 [main] INFO com.itsoku.chat01.Demo01 - TERMINATED代码中有个死循环，调用stop方法之后，线程thread1的状态变为TERMINATED（结束状态），线程停止了。我们使用idea或者eclipse的时候，会发现这个方法是一个废弃的方法，也就是说，在将来，jdk可能就会移除该方法。stop方法为何会被废弃而不推荐使用？stop方法过于暴力，强制把正在执行的方法停止了。大家是否遇到过这样的场景：电力系统需要维修，此时咱们正在写代码，维修人员直接将电源关闭了，代码还没保存的，是不是很崩溃，这种方式就像直接调用线程的stop方法类似。线程正在运行过程中，被强制结束了，可能会导致一些意想不到的后果。可以给大家发送一个通知，告诉大家保存一下手头的工作，将电脑关闭。3、线程中断在java中，线程中断是一种重要的线程写作机制，从表面上理解，中断就是让目标线程停止执行的意思，实际上并非完全如此。在上面中，我们已经详细讨论了stop方法停止线程的坏处，jdk中提供了更好的中断线程的方法。严格的说，线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出了！至于目标线程接收到通知之后如何处理，则完全由目标线程自己决定，这点很重要，如果中断后，线程立即无条件退出，我们又会到stop方法的老问题。Thread提供了3个与线程中断有关的方法，这3个方法容易混淆，大家注意下：public void interrupt() //中断线程public boolean isInterrupted() //判断线程是否被中断public static boolean interrupted() //判断线程是否被中断，并清除当前中断状态interrupt()方法是一个实例方法，它通知目标线程中断，也就是设置中断标志位为true，中断标志位表示当前线程已经被中断了。isInterrupted()方法也是一个实例方法，它判断当前线程是否被中断（通过检查中断标志位）。最后一个方法interrupted()是一个静态方法，返回boolean类型，也是用来判断当前线程是否被中断，但是同时会清除当前线程的中断标志位的状态。while (true) { if (this.isInterrupted()) { System.out.println(\"我要退出了!\"); break; } } }};thread1.setName(\"thread1\");thread1.start();TimeUnit.SECONDS.sleep(1);thread1.interrupt();上面代码中有个死循环，interrupt()方法被调用之后，线程的中断标志将被置为true，循环体中通过检查线程的中断标志是否为ture（this.isInterrupted()）来判断线程是否需要退出了。再看一种中断的方法：static volatile boolean isStop = false;public static void main(String[] args) throws InterruptedException { Thread thread1 = new Thread() { @Override public void run() { while (true) { if (isStop) { System.out.println(\"我要退出了!\"); break; } } } }; thread1.setName(\"thread1\"); thread1.start(); TimeUnit.SECONDS.sleep(1); isStop = true;}代码中通过一个变量isStop来控制线程是否停止。通过变量控制和线程自带的interrupt方法来中断线程有什么区别呢？如果一个线程调用了sleep方法，一直处于休眠状态，通过变量控制，还可以中断线程么？大家可以思考一下。此时只能使用线程提供的interrupt方法来中断线程了。public static void main(String[] args) throws InterruptedException { Thread thread1 = new Thread() { @Override public void run() { while (true) { //休眠100秒 try { TimeUnit.SECONDS.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"我要退出了!\"); break; } } }; thread1.setName(\"thread1\"); thread1.start(); TimeUnit.SECONDS.sleep(1); thread1.interrupt();}调用interrupt()方法之后，线程的sleep方法将会抛出InterruptedException异常。Thread thread1 = new Thread() { @Override public void run() { while (true) { //休眠100秒 try { TimeUnit.SECONDS.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } if (this.isInterrupted()) { System.out.println(\"我要退出了!\"); break; } } }};运行上面的代码，发现程序无法终止。为什么？代码需要改为：Thread thread1 = new Thread() { @Override public void run() { while (true) { //休眠100秒 try { TimeUnit.SECONDS.sleep(100); } catch (InterruptedException e) { this.interrupt(); e.printStackTrace(); } if (this.isInterrupted()) { System.out.println(\"我要退出了!\"); break; } } }};上面代码可以终止。注意：sleep方法由于中断而抛出异常之后，线程的中断标志会被清除（置为false），所以在异常中需要执行this.interrupt()方法，将中断标志位置为true4、等待（wait）和通知（notify）为了支持多线程之间的协作，JDK提供了两个非常重要的方法：等待wait()方法和通知notify()方法。这2个方法并不是在Thread类中的，而是在Object类中定义的。这意味着所有的对象都可以调用者两个方法。public final void wait() throws InterruptedException;public final native void notify();当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。这是什么意思？比如在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。等待到什么时候结束呢？线程A会一直等到其他线程调用obj.notify()方法为止，这时，obj对象成为了多个线程之间的有效通信手段。那么wait()方法和notify()方法是如何工作的呢？如图2.5展示了两者的工作过程。如果一个线程调用了object.wait()方法，那么它就会进出object对象的等待队列。这个队列中，可能会有多个线程，因为系统可能运行多个线程同时等待某一个对象。当object.notify()方法被调用时，它就会从这个队列中随机选择一个线程，并将其唤醒。这里希望大家注意一下，这个选择是不公平的，并不是先等待线程就会优先被选择，这个选择完全是随机的。除notify()方法外，Object独享还有一个nofiyAll()方法，它和notify()方法的功能类似，不同的是，它会唤醒在这个等待队列中所有等待的线程，而不是随机选择一个。这里强调一点，Object.wait()方法并不能随便调用。它必须包含在对应的synchronize语句汇总，无论是wait()方法或者notify()方法都需要首先获取目标独享的一个监视器。图2.6显示了wait()方法和nofiy()方法的工作流程细节。其中T1和T2表示两个线程。T1在正确执行wait()方法钱，必须获得object对象的监视器。而wait()方法在执行后，会释放这个监视器。这样做的目的是使其他等待在object对象上的线程不至于因为T1的休眠而全部无法正常执行。线程T2在notify()方法调用前，也必须获得object对象的监视器。所幸，此时T1已经释放了这个监视器，因此，T2可以顺利获得object对象的监视器。接着，T2执行了notify()方法尝试唤醒一个等待线程，这里假设唤醒了T1。T1在被唤醒后，要做的第一件事并不是执行后续代码，而是要尝试重新获得object对象的监视器，而这个监视器也正是T1在wait()方法执行前所持有的那个。如果暂时无法获得，则T1还必须等待这个监视器。当监视器顺利获得后，T1才可以在真正意义上继续执行。给大家上个例子：public class Demo06 { static Object object = new Object(); public static class T1 extends Thread { @Override public void run() { synchronized (object) { System.out.println(System.currentTimeMillis() + \":T1 start!\"); try { System.out.println(System.currentTimeMillis() + \":T1 wait for object\"); object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(System.currentTimeMillis() + \":T1 end!\"); } } } public static class T2 extends Thread { @Override public void run() { synchronized (object) { System.out.println(System.currentTimeMillis() + \":T2 start，notify one thread! \"); object.notify(); System.out.println(System.currentTimeMillis() + \":T2 end!\"); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } } } public static void main(String[] args) throws InterruptedException { new T1().start(); new T2().start(); }}运行结果：1562934497212:T1 start!1562934497212:T1 wait for object1562934497212:T2 start，notify one thread!1562934497212:T2 end!1562934499213:T1 end!注意下打印结果，T2调用notify方法之后，T1并不能立即继续执行，而是要等待T2释放objec投递锁之后，T1重新成功获取锁后，才能继续执行。因此最后2行日志相差了2秒（因为T2调用notify方法后休眠了2秒）。注意：Object.wait()方法和Thread.sleep()方法都可以让现场等待若干时间。除wait()方法可以被唤醒外，另外一个主要的区别就是wait()方法会释放目标对象的锁，而Thread.sleep()方法不会释放锁。再给大家讲解一下wait()，notify()，notifyAll()，加深一下理解：可以这么理解，obj对象上有2个队列，如图1，q1：等待队列，q2：准备获取锁的队列；两个队列都为空。obj.wait()过程：synchronize(obj){ obj.wait();}假如有3个线程，t1、t2、t3同时执行上面代码，t1、t2、t3会进入q2队列，如图2，进入q2的队列的这些线程才有资格去争抢obj的锁，假设t1争抢到了，那么t2、t3机型在q2中等待着获取锁，t1进入代码块执行wait()方法，此时t1会进入q1队列，然后系统会通知q2队列中的t2、t3去争抢obj的锁，抢到之后过程如t1的过程。最后t1、t2、t3都进入了q1队列，如图3。上面过程之后，又来了线程t4执行了notify()方法，如下：**synchronize(obj){ obj.notify();}t4会获取到obj的锁，然后执行notify()方法，系统会从q1队列中随机取一个线程，将其加入到q2队列，假如t2运气比较好，被随机到了，然后t2进入了q2队列，如图4，进入q2的队列的锁才有资格争抢obj的锁，t4线程执行完毕之后，会释放obj的锁，此时队列q2中的t2会获取到obj的锁，然后继续执行，执行完毕之后，q1中包含t1、t3，q2队列为空，如图5接着又来了个t5队列，执行了notifyAll()方法，如下：synchronize(obj){ obj.notifyAll();}2.调用obj.wait()方法，当前线程会加入队列queue1，然后会释放obj对象的锁t5会获取到obj的锁，然后执行notifyAll()方法，系统会将队列q1中的线程都移到q2中，如图6，t5线程执行完毕之后，会释放obj的锁，此时队列q2中的t1、t3会争抢obj的锁，争抢到的继续执行，未增强到的带锁释放之后，系统会通知q2中的线程继续争抢索，然后继续执行，最后两个队列中都为空了。5、挂起（suspend）和继续执行（resume）线程Thread类中还有2个方法，即线程挂起(suspend)和继续执行(resume)，这2个操作是一对相反的操作，被挂起的线程，必须要等到resume()方法操作后，才能继续执行。系统中已经标注着2个方法过时了，不推荐使用。系统不推荐使用suspend()方法去挂起线程是因为suspend()方法导致线程暂停的同时，并不会释放任何锁资源。此时，其他任何线程想要访问被它占用的锁时，都会被牵连，导致无法正常运行（如图2.7所示）。直到在对应的线程上进行了resume()方法操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。但是，如果resume()方法操作意外地在suspend()方法前就被执行了，那么被挂起的线程可能很难有机会被继续执行了。并且，更严重的是：它所占用的锁不会被释放，因此可能会导致整个系统工作不正常。而且，对于被挂起的线程，从它线程的状态上看，居然还是Runnable状态，这也会影响我们队系统当前状态的判断。上个例子：public class Demo07 { static Object object = new Object(); public static class T1 extends Thread { public T1(String name) { super(name); } @Override public void run() { synchronized (object) { System.out.println(\"in \" + this.getName()); Thread.currentThread().suspend(); } } } public static void main(String[] args) throws InterruptedException { T1 t1 = new T1(\"t1\"); t1.start(); Thread.sleep(100); T1 t2 = new T1(\"t2\"); t2.start(); t1.resume(); t2.resume(); t1.join(); t2.join(); }}运行代码输出：in t1in t2我们会发现程序不会结束，线程t2被挂起了，导致程序无法结束，使用jstack命令查看线程堆栈信息可以看到：\"t2\" #13 prio=5 os_prio=0 tid=0x000000002796c000 nid=0xa3c runnable [0x000000002867f000] java.lang.Thread.State: RUNNABLE at java.lang.Thread.suspend0(Native Method) at java.lang.Thread.suspend(Thread.java:1029) at com.itsoku.chat01.Demo07$T1.run(Demo07.java:20) - locked &lt;0x0000000717372fc0&gt; (a java.lang.Object)发现t2线程在suspend0处被挂起了，t2的状态竟然还是RUNNABLE状态，线程明明被挂起了，状态还是运行中容易导致我们队当前系统进行误判，代码中已经调用resume()方法了，但是由于时间先后顺序的缘故，resume并没有生效，这导致了t2永远滴被挂起了，并且永远占用了object的锁，这对于系统来说可能是致命的。6、等待线程结束（join）和谦让（yeild）很多时候，一个线程的输入可能非常依赖于另外一个或者多个线程的输出，此时，这个线程就需要等待依赖的线程执行完毕，才能继续执行。jdk提供了join()操作来实现这个功能。如下所示，显示了2个join()方法：public final void join() throws InterruptedException;public final synchronized void join(long millis) throws InterruptedException;第1个方法表示无限等待，它会一直只是当前线程。知道目标线程执行完毕。第2个方法有个参数，用于指定等待时间，如果超过了给定的时间目标线程还在执行，当前线程也会停止等待，而继续往下执行。比如：线程T1需要等待T2、T3完成之后才能继续执行，那么在T1线程中需要分别调用T2和T3的join()方法。上个示例：public class Demo08 { static int num = 0; public static class T1 extends Thread { public T1(String name) { super(name); } @Override public void run() { System.out.println(System.currentTimeMillis() + \",start \" + this.getName()); for (int i = 0; i &lt; 10; i++) { num++; try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(System.currentTimeMillis() + \",end \" + this.getName()); } } public static void main(String[] args) throws InterruptedException { T1 t1 = new T1(\"t1\"); t1.start(); t1.join(); System.out.println(System.currentTimeMillis() + \",num = \" + num); }}执行结果：1562939889129,start t11562939891134,end t11562939891134,num = 10num的结果为10，1、3行的时间戳相差2秒左右，说明主线程等待t1完成之后才继续执行的。看一下jdk1.8中Thread.join()方法的实现：public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException(\"timeout value is negative\"); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } }}从join的代码中可以看出，在被等待的线程上使用了synchronize，调用了它的wait()方法，线程最后执行完毕之后，系统会自动调用它的notifyAll()方法，唤醒所有在此线程上等待的其他线程。注意：被等待的线程执行完毕之后，系统自动会调用该线程的notifyAll()方法。所以一般情况下，我们不要去在线程对象上使用wait()、notify()、notifyAll()方法。另外一个方法是Thread.yield()，他的定义如下：public static native void yield();yield是谦让的意思，这是一个静态方法，一旦执行，它会让当前线程出让CPU，但需要注意的是，出让CPU并不是说不让当前线程执行了，当前线程在出让CPU后，还会进行CPU资源的争夺，但是能否再抢到CPU的执行权就不一定了。因此，对Thread.yield()方法的调用好像就是在说：我已经完成了一些主要的工作，我可以休息一下了，可以让CPU给其他线程一些工作机会了。如果觉得一个线程不太重要，或者优先级比较低，而又担心此线程会过多的占用CPU资源，那么可以在适当的时候调用一下Thread.yield()方法，给与其他线程更多的机会。7、总结 创建线程的2中方式：继承Thread类；实现Runnable接口 启动线程：调用线程的start()方法 终止线程：调用线程的stop()方法，方法已过时，建议不要使用 线程中断相关的方法：调用线程实例interrupt()方法将中断标志置为true；使用线程实例方法isInterrupted()获取中断标志；调用Thread的静态方法interrupted()获取线程是否被中断，此方法调用之后会清除中断标志（将中断标志置为false了） wait、notify、notifyAll方法，这块比较难理解，可以回过头去再理理 线程挂起使用线程实例方法suspend()，恢复线程使用线程实例方法resume()，这2个方法都过时了，不建议使用 等待线程结束：调用线程实例方法join() 出让cpu资源：调用线程静态方法yeild()2、为什么多线程极其重要？？？ 硬件方面 - 摩尔定律失效摩尔定律：它是由英特尔创始人之一Gordon Moore(戈登·摩尔)提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。可是从2003年开始CPU主频已经不再翻倍，而是采用多核而不是更快的主频。摩尔定律失效。在主频不再提高且核数在不断增加的情况下，要想让程序更快就要用到并行或并发编程。 软件方面高并发系统，异步+回调等生产需求3、从start一个线程说起// Java线程理解以及openjdk中的实现private native void start0();// Java语言本身底层就是C++语言 OpenJDK源码网址:http://openjdk.java.net/openjdk8\\hotspot\\src\\share\\vm\\runtime更加底层的C++源码解读openjdk8\\jdk\\src\\share\\native\\java\\lang thread.cjava线程是通过start的方法启动执行的，主要内容在native方法start0中，Openjdk的写JNI一般是一一对应的，Thread.java对应的就是Thread.c start0其实就是JVM_StartThread。此时查看源代码可以看到在jvm.h中找到了声明，jvm.cpp中有实现。 openjdk8\\hotspot\\src\\share\\vm\\prims jvm.cppopenjdk8\\hotspot\\src\\share\\vm\\runtime thread.cpp4、用户线程和守护线程Java线程分为用户线程和守护线程，线程的daemon属性为true表示是守护线程，false表示是用户线程守护线程是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程用户线程是系统的工作线程，它会完成这个程序需要完成的业务操作public class DaemonDemo { public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t 开始运行，\" + (Thread.currentThread().isDaemon() ? \"守护线程\" : \"用户线程\")); while (true) { } }, \"t1\"); //线程的daemon属性为true表示是守护线程，false表示是用户线程 t1.setDaemon(true); t1.start(); //3秒钟后主线程再运行 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"----------main线程运行完毕\"); }}重点当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出设置守护线程，需要在start()方法之前**进行5、获得多线程的方法几种？ 传统的是 继承thread类 实现runnable接口， java5以后 实现callable接口 java的线程池获得 6、Callable接口1、与runnable对比// 创建新类MyThread实现runnable接口class MyThread implements Runnable{ @Override public void run() { }}// 新类MyThread2实现callable接口class MyThread2 implements Callable&lt;Integer&gt;{ @Override public Integer call() throws Exception { return 200; } }// 面试题:callable接口与runnable接口的区别？ // 答：（1）是否有返回值// （2）是否抛异常// （3）落地方法不一样，一个是run，一个是call2、怎么用直接替换runnable是否可行？不可行，因为：thread类的构造方法根本没有Callable认识不同的人找中间人public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask futureTask = new FutureTask(new MyThread2()); new Thread(futureTask,\"AA\").start();}运行成功后如何获得返回值？public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask futureTask = new FutureTask(new MyThread2()); new Thread(futureTask,\"AA\").start(); System.out.println(futureTask.get());}二、线程池1、什么是线程池大家用jdbc操作过数据库应该知道，操作数据库需要和数据库建立连接，拿到连接之后才能操作数据库，用完之后销毁。数据库连接的创建和销毁其实是比较耗时的，真正和业务相关的操作耗时是比较短的。每个数据库操作之前都需要创建连接，为了提升系统性能，后来出现了数据库连接池，系统启动的时候，先创建很多连接放在池子里面，使用的时候，直接从连接池中获取一个，使用完毕之后返回到池子里面，继续给其他需要者使用，这其中就省去创建连接的时间，从而提升了系统整体的性能。线程池和数据库连接池的原理也差不多，创建线程去处理业务，可能创建线程的时间比处理业务的时间还长一些，如果系统能够提前为我们创建好线程，我们需要的时候直接拿来使用，用完之后不是直接将其关闭，而是将其返回到线程中中，给其他需要这使用，这样直接节省了创建和销毁的时间，提升了系统的性能。简单的说，在使用了线程池之后，创建线程变成了从线程池中获取一个空闲的线程，然后使用，关闭线程变成了将线程归还到线程池。2、为什么用线程池线程池的优势：​\t\t线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。它的主要特点为：线程复用;控制最大并发数;管理线程。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控3、线程池的使用1、Executors.newFixedThreadPool(int)​\t\tnewFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());}2、Executors.newSingleThreadExecutor()​\t\tnewSingleThreadExecutor 创建的线程池corePoolSize和maximumPoolSize值都是1，它使用的是LinkedBlockingQueue一个任务一个任务的执行，一池一线程public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));}3、Executors.newCachedThreadPool()​\t\tnewCachedThreadPool创建的线程池将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，它使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());}import java.util.Arrays;import java.util.List;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 线程池 * Arrays * Collections * Executors */public class MyThreadPoolDemo { public static void main(String[] args) { //List list = new ArrayList(); //List list = Arrays.asList(\"a\",\"b\"); //固定数的线程池，一池五线程// ExecutorService threadPool = Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口// ExecutorService threadPool = Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口 ExecutorService threadPool = Executors.newCachedThreadPool(); //一个银行网点，可扩展受理业务的窗口 //10个顾客请求 try { for (int i = 1; i &lt;=10; i++) { threadPool.execute(()-&gt;{ System.out.println(Thread.currentThread().getName()+\"\\t 办理业务\"); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool.shutdown(); } }}4、ThreadPoolExecutor底层原理举个例子，加深理解：咱们作为开发者，上面都有开发主管，主管下面带领几个小弟干活，CTO给主管授权说，你可以招聘5个小弟干活，新来任务，如果小弟还不到吴哥，立即去招聘一个来干这个新来的任务，当5个小弟都招来了，再来任务之后，将任务记录到一个表格中，表格中最多记录100个，小弟们会主动去表格中获取任务执行，如果5个小弟都在干活，并且表格中也记录满了，那你可以将小弟扩充到20个，如果20个小弟都在干活，并且存放任务的表也满了，产品经理再来任务后，是直接拒绝，还是让产品自己干，这个由你自己决定，小弟们都尽心尽力在干活，任务都被处理完了，突然公司业绩下滑，几个员工没事干，打酱油，为了节约成本，CTO主管把小弟控制到5人，其他15个人直接被干掉了。所以作为小弟们，别让自己闲着，多干活。原理：先找几个人干活，大家都忙于干活，任务太多可以排期，排期的任务太多了，再招一些人来干活，最后干活的和排期都达到上层领导要求的上限了，那需要采取一些其他策略进行处理了。对于长时间不干活的人，考虑将其开掉，节约资源和成本。public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;} corePoolSize：核心线程大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使有其他空闲线程可以处理任务也会创新线程，等到工作的线程数大于核心线程数时就不会在创建了。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前把核心线程都创造好，并启动 maximumPoolSize：线程池允许创建的最大线程数，此值必须大于等于1。如果队列满了，并且以创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果我们使用了无界队列，那么所有的任务会加入队列，这个参数就没有什么效果了 keepAliveTime：多余的空闲线程的存活时间,当前池中线程数量超过corePoolSize时，当空闲时间,达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止，如果任务很多，并且每个任务的执行时间比较短，避免线程重复创建和回收，可以调大这个时间，提高线程的利用率 unit：keepAliveTIme的时间单位，可以选择的单位有天、小时、分钟、毫秒、微妙、千分之一毫秒和纳秒。类型是一个枚举java.util.concurrent.TimeUnit，这个枚举也经常使用 workQueue：任务队列，被提交但尚未被执行的任务，用于缓存待处理任务的阻塞队列 threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可，可以通过线程工厂给每个创建出来的线程设置更有意义的名字 handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略 调用线程池的execute方法处理任务，执行execute方法的过程： 判断线程池中运行的线程数是否小于corepoolsize，是：则创建新的线程来处理任务，否：执行下一步 试图将任务添加到workQueue指定的队列中，如果无法添加到队列，进入下一步 判断线程池中运行的线程数是否小于maximumPoolSize，是：则新增线程处理当前传入的任务，否：将任务传递给handler对象rejectedExecution方法处理1、在创建了线程池后，开始等待请求。2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断： 2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务； 2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列； 2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。3、当一个线程完成任务时，它会从队列中取下一个任务来执行。4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断： 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。 所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。5、拒绝策略？生产中如设置合理参数1、线程池的拒绝策略​\t\t等待队列已经排满了，再也塞不下新任务了，同时，线程池中的max线程也达到了，无法继续为新任务服务。这个是时候我们就需要拒绝策略机制合理的处理这个问题。2、JDK内置的拒绝策略AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。以上内置拒绝策略均实现了RejectedExecutionHandle接口import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class Demo5 { static class Task implements Runnable { String name; public Task(String name) { this.name = name; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \"处理\" + this.name); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public String toString() { return \"Task{\" + \"name='\" + name + '\\'' + '}'; } } public static void main(String[] args) { ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1), Executors.defaultThreadFactory(), (r, executors) -&gt; { //自定义饱和策略 //记录一下无法处理的任务 System.out.println(\"无法处理的任务：\" + r.toString()); }); for (int i = 0; i &lt; 5; i++) { executor.execute(new Task(\"任务-\" + i)); } executor.shutdown(); }}无法处理的任务：Task{name='任务-2'}无法处理的任务：Task{name='任务-3'}pool-1-thread-1处理任务-0无法处理的任务：Task{name='任务-4'}pool-1-thread-1处理任务-1输出结果中可以看到有3个任务进入了饱和策略中，记录了任务的日志，对于无法处理多任务，我们最好能够记录一下，让开发人员能够知道。任务进入了饱和策略，说明线程池的配置可能不是太合理，或者机器的性能有限，需要做一些优化调整。3、生产中合理的设置参数要想合理的配置线程池，需要先分析任务的特性，可以从以下几个角度分析： 任务的性质：CPU密集型任务、IO密集型任务和混合型任务 任务的优先级：高、中、低 任务的执行时间：长、中、短 任务的依赖性：是否依赖其他的系统资源，如数据库连接。性质不同任务可以用不同规模的线程池分开处理。CPU密集型任务应该尽可能小的线程，如配置cpu数量+1个线程的线程池。由于IO密集型任务并不是一直在执行任务，不能让cpu闲着，则应配置尽可能多的线程，如：cup数量*2。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这2个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。可以通过Runtime.getRuntime().availableProcessors()方法获取cpu数量。优先级不同任务可以对线程池采用优先级队列来处理，让优先级高的先执行。使用队列的时候建议使用有界队列，有界队列增加了系统的稳定性，如果采用无解队列，任务太多的时候可能导致系统OOM，直接让系统宕机。线程池汇总线程大小对系统的性能有一定的影响，我们的目标是希望系统能够发挥最好的性能，过多或者过小的线程数量无法有消息的使用机器的性能。咋Java Concurrency inPractice书中给出了估算线程池大小的公式：Ncpu = CUP的数量Ucpu = 目标CPU的使用率，0&lt;=Ucpu&lt;=1W/C = 等待时间与计算时间的比例为保存处理器达到期望的使用率，最有的线程池的大小等于：Nthreads = Ncpu × Ucpu × (1+W/C) CPU密集型 // 查看CPU核数System. out .println(Runtime. getRuntime ().availableProcessors()); ￼ IO密集型 由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数 * 2 。 看公司业务是CPU密集型还是IO密集型的，这两种不一样，来决定线程池线程数的最佳合理配置数。6、超级大坑 在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？答案是一个都不用，我们工作中只能使用自定义的7、自定义线程池import java.util.Arrays;import java.util.List;import java.util.concurrent.*;/** * 线程池 * Arrays * Collections * Executors */public class MyThreadPoolDemo { public static void main(String[] args) { ExecutorService threadPool = new ThreadPoolExecutor( 2, 5, 2L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(3), Executors.defaultThreadFactory(), //new ThreadPoolExecutor.AbortPolicy() //new ThreadPoolExecutor.CallerRunsPolicy() //new ThreadPoolExecutor.DiscardOldestPolicy() new ThreadPoolExecutor.DiscardPolicy() ); //10个顾客请求 try { for (int i = 1; i &lt;= 10; i++) { threadPool.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t 办理业务\"); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool.shutdown(); } } private static void threadPool() { //List list = new ArrayList(); //List list = Arrays.asList(\"a\",\"b\"); //固定数的线程池，一池五线程// ExecutorService threadPool = Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口// ExecutorService threadPool = Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口 ExecutorService threadPool = Executors.newCachedThreadPool(); //一个银行网点，可扩展受理业务的窗口 //10个顾客请求 try { for (int i = 1; i &lt;= 10; i++) { threadPool.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t 办理业务\"); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool.shutdown(); } }}8、线程池中的2个关闭方法线程池提供了2个关闭方法：shutdown和shutdownNow，当调用者两个方法之后，线程池会遍历内部的工作线程，然后调用每个工作线程的interrrupt方法给线程发送中断信号，内部如果无法响应中断信号的可能永远无法终止，所以如果内部有无线循环的，最好在循环内部检测一下线程的中断信号，合理的退出。调用者两个方法中任意一个，线程池的isShutdown方法就会返回true，当所有的任务线程都关闭之后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。调用shutdown方法之后，线程池将不再接口新任务，内部会将所有已提交的任务处理完毕，处理完毕之后，工作线程自动退出。而调用shutdownNow方法后，线程池会将还未处理的（在队里等待处理的任务）任务移除，将正在处理中的处理完毕之后，工作线程自动退出。至于调用哪个方法来关闭线程，应该由提交到线程池的任务特性决定，多数情况下调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。9、BlockingQueue阻塞队列1、栈与队列栈：先进后出，后进先出队列：先进先出2、阻塞队列阻塞：必须要阻塞/不得不阻塞线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素当队列是空的，从队列中获取元素的操作将会被阻塞当队列是满的，从队列中添加元素的操作将会被阻塞试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增3、种类分析ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按照先进先出原则对元素进行排序LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列，此队列按照先进先出排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool使用了这个队列。PriorityBlockingQueue：支持优先级排序的无界阻塞队列。DelayQueue：使用优先级队列实现的延迟无界阻塞队列。SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列,每个插入操作必须等到另外一个线程调用移除操作，否则插入操作一直处理阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用这个队列LinkedTransferQueue：由链表组成的无界阻塞队列。LinkedBlockingDeque：由链表组成的双向阻塞队列。import java.util.concurrent.*;public class Demo2 { public static void main(String[] args) { ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 50; i++) { int j = i; String taskName = \"任务\" + j; executor.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \"处理\" + taskName); //模拟任务内部处理耗时 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } }); } executor.shutdown(); }}代码中使用Executors.newCachedThreadPool()创建线程池，看一下的源码：public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); }从输出中可以看出，系统创建了50个线程处理任务，代码中使用了SynchronousQueue同步队列，这种队列比较特殊，放入元素必须要有另外一个线程去获取这个元素，否则放入元素会失败或者一直阻塞在那里直到有线程取走，示例中任务处理休眠了指定的时间，导致已创建的工作线程都忙于处理任务，所以新来任务之后，将任务丢入同步队列会失败，丢入队列失败之后，会尝试新建线程处理任务。使用上面的方式创建线程池需要注意，如果需要处理的任务比较耗时，会导致新来的任务都会创建新的线程进行处理，可能会导致创建非常多的线程，最终耗尽系统资源，触发OOM。PriorityBlockingQueue优先级队列的线程池import java.util.concurrent.*;public class Demo3 { static class Task implements Runnable, Comparable&lt;Task&gt; { private int i; private String name; public Task(int i, String name) { this.i = i; this.name = name; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \"处理\" + this.name); } @Override public int compareTo(Task o) { return Integer.compare(o.i, this.i); } } public static void main(String[] args) { ExecutorService executor = new ThreadPoolExecutor(1, 1, 60L, TimeUnit.SECONDS, new PriorityBlockingQueue()); for (int i = 0; i &lt; 10; i++) { String taskName = \"任务\" + i; executor.execute(new Task(i, taskName)); } for (int i = 100; i &gt;= 90; i--) { String taskName = \"任务\" + i; executor.execute(new Task(i, taskName)); } executor.shutdown(); }}输出中，除了第一个任务，其他任务按照优先级高低按顺序处理。原因在于：创建线程池的时候使用了优先级队列，进入队列中的任务会进行排序，任务的先后顺序由Task中的i变量决定。向PriorityBlockingQueue加入元素的时候，内部会调用代码中Task的compareTo方法决定元素的先后顺序。4、BlockingQueue核心方法import java.util.ArrayList;import java.util.List;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;/** * 阻塞队列 */public class BlockingQueueDemo { public static void main(String[] args) throws InterruptedException {// List list = new ArrayList(); BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); //第一组// System.out.println(blockingQueue.add(\"a\"));// System.out.println(blockingQueue.add(\"b\"));// System.out.println(blockingQueue.add(\"c\"));// System.out.println(blockingQueue.element()); //System.out.println(blockingQueue.add(\"x\"));// System.out.println(blockingQueue.remove());// System.out.println(blockingQueue.remove());// System.out.println(blockingQueue.remove());// System.out.println(blockingQueue.remove());// 第二组// System.out.println(blockingQueue.offer(\"a\"));// System.out.println(blockingQueue.offer(\"b\"));// System.out.println(blockingQueue.offer(\"c\"));// System.out.println(blockingQueue.offer(\"x\"));// System.out.println(blockingQueue.poll());// System.out.println(blockingQueue.poll());// System.out.println(blockingQueue.poll());// System.out.println(blockingQueue.poll());// 第三组 // blockingQueue.put(\"a\");// blockingQueue.put(\"b\");// blockingQueue.put(\"c\");// //blockingQueue.put(\"x\");// System.out.println(blockingQueue.take());// System.out.println(blockingQueue.take());// System.out.println(blockingQueue.take());// System.out.println(blockingQueue.take()); // 第四组 System.out.println(blockingQueue.offer(\"a\")); System.out.println(blockingQueue.offer(\"b\")); System.out.println(blockingQueue.offer(\"c\")); System.out.println(blockingQueue.offer(\"a\",3L, TimeUnit.SECONDS)); }}10、扩展线程池虽然jdk提供了ThreadPoolExecutor这个高性能线程池，但是如果我们自己想在这个线程池上面做一些扩展，比如，监控每个任务执行的开始时间，结束时间，或者一些其他自定义的功能，我们应该怎么办？这个jdk已经帮我们想到了，ThreadPoolExecutor内部提供了几个方法beforeExecute、afterExecute、terminated，可以由开发人员自己去这些方法。看一下线程池内部的源码：try { beforeExecute(wt, task);//任务执行之前调用的方法 Throwable thrown = null; try { task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown);//任务执行完毕之后调用的方法 }} finally { task = null; w.completedTasks++; w.unlock();}beforeExecute：任务执行之前调用的方法，有2个参数，第1个参数是执行任务的线程，第2个参数是任务protected void beforeExecute(Thread t, Runnable r) { }afterExecute：任务执行完成之后调用的方法，2个参数，第1个参数表示任务，第2个参数表示任务执行时的异常信息，如果无异常，第二个参数为nullprotected void afterExecute(Runnable r, Throwable t) { }terminated：线程池最终关闭之后调用的方法。所有的工作线程都退出了，最终线程池会退出，退出时调用该方法import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Demo6 { static class Task implements Runnable { String name; public Task(String name) { this.name = name; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \"处理\" + this.name); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public String toString() { return \"Task{\" + \"name='\" + name + '\\'' + '}'; } } public static void main(String[] args) throws InterruptedException { ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1), Executors.defaultThreadFactory(), (r, executors) -&gt; { //自定义饱和策略 //记录一下无法处理的任务 System.out.println(\"无法处理的任务：\" + r.toString()); }) { @Override protected void beforeExecute(Thread t, Runnable r) { System.out.println(System.currentTimeMillis() + \",\" + t.getName() + \",开始执行任务:\" + r.toString()); } @Override protected void afterExecute(Runnable r, Throwable t) { System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \",任务:\" + r.toString() + \"，执行完毕!\"); } @Override protected void terminated() { System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"，关闭线程池!\"); } }; for (int i = 0; i &lt; 10; i++) { executor.execute(new Task(\"任务-\" + i)); } TimeUnit.SECONDS.sleep(1); executor.shutdown(); }}1564324574847,pool-1-thread-1,开始执行任务:Task{name='任务-0'}1564324574850,pool-1-thread-3,开始执行任务:Task{name='任务-2'}pool-1-thread-3处理任务-21564324574849,pool-1-thread-2,开始执行任务:Task{name='任务-1'}pool-1-thread-2处理任务-11564324574848,pool-1-thread-5,开始执行任务:Task{name='任务-4'}pool-1-thread-5处理任务-41564324574848,pool-1-thread-4,开始执行任务:Task{name='任务-3'}pool-1-thread-4处理任务-31564324574850,pool-1-thread-7,开始执行任务:Task{name='任务-6'}pool-1-thread-7处理任务-61564324574850,pool-1-thread-6,开始执行任务:Task{name='任务-5'}1564324574851,pool-1-thread-8,开始执行任务:Task{name='任务-7'}pool-1-thread-8处理任务-7pool-1-thread-1处理任务-0pool-1-thread-6处理任务-51564324574851,pool-1-thread-10,开始执行任务:Task{name='任务-9'}pool-1-thread-10处理任务-91564324574852,pool-1-thread-9,开始执行任务:Task{name='任务-8'}pool-1-thread-9处理任务-81564324576851,pool-1-thread-2,任务:Task{name='任务-1'}，执行完毕!1564324576851,pool-1-thread-3,任务:Task{name='任务-2'}，执行完毕!1564324576852,pool-1-thread-1,任务:Task{name='任务-0'}，执行完毕!1564324576852,pool-1-thread-4,任务:Task{name='任务-3'}，执行完毕!1564324576852,pool-1-thread-8,任务:Task{name='任务-7'}，执行完毕!1564324576852,pool-1-thread-7,任务:Task{name='任务-6'}，执行完毕!1564324576852,pool-1-thread-5,任务:Task{name='任务-4'}，执行完毕!1564324576853,pool-1-thread-6,任务:Task{name='任务-5'}，执行完毕!1564324576853,pool-1-thread-10,任务:Task{name='任务-9'}，执行完毕!1564324576853,pool-1-thread-9,任务:Task{name='任务-8'}，执行完毕!1564324576853,pool-1-thread-9，关闭线程池!从输出结果中可以看到，每个需要执行的任务打印了3行日志，执行前由线程池的beforeExecute打印，执行时会调用任务的run方法，任务执行完毕之后，会调用线程池的afterExecute方法，从每个任务的首尾2条日志中可以看到每个任务耗时2秒左右。线程池最终关闭之后调用了terminated方法。三、CompletableFuture1、Future和Callable接口Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。Callable接口中定义了需要有返回的任务需要实现的方法比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。2、从之前的FutureTask开始Future接口相关架构code1public class CompletableFutureDemo{ public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException{ FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; { System.out.println(\"-----come in FutureTask\"); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } return ThreadLocalRandom.current().nextInt(100); }); Thread t1 = new Thread(futureTask,\"t1\"); t1.start(); //3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞) //System.out.println(Thread.currentThread().getName()+\"\\t\"+futureTask.get()); //3秒钟后才出来结果，我只想等待1秒钟，过时不候 System.out.println(Thread.currentThread().getName()+\"\\t\"+futureTask.get(1L,TimeUnit.SECONDS)); System.out.println(Thread.currentThread().getName()+\"\\t\"+\" run... here\"); }} get()阻塞 一旦调用get()方法，不管是否计算完成都会导致阻塞code2public class CompletableFutureDemo2 { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; { System.out.println(\"-----come in FutureTask\"); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } return \"\"+ ThreadLocalRandom.current().nextInt(100); }); new Thread(futureTask,\"t1\").start(); System.out.println(Thread.currentThread().getName()+\"\\t\"+\"线程完成任务\"); /** * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果 */ while (true){ if(futureTask.isDone()){ System.out.println(futureTask.get()); break; } } }}isDone()轮询轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果.如果想要异步获取结果,通常都会以轮询的方式去获取结果尽量不要阻塞不见不散 – 过时不候 – 轮询3、对Future的改进1、类CompletableFuture2、接口CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段，有些类似Linux系统的管道分隔符传参数。4、核心的四个静态方法1、runAsync 无 返回值public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,Executor executor) 2、supplyAsync 有 返回值public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,Executor executor)上述Executor executor参数说明没有指定Executor的方法，直接使用默认的ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码3、Code 无 返回值public class CompletableFutureDemo3{ public static void main(String[] args) throws ExecutionException, InterruptedException{ CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"-----come in\"); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----task is over\"); }); System.out.println(future.get()); }}4、Code 有 返回值public class CompletableFutureDemo3{ public static void main(String[] args) throws ExecutionException, InterruptedException{ CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"-----come in\"); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return ThreadLocalRandom.current().nextInt(100); }); System.out.println(completableFuture.get()); }}5、Code 减少阻塞和轮询从Java8开始引入了CompletableFuture，它是Future的功能增强版，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法public class CompletableFutureDemo3{ public static void main(String[] args) throws Exception{ CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"-----come in\"); int result = ThreadLocalRandom.current().nextInt(10); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----计算结束耗时1秒钟，result： \"+result); if(result &gt; 6){ int age = 10/0; } return result; }).whenComplete((v,e) -&gt;{ if(e == null){ System.out.println(\"-----result: \"+v); } }).exceptionally(e -&gt; { System.out.println(\"-----exception: \"+e.getCause()+\"\\t\"+e.getMessage()); return -44; }); //主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } }}6、CompletableFuture的优点异步任务结束时，会自动回调某个对象的方法；异步任务出错时，会自动回调某个对象的方法；主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行5、join和get对比get会抛出异常，join不需要6、案例精讲-从电商网站的比价需求说开去切记，功能→性能​\t\t经常出现在等待某条 SQL 执行完成后，再继续执行下一条 SQL ，而这两条 SQL 本身是并无关系的，可以同时进行执行的。我们希望能够两条 SQL 同时进行处理，而不是等待其中的某一条 SQL 完成后，再继续下一条。同理，对于分布式微服务的调用，按照实际业务，如果是无关联step by step的业务，可以尝试是否可以多箭齐发，同时调用。我们去比同一个商品在各个平台上的价格，要求获得一个清单列表，1 step by step，查完京东查淘宝，查完淘宝查天猫……2 all 一口气同时查询。。。。。import lombok.Getter;import java.util.Arrays;import java.util.List;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ThreadLocalRandom;import java.util.concurrent.TimeUnit;import java.util.stream.Collectors;public class T1{ static List&lt;NetMall&gt; list = Arrays.asList( new NetMall(\"jd\"), new NetMall(\"tmall\"), new NetMall(\"pdd\"), new NetMall(\"mi\") ); public static List&lt;String&gt; findPriceSync(List&lt;NetMall&gt; list,String productName){ return list.stream().map(mall -&gt; String.format(productName+\" %s price is %.2f\",mall.getNetMallName(),mall.getPriceByName(productName))).collect(Collectors.toList()); } public static List&lt;String&gt; findPriceASync(List&lt;NetMall&gt; list,String productName){ return list.stream().map(mall -&gt; CompletableFuture.supplyAsync(() -&gt; String.format(productName + \" %s price is %.2f\", mall.getNetMallName(), mall.getPriceByName(productName)))).collect(Collectors.toList()).stream().map(CompletableFuture::join).collect(Collectors.toList()); } public static void main(String[] args){ long startTime = System.currentTimeMillis(); List&lt;String&gt; list1 = findPriceSync(list, \"thinking in java\"); for (String element : list1) { System.out.println(element); } long endTime = System.currentTimeMillis(); System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"); long startTime2 = System.currentTimeMillis(); List&lt;String&gt; list2 = findPriceASync(list, \"thinking in java\"); for (String element : list2) { System.out.println(element); } long endTime2 = System.currentTimeMillis(); System.out.println(\"----costTime: \"+(endTime2 - startTime2) +\" 毫秒\"); }}class NetMall{ @Getter private String netMallName; public NetMall(String netMallName){ this.netMallName = netMallName; } public double getPriceByName(String productName){ return calcPrice(productName); } private double calcPrice(String productName){ try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return ThreadLocalRandom.current().nextDouble() + productName.charAt(0); }}7、CompletableFuture常用方法1、获得结果和触发计算获取结果// 不见不散public T get() // 过时不候public T get(long timeout, TimeUnit unit) // 没有计算完成的情况下，给我一个替代结果 // 立即获取结果不阻塞 计算完，返回计算完成后的结果 没算完，返回设定的valueIfAbsent值public T getNow(T valueIfAbsent) public class CompletableFutureDemo2{ public static void main(String[] args) throws ExecutionException, InterruptedException{ CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return 533; }); //去掉注释上面计算没有完成，返回444 //开启注释上满计算完成，返回计算结果 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(completableFuture.getNow(444)); }}public T join()public class CompletableFutureDemo2{ public static void main(String[] args) throws ExecutionException, InterruptedException{ System.out.println(CompletableFuture.supplyAsync(() -&gt; \"abc\").thenApply(r -&gt; r + \"123\").join()); }} 主动触发计算// 是否打断get方法立即返回括号值public boolean complete(T value) public class CompletableFutureDemo4{ public static void main(String[] args) throws ExecutionException, InterruptedException{ CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return 533; }); //注释掉暂停线程，get还没有算完只能返回complete方法设置的444；暂停2秒钟线程，异步线程能够计算完成返回get try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } //当调用CompletableFuture.get()被阻塞的时候,complete方法就是结束阻塞并get()获取设置的complete里面的值. System.out.println(completableFuture.complete(444)+\"\\t\"+completableFuture.get()); }} 2、对计算结果进行处理thenApply// 计算结果存在依赖关系，这两个线程串行化// 由于存在依赖关系(当前步错，不走下一步)，当前步骤有异常的话就叫停。public class CompletableFutureDemo4{\tpublic static void main(String[] args) throws ExecutionException, InterruptedException{ //当一个线程依赖另一个线程时用 thenApply 方法来把这两个线程串行化, CompletableFuture.supplyAsync(() -&gt; { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"111\"); return 1024; }).thenApply(f -&gt; { System.out.println(\"222\"); return f + 1; }).thenApply(f -&gt; { //int age = 10/0; // 异常情况：那步出错就停在那步。 System.out.println(\"333\"); return f + 1; }).whenCompleteAsync((v,e) -&gt; { System.out.println(\"*****v: \"+v); }).exceptionally(e -&gt; { e.printStackTrace(); return null; }); \tSystem.out.println(\"-----主线程结束，END\"); // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭: try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }\t} } handle// 有异常也可以往下一步走，根据带的异常参数可以进一步处理public class CompletableFutureDemo4{ public static void main(String[] args) throws ExecutionException, InterruptedException{ //当一个线程依赖另一个线程时用 handle 方法来把这两个线程串行化, // 异常情况：有异常也可以往下一步走，根据带的异常参数可以进一步处理 CompletableFuture.supplyAsync(() -&gt; { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"111\"); return 1024; }).handle((f,e) -&gt; { int age = 10/0; System.out.println(\"222\"); return f + 1; }).handle((f,e) -&gt; { System.out.println(\"333\"); return f + 1; }).whenCompleteAsync((v,e) -&gt; { System.out.println(\"*****v: \"+v); }).exceptionally(e -&gt; { e.printStackTrace(); return null; }); System.out.println(\"-----主线程结束，END\"); // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭: try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } }} 3、对计算结果进行消费接收任务的处理结果，并消费处理，无返回结果//thenAcceptpublic static void main(String[] args) throws ExecutionException, InterruptedException{ CompletableFuture.supplyAsync(() -&gt; { return 1; }).thenApply(f -&gt; { return f + 2; }).thenApply(f -&gt; { return f + 3; }).thenApply(f -&gt; { return f + 4; }).thenAccept(r -&gt; System.out.println(r));} Code之任务之间的顺序执行thenRunthenRun(Runnable runnable)// 任务 A 执行完执行 B，并且 B 不需要 A 的结果 thenAcceptthenAccept(Consumer action)// 任务 A 执行完执行 B，B 需要 A 的结果，但是任务 B 无返回值 thenApplythenApply(Function fn)// 任务 A 执行完执行 B，B 需要 A 的结果，同时任务 B 有返回值 System.out.println(CompletableFuture.supplyAsync(() -&gt; \"resultA\").thenRun(() -&gt; {}).join());System.out.println(CompletableFuture.supplyAsync(() -&gt; \"resultA\").thenAccept(resultA -&gt; {}).join());System.out.println(CompletableFuture.supplyAsync(() -&gt; \"resultA\").thenApply(resultA -&gt; resultA + \" resultB\").join());4、对计算速度进行选用谁快用谁applyToEitherpublic class CompletableFutureDemo5{ public static void main(String[] args) throws ExecutionException, InterruptedException{ CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \"); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } return 10; }); CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \"); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return 20; }); CompletableFuture&lt;Integer&gt; thenCombineResult = completableFuture1.applyToEither(completableFuture2,f -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \"); return f + 1; }); System.out.println(Thread.currentThread().getName() + \"\\t\" + thenCombineResult.get()); }}5、对计算结果进行合并两个CompletionStage任务都完成后，最终能把两个任务的结果一起交给thenCombine 来处理先完成的先等着，等待其它分支任务thenCombinecode标准版，好理解先拆分public class CompletableFutureDemo2{ public static void main(String[] args) throws ExecutionException, InterruptedException{ CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \"); return 10; }); CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \"); return 20; }); CompletableFuture&lt;Integer&gt; thenCombineResult = completableFuture1.thenCombine(completableFuture2, (x, y) -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \"); return x + y; }); System.out.println(thenCombineResult.get()); }}code表达式public class CompletableFutureDemo6{ public static void main(String[] args) throws ExecutionException, InterruptedException{ CompletableFuture&lt;Integer&gt; thenCombineResult = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 1\"); return 10; }).thenCombine(CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 2\"); return 20; }), (x,y) -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 3\"); return x + y; }).thenCombine(CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 4\"); return 30; }),(a,b) -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 5\"); return a + b; }); System.out.println(\"-----主线程结束，END\"); System.out.println(thenCombineResult.get()); // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭: try { TimeUnit.SECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } }}8、分支合并框架Fork：把一个复杂任务进行分拆，大事化小Join：把分拆任务的结果进行合并1、相关类1、ForkJoinPool2、ForkJoinTask3、RecursiveTask// 递归任务：继承后可以实现递归(自己调自己)调用的任务 class Fibonacci extends RecursiveTask&lt;Integer&gt; { final int n; Fibonacci(int n) { this.n = n; } Integer compute() { if (n &lt;= 1) return n; Fibonacci f1 = new Fibonacci(n - 1); f1.fork(); Fibonacci f2 = new Fibonacci(n - 2); return f2.compute() + f1.join(); } }2、示例import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;class MyTask extends RecursiveTask&lt;Integer&gt;{ private static final Integer ADJUST_VALUE = 10; private int begin; private int end; private int result; public MyTask(int begin, int end) { this.begin = begin; this.end = end; } @Override protected Integer compute() { if((end - begin)&lt;=ADJUST_VALUE){ for(int i =begin;i &lt;= end;i++){ result = result + i; } }else{ int middle = (begin + end)/2; MyTask task01 = new MyTask(begin,middle); MyTask task02 = new MyTask(middle+1,end); task01.fork(); task02.fork(); result = task01.join() + task02.join(); } return result; }}/** * 分支合并例子 * ForkJoinPool * ForkJoinTask * RecursiveTask */public class ForkJoinDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { MyTask myTask = new MyTask(0,100); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask); System.out.println(forkJoinTask.get()); forkJoinPool.shutdown(); }}四、Java“锁”事1、Lock// Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects.// 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象2、synchronized与Lock的区别 首先synchronized是java内置关键字，在jvm层面，Lock是个java类； synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。3、synchronized 修饰实例方法，作用于当前实例，进入同步代码前需要先获取实例的锁 修饰静态方法，作用于类的Class对象，进入修饰的静态方法前需要先获取类的Class对象的锁 修饰代码块，需要指定加锁对象(记做lockobj)，在进入同步代码块前需要先获取lockobj的锁1、synchronized作用于实例对象所谓实例对象锁就是用synchronized修饰实例对象的实例方法，注意是实例方法，不是静态方法，如：public class Demo2 { int num = 0; public synchronized void add() { num++; } public static class T extends Thread { private Demo2 demo2; public T(Demo2 demo2) { this.demo2 = demo2; } @Override public void run() { for (int i = 0; i &lt; 10000; i++) { this.demo2.add(); } } } public static void main(String[] args) throws InterruptedException { Demo2 demo2 = new Demo2(); T t1 = new T(demo2); T t2 = new T(demo2); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(demo2.num); }}main()方法中创建了一个对象demo2和2个线程t1、t2，t1、t2中调用demo2的add()方法10000次，add()方法中执行了num++，num++实际上是分3步，获取num，然后将num+1，然后将结果赋值给num，如果t2在t1读取num和num+1之间获取了num的值，那么t1和t2会读取到同样的值，然后执行num++，两次操作之后num是相同的值，最终和期望的结果不一致，造成了线程安全失败，因此我们对add方法加了synchronized来保证线程安全。注意：m1()方法是实例方法，两个线程操作m1()时，需要先获取demo2的锁，没有获取到锁的，将等待，直到其他线程释放锁为止。synchronize作用于实例方法需要注意： 实例方法上加synchronized，线程安全的前提是，多个线程操作的是同一个实例，如果多个线程作用于不同的实例，那么线程安全是无法保证的 同一个实例的多个实例方法上有synchronized，这些方法都是互斥的，同一时间只允许一个线程操作同一个实例的其中的一个synchronized方法2、synchronized作用于静态方法当synchronized作用于静态方法时，锁的对象就是当前类的Class对象。如：public class Demo3 { static int num = 0; public static synchronized void m1() { for (int i = 0; i &lt; 10000; i++) { num++; } } public static class T1 extends Thread { @Override public void run() { Demo3.m1(); } } public static void main(String[] args) throws InterruptedException { T1 t1 = new T1(); T1 t2 = new T1(); T1 t3 = new T1(); t1.start(); t2.start(); t3.start(); //等待3个线程结束打印num t1.join(); t2.join(); t3.join(); System.out.println(Demo3.num); /** * 打印结果： * 30000 */ }}上面代码打印30000，和期望结果一致。m1()方法是静态方法，有synchronized修饰，锁用于与Demo3.class对象，和下面的写法类似：public static void m1() { synchronized (Demo4.class) { for (int i = 0; i &lt; 10000; i++) { num++; } }}3、synchronized同步代码块除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了，同步代码块的使用示例如下：public class Demo5 implements Runnable { static Demo5 instance = new Demo5(); static int i = 0; @Override public void run() { //省略其他耗时操作.... //使用同步代码块对变量i进行同步操作,锁对象为instance synchronized (instance) { for (int j = 0; j &lt; 10000; j++) { i++; } } } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); }}从代码看出，将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行i++;操作。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码：//this,当前实例对象锁synchronized(this){ for(int j=0;j&lt;1000000;j++){ i++; }}//class对象锁synchronized(Demo5.class){ for(int j=0;j&lt;1000000;j++){ i++; }}分析代码是否互斥的方法，先找出synchronized作用的对象是谁，如果多个线程操作的方法中synchronized作用的锁对象一样，那么这些线程同时异步执行这些方法就是互斥的。如下代码:public class Demo6 { //作用于当前类的实例对象 public synchronized void m1() { } //作用于当前类的实例对象 public synchronized void m2() { } //作用于当前类的实例对象 public void m3() { synchronized (this) { } } //作用于当前类Class对象 public static synchronized void m4() { } //作用于当前类Class对象 public static void m5() { synchronized (Demo6.class) { } } public static class T extends Thread{ Demo6 demo6; public T(Demo6 demo6) { this.demo6 = demo6; } @Override public void run() { super.run(); } } public static void main(String[] args) { Demo6 d1 = new Demo6(); Thread t1 = new Thread(() -&gt; { d1.m1(); }); t1.start(); Thread t2 = new Thread(() -&gt; { d1.m2(); }); t2.start(); Thread t3 = new Thread(() -&gt; { d1.m2(); }); t3.start(); Demo6 d2 = new Demo6(); Thread t4 = new Thread(() -&gt; { d2.m2(); }); t4.start(); Thread t5 = new Thread(() -&gt; { Demo6.m4(); }); t5.start(); Thread t6 = new Thread(() -&gt; { Demo6.m5(); }); t6.start(); }}分析上面代码： 线程t1、t2、t3中调用的方法都需要获取d1的锁，所以他们是互斥的 t1/t2/t3这3个线程和t4不互斥，他们可以同时运行，因为前面三个线程依赖于d1的锁，t4依赖于d2的锁 t5、t6都作用于当前类的Class对象锁，所以这两个线程是互斥的，和其他几个线程不互斥4、ReentrantLockReentrantLock是Lock的默认实现，在聊ReentranLock之前，我们需要先弄清楚一些概念： 可重入锁：可重入锁是指同一个线程可以多次获得同一把锁；ReentrantLock和关键字Synchronized都是可重入锁 可中断锁：可中断锁时子线程在获取锁的过程中，是否可以相应线程中断操作。synchronized是不可中断的，ReentrantLock是可中断的 公平锁和非公平锁：公平锁是指多个线程尝试获取同一把锁的时候，获取锁的顺序按照线程到达的先后顺序获取，而不是随机插队的方式获取。synchronized是非公平锁，而ReentrantLock是两种都可以实现，不过默认是非公平锁1、synchronized的局限性synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁由jvm实现，用户不需要显示的释放锁，非常方便，然而synchronized也有一定的局限性，例如： 当线程尝试获取锁的时候，如果获取不到锁会一直阻塞，这个阻塞的过程，用户无法控制 如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待JDK1.5之后发布，加入了Doug Lea实现的java.util.concurrent包。包内提供了Lock类，用来提供更多扩展的加锁功能。Lock弥补了synchronized的局限，提供了更加细粒度的加锁功能。2、ReentrantLock基本使用我们使用3个线程来对一个共享变量++操作，先使用synchronized实现，然后使用ReentrantLock实现。synchronized方式：public class Demo2 { private static int num = 0; private static synchronized void add() { num++; } public static class T extends Thread { @Override public void run() { for (int i = 0; i &lt; 10000; i++) { Demo2.add(); } } } public static void main(String[] args) throws InterruptedException { T t1 = new T(); T t2 = new T(); T t3 = new T(); t1.start(); t2.start(); t3.start(); t1.join(); t2.join(); t3.join(); System.out.println(Demo2.num); }}ReentrantLock方式：import java.util.concurrent.locks.ReentrantLock;public class Demo3 { private static int num = 0; private static ReentrantLock lock = new ReentrantLock(); private static void add() { lock.lock(); try { num++; } finally { lock.unlock(); } } public static class T extends Thread { @Override public void run() { for (int i = 0; i &lt; 10000; i++) { Demo3.add(); } } } public static void main(String[] args) throws InterruptedException { T t1 = new T(); T t2 = new T(); T t3 = new T(); t1.start(); t2.start(); t3.start(); t1.join(); t2.join(); t3.join(); System.out.println(Demo3.num); }}ReentrantLock的使用过程： 创建锁：ReentrantLock lock = new ReentrantLock(); 获取锁：lock.lock() 释放锁：lock.unlock();对比上面的代码，与关键字synchronized相比，ReentrantLock锁有明显的操作过程，开发人员必须手动的指定何时加锁，何时释放锁，正是因为这样手动控制，ReentrantLock对逻辑控制的灵活度要远远胜于关键字synchronized，上面代码需要注意lock.unlock()一定要放在finally中，否则，若程序出现了异常，锁没有释放，那么其他线程就再也没有机会获取这个锁了。3、ReentrantLock获取锁的过程是可中断的对于synchronized关键字，如果一个线程在等待获取锁，最终只有2种结果： 要么获取到锁然后继续后面的操作 要么一直等待，直到其他线程释放锁为止而ReentrantLock提供了另外一种可能，就是在等待获取锁的过程中（发起获取锁请求到还未获取到锁这段时间内）是可以被中断的，也就是说在等待锁的过程中，程序可以根据需要取消获取锁的请求。有些使用这个操作是非常有必要的。比如：你和好朋友越好一起去打球，如果你等了半小时朋友还没到，突然你接到一个电话，朋友由于突发状况，不能来了，那么你一定达到回府。中断操作正是提供了一套类似的机制，如果一个线程正在等待获取锁，那么它依然可以收到一个通知，被告知无需等待，可以停止工作了。示例代码：import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantLock;public class Demo6 { private static ReentrantLock lock1 = new ReentrantLock(false); private static ReentrantLock lock2 = new ReentrantLock(false); public static class T extends Thread { int lock; public T(String name, int lock) { super(name); this.lock = lock; } @Override public void run() { try { if (this.lock == 1) { lock1.lockInterruptibly(); TimeUnit.SECONDS.sleep(1); lock2.lockInterruptibly(); } else { lock2.lockInterruptibly(); TimeUnit.SECONDS.sleep(1); lock1.lockInterruptibly(); } } catch (InterruptedException e) { System.out.println(\"中断标志:\" + this.isInterrupted()); e.printStackTrace(); } finally { if (lock1.isHeldByCurrentThread()) { lock1.unlock(); } if (lock2.isHeldByCurrentThread()) { lock2.unlock(); } } } } public static void main(String[] args) throws InterruptedException { T t1 = new T(\"t1\", 1); T t2 = new T(\"t2\", 2); t1.start(); t2.start(); }}先运行一下上面代码，发现程序无法结束，使用jstack查看线程堆栈信息，发现2个线程死锁了。Found one Java-level deadlock:=============================\"t2\": waiting for ownable synchronizer 0x0000000717380c20, (a java.util.concurrent.locks.ReentrantLock$NonfairSync), which is held by \"t1\"\"t1\": waiting for ownable synchronizer 0x0000000717380c50, (a java.util.concurrent.locks.ReentrantLock$NonfairSync), which is held by \"t2lock1被线程t1占用，lock2被线程t2占用，线程t1在等待获取lock2，线程t2在等待获取lock1，都在相互等待获取对方持有的锁，最终产生了死锁，如果是在synchronized关键字情况下发生了死锁现象，程序是无法结束的。我们对上面代码改造一下，线程t2一直无法获取到lock1，那么等待5秒之后，我们中断获取锁的操作。主要修改一下main方法，如下：T t1 = new T(\"t1\", 1);T t2 = new T(\"t2\", 2);t1.start();t2.start();TimeUnit.SECONDS.sleep(5);t2.interrupt();新增了2行代码TimeUnit.SECONDS.sleep(5);t2.interrupt();，程序可以结束了，运行结果：java.lang.InterruptedException at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222) at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at com.itsoku.chat06.Demo6$T.run(Demo6.java:31)中断标志:false从上面信息中可以看出，代码的31行触发了异常，中断标志输出：falset2在31行一直获取不到lock1的锁，主线程中等待了5秒之后，t2线程调用了interrupt()方法，将线程的中断标志置为true，此时31行会触发InterruptedException异常，然后线程t2可以继续向下执行，释放了lock2的锁，然后线程t1可以正常获取锁，程序得以继续进行。线程发送中断信号触发InterruptedException异常之后，中断标志将被清空。关于获取锁的过程中被中断，注意几点: ReentrankLock中必须使用实例方法lockInterruptibly()获取锁时，在线程调用interrupt()方法之后，才会引发InterruptedException异常 线程调用interrupt()之后，线程的中断标志会被置为true 触发InterruptedException异常之后，线程的中断标志会被清空，即置为false 所以当线程调用interrupt()引发InterruptedException异常，中断标志的变化是:false-&gt;true-&gt;false4、ReentrantLock锁申请等待限时申请锁等待限时是什么意思？一般情况下，获取锁的时间我们是不知道的，synchronized关键字获取锁的过程中，只能等待其他线程把锁释放之后才能够有机会获取到锁。所以获取锁的时间有长有短。如果获取锁的时间能够设置超时时间，那就非常好了。ReentrantLock刚好提供了这样功能，给我们提供了获取锁限时等待的方法tryLock()，可以选择传入时间参数，表示等待指定的时间，无参则表示立即返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。tryLock无参方法看一下源码中tryLock方法：public boolean tryLock()返回boolean类型的值，此方法会立即返回，结果表示获取锁是否成功，示例：import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantLock;public class Demo8 { private static ReentrantLock lock1 = new ReentrantLock(false); public static class T extends Thread { public T(String name) { super(name); } @Override public void run() { try { System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"开始获取锁!\"); //获取锁超时时间设置为3秒，3秒内是否能否获取锁都会返回 if (lock1.tryLock()) { System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"获取到了锁!\"); //获取到锁之后，休眠5秒 TimeUnit.SECONDS.sleep(5); } else { System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"未能获取到锁!\"); } } catch (InterruptedException e) { e.printStackTrace(); } finally { if (lock1.isHeldByCurrentThread()) { lock1.unlock(); } } } } public static void main(String[] args) throws InterruptedException { T t1 = new T(\"t1\"); T t2 = new T(\"t2\"); t1.start(); t2.start(); }}代码中获取锁成功之后，休眠5秒，会导致另外一个线程获取锁失败，运行代码，输出：1563356291081:t2开始获取锁!1563356291081:t2获取到了锁!1563356291081:t1开始获取锁!1563356291081:t1未能获取到锁!tryLock有参方法可以明确设置获取锁的超时时间，该方法签名：public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException该方法在指定的时间内不管是否可以获取锁，都会返回结果，返回true，表示获取锁成功，返回false表示获取失败。此方法有2个参数，第一个参数是时间类型，是一个枚举，可以表示时、分、秒、毫秒等待，使用比较方便，第1个参数表示在时间类型上的时间长短。此方法在执行的过程中，如果调用了线程的中断interrupt()方法，会触发InterruptedException异常。import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantLock;public class Demo7 { private static ReentrantLock lock1 = new ReentrantLock(false); public static class T extends Thread { public T(String name) { super(name); } @Override public void run() { try { System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"开始获取锁!\"); //获取锁超时时间设置为3秒，3秒内是否能否获取锁都会返回 if (lock1.tryLock(3, TimeUnit.SECONDS)) { System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"获取到了锁!\"); //获取到锁之后，休眠5秒 TimeUnit.SECONDS.sleep(5); } else { System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"未能获取到锁!\"); } } catch (InterruptedException e) { e.printStackTrace(); } finally { if (lock1.isHeldByCurrentThread()) { lock1.unlock(); } } } } public static void main(String[] args) throws InterruptedException { T t1 = new T(\"t1\"); T t2 = new T(\"t2\"); t1.start(); t2.start(); }}程序中调用了ReentrantLock的实例方法tryLock(3, TimeUnit.SECONDS)，表示获取锁的超时时间是3秒，3秒后不管是否能否获取锁，该方法都会有返回值，获取到锁之后，内部休眠了5秒，会导致另外一个线程获取锁失败。运行程序，输出：1563355512901:t2开始获取锁!1563355512901:t1开始获取锁!1563355512902:t2获取到了锁!1563355515904:t1未能获取到锁!输出结果中分析，t2获取到锁了，然后休眠了5秒，t1获取锁失败，t1打印了2条信息，时间相差3秒左右。关于tryLock()方法和tryLock(long timeout, TimeUnit unit)方法，说明一下： 都会返回boolean值，结果表示获取锁是否成功 tryLock()方法，不管是否获取成功，都会立即返回；而有参的tryLock方法会尝试在指定的时间内去获取锁，中间会阻塞的现象，在指定的时间之后会不管是否能够获取锁都会返回结果 tryLock()方法不会响应线程的中断方法；而有参的tryLock方法会响应线程的中断方法，而触发InterruptedException异常，这个从2个方法的声明上可以可以看出来5、ReentrantLock其他常用的方法 isHeldByCurrentThread：实例方法，判断当前线程是否持有ReentrantLock的锁，上面代码中有使用过。获取锁的4种方法对比 获取锁的方法 是否立即响应(不会阻塞) 是否响应中断 lock() × × lockInterruptibly() × √ tryLock() √ × tryLock(long timeout, TimeUnit unit) × √ 6、总结 ReentrantLock可以实现公平锁和非公平锁 ReentrantLock默认实现的是非公平锁 ReentrantLock的获取锁和释放锁必须成对出现，锁了几次，也要释放几次 释放锁的操作必须放在finally中执行 lockInterruptibly()实例方法可以相应线程的中断方法，调用线程的interrupt()方法时，lockInterruptibly()方法会触发InterruptedException异常 关于InterruptedException异常说一下，看到方法声明上带有 throws InterruptedException，表示该方法可以相应线程中断，调用线程的interrupt()方法时，这些方法会触发InterruptedException异常，触发InterruptedException时，线程的中断中断状态会被清除。所以如果程序由于调用interrupt()方法而触发InterruptedException异常，线程的标志由默认的false变为ture，然后又变为false 实例方法tryLock()会尝试获取锁，会立即返回，返回值表示是否获取成功 实例方法tryLock(long timeout, TimeUnit unit)会在指定的时间内尝试获取锁，指定的时间内是否能够获取锁，都会返回，返回值表示是否获取锁成功，该方法会响应线程的中断5、悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。synchronized关键字和Lock的实现类都是悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。显式的锁定之后再操作同步资源//=============悲观锁的调用方式public synchronized void m1(){ //加锁后的业务逻辑......}// 保证多个线程使用的是同一个lock对象的前提下ReentrantLock lock = new ReentrantLock();public void m2() { lock.lock(); try { // 操作同步资源 }finally { lock.unlock(); }}6、乐观锁//=============乐观锁的调用方式// 保证多个线程使用的是同一个AtomicIntegerprivate AtomicInteger atomicInteger = new AtomicInteger();atomicInteger.incrementAndGet();​\t\t乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命，再抢乐观锁一般有两种实现方式： 采用版本号机制 CAS（Compare-and-Swap，即比较并替换）算法实现7、八锁案例1、JDK源码(notify方法)2、8种锁的案例实际体现在3个地方 作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁； 作用于代码块，对括号里配置的对象加锁。 作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；1、标准访问有ab两个线程，请问先打印邮件还是短信class Phone //资源类{ public synchronized void sendEmail() { System.out.println(\"-------sendEmail\"); } public synchronized void sendSMS() { System.out.println(\"-------sendSMS\"); }}public class Lock8Demo{ public static void main(String[] args)//一切程序的入口，主线程 { Phone phone = new Phone();//资源类1 new Thread(() -&gt; { phone.sendEmail(); },\"a\").start(); //暂停毫秒 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone.sendSMS(); },\"b\").start(); }}-------sendEmail-------sendSMS2、sendEmail方法暂停3秒钟，请问先打印邮件还是短信class Phone //资源类{ public synchronized void sendEmail() { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-------sendEmail\"); } public synchronized void sendSMS() { System.out.println(\"-------sendSMS\"); }}public class Lock8Demo{ public static void main(String[] args)//一切程序的入口，主线程 { Phone phone = new Phone();//资源类1 new Thread(() -&gt; { phone.sendEmail(); },\"a\").start(); //暂停毫秒 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone.sendSMS(); },\"b\").start(); }}-------sendEmail-------sendSMS1-2结论一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些synchronized方法锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法3、新增一个普通的hello方法，请问先打印邮件还是helloclass Phone //资源类{ public synchronized void sendEmail() { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-------sendEmail\"); } public synchronized void sendSMS() { System.out.println(\"-------sendSMS\"); } public void hello() { System.out.println(\"-------hello\"); }}public class Lock8Demo{ public static void main(String[] args)//一切程序的入口，主线程 { Phone phone = new Phone();//资源类1 new Thread(() -&gt; { phone.sendEmail(); },\"a\").start(); //暂停毫秒 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone.hello(); },\"b\").start(); }}-------hello-------sendEmail4、有两部手机，请问先打印邮件还是短信class Phone //资源类{ public synchronized void sendEmail() { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-------sendEmail\"); } public synchronized void sendSMS() { System.out.println(\"-------sendSMS\"); } public void hello() { System.out.println(\"-------hello\"); }}public class Lock8Demo{ public static void main(String[] args)//一切程序的入口，主线程 { Phone phone = new Phone();//资源类1 Phone phone2 = new Phone();//资源类2 new Thread(() -&gt; { phone.sendEmail(); },\"a\").start(); //暂停毫秒 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone2.sendSMS(); },\"b\").start(); }}-------sendSMS-------sendEmail3-4结论加个普通方法后发现和同步锁无关,hello换成两个对象后，不是同一把锁了，情况立刻变化。5、两个静态同步方法，同1部手机，请问先打印邮件还是短信class Phone //资源类{ public static synchronized void sendEmail() { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-------sendEmail\"); } public static synchronized void sendSMS() { System.out.println(\"-------sendSMS\"); } public void hello() { System.out.println(\"-------hello\"); }}public class Lock8Demo{ public static void main(String[] args)//一切程序的入口，主线程 { Phone phone = new Phone();//资源类1 new Thread(() -&gt; { phone.sendEmail(); },\"a\").start(); //暂停毫秒 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone.sendSMS(); },\"b\").start(); }}-------sendEmail-------sendSMS6、两个静态同步方法， 2部手机，请问先打印邮件还是短信class Phone //资源类{ public static synchronized void sendEmail() { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-------sendEmail\"); } public static synchronized void sendSMS() { System.out.println(\"-------sendSMS\"); } public void hello() { System.out.println(\"-------hello\"); }}public class Lock8Demo{ public static void main(String[] args)//一切程序的入口，主线程 { Phone phone = new Phone();//资源类1 Phone phone2 = new Phone();//资源类2 new Thread(() -&gt; { phone.sendEmail(); },\"a\").start(); //暂停毫秒 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone2.sendSMS(); },\"b\").start(); }}-------sendEmail-------sendSMS5-6结论都换成静态同步方法后，情况又变化三种 synchronized 锁的内容有一些差别:对于普通同步方法，锁的是当前实例对象，通常指this,具体的一部部手机,所有的普通同步方法用的都是同一把锁——实例对象本身，对于静态同步方法，锁的是当前类的Class对象，如Phone.class唯一的一个模板对于同步方法块，锁的是 synchronized 括号内的对象7、1个静态同步方法，1个普通同步方法,同1部手机，请问先打印邮件还是短信class Phone //资源类{ public static synchronized void sendEmail() { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-------sendEmail\"); } public synchronized void sendSMS() { System.out.println(\"-------sendSMS\"); } public void hello() { System.out.println(\"-------hello\"); }}public class Lock8Demo{ public static void main(String[] args)//一切程序的入口，主线程 { Phone phone = new Phone();//资源类1 new Thread(() -&gt; { phone.sendEmail(); },\"a\").start(); //暂停毫秒 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone.sendSMS(); },\"b\").start(); }}-------sendSMS-------sendEmail8、1个静态同步方法，1个普通同步方法,2部手机，请问先打印邮件还是短信class Phone //资源类{ public static synchronized void sendEmail() { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-------sendEmail\"); } public synchronized void sendSMS() { System.out.println(\"-------sendSMS\"); } public void hello() { System.out.println(\"-------hello\"); }}public class Lock8Demo{ public static void main(String[] args)//一切程序的入口，主线程 { Phone phone = new Phone();//资源类1 Phone phone2 = new Phone();//资源类2 new Thread(() -&gt; { phone.sendEmail(); },\"a\").start(); //暂停毫秒 try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone2.sendSMS(); },\"b\").start(); }}-------sendSMS-------sendEmail7-8结论当一个线程试图访问同步代码时它首先必须得到锁，退出或抛出异常时必须释放锁。所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身,本类this也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。8、公平锁和非公平锁在大多数情况下，锁的申请都是非公平的，也就是说，线程1首先请求锁A，接着线程2也请求了锁A。那么当锁A可用时，是线程1可获得锁还是线程2可获得锁呢？这是不一定的，系统只是会从这个锁的等待队列中随机挑选一个，因此不能保证其公平性。这就好比买票不排队，大家都围在售票窗口前，售票员忙的焦头烂额，也顾及不上谁先谁后，随便找个人出票就完事了，最终导致的结果是，有些人可能一直买不到票。而公平锁，则不是这样，它会按照到达的先后顺序获得资源。公平锁的一大特点是：它不会产生饥饿现象，只要你排队，最终还是可以等到资源的；synchronized关键字默认是有jvm内部实现控制的，是非公平锁。而ReentrantLock运行开发者自己设置锁的公平性。看一下jdk中ReentrantLock的源码，2个构造方法：public ReentrantLock() { sync = new NonfairSync();}public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();}默认构造方法创建的是非公平锁。第2个构造方法，有个fair参数，当fair为true的时候创建的是公平锁，公平锁看起来很不错，不过要实现公平锁，系统内部肯定需要维护一个有序队列，因此公平锁的实现成本比较高，性能相对于非公平锁来说相对低一些。因此，在默认情况下，锁是非公平的，如果没有特别要求，则不建议使用公平锁。公平锁和非公平锁在程序调度上是很不一样，来一个公平锁示例看一下：import java.util.concurrent.locks.ReentrantLock;public class Demo5 { private static int num = 0; private static ReentrantLock fairLock = new ReentrantLock(true); public static class T extends Thread { public T(String name) { super(name); } @Override public void run() { for (int i = 0; i &lt; 5; i++) { fairLock.lock(); try { System.out.println(this.getName() + \"获得锁!\"); } finally { fairLock.unlock(); } } } } public static void main(String[] args) throws InterruptedException { T t1 = new T(\"t1\"); T t2 = new T(\"t2\"); T t3 = new T(\"t3\"); t1.start(); t2.start(); t3.start(); t1.join(); t2.join(); t3.join(); }}看一下输出的结果，锁是按照先后顺序获得的。修改一下上面代码，改为非公平锁试试，如下：ReentrantLock fairLock = new ReentrantLock(false);从ReentrantLock卖票编码演示公平和非公平现象import java.util.concurrent.locks.ReentrantLock;class Ticket{ private int number = 30; ReentrantLock lock = new ReentrantLock(); public void sale() { lock.lock(); try { if(number &gt; 0) { System.out.println(Thread.currentThread().getName()+\"卖出第：\\t\"+(number--)+\"\\t 还剩下:\"+number); } }catch (Exception e){ e.printStackTrace(); }finally { lock.unlock(); } }}public class SaleTicketDemo{ public static void main(String[] args) { Ticket ticket = new Ticket(); new Thread(() -&gt; { for (int i = 0; i &lt;35; i++) ticket.sale(); },\"a\").start(); new Thread(() -&gt; { for (int i = 0; i &lt;35; i++) ticket.sale(); },\"b\").start(); new Thread(() -&gt; { for (int i = 0; i &lt;35; i++) ticket.sale(); },\"c\").start(); }}生活中，排队讲求先来后到视为公平。程序中的公平性也是符合请求锁的绝对时间的，其实就是 FIFO，否则视为不公平1、源码解读​\t\t按序排队公平锁，就是判断同步队列是否还有先驱节点的存在(我前面还有人吗?)，如果没有先驱节点才能获取锁；先占先得非公平锁，是不管这个事的，只要能抢获到同步状态就可以2、为什么会有公平锁/非公平锁的设计为什么默认非公平？ 恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。 使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。3、使⽤公平锁会有什么问题公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”4、什么时候用公平？什么时候用非公平？如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；否则那就用公平锁，大家公平使用。9、可重入锁(又名递归锁)是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。如果是1个有 synchronized 修饰的递归调用方法，程序第2次进入被自己阻塞了岂不是天大的笑话，出现了作茧自缚。所以Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。1、“可重入锁”这四个字分开来解释：可：可以。重：再次。入：进入。锁：同步锁。进入什么:进入同步域（即同步代码块/方法或显式锁锁定的代码）一句话:一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁2、可重入锁种类1、隐式锁（即synchronized关键字使用的锁）默认是可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。简单的来说就是：在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。同步块public class ReEntryLockDemo{ public static void main(String[] args){ final Object objectLockA = new Object(); new Thread(() -&gt; { synchronized (objectLockA){ System.out.println(\"-----外层调用\"); synchronized (objectLockA){ System.out.println(\"-----中层调用\"); synchronized (objectLockA){ System.out.println(\"-----内层调用\"); } } } },\"a\").start(); }}同步方法public class ReEntryLockDemo{ public synchronized void m1(){ System.out.println(\"-----m1\"); m2(); } public synchronized void m2(){ System.out.println(\"-----m2\"); m3(); } public synchronized void m3(){ System.out.println(\"-----m3\"); } public static void main(String[] args){ ReEntryLockDemo reEntryLockDemo = new ReEntryLockDemo(); reEntryLockDemo.m1(); }}2、显式锁（即Lock）也有ReentrantLock这样的可重入锁。public class Demo4 { private static int num = 0; private static ReentrantLock lock = new ReentrantLock(); private static void add() { lock.lock(); lock.lock(); try { num++; } finally { lock.unlock(); lock.unlock(); } } public static class T extends Thread { @Override public void run() { for (int i = 0; i &lt; 10000; i++) { Demo4.add(); } } } public static void main(String[] args) throws InterruptedException { T t1 = new T(); T t2 = new T(); T t3 = new T(); t1.start(); t2.start(); t3.start(); t1.join(); t2.join(); t3.join(); System.out.println(Demo4.num); }}上面代码中add()方法中，当一个线程进入的时候，会执行2次获取锁的操作，运行程序可以正常结束，并输出和期望值一样的30000，假如ReentrantLock是不可重入的锁，那么同一个线程第2次获取锁的时候由于前面的锁还未释放而导致死锁，程序是无法正常结束的。ReentrantLock命名也挺好的Re entrant Lock，和其名字一样，可重入锁。代码中还有几点需要注意： lock()方法和unlock()方法需要成对出现，锁了几次，也要释放几次，否则后面的线程无法获取锁了；可以将add中的unlock删除一个事实，上面代码运行将无法结束 unlock()方法放在finally中执行，保证不管程序是否有异常，锁必定会释放/** * @create 2020-05-14 11:59 * 在一个Synchronized修饰的方法或代码块的内部调用本类的其他Synchronized修饰的方法或代码块时，是永远可以得到锁的 */public class ReEntryLockDemo{ static Lock lock = new ReentrantLock(); public static void main(String[] args){ new Thread(() -&gt; { lock.lock(); try { System.out.println(\"----外层调用lock\"); lock.lock(); try { System.out.println(\"----内层调用lock\"); }finally { // 这里故意注释，实现加锁次数和释放次数不一样 // 由于加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直在等待。 lock.unlock(); // 正常情况，加锁几次就要解锁几次 } }finally { lock.unlock(); } },\"a\").start(); new Thread(() -&gt; { lock.lock(); try { System.out.println(\"b thread----外层调用lock\"); }finally { lock.unlock(); } },\"b\").start(); }}3、Synchronized的重入的实现机理​\t\t每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。​\t\t当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。​\t\t在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。​\t\t当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。10、死锁​\t\t死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。1、产生死锁主要原因 系统资源不足 进程运行推进的顺序不合适 资源分配不当public class DeadLockDemo{ public static void main(String[] args){ final Object objectLockA = new Object(); final Object objectLockB = new Object(); new Thread(() -&gt; { synchronized (objectLockA){ System.out.println(Thread.currentThread().getName()+\"\\t\"+\"自己持有A，希望获得B\"); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (objectLockB) { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"A-------已经获得B\"); } } },\"A\").start(); new Thread(() -&gt; { synchronized (objectLockB){ System.out.println(Thread.currentThread().getName()+\"\\t\"+\"自己持有B，希望获得A\"); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (objectLockA){ System.out.println(Thread.currentThread().getName()+\"\\t\"+\"B-------已经获得A\"); } } },\"B\").start(); }}2、如何排查死锁 纯命令jps -ljstack 进程编号 图形化jconsole五、线程间通信1、面试题：两个线程打印两个线程，一个线程打印1-52，另一个打印字母A-Z打印顺序为12A34B…5152Z1、synchronized实现package com.xue.thread; import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock; class ShareDataOne//资源类{ private int number = 0;//初始值为零的一个变量 public synchronized void increment() throws InterruptedException { //1判断 if(number !=0 ) { this.wait(); } //2干活 ++number; System.out.println(Thread.currentThread().getName()+\"\\t\"+number); //3通知 this.notifyAll(); } public synchronized void decrement() throws InterruptedException { // 1判断 if (number == 0) { this.wait(); } // 2干活 --number; System.out.println(Thread.currentThread().getName() + \"\\t\" + number); // 3通知 this.notifyAll(); }} /** * * @Description: *现在两个线程， * 可以操作初始值为零的一个变量， * 实现一个线程对该变量加1，一个线程对该变量减1， * 交替，来10轮。 * @author xialei * * * 笔记：Java里面如何进行工程级别的多线程编写 * 1 多线程变成模板（套路）-----上 * 1.1 线程 操作 资源类 * 1.2 高内聚 低耦合 * 2 多线程变成模板（套路）-----下 * 2.1 判断 * 2.2 干活 * 2.3 通知 */public class NotifyWaitDemoOne{ public static void main(String[] args){ ShareDataOne sd = new ShareDataOne(); new Thread(() -&gt; { for (int i = 1; i &lt; 10; i++) { try { sd.increment(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }, \"A\").start(); new Thread(() -&gt; { for (int i = 1; i &lt; 10; i++) { try { sd.decrement(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }, \"B\").start(); }}/* * * * 2 多线程变成模板（套路）-----下 * 2.1 判断 * 2.2 干活 * 2.3 通知 * 3 防止虚假唤醒用while * * * */2、换成4个线程​\t\t换成4个线程会导致错误，虚假唤醒​\t\t原因：在java多线程判断时，不能用if，程序出事出在了判断上面，突然有一添加的线程进到if了，突然中断了交出控制权，没有进行验证，而是直接走下去了，加了两次，甚至多次3、4个线程解决方案解决虚假唤醒：查看API，java.lang.Object中断和虚假唤醒是可能产生的，所以要用loop循环，if只判断一次，while是只要唤醒就要拉回来再判断一次。if换成while4、java8新版实现class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.unlock(); } }package com.xue.thread; import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock; import org.omg.IOP.Codec; class ShareData//资源类{ private int number = 0;//初始值为零的一个变量 private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void increment() throws InterruptedException { lock.lock(); try { //判断 while(number!=0) { condition.await(); } //干活 ++number; System.out.println(Thread.currentThread().getName()+\" \\t \"+number); //通知 condition.signalAll(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } public void decrement() throws InterruptedException { lock.lock(); try { //判断 while(number!=1) { condition.await(); } //干活 --number; System.out.println(Thread.currentThread().getName()+\" \\t \"+number); //通知 condition.signalAll(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } /*public synchronized void increment() throws InterruptedException { //判断 while(number!=0) { this.wait(); } //干活 ++number; System.out.println(Thread.currentThread().getName()+\" \\t \"+number); //通知 this.notifyAll();; } public synchronized void decrement() throws InterruptedException { //判断 while(number!=1) { this.wait(); } //干活 --number; System.out.println(Thread.currentThread().getName()+\" \\t \"+number); //通知 this.notifyAll(); }*/} /** * * @Description: *现在两个线程， * 可以操作初始值为零的一个变量， * 实现一个线程对该变量加1，一个线程对该变量减1， * 交替，来10轮。 * * * 笔记：Java里面如何进行工程级别的多线程编写 * 1 多线程变成模板（套路）-----上 * 1.1 线程 操作 资源类 * 1.2 高内聚 低耦合 * 2 多线程变成模板（套路）-----下 * 2.1 判断 * 2.2 干活 * 2.3 通知 */public class NotifyWaitDemo{ public static void main(String[] args) { ShareData sd = new ShareData(); new Thread(() -&gt; { for (int i = 1; i &lt;= 10; i++) { try { sd.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"A\").start(); new Thread(() -&gt; { for (int i = 1; i &lt;= 10; i++) { try { sd.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"B\").start(); new Thread(() -&gt; { for (int i = 1; i &lt;= 10; i++) { try { sd.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"C\").start(); new Thread(() -&gt; { for (int i = 1; i &lt;= 10; i++) { try { sd.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"D\").start(); }}/* * * * 2 多线程变成模板（套路）-----下 * 2.1 判断 * 2.2 干活 * 2.3 通知 * 3 防止虚假唤醒用while * * * */2、线程间定制化调用通信1、有顺序通知，需要有标识位2、有一个锁Lock，3把钥匙Condition3、判断标志位4、输出线程名+第几次+第几轮5、修改标志位，通知下一个package com.xue.thread; import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock; class ShareResource{ private int number = 1;//1:A 2:B 3:C private Lock lock = new ReentrantLock(); private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private Condition c3 = lock.newCondition(); public void print5(int totalLoopNumber) { lock.lock(); try { //1 判断 while(number != 1) { //A 就要停止 c1.await(); } //2 干活 for (int i = 1; i &lt;=5; i++) { System.out.println(Thread.currentThread().getName()+\"\\t\"+i+\"\\t totalLoopNumber: \"+totalLoopNumber); } //3 通知 number = 2; c2.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } public void print10(int totalLoopNumber) { lock.lock(); try { //1 判断 while(number != 2) { //A 就要停止 c2.await(); } //2 干活 for (int i = 1; i &lt;=10; i++) { System.out.println(Thread.currentThread().getName()+\"\\t\"+i+\"\\t totalLoopNumber: \"+totalLoopNumber); } //3 通知 number = 3; c3.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } public void print15(int totalLoopNumber) { lock.lock(); try { //1 判断 while(number != 3) { //A 就要停止 c3.await(); } //2 干活 for (int i = 1; i &lt;=15; i++) { System.out.println(Thread.currentThread().getName()+\"\\t\"+i+\"\\t totalLoopNumber: \"+totalLoopNumber); } //3 通知 number = 1; c1.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } /** * * @Description: * 多线程之间按顺序调用，实现A-&gt;B-&gt;C * 三个线程启动，要求如下： * * AA打印5次，BB打印10次，CC打印15次 * 接着 * AA打印5次，BB打印10次，CC打印15次 * ......来10轮 * */public class ThreadOrderAccess{ public static void main(String[] args) { ShareResource sr = new ShareResource(); new Thread(() -&gt; { for (int i = 1; i &lt;=10; i++) { sr.print5(i); } }, \"AA\").start(); new Thread(() -&gt; { for (int i = 1; i &lt;=10; i++) { sr.print10(i); } }, \"BB\").start(); new Thread(() -&gt; { for (int i = 1; i &lt;=10; i++) { sr.print15(i); } }, \"CC\").start(); }}六、LockSupport与线程中断1、线程中断机制1、如何停止、中断一个运行中的线程？？2、什么是中断？首先\t\t一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。其次\t\t在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制——中断。​\t\t中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true；接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，此时究竟该做什么需要你自己写代码实现。​\t\t每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设为true；可以在别的线程中调用，也可以在自己的线程中调用3、中断的相关API方法 public void interrupt() 实例方法，实例方法interrupt()仅仅是设置线程的中断状态为true，不会停止线程 public static boolean interrupted() 静态方法，Thread.interrupted(); 判断线程是否被中断，并清除当前中断状态这个方法做了两件事：1 返回当前线程的中断状态2 将当前线程的中断状态设为false 这个方法有点不好理解，因为连续调用两次的结果可能不一样。 public boolean isInterrupted() 实例方法，判断当前线程是否被中断（通过检查中断标志位） 2、如何使用中断标识停止线程？在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑。1、通过一个volatile变量实现public class InterruptDemo{ \tpublic volatile static boolean exit = false; \tpublic static class T extends Thread { @Override public void run() { while (true) { //循环处理业务 if (exit) { break; } } } } public static void setExit() { exit = true; } public static void main(String[] args) throws InterruptedException { T t = new T(); t.start(); TimeUnit.SECONDS.sleep(3); setExit(); }}代码中启动了一个线程，线程的run方法中有个死循环，内部通过exit变量的值来控制是否退出。TimeUnit.SECONDS.sleep(3);让主线程休眠3秒，此处为什么使用TimeUnit？TimeUnit使用更方便一些，能够很清晰的控制休眠时间，底层还是转换为Thread.sleep实现的。程序有个重点：volatile关键字，exit变量必须通过这个修饰，如果把这个去掉，程序无法正常退出。volatile控制了变量在多线程中的可见性。2、通过AtomicBooleanpublic class StopThreadDemo{ private final static AtomicBoolean atomicBoolean = new AtomicBoolean(true); public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { while(atomicBoolean.get()) { try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----hello\"); } }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } atomicBoolean.set(false); }}3、通过Thread类自带的中断api方法实现 实例方法interrupt()，没有返回值| public void interrupt() | 实例方法，调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真正立刻停止线程。 || ———————– | ———————————————————— | 实例方法isInterrupted，返回布尔值| public boolean isInterrupted() | 实例方法，获取中断标志位的当前值是什么，判断当前线程是否被中断（通过检查中断标志位），默认是false || —————————— | ———————————————————— |public class InterruptDemo{ public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { while(true) { if(Thread.currentThread().isInterrupted()) { System.out.println(\"-----t1 线程被中断了，break，程序结束\"); break; } System.out.println(\"-----hello\"); } }, \"t1\"); t1.start(); System.out.println(\"**************\"+t1.isInterrupted()); //暂停5毫秒 try { TimeUnit.MILLISECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } t1.interrupt(); System.out.println(\"**************\"+t1.isInterrupted()); }}运行上面的程序，程序可以正常结束。线程内部有个中断标志，当调用线程的interrupt()实例方法之后，线程的中断标志会被置为true，可以通过线程的实例方法isInterrupted()获取线程的中断标志。4、当前线程的中断标识为true，是不是就立刻停止？具体来说，当对一个线程，调用 interrupt() 时：① 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以， interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。② 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。public class InterruptDemo2 { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 300; i++) { System.out.println(\"-------\" + i); } System.out.println(\"after t1.interrupt()--第2次---: \" + Thread.currentThread().isInterrupted()); }, \"t1\"); t1.start(); System.out.println(\"before t1.interrupt()----: \" + t1.isInterrupted()); //实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程 t1.interrupt(); //活动状态,t1线程还在执行中 try { TimeUnit.MILLISECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"after t1.interrupt()--第1次---: \" + t1.isInterrupted()); //非活动状态,t1线程不在执行中，已经结束执行了。 try { TimeUnit.MILLISECONDS.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"after t1.interrupt()--第3次---: \" + t1.isInterrupted()); }}中断只是一种协同机制，修改中断标识位仅此而已，不是立刻stop打断5、静态方法Thread.interrupted()/** * 作用是测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态， * 第二次再调用时中断状态已经被清除，将返回一个false。 */public class InterruptDemo{ public static void main(String[] args) throws InterruptedException { System.out.println(Thread.currentThread().getName()+\"---\"+Thread.interrupted()); System.out.println(Thread.currentThread().getName()+\"---\"+Thread.interrupted()); System.out.println(\"111111\"); Thread.currentThread().interrupt(); System.out.println(\"222222\"); System.out.println(Thread.currentThread().getName()+\"---\"+Thread.interrupted()); System.out.println(Thread.currentThread().getName()+\"---\"+Thread.interrupted()); }}| public static boolean interrupted() | 静态方法，Thread.interrupted(); 判断线程是否被中断，并清除当前中断状态，类似i++这个方法做了两件事：1 返回当前线程的中断状态2 将当前线程的中断状态设为false 这个方法有点不好理解，因为连续调用两次的结果可能不一样。 || ———————————– | ———————————————————— |都会返回中断状态，两者对比6、总结线程中断相关的方法：interrupt()方法是一个实例方法\t\t它通知目标线程中断，也就是设置目标线程的中断标志位为true，中断标志位表示当前线程已经被中断了。isInterrupted()方法也是一个实例方法\t\t它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志Thread类的静态方法interrupted()\t\t返回当前线程的中断状态(boolean类型)且将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置false3、LockSupport是什么LockSupport位于java.util.concurrent（简称juc）包中，算是juc中一个基础类，juc中很多地方都会使用LockSupport，非常重要，希望大家一定要掌握。关于线程等待/唤醒的方法，前面的文章中我们已经讲过2种了： 方式1：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程 方式2：使用juc包中Condition的await()方法让线程等待，使用signal()方法唤醒线程LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。下面这句话，后面详细说LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程4、线程等待唤醒机制1、3种让线程等待和唤醒的方法 使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程 使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程 LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程2、Object类中的wait和notify方法实现线程等待和唤醒/** * * 要求：t1线程等待3秒钟，3秒钟后t2线程唤醒t1线程继续工作 * * 1 正常程序演示 * * 以下异常情况： * 2 wait方法和notify方法，两个都去掉同步代码块后看运行效果 * 2.1 异常情况 * Exception in thread \"t1\" java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method) * Exception in thread \"t2\" java.lang.IllegalMonitorStateException at java.lang.Object.notify(Native Method) * 2.2 结论 * Object类中的wait、notify、notifyAll用于线程等待和唤醒的方法，都必须在synchronized内部执行（必须用到关键字synchronized）。 * * 3 将notify放在wait方法前面 * 3.1 程序一直无法结束 * 3.2 结论 * 先wait后notify、notifyall方法，等待中的线程才会被唤醒，否则无法唤醒 */public class LockSupportDemo{ public static void main(String[] args)//main方法，主线程一切程序入口 { Object objectLock = new Object(); //同一把锁，类似资源类 new Thread(() -&gt; { synchronized (objectLock) { try { objectLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒了\"); },\"t1\").start(); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3L); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { synchronized (objectLock) { objectLock.notify(); } //objectLock.notify(); /*synchronized (objectLock) { try { objectLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }*/ },\"t2\").start(); }}1、正常public class LockSupportDemo{ public static void main(String[] args)//main方法，主线程一切程序入口 { Object objectLock = new Object(); //同一把锁，类似资源类 new Thread(() -&gt; { synchronized (objectLock) { try { objectLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒了\"); },\"t1\").start(); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3L); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { synchronized (objectLock) { objectLock.notify(); } },\"t2\").start(); }}2、异常1/** * 要求：t1线程等待3秒钟，3秒钟后t2线程唤醒t1线程继续工作 * 以下异常情况： * 2 wait方法和notify方法，两个都去掉同步代码块后看运行效果 * 2.1 异常情况 * Exception in thread \"t1\" java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method) * Exception in thread \"t2\" java.lang.IllegalMonitorStateException at java.lang.Object.notify(Native Method) * 2.2 结论 * Object类中的wait、notify、notifyAll用于线程等待和唤醒的方法，都必须在synchronized内部执行（必须用到关键字synchronized）。 */public class LockSupportDemo{ public static void main(String[] args)//main方法，主线程一切程序入口 { Object objectLock = new Object(); //同一把锁，类似资源类 new Thread(() -&gt; { try { objectLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒了\"); },\"t1\").start(); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3L); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { objectLock.notify(); },\"t2\").start(); }}wait方法和notify方法，两个都去掉同步代码块3、异常2/** * * 要求：t1线程等待3秒钟，3秒钟后t2线程唤醒t1线程继续工作 * * 3 将notify放在wait方法前先执行，t1先notify了，3秒钟后t2线程再执行wait方法 * 3.1 程序一直无法结束 * 3.2 结论 * 先wait后notify、notifyall方法，等待中的线程才会被唤醒，否则无法唤醒 */public class LockSupportDemo{ public static void main(String[] args)//main方法，主线程一切程序入口 { Object objectLock = new Object(); //同一把锁，类似资源类 new Thread(() -&gt; { synchronized (objectLock) { objectLock.notify(); } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"通知了\"); },\"t1\").start(); //t1先notify了，3秒钟后t2线程再执行wait方法 try { TimeUnit.SECONDS.sleep(3L); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { synchronized (objectLock) { try { objectLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒了\"); },\"t2\").start(); }}将notify放在wait方法前面程序无法执行，无法唤醒4、总结wait和notify方法必须要在同步块或者方法里面，且成对出现使用先wait后notify才OK3、Condition接口中的await后signal方法实现线程的等待和唤醒1、正常public class LockSupportDemo2{ public static void main(String[] args) { Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); new Thread(() -&gt; { lock.lock(); try { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"start\"); condition.await(); System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } },\"t1\").start(); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3L); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { lock.lock(); try { condition.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"通知了\"); },\"t2\").start(); }}2、异常1/** * 异常： * condition.await();和condition.signal();都触发了IllegalMonitorStateException异常 * * 原因：调用condition中线程等待和唤醒的方法的前提是，要在lock和unlock方法中,要有锁才能调用 */public class LockSupportDemo2{ public static void main(String[] args) { Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); new Thread(() -&gt; { try { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"start\"); condition.await(); System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒\"); } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\").start(); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3L); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { try { condition.signal(); } catch (Exception e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"通知了\"); },\"t2\").start(); }}去掉lock/unlockcondition.await();和 condition.signal();都触发了 IllegalMonitorStateException异常。结论：lock、unlock对里面才能正确调用调用condition中线程等待和唤醒的方法3、异常2/** * 异常： * 程序无法运行 * * 原因：先await()后signal才OK，否则线程无法被唤醒 */public class LockSupportDemo2{ public static void main(String[] args) { Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); new Thread(() -&gt; { lock.lock(); try { condition.signal(); System.out.println(Thread.currentThread().getName()+\"\\t\"+\"signal\"); } catch (Exception e) { e.printStackTrace(); }finally { lock.unlock(); } },\"t1\").start(); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3L); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { lock.lock(); try { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"等待被唤醒\"); condition.await(); System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒\"); } catch (Exception e) { e.printStackTrace(); }finally { lock.unlock(); } },\"t2\").start(); }}先signal后await4、总结Condtion中的线程等待和唤醒方法之前，需要先获取锁一定要先await后signal，不要反了4、Object和Condition使用的限制条件线程先要获得并持有锁，必须在锁块(synchronized或lock)中必须要先等待后唤醒，线程才能够被唤醒5、LockSupport类中的park等待和unpark唤醒通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。​\t\tLockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)，permit只有两个值1和零，默认是零。可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。1、主要方法阻塞park() /park(Object blocker)阻塞当前线程/阻塞传入的具体线程唤醒unpark(Thread thread)唤醒处于阻塞状态的指定线程2、代码正常+无锁块要求public class LockSupportDemo3{ public static void main(String[] args) { //正常使用+不需要锁块Thread t1 = new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+\" \"+\"1111111111111\"); LockSupport.park(); System.out.println(Thread.currentThread().getName()+\" \"+\"2222222222222------end被唤醒\");},\"t1\");t1.start();//暂停几秒钟线程try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }LockSupport.unpark(t1);System.out.println(Thread.currentThread().getName()+\" -----LockSupport.unparrk() invoked over\"); }}之前错误的先唤醒后等待，LockSupport照样支持public class T1{ public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"\\t\"+System.currentTimeMillis()); LockSupport.park(); System.out.println(Thread.currentThread().getName()+\"\\t\"+System.currentTimeMillis()+\"---被叫醒\"); },\"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } LockSupport.unpark(t1); System.out.println(Thread.currentThread().getName()+\"\\t\"+System.currentTimeMillis()+\"---unpark over\"); }}七、集合不安全1、线程不安全错误java.util.ConcurrentModificationExceptionArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常 并发修改异常2、List不安全List&lt;String&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt;30 ; i++) { new Thread(()-&gt;{ list.add(UUID.randomUUID().toString().substring(0,8)); System.out.println(list); },String.valueOf(i)).start(); } // 看ArrayList的源码public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;}// 没有synchronized线程不安全1、 解决方案1、VectorList list = new Vector&lt;&gt;();// 看Vector的源码public synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;}// 有synchronized线程安全2、CollectionsList list = Collections.synchronizedList(new ArrayList&lt;&gt;());// Collections提供了方法synchronizedList保证list是同步线程安全的// 那HashMap，HashSet是线程安全的吗？也不是,所以有同样的线程安全方法3、写时复制(JUC)List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();4、CopyOnWrite理论/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */public boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); }}​\t\tCopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。添加元素后，再将原容器的引用指向新的容器setArray(newElements)。这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。3、Set不安全Set&lt;String&gt; set = new HashSet&lt;&gt;();//线程不安全 Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();//线程安全HashSet底层数据结构是什么？HashMap ? 但HashSet的add是放一个值，而HashMap是放K、V键值对 public HashSet() { map = new HashMap&lt;&gt;();} private static final Object PRESENT = new Object(); public boolean add(E e) { return map.put(e, PRESENT)==null;}4、Map不安全Map&lt;String,String&gt; map = new HashMap&lt;&gt;();//线程不安全Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();//线程安全import java.util.*;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.CopyOnWriteArrayList;import java.util.concurrent.CopyOnWriteArraySet;/** * 请举例说明集合类是不安全的 */public class NotSafeDemo { public static void main(String[] args) { Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 0; i &lt;30 ; i++) { new Thread(()-&gt;{ map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(0,8)); System.out.println(map); },String.valueOf(i)).start(); } } private static void setNoSafe() { Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); for (int i = 0; i &lt;30 ; i++) { new Thread(()-&gt;{ set.add(UUID.randomUUID().toString().substring(0,8)); System.out.println(set); },String.valueOf(i)).start(); } } private static void listNoSafe() { // List&lt;String&gt; list = Arrays.asList(\"a\",\"b\",\"c\"); // list.forEach(System.out::println); //写时复制 List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); // new CopyOnWriteArrayList&lt;&gt;(); //Collections.synchronizedList(new ArrayList&lt;&gt;()); //new Vector&lt;&gt;();//new ArrayList&lt;&gt;(); for (int i = 0; i &lt;30 ; i++) { new Thread(()-&gt;{ list.add(UUID.randomUUID().toString().substring(0,8)); System.out.println(list); },String.valueOf(i)).start(); } }} /** * 写时复制 CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加， 而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。 添加元素后，再将原容器的引用指向新的容器setArray(newElements)。 这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。 所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。 * * * * public boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); } } */八、JUC强大的辅助类1、CountDownLatch减少计数CountDownLatch称之为闭锁，它可以使一个或一批线程在闭锁上等待，等到其他线程执行完相应操作后，闭锁打开，这些等待的线程才可以继续执行。确切的说，闭锁在内部维护了一个倒计数器。通过该计数器的值来决定闭锁的状态，从而决定是否允许等待的线程继续执行。常用方法：public CountDownLatch(int count)：构造方法，count表示计数器的值，不能小于0，否者会报异常。public void await() throws InterruptedException：调用await()会让当前线程等待，直到计数器为0的时候，方法才会返回，此方法会响应线程中断操作。public boolean await(long timeout, TimeUnit unit) throws InterruptedException：限时等待，在超时之前，计数器变为了0，方法返回true，否者直到超时，返回false，此方法会响应线程中断操作。public void countDown()：让计数器减1CountDownLatch使用步骤： 创建CountDownLatch对象 调用其实例方法await()，让当前线程等待 调用countDown()方法，让计数器减1 当计数器变为0的时候，await()方法会返回package com.xue.thread;import java.util.concurrent.CountDownLatch; /** * * @Description: * *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。 * * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。 * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)， * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。 * * 解释：6个同学陆续离开教室后值班同学才可以关门。 * * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 */public class CountDownLatchDemo{ public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;=6; i++) //6个上自习的同学，各自离开教室的时间不一致 { new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+\"\\t 号同学离开教室\"); countDownLatch.countDown(); }, String.valueOf(i)).start(); } countDownLatch.await(); System.out.println(Thread.currentThread().getName()+\"\\t****** 班长关门走人，main线程是班长\"); }} CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)， 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。示例1假如有这样一个需求，当我们需要解析一个Excel里多个sheet的数据时，可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要统计解析总耗时。分析一下：解析每个sheet耗时可能不一样，总耗时就是最长耗时的那个操作。我们能够想到的最简单的做法是使用join，代码如下：import java.util.concurrent.TimeUnit;public class Demo1 { public static class T extends Thread { //休眠时间（秒） int sleepSeconds; public T(String name, int sleepSeconds) { super(name); this.sleepSeconds = sleepSeconds; } @Override public void run() { Thread ct = Thread.currentThread(); long startTime = System.currentTimeMillis(); System.out.println(startTime + \",\" + ct.getName() + \",开始处理!\"); try { //模拟耗时操作，休眠sleepSeconds秒 TimeUnit.SECONDS.sleep(this.sleepSeconds); } catch (InterruptedException e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(endTime + \",\" + ct.getName() + \",处理完毕,耗时:\" + (endTime - startTime)); } } public static void main(String[] args) throws InterruptedException { long starTime = System.currentTimeMillis(); T t1 = new T(\"解析sheet1线程\", 2); t1.start(); T t2 = new T(\"解析sheet2线程\", 5); t2.start(); t1.join(); t2.join(); long endTime = System.currentTimeMillis(); System.out.println(\"总耗时:\" + (endTime - starTime)); }}1563767560271,解析sheet1线程,开始处理!1563767560272,解析sheet2线程,开始处理!1563767562273,解析sheet1线程,处理完毕,耗时:20021563767565274,解析sheet2线程,处理完毕,耗时:5002总耗时:5005代码中启动了2个解析sheet的线程，第一个耗时2秒，第二个耗时5秒，最终结果中总耗时：5秒。上面的关键技术点是线程的join()方法，此方法会让当前线程等待被调用的线程完成之后才能继续。可以看一下join的源码，内部其实是在synchronized方法中调用了线程的wait方法，最后被调用的线程执行完毕之后，由jvm自动调用其notifyAll()方法，唤醒所有等待中的线程。这个notifyAll()方法是由jvm内部自动调用的，jdk源码中是看不到的，需要看jvm源码，有兴趣的同学可以去查一下。所以JDK不推荐在线程上调用wait、notify、notifyAll方法。而在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的这个功能。我们使用CountDownLatch来完成上面示例中使用join实现的功能，代码如下：import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;public class Demo2 { public static class T extends Thread { //休眠时间（秒） int sleepSeconds; CountDownLatch countDownLatch; public T(String name, int sleepSeconds, CountDownLatch countDownLatch) { super(name); this.sleepSeconds = sleepSeconds; this.countDownLatch = countDownLatch; } @Override public void run() { Thread ct = Thread.currentThread(); long startTime = System.currentTimeMillis(); System.out.println(startTime + \",\" + ct.getName() + \",开始处理!\"); try { //模拟耗时操作，休眠sleepSeconds秒 TimeUnit.SECONDS.sleep(this.sleepSeconds); } catch (InterruptedException e) { e.printStackTrace(); } finally { countDownLatch.countDown(); } long endTime = System.currentTimeMillis(); System.out.println(endTime + \",\" + ct.getName() + \",处理完毕,耗时:\" + (endTime - startTime)); } } public static void main(String[] args) throws InterruptedException { System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 start!\"); CountDownLatch countDownLatch = new CountDownLatch(2); long starTime = System.currentTimeMillis(); T t1 = new T(\"解析sheet1线程\", 2, countDownLatch); t1.start(); T t2 = new T(\"解析sheet2线程\", 5, countDownLatch); t2.start(); countDownLatch.await(); System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 end!\"); long endTime = System.currentTimeMillis(); System.out.println(\"总耗时:\" + (endTime - starTime)); }}1563767580511,main线程 start!1563767580513,解析sheet1线程,开始处理!1563767580513,解析sheet2线程,开始处理!1563767582515,解析sheet1线程,处理完毕,耗时:20021563767585515,解析sheet2线程,处理完毕,耗时:50021563767585515,main线程 end!总耗时:5003从结果中看出，效果和join实现的效果一样，代码中创建了计数器为2的CountDownLatch，主线程中调用countDownLatch.await();会让主线程等待，t1、t2线程中模拟执行耗时操作，最终在finally中调用了countDownLatch.countDown();,此方法每调用一次，CountDownLatch内部计数器会减1，当计数器变为0的时候，主线程中的await()会返回，然后继续执行。注意：上面的countDown()这个是必须要执行的方法，所以放在finally中执行。示例2等待指定的时间还是上面的示例，2个线程解析2个sheet，主线程等待2个sheet解析完成。主线程说，我等待2秒，你们还是无法处理完成，就不等待了，直接返回。如下代码：import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;public class Demo3 { public static class T extends Thread { //休眠时间（秒） int sleepSeconds; CountDownLatch countDownLatch; public T(String name, int sleepSeconds, CountDownLatch countDownLatch) { super(name); this.sleepSeconds = sleepSeconds; this.countDownLatch = countDownLatch; } @Override public void run() { Thread ct = Thread.currentThread(); long startTime = System.currentTimeMillis(); System.out.println(startTime + \",\" + ct.getName() + \",开始处理!\"); try { //模拟耗时操作，休眠sleepSeconds秒 TimeUnit.SECONDS.sleep(this.sleepSeconds); } catch (InterruptedException e) { e.printStackTrace(); } finally { countDownLatch.countDown(); } long endTime = System.currentTimeMillis(); System.out.println(endTime + \",\" + ct.getName() + \",处理完毕,耗时:\" + (endTime - startTime)); } } public static void main(String[] args) throws InterruptedException { System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 start!\"); CountDownLatch countDownLatch = new CountDownLatch(2); long starTime = System.currentTimeMillis(); T t1 = new T(\"解析sheet1线程\", 2, countDownLatch); t1.start(); T t2 = new T(\"解析sheet2线程\", 5, countDownLatch); t2.start(); boolean result = countDownLatch.await(2, TimeUnit.SECONDS); System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 end!\"); long endTime = System.currentTimeMillis(); System.out.println(\"主线程耗时:\" + (endTime - starTime) + \",result:\" + result); }}1563767637316,main线程 start!1563767637320,解析sheet1线程,开始处理!1563767637320,解析sheet2线程,开始处理!1563767639321,解析sheet1线程,处理完毕,耗时:20011563767639322,main线程 end!主线程耗时:2004,result:false1563767642322,解析sheet2线程,处理完毕,耗时:5002从输出结果中可以看出，线程2耗时了5秒，主线程耗时了2秒，主线程中调用countDownLatch.await(2, TimeUnit.SECONDS);，表示最多等2秒，不管计数器是否为0，await方法都会返回，若等待时间内，计数器变为0了，立即返回true，否则超时后返回false。示例32个CountDown结合使用的示例有3个人参见跑步比赛，需要先等指令员发指令枪后才能开跑，所有人都跑完之后，指令员喊一声，大家跑完了。示例代码：import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;public class Demo4 { public static class T extends Thread { //跑步耗时（秒） int runCostSeconds; CountDownLatch commanderCd; CountDownLatch countDown; public T(String name, int runCostSeconds, CountDownLatch commanderCd, CountDownLatch countDown) { super(name); this.runCostSeconds = runCostSeconds; this.commanderCd = commanderCd; this.countDown = countDown; } @Override public void run() { //等待指令员枪响 try { commanderCd.await(); } catch (InterruptedException e) { e.printStackTrace(); } Thread ct = Thread.currentThread(); long startTime = System.currentTimeMillis(); System.out.println(startTime + \",\" + ct.getName() + \",开始跑!\"); try { //模拟耗时操作，休眠runCostSeconds秒 TimeUnit.SECONDS.sleep(this.runCostSeconds); } catch (InterruptedException e) { e.printStackTrace(); } finally { countDown.countDown(); } long endTime = System.currentTimeMillis(); System.out.println(endTime + \",\" + ct.getName() + \",跑步结束,耗时:\" + (endTime - startTime)); } } public static void main(String[] args) throws InterruptedException { System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 start!\"); CountDownLatch commanderCd = new CountDownLatch(1); CountDownLatch countDownLatch = new CountDownLatch(3); long starTime = System.currentTimeMillis(); T t1 = new T(\"小张\", 2, commanderCd, countDownLatch); t1.start(); T t2 = new T(\"小李\", 5, commanderCd, countDownLatch); t2.start(); T t3 = new T(\"路人甲\", 10, commanderCd, countDownLatch); t3.start(); //主线程休眠5秒,模拟指令员准备发枪耗时操作 TimeUnit.SECONDS.sleep(5); System.out.println(System.currentTimeMillis() + \",枪响了，大家开始跑\"); commanderCd.countDown(); countDownLatch.await(); long endTime = System.currentTimeMillis(); System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"所有人跑完了，主线程耗时:\" + (endTime - starTime)); }}1563767691087,main线程 start!1563767696092,枪响了，大家开始跑1563767696092,小张,开始跑!1563767696092,小李,开始跑!1563767696092,路人甲,开始跑!1563767698093,小张,跑步结束,耗时:20011563767701093,小李,跑步结束,耗时:50011563767706093,路人甲,跑步结束,耗时:100011563767706093,main所有人跑完了，主线程耗时:15004代码中，t1、t2、t3启动之后，都阻塞在commanderCd.await();，主线程模拟发枪准备操作耗时5秒，然后调用commanderCd.countDown();模拟发枪操作，此方法被调用以后，阻塞在commanderCd.await();的3个线程会向下执行。主线程调用countDownLatch.await();之后进行等待，每个人跑完之后，调用countDown.countDown();通知一下countDownLatch让计数器减1，最后3个人都跑完了，主线程从countDownLatch.await();返回继续向下执行。手写一个并行处理任务的工具类import org.springframework.util.CollectionUtils;import java.util.List;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.function.Consumer;import java.util.stream.Collectors;import java.util.stream.Stream;public class TaskDisposeUtils { //并行线程数 public static final int POOL_SIZE; static { POOL_SIZE = Integer.max(Runtime.getRuntime().availableProcessors(), 5); } /** * 并行处理，并等待结束 * * @param taskList 任务列表 * @param consumer 消费者 * @param &lt;T&gt; * @throws InterruptedException */ public static &lt;T&gt; void dispose(List&lt;T&gt; taskList, Consumer&lt;T&gt; consumer) throws InterruptedException { dispose(true, POOL_SIZE, taskList, consumer); } /** * 并行处理，并等待结束 * * @param moreThread 是否多线程执行 * @param poolSize 线程池大小 * @param taskList 任务列表 * @param consumer 消费者 * @param &lt;T&gt; * @throws InterruptedException */ public static &lt;T&gt; void dispose(boolean moreThread, int poolSize, List&lt;T&gt; taskList, Consumer&lt;T&gt; consumer) throws InterruptedException { if (CollectionUtils.isEmpty(taskList)) { return; } if (moreThread &amp;&amp; poolSize &gt; 1) { poolSize = Math.min(poolSize, taskList.size()); ExecutorService executorService = null; try { executorService = Executors.newFixedThreadPool(poolSize); CountDownLatch countDownLatch = new CountDownLatch(taskList.size()); for (T item : taskList) { executorService.execute(() -&gt; { try { consumer.accept(item); } finally { countDownLatch.countDown(); } }); } countDownLatch.await(); } finally { if (executorService != null) { executorService.shutdown(); } } } else { for (T item : taskList) { consumer.accept(item); } } } public static void main(String[] args) throws InterruptedException { //生成1-10的10个数字，放在list中，相当于10个任务 List&lt;Integer&gt; list = Stream.iterate(1, a -&gt; a + 1).limit(10).collect(Collectors.toList()); //启动多线程处理list中的数据，每个任务休眠时间为list中的数值 TaskDisposeUtils.dispose(list, item -&gt; { try { long startTime = System.currentTimeMillis(); TimeUnit.SECONDS.sleep(item); long endTime = System.currentTimeMillis(); System.out.println(System.currentTimeMillis() + \",任务\" + item + \"执行完毕，耗时:\" + (endTime - startTime)); } catch (InterruptedException e) { e.printStackTrace(); } }); //上面所有任务处理完毕完毕之后，程序才能继续 System.out.println(list + \"中的任务都处理完毕!\"); }}运行代码输出：1563769828130,任务1执行完毕，耗时:10001563769829130,任务2执行完毕，耗时:20001563769830131,任务3执行完毕，耗时:30011563769831131,任务4执行完毕，耗时:40011563769832131,任务5执行完毕，耗时:50011563769833130,任务6执行完毕，耗时:60001563769834131,任务7执行完毕，耗时:70011563769835131,任务8执行完毕，耗时:80011563769837131,任务9执行完毕，耗时:90011563769839131,任务10执行完毕，耗时:10001[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]中的任务都处理完毕!TaskDisposeUtils是一个并行处理的工具类，可以传入n个任务内部使用线程池进行处理，等待所有任务都处理完成之后，方法才会返回。比如我们发送短信，系统中有1万条短信，我们使用上面的工具，每次取100条并行发送，待100个都处理完毕之后，再取一批按照同样的逻辑发送。2、CyclicBarrier循环栅栏CyclicBarrier通常称为循环屏障。它和CountDownLatch很相似，都可以使线程先等待然后再执行。不过CountDownLatch是使一批线程等待另一批线程执行完后再执行；而CyclicBarrier只是使等待的线程达到一定数目后再让它们继续执行。故而CyclicBarrier内部也有一个计数器,计数器的初始值在创建对象时通过构造参数指定,如下所示：public CyclicBarrier(int parties) { this(parties, null);}每调用一次await()方法都将使阻塞的线程数+1，只有阻塞的线程数达到设定值时屏障才会打开，允许阻塞的所有线程继续执行。除此之外，CyclicBarrier还有几点需要注意的地方: CyclicBarrier的计数器可以重置而CountDownLatch不行，这意味着CyclicBarrier实例可以被重复使用而CountDownLatch只能被使用一次。而这也是循环屏障循环二字的语义所在。 CyclicBarrier允许用户自定义barrierAction操作，这是个可选操作，可以在创建CyclicBarrier对象时指定public CyclicBarrier(int parties, Runnable barrierAction) { if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;}一旦用户在创建CyclicBarrier对象时设置了barrierAction参数，则在阻塞线程数达到设定值屏障打开前，会调用barrierAction的run()方法完成用户自定义的操作。package com.xue.thread; import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier; /** * * * CyclicBarrier * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是， * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞， * 直到最后一个线程到达屏障时，屏障才会开门，所有 * 被屏障拦截的线程才会继续干活。 * 线程进入屏障通过CyclicBarrier的await()方法。 * * 集齐7颗龙珠就可以召唤神龙 */public class CyclicBarrierDemo{ private static final int NUMBER = 7; public static void main(String[] args) { //CyclicBarrier(int parties, Runnable barrierAction) CyclicBarrier cyclicBarrier = new CyclicBarrier(NUMBER, ()-&gt;{System.out.println(\"*****集齐7颗龙珠就可以召唤神龙\");}) ; for (int i = 1; i &lt;= 7; i++) { new Thread(() -&gt; { try { System.out.println(Thread.currentThread().getName()+\"\\t 星龙珠被收集 \"); cyclicBarrier.await(); } catch (InterruptedException | BrokenBarrierException e) { // TODO Auto-generated catch block e.printStackTrace(); } }, String.valueOf(i)).start(); } }} CyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是， 让一组线程到达一个屏障（也可以叫同步点）时被阻塞， 直到最后一个线程到达屏障时，屏障才会开门，所有 被屏障拦截的线程才会继续干活。 线程进入屏障通过CyclicBarrier的await()方法。示例1 简单使用CyclicBarrier公司组织旅游，大家都有经历过，10个人，中午到饭点了，需要等到10个人都到了才能开饭，先到的人坐那等着，代码如下：import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;public class Demo1 { public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10); public static class T extends Thread { int sleep; public T(String name, int sleep) { super(name); this.sleep = sleep; } @Override public void run() { try { //模拟休眠 TimeUnit.SECONDS.sleep(sleep); long starTime = System.currentTimeMillis(); //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续 cyclicBarrier.await(); long endTime = System.currentTimeMillis(); System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } } public static void main(String[] args) throws InterruptedException { for (int i = 1; i &lt;= 10; i++) { new T(\"员工\" + i, i).start(); } }}员工1,sleep:1 等待了9000(ms),开始吃饭了！员工9,sleep:9 等待了1000(ms),开始吃饭了！员工8,sleep:8 等待了2001(ms),开始吃饭了！员工7,sleep:7 等待了3001(ms),开始吃饭了！员工6,sleep:6 等待了4001(ms),开始吃饭了！员工4,sleep:4 等待了6000(ms),开始吃饭了！员工5,sleep:5 等待了5000(ms),开始吃饭了！员工10,sleep:10 等待了0(ms),开始吃饭了！员工2,sleep:2 等待了7999(ms),开始吃饭了！员工3,sleep:3 等待了7000(ms),开始吃饭了！代码中模拟了10个员工上桌吃饭的场景，等待所有员工都到齐了才能开发，可以看到第10个员工最慢，前面的都在等待第10个员工，员工1等待了9秒，上面代码中调用cyclicBarrier.await();会让当前线程等待。当10个员工都调用了cyclicBarrier.await();之后，所有处于等待中的员工都会被唤醒，然后继续运行。示例2 循环使用CyclicBarrier对示例1进行改造一下，吃饭完毕之后，所有人都去车上，待所有人都到车上之后，驱车去下一景点玩。import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;public class Demo2 { public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10); public static class T extends Thread { int sleep; public T(String name, int sleep) { super(name); this.sleep = sleep; } //等待吃饭 void eat() { try { //模拟休眠 TimeUnit.SECONDS.sleep(sleep); long starTime = System.currentTimeMillis(); //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续 cyclicBarrier.await(); long endTime = System.currentTimeMillis(); System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\"); //休眠sleep时间，模拟当前员工吃饭耗时 TimeUnit.SECONDS.sleep(sleep); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } //等待所有人到齐之后，开车去下一站 void drive() { try { long starTime = System.currentTimeMillis(); //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续 cyclicBarrier.await(); long endTime = System.currentTimeMillis(); System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),去下一景点的路上！\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } @Override public void run() { //等待所有人到齐之后吃饭，先到的人坐那等着，什么事情不要干 this.eat(); //等待所有人到齐之后开车去下一景点，先到的人坐那等着，什么事情不要干 this.drive(); } } public static void main(String[] args) throws InterruptedException { for (int i = 1; i &lt;= 10; i++) { new T(\"员工\" + i, i).start(); } }}员工10,sleep:10 等待了0(ms),开始吃饭了！员工5,sleep:5 等待了5000(ms),开始吃饭了！员工6,sleep:6 等待了4000(ms),开始吃饭了！员工9,sleep:9 等待了1001(ms),开始吃饭了！员工4,sleep:4 等待了6000(ms),开始吃饭了！员工3,sleep:3 等待了7000(ms),开始吃饭了！员工1,sleep:1 等待了9001(ms),开始吃饭了！员工2,sleep:2 等待了8000(ms),开始吃饭了！员工8,sleep:8 等待了2001(ms),开始吃饭了！员工7,sleep:7 等待了3000(ms),开始吃饭了！员工10,sleep:10 等待了0(ms),去下一景点的路上！员工1,sleep:1 等待了8998(ms),去下一景点的路上！员工5,sleep:5 等待了4999(ms),去下一景点的路上！员工4,sleep:4 等待了5999(ms),去下一景点的路上！员工3,sleep:3 等待了6998(ms),去下一景点的路上！员工2,sleep:2 等待了7998(ms),去下一景点的路上！员工9,sleep:9 等待了999(ms),去下一景点的路上！员工8,sleep:8 等待了1999(ms),去下一景点的路上！员工7,sleep:7 等待了2999(ms),去下一景点的路上！员工6,sleep:6 等待了3999(ms),去下一景点的路上！坑，又是员工10最慢，要提升效率了，不能吃的太多，得减肥。代码中CyclicBarrier相当于使用了2次，第一次用于等待所有人到达后开饭，第二次用于等待所有人上车后驱车去下一景点。注意一些先到的员工会在其他人到达之前，都处于等待状态（cyclicBarrier.await();会让当前线程阻塞），无法干其他事情，等到最后一个人到了会唤醒所有人，然后继续。 CyclicBarrier内部相当于有个计数器（构造方法传入的），每次调用await();后，计数器会减1，并且await()方法会让当前线程阻塞，等待计数器减为0的时候，所有在await()上等待的线程被唤醒，然后继续向下执行，此时计数器又会被还原为创建时的值，然后可以继续再次使用。示例3 最后到的人给大家上酒，然后开饭还是示例1中的例子，员工10是最后到达的，让所有人都久等了，那怎么办，得给所有人倒酒，然后开饭，代码如下：import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;public class Demo3 { public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10, () -&gt; { //模拟倒酒，花了2秒，又得让其他9个人等2秒 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"说，不好意思，让大家久等了，给大家倒酒赔罪!\"); }); public static class T extends Thread { int sleep; public T(String name, int sleep) { super(name); this.sleep = sleep; } @Override public void run() { try { //模拟休眠 TimeUnit.SECONDS.sleep(sleep); long starTime = System.currentTimeMillis(); //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续 cyclicBarrier.await(); long endTime = System.currentTimeMillis(); System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } } public static void main(String[] args) throws InterruptedException { for (int i = 1; i &lt;= 10; i++) { new T(\"员工\" + i, i).start(); } }}员工10说，不好意思，让大家久等了，给大家倒酒赔罪!员工10,sleep:10 等待了2000(ms),开始吃饭了！员工1,sleep:1 等待了11000(ms),开始吃饭了！员工2,sleep:2 等待了10000(ms),开始吃饭了！员工5,sleep:5 等待了7000(ms),开始吃饭了！员工7,sleep:7 等待了5000(ms),开始吃饭了！员工9,sleep:9 等待了3000(ms),开始吃饭了！员工4,sleep:4 等待了8000(ms),开始吃饭了！员工3,sleep:3 等待了9001(ms),开始吃饭了！员工8,sleep:8 等待了4001(ms),开始吃饭了！员工6,sleep:6 等待了6001(ms),开始吃饭了！代码中创建CyclicBarrier对象时，多传入了一个参数（内部是倒酒操作），先到的人先等待，待所有人都到齐之后，需要先给大家倒酒，然后唤醒所有等待中的人让大家开饭。从输出结果中我们发现，倒酒操作是由最后一个人操作的，最后一个人倒酒完毕之后，才唤醒所有等待中的其他员工，让大家开饭。示例4 其中一个人等待中被打断了员工5等待中，突然接了个电话，有点急事，然后就拿起筷子开吃了，其他人会怎么样呢？看着他吃么？import java.sql.Time;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;public class Demo4 { public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10); public static class T extends Thread { int sleep; public T(String name, int sleep) { super(name); this.sleep = sleep; } @Override public void run() { long starTime = 0, endTime = 0; try { //模拟休眠 TimeUnit.SECONDS.sleep(sleep); starTime = System.currentTimeMillis(); //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续 System.out.println(this.getName() + \"到了！\"); cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } endTime = System.currentTimeMillis(); System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\"); } } public static void main(String[] args) throws InterruptedException { for (int i = 1; i &lt;= 10; i++) { int sleep = 0; if (i == 10) { sleep = 10; } T t = new T(\"员工\" + i, sleep); t.start(); if (i == 5) { //模拟员工5接了个电话，将自己等待吃饭给打断了 TimeUnit.SECONDS.sleep(1); System.out.println(t.getName() + \",有点急事，我先开干了！\"); t.interrupt(); TimeUnit.SECONDS.sleep(2); } } }}员工4到了！员工3到了！员工5到了！员工1到了！员工2到了！员工5,有点急事，我先开干了！java.util.concurrent.BrokenBarrierException员工1,sleep:0 等待了1001(ms),开始吃饭了！ at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)员工3,sleep:0 等待了1001(ms),开始吃饭了！ at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)员工4,sleep:0 等待了1001(ms),开始吃饭了！ at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)员工2,sleep:0 等待了1001(ms),开始吃饭了！员工5,sleep:0 等待了1002(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.lang.InterruptedException at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.reportInterruptAfterWait(AbstractQueuedSynchronizer.java:2014) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2048) at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:234) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException员工6到了！ at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)员工9到了！ at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)员工8到了！员工7到了！员工6,sleep:0 等待了0(ms),开始吃饭了！员工7,sleep:0 等待了1(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)员工8,sleep:0 等待了1(ms),开始吃饭了！员工9,sleep:0 等待了1(ms),开始吃饭了！Disconnected from the target VM, address: '127.0.0.1:64413', transport: 'socket'java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)员工10到了！员工10,sleep:10 等待了0(ms),开始吃饭了！输出的信息看着有点乱，给大家理一理，员工5遇到急事，拿起筷子就是吃，这样好么，当然不好，他这么做了，后面看他这么做了都跟着这么做（这种场景是不是很熟悉，有一个人拿起筷子先吃起来，其他人都跟着上了），直接不等其他人了，拿起筷子就开吃了。CyclicBarrier遇到这种情况就是这么处理的。前面4个员工都在await()处等待着，员工5也在await()上等待着，等了1秒（TimeUnit.SECONDS.sleep(1);），接了个电话，然后给员工5发送中断信号后（t.interrupt();），员工5的await()方法会触发InterruptedException异常，此时其他等待中的前4个员工，看着5开吃了，自己立即也不等了，内部从await()方法中触发BrokenBarrierException异常，然后也开吃了，后面的6/7/8/9/10员工来了以后发现大家都开吃了，自己也不等了，6-10员工调用await()直接抛出了BrokenBarrierException异常，然后继续向下。结论： 内部有一个人把规则破坏了（接收到中断信号），其他人都不按规则来了，不会等待了 接收到中断信号的线程，await方法会触发InterruptedException异常，然后被唤醒向下运行 其他等待中 或者后面到达的线程，会在await()方法上触发BrokenBarrierException异常，然后继续执行示例5 其中一个人只愿意等的5秒基于示例1，员工1只愿意等的5秒，5s后如果大家还没到期，自己要开吃了，员工1开吃了，其他人会怎么样呢？import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;public class Demo5 { public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10); public static class T extends Thread { int sleep; public T(String name, int sleep) { super(name); this.sleep = sleep; } @Override public void run() { long starTime = 0, endTime = 0; try { //模拟休眠 TimeUnit.SECONDS.sleep(sleep); starTime = System.currentTimeMillis(); //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续 System.out.println(this.getName() + \"到了！\"); if (this.getName().equals(\"员工1\")) { cyclicBarrier.await(5, TimeUnit.SECONDS); } else { cyclicBarrier.await(); } } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } catch (TimeoutException e) { e.printStackTrace(); } endTime = System.currentTimeMillis(); System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\"); } } public static void main(String[] args) throws InterruptedException { for (int i = 1; i &lt;= 10; i++) { T t = new T(\"员工\" + i, i); t.start(); } }}员工1到了！员工2到了！员工3到了！员工4到了！员工5到了！员工6到了！员工1,sleep:1 等待了5001(ms),开始吃饭了！员工5,sleep:5 等待了1001(ms),开始吃饭了！java.util.concurrent.TimeoutException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435) at com.itsoku.chat15.Demo5$T.run(Demo5.java:32)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)员工6,sleep:6 等待了2(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException员工2,sleep:2 等待了4002(ms),开始吃饭了！ at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)员工3,sleep:3 等待了3001(ms),开始吃饭了！ at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)员工4,sleep:4 等待了2001(ms),开始吃饭了！ at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException员工7到了！ at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)员工7,sleep:7 等待了0(ms),开始吃饭了！ at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)员工8到了！员工8,sleep:8 等待了0(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)员工9到了！java.util.concurrent.BrokenBarrierException员工9,sleep:9 等待了0(ms),开始吃饭了！ at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException员工10到了！ at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)员工10,sleep:10 等待了0(ms),开始吃饭了！ at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)从输出结果中我们可以看到：1等待5秒之后，开吃了，其他等待人都开吃了，后面来的人不等待，直接开吃了。员工1调用有参await方法等待5秒之后，触发了TimeoutException异常，然后继续向下运行，其他的在5开吃之前已经等了一会的的几个员工，他们看到5开吃了，自己立即不等待了，也也开吃了（他们的await抛出了BrokenBarrierException异常）；还有几个员工在5开吃之后到达的，他们直接不等待了，直接抛出BrokenBarrierException异常，然后也开吃了。结论： 等待超时的方法 public int await(long timeout, TimeUnit unit) throws InterruptedException,BrokenBarrierException,TimeoutException 内部有一个人把规则破坏了（等待超时），其他人都不按规则来了，不会等待了 等待超时的线程，await方法会触发TimeoutException异常，然后被唤醒向下运行 其他等待中 或者后面到达的线程，会在await()方法上触发BrokenBarrierException异常，然后继续执行 示例6 重建规则示例5中改造一下，员工1等待5秒超时之后，开吃了，打破了规则，先前等待中的以及后面到达的都不按规则来了，都拿起筷子开吃。过了一会，导游重新告知大家，要按规则来，然后重建了规则，大家都按规则来了。import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;public class Demo6 { public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10); //规则是否已重建 public static boolean guizhe = false; public static class T extends Thread { int sleep; public T(String name, int sleep) { super(name); this.sleep = sleep; } @Override public void run() { long starTime = 0, endTime = 0; try { //模拟休眠 TimeUnit.SECONDS.sleep(sleep); starTime = System.currentTimeMillis(); //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续 System.out.println(this.getName() + \"到了！\"); if (!guizhe) { if (this.getName().equals(\"员工1\")) { cyclicBarrier.await(5, TimeUnit.SECONDS); } else { cyclicBarrier.await(); } } else { cyclicBarrier.await(); } } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } catch (TimeoutException e) { e.printStackTrace(); } endTime = System.currentTimeMillis(); System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\"); } } public static void main(String[] args) throws InterruptedException { for (int i = 1; i &lt;= 10; i++) { T t = new T(\"员工\" + i, i); t.start(); } //等待10秒之后，重置，重建规则 TimeUnit.SECONDS.sleep(15); cyclicBarrier.reset(); guizhe = true; System.out.println(\"---------------大家太皮了，请大家按规则来------------------\"); //再来一次 for (int i = 1; i &lt;= 10; i++) { T t = new T(\"员工\" + i, i); t.start(); } }}员工1到了！员工2到了！员工3到了！员工4到了！员工5到了！java.util.concurrent.TimeoutException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435) at com.itsoku.chat15.Demo6$T.run(Demo6.java:36)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)员工6到了！员工1,sleep:1 等待了5002(ms),开始吃饭了！员工6,sleep:6 等待了4(ms),开始吃饭了！员工4,sleep:4 等待了2004(ms),开始吃饭了！员工5,sleep:5 等待了1004(ms),开始吃饭了！员工3,sleep:3 等待了3002(ms),开始吃饭了！员工2,sleep:2 等待了4004(ms),开始吃饭了！员工7到了！员工7,sleep:7 等待了0(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)员工8到了！员工8,sleep:8 等待了0(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException员工9到了！ at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)员工9,sleep:9 等待了0(ms),开始吃饭了！ at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException员工10到了！ at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)员工10,sleep:10 等待了0(ms),开始吃饭了！ at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)---------------大家太皮了，请大家按规则来------------------员工1到了！员工2到了！员工3到了！员工4到了！员工5到了！员工6到了！员工7到了！员工8到了！员工9到了！员工10到了！员工10,sleep:10 等待了0(ms),开始吃饭了！员工1,sleep:1 等待了9000(ms),开始吃饭了！员工2,sleep:2 等待了8000(ms),开始吃饭了！员工3,sleep:3 等待了6999(ms),开始吃饭了！员工7,sleep:7 等待了3000(ms),开始吃饭了！员工6,sleep:6 等待了4000(ms),开始吃饭了！员工5,sleep:5 等待了5000(ms),开始吃饭了！员工4,sleep:4 等待了6000(ms),开始吃饭了！员工9,sleep:9 等待了999(ms),开始吃饭了！员工8,sleep:8 等待了1999(ms),开始吃饭了！第一次规则被打乱了，过了一会导游重建了规则（cyclicBarrier.reset();），接着又重来来了一次模拟等待吃饭的操作，正常了。CountDownLatch和CyclicBarrier的区别还是举例子说明一下：CountDownLatch示例主管相当于 CountDownLatch，干活的小弟相当于做事情的线程。老板交给主管了一个任务，让主管搞完之后立即上报给老板。主管下面有10个小弟，接到任务之后将任务划分为10个小任务分给每个小弟去干，主管一直处于等待状态（主管会调用await()方法，此方法会阻塞当前线程），让每个小弟干完之后通知一下主管（调用countDown()方法通知主管，此方法会立即返回），主管等到所有的小弟都做完了，会被唤醒，从await()方法上苏醒，然后将结果反馈给老板。期间主管会等待，会等待所有小弟将结果汇报给自己。而CyclicBarrier是一批线程让自己等待，等待所有的线程都准备好了，自己才能继续。3、Semaphore信号灯Semaphore（信号量）为多线程协作提供了更为强大的控制方法，前面的文章中我们学了synchronized和重入锁ReentrantLock，这2种锁一次都只能允许一个线程访问一个资源，而信号量可以控制有多少个线程可以同时访问特定的资源。Semaphore常用场景：限流举个例子：比如有个停车场，有5个空位，门口有个门卫，手中5把钥匙分别对应5个车位上面的锁，来一辆车，门卫会给司机一把钥匙，然后进去找到对应的车位停下来，出去的时候司机将钥匙归还给门卫。停车场生意比较好，同时来了100两车，门卫手中只有5把钥匙，同时只能放5辆车进入，其他车只能等待，等有人将钥匙归还给门卫之后，才能让其他车辆进入。上面的例子中门卫就相当于Semaphore，车钥匙就相当于许可证，车就相当于线程。1、Semaphore主要方法 Semaphore(int permits)：构造方法，参数表示许可证数量，用来创建信号量 Semaphore(int permits,boolean fair)：构造方法，当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量 void acquire() throws InterruptedException：从此信号量获取1个许可前线程将一直阻塞，相当于一辆车占了一个车位，此方法会响应线程中断，表示调用线程的interrupt方法，会使该方法抛出InterruptedException异常 void acquire(int permits) throws InterruptedException ：和acquire()方法类似，参数表示需要获取许可的数量；比如一个大卡车要入停车场，由于车比较大，需要申请3个车位才可以停放 void acquireUninterruptibly(int permits) ：和acquire(int permits) 方法类似，只是不会响应线程中断 boolean tryAcquire()：尝试获取1个许可，不管是否能够获取成功，都立即返回，true表示获取成功，false表示获取失败 boolean tryAcquire(int permits)：和tryAcquire()，表示尝试获取permits个许可 boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException：尝试在指定的时间内获取1个许可，获取成功返回true，指定的时间过后还是无法获取许可，返回false boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException：和tryAcquire(long timeout, TimeUnit unit)类似，多了一个permits参数，表示尝试获取permits个许可 void release()：释放一个许可，将其返回给信号量，相当于车从停车场出去时将钥匙归还给门卫 void release(int n)：释放n个许可 int availablePermits()：当前可用的许可数package com.xue.thread; import java.util.Random;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit; /** * * @Description: TODO(这里用一句话描述这个类的作用) * * 在信号量上我们定义两种操作： * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1）， * 要么一直等下去，直到有线程释放信号量，或超时。 * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。 * * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。 */public class SemaphoreDemo{ public static void main(String[] args) { Semaphore semaphore = new Semaphore(3);//模拟3个停车位 for (int i = 1; i &lt;=6; i++) //模拟6部汽车 { new Thread(() -&gt; { try { semaphore.acquire(); System.out.println(Thread.currentThread().getName()+\"\\t 抢到了车位\"); TimeUnit.SECONDS.sleep(new Random().nextInt(5)); System.out.println(Thread.currentThread().getName()+\"\\t------- 离开\"); } catch (InterruptedException e) { e.printStackTrace(); }finally { semaphore.release(); } }, String.valueOf(i)).start(); } }}在信号量上我们定义两种操作： acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。 release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。2、Semaphore简单的使用import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class Demo1 { static Semaphore semaphore = new Semaphore(2); public static class T extends Thread { public T(String name) { super(name); } @Override public void run() { Thread thread = Thread.currentThread(); try { semaphore.acquire(); System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可!\"); TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",释放许可!\"); } } } public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 10; i++) { new T(\"t-\" + i).start(); } }}代码中new Semaphore(2)创建了许可数量为2的信号量，每个线程获取1个许可，同时允许两个线程获取许可，从输出中也可以看出，同时有两个线程可以获取许可，其他线程需要等待已获取许可的线程释放许可之后才能运行。为获取到许可的线程会阻塞在acquire()方法上，直到获取到许可才能继续。3、获取许可之后不释放门卫（Semaphore）有点呆，司机进去的时候给了钥匙，出来的时候不归还，门卫也不会说什么。最终结果就是其他车辆都无法进入了。import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class Demo2 { static Semaphore semaphore = new Semaphore(2); public static class T extends Thread { public T(String name) { super(name); } @Override public void run() { Thread thread = Thread.currentThread(); try { semaphore.acquire(); System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可!\"); TimeUnit.SECONDS.sleep(3); System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",运行结束!\"); System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",当前可用许可数量:\" + semaphore.availablePermits()); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 10; i++) { new T(\"t-\" + i).start(); } }}上面程序运行后一直无法结束，观察一下代码，代码中获取许可后，没有释放许可的代码，最终导致，可用许可数量为0，其他线程无法获取许可，会在semaphore.acquire();处等待，导致程序无法结束。4、释放许可正确的姿势示例1中，在finally里面释放锁，会有问题么？如果获取锁的过程中发生异常，导致获取锁失败，最后finally里面也释放了许可，最终会怎么样，导致许可数量凭空增长了。示例代码：import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class Demo3 { static Semaphore semaphore = new Semaphore(1); public static class T extends Thread { public T(String name) { super(name); } @Override public void run() { Thread thread = Thread.currentThread(); try { semaphore.acquire(); System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可,当前可用许可数量:\" + semaphore.availablePermits()); //休眠100秒 TimeUnit.SECONDS.sleep(100); System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",运行结束!\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",当前可用许可数量:\" + semaphore.availablePermits()); } } public static void main(String[] args) throws InterruptedException { T t1 = new T(\"t1\"); t1.start(); //休眠1秒 TimeUnit.SECONDS.sleep(1); T t2 = new T(\"t2\"); t2.start(); //休眠1秒 TimeUnit.SECONDS.sleep(1); T t3 = new T(\"t3\"); t3.start(); //给t2和t3发送中断信号 t2.interrupt(); t3.interrupt(); }}程序中信号量许可数量为1，创建了3个线程获取许可，线程t1获取成功了，然后休眠100秒。其他两个线程阻塞在semaphore.acquire();方法处，代码中对线程t2、t3发送中断信号，我们看一下Semaphore中acquire的源码：public void acquire() throws InterruptedException这个方法会响应线程中断，主线程中对t2、t3发送中断信号之后，acquire()方法会触发InterruptedException异常，t2、t3最终没有获取到许可，但是他们都执行了finally中的释放许可的操作，最后导致许可数量变为了2，导致许可数量增加了。所以程序中释放许可的方式有问题。需要改进一下，获取许可成功才去释放锁。正确的释放锁的方式，如下：import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class Demo4 { static Semaphore semaphore = new Semaphore(1); public static class T extends Thread { public T(String name) { super(name); } @Override public void run() { Thread thread = Thread.currentThread(); //获取许可是否成功 boolean acquireSuccess = false; try { semaphore.acquire(); acquireSuccess = true; System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可,当前可用许可数量:\" + semaphore.availablePermits()); //休眠100秒 TimeUnit.SECONDS.sleep(5); System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",运行结束!\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { if (acquireSuccess) { semaphore.release(); } } System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",当前可用许可数量:\" + semaphore.availablePermits()); } } public static void main(String[] args) throws InterruptedException { T t1 = new T(\"t1\"); t1.start(); //休眠1秒 TimeUnit.SECONDS.sleep(1); T t2 = new T(\"t2\"); t2.start(); //休眠1秒 TimeUnit.SECONDS.sleep(1); T t3 = new T(\"t3\"); t3.start(); //给t2和t3发送中断信号 t2.interrupt(); t3.interrupt(); }}程序中增加了一个变量acquireSuccess用来标记获取许可是否成功，在finally中根据这个变量是否为true，来确定是否释放许可。5、在规定的时间内希望获取许可司机来到停车场，发现停车场已经满了，只能在外等待内部的车出来之后才能进去，但是要等多久，他自己也不知道，他希望等10分钟，如果还是无法进去，就不到这里停车了。Semaphore内部2个方法可以提供超时获取许可的功能：public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedExceptionpublic boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException在指定的时间内去尝试获取许可，如果能够获取到，返回true，获取不到返回false。import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class Demo5 { static Semaphore semaphore = new Semaphore(1); public static class T extends Thread { public T(String name) { super(name); } @Override public void run() { Thread thread = Thread.currentThread(); //获取许可是否成功 boolean acquireSuccess = false; try { //尝试在1秒内获取许可，获取成功返回true，否则返回false System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",尝试获取许可,当前可用许可数量:\" + semaphore.availablePermits()); acquireSuccess = semaphore.tryAcquire(1, TimeUnit.SECONDS); //获取成功执行业务代码 if (acquireSuccess) { System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可成功,当前可用许可数量:\" + semaphore.availablePermits()); //休眠5秒 TimeUnit.SECONDS.sleep(5); } else { System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可失败,当前可用许可数量:\" + semaphore.availablePermits()); } } catch (InterruptedException e) { e.printStackTrace(); } finally { if (acquireSuccess) { semaphore.release(); } } } } public static void main(String[] args) throws InterruptedException { T t1 = new T(\"t1\"); t1.start(); //休眠1秒 TimeUnit.SECONDS.sleep(1); T t2 = new T(\"t2\"); t2.start(); //休眠1秒 TimeUnit.SECONDS.sleep(1); T t3 = new T(\"t3\"); t3.start(); }}代码中许可数量为1，semaphore.tryAcquire(1, TimeUnit.SECONDS);：表示尝试在1秒内获取许可，获取成功立即返回true，超过1秒还是获取不到，返回false。线程t1获取许可成功，之后休眠了5秒，从输出中可以看出t2和t3都尝试了1秒，获取失败。6、其他一些使用说明 Semaphore默认创建的是非公平的信号量，什么意思呢？这个涉及到公平与非公平。举个例子：5个车位，允许5个车辆进去，来了100辆车，只能进去5辆，其他95在外面排队等着。里面刚好出来了1辆，此时刚好又来了10辆车，这10辆车是直接插队到其他95辆前面去，还是到95辆后面去排队呢？排队就表示公平，直接去插队争抢第一个，就表示不公平。对于停车场，排队肯定更好一些咯。不过对于信号量来说不公平的效率更高一些，所以默认是不公平的。 建议阅读以下Semaphore的源码，对常用的方法有个了解，不需要都记住，用的时候也方便查询就好。 方法中带有throws InterruptedException声明的，表示这个方法会响应线程中断信号，什么意思？表示调用线程的interrupt()方法，会让这些方法触发InterruptedException异常，即使这些方法处于阻塞状态，也会立即返回，并抛出InterruptedException异常，线程中断信号也会被清除。九、Java内存模型之JMMJMM(java内存模型)，由于并发程序要比串行程序复杂很多，其中一个重要原因是并发程序中数据访问一致性和安全性将会受到严重挑战。如何保证一个线程可以看到正确的数据呢？这个问题看起来很白痴。对于串行程序来说，根本就是小菜一碟，如果你读取一个变量，这个变量的值是1，那么你读取到的一定是1，就是这么简单的问题在并行程序中居然变得复杂起来。事实上，如果不加控制地任由线程胡乱并行，即使原本是1的数值，你也可能读到2。因此我们需要在深入了解并行机制的前提下，再定义一种规则，保证多个线程间可以有小弟，正确地协同工作。而JMM也就是为此而生的。1、计算机硬件存储体系计算机存储结构，从本地磁盘到主存到CPU缓存，也就是从硬盘到内存，到CPU。一般对应的程序的操作就是从数据库查数据到内存然后到CPU进行计算​\t\t因为有这么多级的缓存(cpu和物理主内存的速度不一致的)，CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题​\t\tJava虚拟机规范中试图定义一种Java内存模型（java Memory Model，简称JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。推导出我们需要知道JMM2、Java内存模型Java Memory Model​\t\tJMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。原则： JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的能干嘛？1 通过JMM来实现线程和主内存之间的抽象关系。2 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。3、JMM规范下，三大特性1、可见性​\t\tJava中普通的共享变量不保证可见性，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现”脏读”，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成线程脏读：如果没有可见性保证2、原子性指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰原子性是指操作是不可分的，要么全部一起执行，要么不执行。在java中，其表现在对于共享变量的某些操作，是不可分的，必须连续的完成。比如a++，对于共享变量a的操作，实际上会执行3个步骤：1.读取变量a的值，假如a=12.a的值+1，为23.将2值赋值给变量a，此时a的值应该为2这三个操作中任意一个操作，a的值如果被其他线程篡改了，那么都会出现我们不希望出现的结果。所以必须保证这3个操作是原子性的，在操作a++的过程中，其他线程不会改变a的值，如果在上面的过程中出现其他线程修改了a的值，在满足原子性的原则下，上面的操作应该失败。3、有序性对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提供性能，编译器和处理器通常会对指令序列进行重新排序。指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生”脏读”，简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测4、JMM规范下，多线程对变量的读写过程1、读取过程​\t\t由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:JMM定义了线程和主内存之间的抽象关系1 线程之间的共享变量存储在主内存中(从硬件角度来说就是内存条)2 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本(从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等)2、小总结 我们定义的所有共享变量都储存在物理主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝) 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级) 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)5、JMM规范下，多线程先行发生原则之happens-before在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者 代码重排序，那么这两个操作之间必须存在happens-before关系。1、先行发生原则说明​\t\t如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。​\t\t我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下有一个“先行发生”(Happens-Before)的原则限制和规矩这个原则非常重要： \t\t它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。2、happens-before总原则 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。 1+2+3 = 3+2+1 周一张三周二李四，假如有事情调换班可以的 6、happens-before之8条1、次序规则一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作；前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1。2、锁定规则一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作；public class HappenBeforeDemo{ static Object objectLock = new Object(); public static void main(String[] args) throws InterruptedException { //对于同一把锁objectLock，threadA一定先unlock同一把锁后B才能获得该锁， A 先行发生于B synchronized (objectLock) { } }}3、volatile变量规则对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后。4、传递规则如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；5、线程启动规则(Thread Start Rule)Thread对象的start()方法先行发生于此线程的每一个动作6、线程中断规则(Thread Interruption Rule)对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；可以通过Thread.interrupted()检测到是否发生中断7、线程终止规则(Thread Termination Rule)线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。8、对象终结规则(Finalizer Rule)一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始对象没有完成初始化之前，是不能调用finalized()方法的7、案例说明​\t\t假设存在线程A和B，线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？我们就这段简单的代码一次分析happens-before的规则（规则5、6、7、8 可以忽略，因为他们和这段代码毫无关系）：1 由于两个方法是由不同的线程调用，不在同一个线程中，所以肯定不满足程序次序规则；2 两个方法都没有使用锁，所以不满足锁定规则；3 变量不是用volatile修饰的，所以volatile变量规则不满足；4 传递规则肯定不满足；​\t\t所以我们无法通过happens-before原则推导出线程A happens-before线程B，虽然可以确认在时间上线程A优先于线程B指定，但就是无法确认线程B获得的结果是什么，所以这段代码不是线程安全的。那么怎么修复这段代码呢？ 把getter/setter方法都定义为synchronized方法 把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景十、volatile与Java内存模型1、被volatile修改的变量有2大特点 可见性 有序性2、volatile的内存语义 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。 当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量 所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。3、内存屏障（重点）1、生活case 没有管控，顺序难保 设定规则，禁止乱序 上海南京路步行街武警“人墙”当红灯2、内存屏障是什么​\t\t内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。​\t\t内存屏障之前的所有写操作都要回写到主内存，内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。一句话：对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。3、volatile凭什么可以保证可见性和有序性？？？内存屏障 (Memory Barriers / Fences)4、JVM中提供了四类内存屏障指令Unsafe.classUnsafe.javaUnsafe.cppOrderAccess.hpporderAccess_linux_x86.inline.hpp5、四大屏障分别是什么意思orderAccess_linux_x86.inline.hpp6、happens-before 之 volatile 变量规则 当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。 当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。 当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。 7、JMM 就将内存屏障插⼊策略分为 4 种 写 在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障 在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障 读 在每个 volatile 读操作的后⾯插⼊⼀个 LoadLoad 屏障 在每个 volatile 读操作的后⾯插⼊⼀个 LoadStore 屏障 4、volatile特性1、保证可见性保证不同线程对这个变量进行操作时的可见性，即变量一旦改变所有线程立即可见public class VolatileSeeDemo{ static boolean flag = true; //不加volatile，没有可见性 //static volatile boolean flag = true; //加了volatile，保证可见性 public static void main(String[] args) { new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+\"\\t come in\"); while (flag) { } System.out.println(Thread.currentThread().getName()+\"\\t flag被修改为false,退出.....\"); },\"t1\").start(); //暂停2秒钟后让main线程修改flag值 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } flag = false; System.out.println(\"main线程修改完成\"); }} 不加volatile，没有可见性，程序无法停止 加了volatile，保证可见性，程序可以停止线程t1中为何看不到被主线程main修改为false的flag的值？ 问题可能:1. 主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。2. 主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中更新获取flag最新的值。 我们的诉求：1.线程中修改了工作内存中的副本之后，立即将其刷新到主内存；2.工作内存中每次读取共享变量时，都去主内存中重新读取，然后拷贝到工作内存。 解决：使用volatile修饰共享变量，就可以达到上面的效果，被volatile修改的变量有以下特点：1. 线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存2. 线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存1、volatile变量的读写过程Java内存模型中定义的8种工作内存与主内存之间的原子操作read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令：lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用2、没有原子性1、volatile变量的复合操作(如i++)不具有原子性class MyNumber{ volatile int number = 0; public void addPlusPlus() { number++; }}public class VolatileNoAtomicDemo{ public static void main(String[] args) throws InterruptedException { MyNumber myNumber = new MyNumber(); for (int i = 1; i &lt;=10; i++) { new Thread(() -&gt; { for (int j = 1; j &lt;= 1000; j++) { myNumber.addPlusPlus(); } },String.valueOf(i)).start(); } //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"\\t\" + myNumber.number); }}从i++的字节码角度说明原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。public void add(){ i++; //不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分3步完成 }如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于add方法必须使用synchronized修饰，以便保证线程安全.多线程环境下，\"数据计算\"和\"数据赋值\"操作可能多次出现，即操作非原子。若数据在加载之后，若主内存count变量发生修改之后，由于线程工作内存中的值在此前已经加载，从而不会对变更操作做出相应变化，即私有内存和公共内存中变量不同步，进而导致数据不一致对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的。由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改共享变量的场景必须使用加锁同步2、读取赋值一个普通变量的情况当线程1对主内存对象发起read操作到write操作第一套流程的时间里，线程2随时都有可能对这个主内存对象发起第二套操作3、既然一修改就是可见，为什么还不能保证原子性？volatile主要是对其中部分指令做了处理要use(使用)一个变量的时候必需load(载入），要载入的时候必需从主内存read(读取）这样就解决了读的可见性。 写操作是把assign和store做了关联(在assign(赋值)后必需store(存储))。store(存储)后write(写入)。也就是做到了给一个变量赋值的时候一串关联指令直接把变量值写到主内存。就这样通过用的时候直接从主内存取，在赋值到直接写回主内存做到了内存可见性。注意蓝色框框的间隙。。。。。。o(╥﹏╥)o4、读取赋值一个volatile变量的情况 read-load-use 和 assign-store-write 成为了两个不可分割的原子操作，但是在use和assign之间依然有极小的一段真空期，有可能变量会被其他线程读取，导致写丢失一次...o(╥﹏╥)o但是无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了volatile变量不适合参与到依赖当前值的运算，如i = i + 1; i++;之类的那么依靠可见性的特点volatile可以用在哪些地方呢？ 通常volatile用做保存某个状态的boolean值or int值。《深入理解Java虚拟机》提到：5、面试回答JVM的字节码，i++分成三步，间隙期不同步非原子操作(i++)3、指令禁重排重排序重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序不存在数据依赖关系，可以重排序；存在数据依赖关系，禁止重排序但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！ 重排序的分类和执行流程编译器优化的重排序： 编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序指令级并行的重排序： 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序内存系统的重排序： 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行 数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。 案例 ：不存在数据依赖关系，可以重排序===&gt; 重排序OK 。 重排前 重排后 int a = 1; //1int b = 20; //2int c = a + b; //3 int b = 20; //1int a = 1; //2int c = a + b; //3 结论：编译器调整了语句的顺序，但是不影响程序的最终结果。 重排序OK 存在数据依赖关系，禁止重排序===&gt; 重排序发生，会导致程序运行结果不同。编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境，下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。1、volatile的底层实现是通过内存屏障volatile有关的禁止指令重排的行为 当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。 当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。 当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。 四大屏障的插入情况 在每一个volatile写操作前面插入一个StoreStore屏障 StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。 在每一个volatile写操作后面插入一个StoreLoad屏障 StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序 在每一个volatile读操作后面插入一个LoadLoad屏障 LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。 在每一个volatile读操作后面插入一个LoadStore屏障 LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。 //模拟一个单线程，什么顺序读？什么顺序写？public class VolatileTest { int i = 0; volatile boolean flag = false; public void write(){ i = 2; flag = true; } public void read(){ if(flag){ System.out.println(\"---i = \" + i); } }}4、如何正确使用volatile1、单一赋值可以，but含复合运算赋值不可以(i++之类)volatile int a = 10volatile boolean flag = false 2、状态标志，判断业务是否结束/** * * 使用：作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束 * 理由：状态标志并不依赖于程序内任何其他状态，且通常只有一种状态转换 * 例子：判断业务是否结束 */public class UseVolatileDemo{ private volatile static boolean flag = true; public static void main(String[] args) { new Thread(() -&gt; { while(flag) { //do something...... } },\"t1\").start(); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(2L); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { flag = false; },\"t2\").start(); }}3、开销较低的读，写锁策略public class UseVolatileDemo{ /** * 使用：当读远多于写，结合使用内部锁和 volatile 变量来减少同步的开销 * 理由：利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性 */ public class Counter { private volatile int value; public int getValue() { return value; //利用volatile保证读取操作的可见性 } public synchronized int increment() { return value++; //利用synchronized保证复合操作的原子性 } }}4、DCL双端锁的发布问题代码public class SafeDoubleCheckSingleton{ private static SafeDoubleCheckSingleton singleton; //私有化构造方法 private SafeDoubleCheckSingleton(){ } //双重锁设计 public static SafeDoubleCheckSingleton getInstance(){ if (singleton == null){ //1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象 synchronized (SafeDoubleCheckSingleton.class){ if (singleton == null){ //隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取 singleton = new SafeDoubleCheckSingleton(); } } } //2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象 return singleton; }}单线程看问题代码单线程环境下(或者说正常情况下)，在”问题代码处”，会执行如下操作，保证能获取到已完成初始化的实例由于存在指令重排序……多线程看问题代码隐患：多线程环境下，在”问题代码处”，会执行如下操作，由于重排序导致2,3乱序，后果就是其他线程得到的是null而不是完成初始化的对象解决01加volatile修饰面试题，反周志明老师的案例，你还有不加volatile的方法吗解决02 – 采用静态内部类的方式实现//现在比较好的做法就是采用静态内部内的方式实现 public class SingletonDemo{ private SingletonDemo() { } private static class SingletonDemoHandler { private static SingletonDemo instance = new SingletonDemo(); } public static SingletonDemo getInstance() { return SingletonDemoHandler.instance; }}5、最后的小总结1、内存屏障是什么2、内存屏障能干嘛 阻止屏障两边的指令重排序 写数据时加入屏障，强制将线程私有工作内存的数据刷回主物理内存 读数据时加入屏障，线程私有工作内存的数据失效，重新到主物理内存中获取最新数据3、内存屏障四大指令 在每一个volatile写操作前面插入一个StoreStore屏障 在每一个volatile写操作后面插入一个StoreLoad屏障 在每一个volatile读操作后面插入一个LoadLoad屏障 在每一个volatile读操作后面插入一个LoadStore屏障 4、凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的?字节码层面5、volatile可见性6、volatile禁重排写指令读指令7、对比java.util.concurrent.locks.Lock来理解8、一句话总结十一、CAS1、没有CAS之前1、多线程环境不使用原子类保证线程安全（基本数据类型）public class T3{ volatile int number = 0; //读取 public int getNumber() { return number; } //写入加锁保证原子性 public synchronized void setNumber() { number++; }}2、多线程环境 使用原子类保证线程安全（基本数据类型）public class T3{ volatile int number = 0; //读取 public int getNumber() { return number; } //写入加锁保证原子性 public synchronized void setNumber() { number++; } //================================= AtomicInteger atomicInteger = new AtomicInteger(); public int getAtomicInteger() { return atomicInteger.get(); } public void setAtomicInteger() { atomicInteger.getAndIncrement(); }}2、CAS是什么compare and swap的缩写，中文翻译成比较并交换,实现并发算法时常用到的一种技术。它包含三个操作数——内存位置、预期原值及更新值。执行CAS操作的时候，将内存位置的值与预期原值比较：如果相匹配，那么处理器会自动将该位置值更新为新值，如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。 CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。它是非阻塞的且自身原子性，也就是说这玩意效率更高且通过硬件保证，说明这玩意更可靠。 CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现的， 其实在这一点上还是有排他锁的，只是比起用synchronized， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好public class CASDemo{ public static void main(String[] args) throws InterruptedException { AtomicInteger atomicInteger = new AtomicInteger(5); System.out.println(atomicInteger.compareAndSet(5, 2020)+\"\\t\"+atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(5, 1024)+\"\\t\"+atomicInteger.get()); }}1、源码分析compareAndSet(int expect,int update)compareAndSet()方法的源代码：上面三个方法都是类似的，主要对4个参数做一下说明。var1：表示要操作的对象var2：表示要操作对象中属性地址的偏移量var4：表示需要修改数据的期望的值var5/var6：表示需要修改为的新值3、CAS底层原理？如果知道，谈谈你对UnSafe的理解1、UnSafe Unsafe \t是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务 变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。 变量value用volatile修饰，保证了多线程之间的内存可见性。2、我们知道i++线程不安全的，那atomicInteger.getAndIncrement()CAS的全称为Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。new AtomicInteger().getAndIncrement();假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同CPU上）： AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存。 线程A通过getIntVolatile(var1, var2)拿到value值3，这时线程A被挂起。 线程B也通过getIntVolatile(var1, var2)方法获取到value值3，此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切OK。 这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值数字3和主内存的值数字4不一致，说明该值已经被其它线程抢先一步修改过了，那A线程本次修改失败，只能重新读取重新来一遍了。 线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。 3、底层汇编native修饰的方法代表是底层方法Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(\"Unsafe_CompareAndSwapInt\"); oop p = JNIHandles::resolve(obj);// 先想办法拿到变量value在内存中的地址，根据偏移量valueOffset，计算 value 的地址 jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值 return (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END(Atomic::cmpxchg(x, addr, e)) == e;cmpxchg// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值 return (jint)(Atomic::cmpxchg(x, addr, e)) == e;unsigned Atomic::cmpxchg(unsigned int exchange_value,volatile unsigned int* dest, unsigned int compare_value) { assert(sizeof(unsigned int) == sizeof(jint), \"more work to do\"); /* * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载函数*/ return (unsigned int)Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest, (jint)compare_value);}在不同的操作系统下会调用不同的cmpxchg重载函数，本次用的是win10系统inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) { //判断是否是多核CPU int mp = os::is_MP(); __asm { //三个move指令表示的是将后面的值移动到前面的寄存器上 mov edx, dest mov ecx, exchange_value mov eax, compare_value //CPU原语级别，CPU触发 LOCK_IF_MP(mp) //比较并交换指令 //cmpxchg: 即“比较并交换”指令 //dword: 全称是 double word 表示两个字，一共四个字节 //ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 //将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值进行对比， //如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中 cmpxchg dword ptr [edx], ecx }}到这里应该理解了CAS真正实现的机制了，它最终是由操作系统的汇编指令完成的。4、总结你只需要记住：CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令cmpxchg指令。 核心思想就是：比较要更新变量的值V和预期值E（compare），相等才会将V的值设为新值N（swap）如果不相等自旋再来。4、原子引用AtomicInteger原子整型，可否有其它原子类型？ AtomicBook AtomicOrder 。。。@Getter@ToString@AllArgsConstructorclass User{ String userName; int age;}/** * @auther zzyy * @create 2018-12-31 17:22 */public class AtomicReferenceDemo{ public static void main(String[] args) { User z3 = new User(\"z3\",24); User li4 = new User(\"li4\",26); AtomicReference&lt;User&gt; atomicReferenceUser = new AtomicReference&lt;&gt;(); atomicReferenceUser.set(z3); System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+\"\\t\"+atomicReferenceUser.get().toString()); System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+\"\\t\"+atomicReferenceUser.get().toString()); }}5、自旋锁，借鉴CAS思想自旋锁（spinlock）是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU/** * 题目：实现一个自旋锁 * 自旋锁好处：循环比较获取没有类似wait的阻塞。 * * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现 * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。 */public class SpinLockDemo{ AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); public void myLock() { Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+\"\\t come in\"); while(!atomicReference.compareAndSet(null,thread)) { } } public void myUnLock() { Thread thread = Thread.currentThread(); atomicReference.compareAndSet(thread,null); System.out.println(Thread.currentThread().getName()+\"\\t myUnLock over\"); } public static void main(String[] args) { SpinLockDemo spinLockDemo = new SpinLockDemo(); new Thread(() -&gt; { spinLockDemo.myLock(); try { TimeUnit.SECONDS.sleep( 5 ); } catch (InterruptedException e) { e.printStackTrace(); } spinLockDemo.myUnLock(); },\"A\").start(); //暂停一会儿线程，保证A线程先于B线程启动并完成 try { TimeUnit.SECONDS.sleep( 1 ); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { spinLockDemo.myLock(); spinLockDemo.myUnLock(); },\"B\").start(); }}6、CAS缺点1、循环时间长开销很大我们可以看到getAndAddInt方法执行时，有个do while如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。2、引出来ABA问题？？？CAS会导致“ABA问题”。 CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。 比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。 尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。public class ABADemo{ static AtomicInteger atomicInteger = new AtomicInteger(100); static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1); public static void main(String[] args) { new Thread(() -&gt; { atomicInteger.compareAndSet(100,101); atomicInteger.compareAndSet(101,100); },\"t1\").start(); new Thread(() -&gt; { //暂停一会儿线程 try { Thread.sleep( 500 ); } catch (InterruptedException e) { e.printStackTrace(); }; System.out.println(atomicInteger.compareAndSet(100, 2019)+\"\\t\"+atomicInteger.get()); },\"t2\").start(); //暂停一会儿线程,main彻底等待上面的ABA出现演示完成。 try { Thread.sleep( 2000 ); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"============以下是ABA问题的解决=============================\"); new Thread(() -&gt; { int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName()+\"\\t 首次版本号:\"+stamp);//1 //暂停一会儿线程, try { Thread.sleep( 1000 ); } catch (InterruptedException e) { e.printStackTrace(); } atomicStampedReference.compareAndSet(100,101,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName()+\"\\t 2次版本号:\"+atomicStampedReference.getStamp()); atomicStampedReference.compareAndSet(101,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName()+\"\\t 3次版本号:\"+atomicStampedReference.getStamp()); },\"t3\").start(); new Thread(() -&gt; { int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName()+\"\\t 首次版本号:\"+stamp);//1 //暂停一会儿线程，获得初始值100和初始版本号1，故意暂停3秒钟让t3线程完成一次ABA操作产生问题 try { Thread.sleep( 3000 ); } catch (InterruptedException e) { e.printStackTrace(); } boolean result = atomicStampedReference.compareAndSet(100,2019,stamp,stamp+1); System.out.println(Thread.currentThread().getName()+\"\\t\"+result+\"\\t\"+atomicStampedReference.getReference()); },\"t4\").start(); }}十二、原子操作类之18罗汉增强 AtomicBoolean AtomicInteger AtomicIntegerArray AtomicIntegerFieldUpdater AtomicLong AtomicLongArray AtomicLongFieldUpdater AtomicMarkableReference AtomicReference AtomicReferenceArray AtomicReferenceFieldUpdater AtomicStampedReference DoubleAccumulator DoubleAdder LongAccumulator LongAdder1、基本类型原子类 AtomicInteger AtomicBoolean AtomicLong1、常用API简介public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）2、tsleep→countDownLatchclass MyNumber{ @Getter private AtomicInteger atomicInteger = new AtomicInteger(); public void addPlusPlus() { atomicInteger.incrementAndGet(); }}/** * @create 2020-07-03 17:16 */public class AtomicIntegerDemo{ public static void main(String[] args) throws InterruptedException { MyNumber myNumber = new MyNumber(); CountDownLatch countDownLatch = new CountDownLatch(100); for (int i = 1; i &lt;=100; i++) { new Thread(() -&gt; { try { for (int j = 1; j &lt;=5000; j++) { myNumber.addPlusPlus(); } }finally { countDownLatch.countDown(); } },String.valueOf(i)).start(); } countDownLatch.await(); System.out.println(myNumber.getAtomicInteger().get()); }}2、数组类型原子类 AtomicIntegerArray AtomicLongArray AtomicReferenceArraypublic class AtomicIntegerArrayDemo{ public static void main(String[] args) { AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[5]); //AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(5); //AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[]{1,2,3,4,5}); for (int i = 0; i &lt;atomicIntegerArray.length(); i++) { System.out.println(atomicIntegerArray.get(i)); } System.out.println(); System.out.println(); System.out.println(); int tmpInt = 0; tmpInt = atomicIntegerArray.getAndSet(0,1122); System.out.println(tmpInt+\"\\t\"+atomicIntegerArray.get(0)); atomicIntegerArray.getAndIncrement(1); atomicIntegerArray.getAndIncrement(1); tmpInt = atomicIntegerArray.getAndIncrement(1); System.out.println(tmpInt+\"\\t\"+atomicIntegerArray.get(1)); }}3、引用类型原子类 AtomicReference@Getter@ToString@AllArgsConstructorclass User{ String userName; int age;}public class AtomicReferenceDemo{ public static void main(String[] args) { User z3 = new User(\"z3\",24); User li4 = new User(\"li4\",26); AtomicReference&lt;User&gt; atomicReferenceUser = new AtomicReference&lt;&gt;(); atomicReferenceUser.set(z3); System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+\"\\t\"+atomicReferenceUser.get().toString()); System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+\"\\t\"+atomicReferenceUser.get().toString()); }}自旋锁SpinLockDemo/** * 题目：实现一个自旋锁 * 自旋锁好处：循环比较获取没有类似wait的阻塞。 * * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现 * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。 */public class SpinLockDemo{ AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); public void myLock() { Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+\"\\t come in\"); while(!atomicReference.compareAndSet(null,thread)) { } } public void myUnLock() { Thread thread = Thread.currentThread(); atomicReference.compareAndSet(thread,null); System.out.println(Thread.currentThread().getName()+\"\\t myUnLock over\"); } public static void main(String[] args) { SpinLockDemo spinLockDemo = new SpinLockDemo(); new Thread(() -&gt; { spinLockDemo.myLock(); //暂停一会儿线程 try { TimeUnit.SECONDS.sleep( 5 ); } catch (InterruptedException e) { e.printStackTrace(); } spinLockDemo.myUnLock(); },\"A\").start(); //暂停一会儿线程，保证A线程先于B线程启动并完成 try { TimeUnit.SECONDS.sleep( 1 ); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { spinLockDemo.myLock(); spinLockDemo.myUnLock(); },\"B\").start(); }} AtomicStampedReference 携带版本号的引用类型原子类，可以解决ABA问题 解决修改过几次 状态戳原子引用 ABADemopublic class ABADemo{ static AtomicInteger atomicInteger = new AtomicInteger(100); static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1); public static void main(String[] args) { abaProblem(); abaResolve(); } public static void abaResolve() { new Thread(() -&gt; { int stamp = atomicStampedReference.getStamp(); System.out.println(\"t3 ----第1次stamp \"+stamp); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } atomicStampedReference.compareAndSet(100,101,stamp,stamp+1); System.out.println(\"t3 ----第2次stamp \"+atomicStampedReference.getStamp()); atomicStampedReference.compareAndSet(101,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1); System.out.println(\"t3 ----第3次stamp \"+atomicStampedReference.getStamp()); },\"t3\").start(); new Thread(() -&gt; { int stamp = atomicStampedReference.getStamp(); System.out.println(\"t4 ----第1次stamp \"+stamp); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } boolean result = atomicStampedReference.compareAndSet(100, 20210308, stamp, stamp + 1); System.out.println(Thread.currentThread().getName()+\"\\t\"+result+\"\\t\"+atomicStampedReference.getReference()); },\"t4\").start(); } public static void abaProblem() { new Thread(() -&gt; { atomicInteger.compareAndSet(100,101); atomicInteger.compareAndSet(101,100); },\"t1\").start(); try { TimeUnit.MILLISECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { atomicInteger.compareAndSet(100,20210308); System.out.println(atomicInteger.get()); },\"t2\").start(); }} AtomicMarkableReference 原子更新带有标记位的引用类型对象 解决是否修改过 它的定义就是将状态戳简化为true false – 类似一次性筷子 状态戳(true/false)原子引用public class ABADemo{ static AtomicInteger atomicInteger = new AtomicInteger(100); static AtomicStampedReference&lt;Integer&gt; stampedReference = new AtomicStampedReference&lt;&gt;(100,1); static AtomicMarkableReference&lt;Integer&gt; markableReference = new AtomicMarkableReference&lt;&gt;(100,false); public static void main(String[] args) { new Thread(() -&gt; { atomicInteger.compareAndSet(100,101); atomicInteger.compareAndSet(101,100); System.out.println(Thread.currentThread().getName()+\"\\t\"+\"update ok\"); },\"t1\").start(); new Thread(() -&gt; { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } atomicInteger.compareAndSet(100,2020); },\"t2\").start(); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(atomicInteger.get()); System.out.println(); System.out.println(); System.out.println(); System.out.println(\"============以下是ABA问题的解决,让我们知道引用变量中途被更改了几次=========================\"); new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+\"\\t 1次版本号\"+stampedReference.getStamp()); //故意暂停200毫秒，让后面的t4线程拿到和t3一样的版本号 try { TimeUnit.MILLISECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } stampedReference.compareAndSet(100,101,stampedReference.getStamp(),stampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName()+\"\\t 2次版本号\"+stampedReference.getStamp()); stampedReference.compareAndSet(101,100,stampedReference.getStamp(),stampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName()+\"\\t 3次版本号\"+stampedReference.getStamp()); },\"t3\").start(); new Thread(() -&gt; { int stamp = stampedReference.getStamp(); System.out.println(Thread.currentThread().getName()+\"\\t =======1次版本号\"+stamp); //暂停2秒钟,让t3先完成ABA操作了，看看自己还能否修改 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } boolean b = stampedReference.compareAndSet(100, 2020, stamp, stamp + 1); System.out.println(Thread.currentThread().getName()+\"\\t=======2次版本号\"+stampedReference.getStamp()+\"\\t\"+stampedReference.getReference()); },\"t4\").start(); System.out.println(); System.out.println(); System.out.println(); System.out.println(\"============AtomicMarkableReference不关心引用变量更改过几次，只关心是否更改过======================\"); new Thread(() -&gt; { boolean marked = markableReference.isMarked(); System.out.println(Thread.currentThread().getName()+\"\\t 1次版本号\"+marked); try { TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } markableReference.compareAndSet(100,101,marked,!marked); System.out.println(Thread.currentThread().getName()+\"\\t 2次版本号\"+markableReference.isMarked()); markableReference.compareAndSet(101,100,markableReference.isMarked(),!markableReference.isMarked()); System.out.println(Thread.currentThread().getName()+\"\\t 3次版本号\"+markableReference.isMarked()); },\"t5\").start(); new Thread(() -&gt; { boolean marked = markableReference.isMarked(); System.out.println(Thread.currentThread().getName()+\"\\t 1次版本号\"+marked); //暂停几秒钟线程 try { TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } markableReference.compareAndSet(100,2020,marked,!marked); System.out.println(Thread.currentThread().getName()+\"\\t\"+markableReference.getReference()+\"\\t\"+markableReference.isMarked()); },\"t6\").start(); }}4、对象的属性修改原子类 AtomicIntegerFieldUpdater 原子更新对象中int类型字段的值 AtomicLongFieldUpdater 原子更新对象中Long类型字段的值 AtomicReferenceFieldUpdater 原子更新引用类型字段的值 1、使用目的以一种线程安全的方式操作非线程安全对象内的某些字段2、使用要求更新的对象属性必须使用 public volatile 修饰符。因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。3、AtomicIntegerFieldUpdaterDemoclass BankAccount{ private String bankName = \"CCB\";//银行 public volatile int money = 0;//钱数 AtomicIntegerFieldUpdater&lt;BankAccount&gt; accountAtomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,\"money\"); //不加锁+性能高，局部微创 public void transferMoney(BankAccount bankAccount) { accountAtomicIntegerFieldUpdater.incrementAndGet(bankAccount); }}/** * @auther zzyy * @create 2020-07-14 18:06 * 以一种线程安全的方式操作非线程安全对象的某些字段。 * 需求： * 1000个人同时向一个账号转账一元钱，那么累计应该增加1000元， * 除了synchronized和CAS,还可以使用AtomicIntegerFieldUpdater来实现。 */public class AtomicIntegerFieldUpdaterDemo{ public static void main(String[] args) { BankAccount bankAccount = new BankAccount(); for (int i = 1; i &lt;=1000; i++) { int finalI = i; new Thread(() -&gt; { bankAccount.transferMoney(bankAccount); },String.valueOf(i)).start(); } //暂停毫秒 try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(bankAccount.money); }}4、AtomicReferenceFieldUpdaterclass MyVar{ public volatile Boolean isInit = Boolean.FALSE; AtomicReferenceFieldUpdater&lt;MyVar,Boolean&gt; atomicReferenceFieldUpdater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,\"isInit\"); public void init(MyVar myVar) { if(atomicReferenceFieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE)) { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---init.....\"); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---init.....over\"); }else{ System.out.println(Thread.currentThread().getName()+\"\\t\"+\"------其它线程正在初始化\"); } }}/** * 多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能初始化一次 */public class AtomicIntegerFieldUpdaterDemo{ public static void main(String[] args) throws InterruptedException { MyVar myVar = new MyVar(); for (int i = 1; i &lt;=5; i++) { new Thread(() -&gt; { myVar.init(myVar); },String.valueOf(i)).start(); } }}5、你在哪里用了volatileAtomicReferenceFieldUpdater6、原子操作增强类原理深度解析 DoubleAccumulator DoubleAdder LongAccumulator LongAdder1、点赞计数器，看看性能LongAdder只能用来计算加法，且从零开始计算LongAccumulator提供了自定义的函数操作//long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等import java.util.concurrent.atomic.LongAccumulator;import java.util.concurrent.atomic.LongAdder;import java.util.function.LongBinaryOperator;public class LongAccumulatorDemo{ LongAdder longAdder = new LongAdder(); public void add_LongAdder() { longAdder.increment(); } //LongAccumulator longAccumulator = new LongAccumulator((x, y) -&gt; x + y,0); LongAccumulator longAccumulator = new LongAccumulator(new LongBinaryOperator() { @Override public long applyAsLong(long left, long right) { return left - right; } },777); public void add_LongAccumulator() { longAccumulator.accumulate(1); } public static void main(String[] args) { LongAccumulatorDemo demo = new LongAccumulatorDemo(); demo.add_LongAccumulator(); demo.add_LongAccumulator(); System.out.println(demo.longAccumulator.longValue()); }}2、LongAdderAPIDemopublic class LongAdderAPIDemo{ public static void main(String[] args) { LongAdder longAdder = new LongAdder(); longAdder.increment(); longAdder.increment(); longAdder.increment(); System.out.println(longAdder.longValue()); LongAccumulator longAccumulator = new LongAccumulator((x,y) -&gt; x * y,2); longAccumulator.accumulate(1); longAccumulator.accumulate(2); longAccumulator.accumulate(3); System.out.println(longAccumulator.longValue()); }}3、LongAdder高性能对比Code演示class ClickNumberNet{ int number = 0; public synchronized void clickBySync() { number++; } AtomicLong atomicLong = new AtomicLong(0); public void clickByAtomicLong() { atomicLong.incrementAndGet(); } LongAdder longAdder = new LongAdder(); public void clickByLongAdder() { longAdder.increment(); } LongAccumulator longAccumulator = new LongAccumulator((x,y) -&gt; x + y,0); public void clickByLongAccumulator() { longAccumulator.accumulate(1); }}/** * @auther zzyy * @create 2020-05-21 22:23 * 50个线程，每个线程100W次，总点赞数出来 */public class LongAdderDemo2{ public static void main(String[] args) throws InterruptedException { ClickNumberNet clickNumberNet = new ClickNumberNet(); long startTime; long endTime; CountDownLatch countDownLatch = new CountDownLatch(50); CountDownLatch countDownLatch2 = new CountDownLatch(50); CountDownLatch countDownLatch3 = new CountDownLatch(50); CountDownLatch countDownLatch4 = new CountDownLatch(50); startTime = System.currentTimeMillis(); for (int i = 1; i &lt;=50; i++) { new Thread(() -&gt; { try { for (int j = 1; j &lt;=100 * 10000; j++) { clickNumberNet.clickBySync(); } }finally { countDownLatch.countDown(); } },String.valueOf(i)).start(); } countDownLatch.await(); endTime = System.currentTimeMillis(); System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickBySync result: \"+clickNumberNet.number); startTime = System.currentTimeMillis(); for (int i = 1; i &lt;=50; i++) { new Thread(() -&gt; { try { for (int j = 1; j &lt;=100 * 10000; j++) { clickNumberNet.clickByAtomicLong(); } }finally { countDownLatch2.countDown(); } },String.valueOf(i)).start(); } countDownLatch2.await(); endTime = System.currentTimeMillis(); System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByAtomicLong result: \"+clickNumberNet.atomicLong); startTime = System.currentTimeMillis(); for (int i = 1; i &lt;=50; i++) { new Thread(() -&gt; { try { for (int j = 1; j &lt;=100 * 10000; j++) { clickNumberNet.clickByLongAdder(); } }finally { countDownLatch3.countDown(); } },String.valueOf(i)).start(); } countDownLatch3.await(); endTime = System.currentTimeMillis(); System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByLongAdder result: \"+clickNumberNet.longAdder.sum()); startTime = System.currentTimeMillis(); for (int i = 1; i &lt;=50; i++) { new Thread(() -&gt; { try { for (int j = 1; j &lt;=100 * 10000; j++) { clickNumberNet.clickByLongAccumulator(); } }finally { countDownLatch4.countDown(); } },String.valueOf(i)).start(); } countDownLatch4.await(); endTime = System.currentTimeMillis(); System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByLongAccumulator result: \"+clickNumberNet.longAccumulator.longValue()); }}4、源码、原理分析1、架构LongAdder是Striped64的子类2、剩下两罗汉Striped64Number3、原理(LongAdder为什么这么快)1、Striped64有几个比较重要的成员函数/** Number of CPUS, to place bound on table size CPU数量，即cells数组的最大长度 */static final int NCPU = Runtime.getRuntime().availableProcessors();/** * Table of cells. When non-null, size is a power of 2.cells数组，为2的幂，2,4,8,16.....，方便以后位运算 */transient volatile Cell[] cells;/**基础value值，当并发较低时，只累加该值主要用于没有竞争的情况，通过CAS更新。 * Base value, used mainly when there is no contention, but also as * a fallback during table initialization races. Updated via CAS. */transient volatile long base;/**创建或者扩容Cells数组时使用的自旋锁变量调整单元格大小（扩容），创建单元格时使用的锁。 * Spinlock (locked via CAS) used when resizing and/or creating Cells. */transient volatile int cellsBusy;最重要的2个2、Striped64中一些变量或者方法的定义3、Cell是 java.util.concurrent.atomic 下 Striped64 的一个内部类4、LongAdder为什么这么快​\t\tLongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。​\t\tsum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。内部有一个base变量，一个Cell[]数组。base变量：非竞态条件下，直接累加到该变量上Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中4、源码解读深度分析​\t\tLongAdder在无竞争的情况，跟AtomicLong一样，对同一个base进行操作，当出现竞争关系时则是采用化整为零的做法，从空间换时间，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。longAdder.increment()1、add(1L) 最初无竞争时只更新base； 如果更新base失败后，首次新建一个Cell[]数组 当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容2、longAccumulatelongAccumulate入参说明Striped64中一些变量或者方法的定义线程hash值：probe总纲上述代码首先给当前线程分配一个hash值，然后进入一个for(;;)自旋，这个自旋分为三个分支：CASE1：Cell[]数组已经初始化CASE2：Cell[]数组未初始化(首次新建)CASE3：Cell[]数组正在初始化中刚刚要初始化Cell[]数组(首次新建)未初始化过Cell[]数组，尝试占有锁并首次初始化cells数组如果上面条件都执行成功就会执行数组的初始化及赋值操作， Cell[] rs = new Cell[2]表示数组的长度为2，rs[h &amp; 1] = new Cell(x) 表示创建一个新的Cell元素，value是x值，默认为1。h &amp; 1类似于我们之前HashMap常用到的计算散列桶index的算法，通常都是hash &amp; (table.len - 1)。同hashmap一个意思。兜底多个线程尝试CAS修改失败的线程会走到这个分支该分支实现直接操作base基数，将值累加到base上，也即其它线程正在初始化，多个线程正在更新base的值。Cell数组不再为空且可能存在Cell数组扩容多个线程同时命中一个cell的竞争 上面代码判断当前线程hash后指向的数据位置元素是否为空，如果为空则将Cell数据放入数组中，跳出循环。如果不空则继续循环。 说明当前线程对应的数组中有了数据，也重置过hash值，这时通过CAS操作尝试对当前数中的value值进行累加x操作，x默认为1，如果CAS成功则直接跳出循环。 3、sumsum()会将所有Cell数组中的value和base累加作为返回值。核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。为啥在并发情况下sum的值不精确sum执行时，并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性的，它是最终一致性的。​\t\t首先，最终返回的sum局部变量，初始被复制为base，而最终返回时，很可能base已经被更新了，而此时局部变量sum不会更新，造成不一致。其次，这里对cell的读取也无法保证是最后一次写入的值。所以，sum方法在没有并发的情况下，可以获得正确的结果。5、使用总结 AtomicLong 线程安全，可允许一些性能损耗，要求高精度时可使用 保证精度，性能代价 AtomicLong是多个线程针对单个热点值value进行原子操作 LongAdder 当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用 保证性能，精度代价 LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作 7、总结1、AtomicLong 原理 CAS+自旋 incrementAndGet 场景 低并发下的全局计算 AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题。 缺陷 高并发后性能急剧下降 AtomicLong的自旋会成为瓶颈 N个线程CAS操作修改线程的值，每次只有一个成功过，其它N - 1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。 2、LongAdder 原理 CAS+Base+Cell数组分散 空间换时间并分散了热点数据 场景 高并发下的全局计算 缺陷 sum求和后还有计算线程修改结果的话，最后结果不够准确 十三、ThreadLocal、InheritableThreadLocal1、ThreadLocal简介​\t\t稍微翻译一下：​\t\tThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。​\t\t实现每一个线程都有自己专属的本地变量副本(自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份)，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。2、永远的helloworld按照总销售额统计，方便集团公司做计划统计class MovieTicket{ int number = 50; public synchronized void saleTicket() { if(number &gt; 0) { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"号售票员卖出第： \"+(number--)); }else{ System.out.println(\"--------卖完了\"); } }}/** * 三个售票员卖完50张票务，总量完成即可，吃大锅饭，售票员每个月固定月薪 */public class ThreadLocalDemo{ public static void main(String[] args) { MovieTicket movieTicket = new MovieTicket(); for (int i = 1; i &lt;=3; i++) { new Thread(() -&gt; { for (int j = 0; j &lt;20; j++) { movieTicket.saleTicket(); try { TimeUnit.MILLISECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } },String.valueOf(i)).start(); } }}不参加总和计算，希望各自分灶吃饭，各凭销售本事提成，按照出单数各自统计class MovieTicket{ int number = 50; public synchronized void saleTicket() { if(number &gt; 0) { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"号售票员卖出第： \"+(number--)); }else{ System.out.println(\"--------卖完了\"); } }}class House{ ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0); public void saleHouse() { Integer value = threadLocal.get(); value++; threadLocal.set(value); }}/** * 1 三个售票员卖完50张票务，总量完成即可，吃大锅饭，售票员每个月固定月薪 * * 2 分灶吃饭，各个销售自己动手，丰衣足食 */public class ThreadLocalDemo{ public static void main(String[] args) { /*MovieTicket movieTicket = new MovieTicket(); for (int i = 1; i &lt;=3; i++) { new Thread(() -&gt; { for (int j = 0; j &lt;20; j++) { movieTicket.saleTicket(); try { TimeUnit.MILLISECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } },String.valueOf(i)).start(); }*/ //=========================================== House house = new House(); new Thread(() -&gt; { try { for (int i = 1; i &lt;=3; i++) { house.saleHouse(); } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---\"+house.threadLocal.get()); }finally { house.threadLocal.remove();//如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题 } },\"t1\").start(); new Thread(() -&gt; { try { for (int i = 1; i &lt;=2; i++) { house.saleHouse(); } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---\"+house.threadLocal.get()); }finally { house.threadLocal.remove(); } },\"t2\").start(); new Thread(() -&gt; { try { for (int i = 1; i &lt;=5; i++) { house.saleHouse(); } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---\"+house.threadLocal.get()); }finally { house.threadLocal.remove(); } },\"t3\").start(); System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---\"+house.threadLocal.get()); }}1、小总结因为每个 Thread 内有自己的实例副本且该副本只由当前线程自己使用既然其它 Thread 不可访问，那就不存在多线程间共享的问题。统一设置初始值，但是每个线程对这个值的修改都是各自线程互相独立的 加入synchronized或者Lock控制资源的访问顺序 人手一份，大家各自安好，没必要抢夺 3、从阿里ThreadLocal规范开始1、非线程安全的SimpleDateFormat​\t\t上述翻译：SimpleDateFormat中的日期格式不是同步的。推荐（建议）为每个线程创建独立的格式实例。如果多个线程同时访问一个格式，则它必须保持外部同步。public class DateUtils{ public static final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); /** * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象 * @param stringDate * @return * @throws Exception */ public static Date parseDate(String stringDate)throws Exception{ return sdf.parse(stringDate); } public static void main(String[] args) throws Exception{ for (int i = 1; i &lt;=30; i++) { new Thread(() -&gt; { try { System.out.println(DateUtils.parseDate(\"2020-11-11 11:11:11\")); } catch (Exception e) { e.printStackTrace(); } },String.valueOf(i)).start(); } }}java.lang.NumberFormatException: For input string: \"\"\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\tat java.lang.Long.parseLong(Long.java:601)\tat java.lang.Long.parseLong(Long.java:631)\tat java.text.DigitList.getLong(DigitList.java:195)\tat java.text.DecimalFormat.parse(DecimalFormat.java:2082)\tat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)\tat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)\tat java.text.DateFormat.parse(DateFormat.java:364)\tat com.zdww.tcm.utils.DateTimeUtil.parseDate(DateTimeUtil.java:1129)\tat com.zdww.tcm.utils.DateTimeUtil.lambda$main$0(DateTimeUtil.java:1137)\tat java.lang.Thread.run(Thread.java:748)java.lang.NumberFormatException: For input string: \".20202E.20202E44\"\tat sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:2043)\tat sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)\tat java.lang.Double.parseDouble(Double.java:538)\tat java.text.DigitList.getDouble(DigitList.java:169)\tat java.text.DecimalFormat.parse(DecimalFormat.java:2087)\tat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)\tat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)\tat java.text.DateFormat.parse(DateFormat.java:364)\tat com.zdww.tcm.utils.DateTimeUtil.parseDate(DateTimeUtil.java:1129)\tat com.zdww.tcm.utils.DateTimeUtil.lambda$main$0(DateTimeUtil.java:1137)​\t\tSimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息,例如sdf.parse(dateStr),sdf.format(date) 诸如此类的方法参数传入的日期相关String,Date等等, 都是交由Calendar引用来储存的.这样就会导致一个问题如果你的SimpleDateFormat是个static的, 那么多个thread 之间就会共享这个SimpleDateFormat, 同时也是共享这个Calendar引用。2、解决1将SimpleDateFormat定义成局部变量。缺点：每调用一次方法就会创建一个SimpleDateFormat对象，方法结束又要作为垃圾回收。public class DateUtils{ public static final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); /** * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象 * @param stringDate * @return * @throws Exception */ public static Date parseDate(String stringDate)throws Exception{ return sdf.parse(stringDate); } public static void main(String[] args) throws Exception{ for (int i = 1; i &lt;=30; i++) { new Thread(() -&gt; { try { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf.parse(\"2020-11-11 11:11:11\")); sdf = null; } catch (Exception e) { e.printStackTrace(); } },String.valueOf(i)).start(); } }}3、解决2ThreadLocal，也叫做线程本地变量或者线程本地存储public class DateUtils{ private static final ThreadLocal&lt;SimpleDateFormat&gt; sdf_threadLocal = ThreadLocal.withInitial(()-&gt; new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); /** * ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。 * @param stringDate * @return * @throws Exception */ public static Date parseDateTL(String stringDate)throws Exception{ return sdf_threadLocal.get().parse(stringDate); } public static void main(String[] args) throws Exception{ for (int i = 1; i &lt;=30; i++) { new Thread(() -&gt; { try { System.out.println(DateUtils.parseDateTL(\"2020-11-11 11:11:11\")); } catch (Exception e) { e.printStackTrace(); } },String.valueOf(i)).start(); } }}public class DateUtils{ /* 1 SimpleDateFormat如果多线程共用是线程不安全的类 public static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); public static String format(Date date) { return SIMPLE_DATE_FORMAT.format(date); } public static Date parse(String datetime) throws ParseException { return SIMPLE_DATE_FORMAT.parse(datetime); }*/ //2 ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。 public static final ThreadLocal&lt;SimpleDateFormat&gt; SIMPLE_DATE_FORMAT_THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); public static String format(Date date){ return SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().format(date); } public static Date parse(String datetime) throws ParseException{ return SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().parse(datetime); } //3 DateTimeFormatter 代替 SimpleDateFormat /*public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); public static String format(LocalDateTime localDateTime) { return DATE_TIME_FORMAT.format(localDateTime); } public static LocalDateTime parse(String dateString) { return LocalDateTime.parse(dateString,DATE_TIME_FORMAT); }*/}4、ThreadLocal源码分析1、Thread，ThreadLocal，ThreadLocalMap 关系Thread和ThreadLocal再次体会，各自线程，人手一份ThreadLocal和ThreadLocalMapAll三者总概括​\t\tthreadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放近似的可以理解为:ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以ThreadLocal为Key)，不过是经过了两层包装的ThreadLocal对象：​\t\tJVM内部维护了一个线程版的Map&lt;Thread,T&gt;(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中),每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。5、ThreadLocal内存泄露问题1、什么是内存泄漏不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。2、谁惹的祸？3、强引用、软引用、弱引用、虚引用分别是什么？ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以它为Key)，不过是经过了两层包装的ThreadLocal对象：（1）第一层包装是使用 WeakReference&lt;ThreadLocal&lt;?» 将ThreadLocal对象变成一个弱引用的对象；（2）第二层包装是定义了一个专门的类 Entry 来扩展 WeakReference&lt;ThreadLocal&lt;?»java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。1、强引用(默认支持模式)当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，死都不收。​\t\t强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。​\t\t对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。public static void strongReference(){ MyObject myObject = new MyObject(); System.out.println(\"-----gc before: \"+myObject); myObject = null; System.gc(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----gc after: \"+myObject);}2、软引用软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。对于只有软引用的对象来说，当系统内存充足时它 不会 被回收，当系统内存不足时它 会 被回收。软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！class MyObject{ //一般开发中不用调用这个方法，本次只是为了演示 @Override protected void finalize() throws Throwable { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---finalize method invoked....\"); }}public class ReferenceDemo{ public static void main(String[] args) { //当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m SoftReference&lt;MyObject&gt; softReference = new SoftReference&lt;&gt;(new MyObject()); System.gc(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----gc after内存够用: \"+softReference.get()); try { byte[] bytes = new byte[9 * 1024 * 1024]; }catch (Exception e){ e.printStackTrace(); }finally { System.out.println(\"-----gc after内存不够: \"+softReference.get()); } } public static void strongReference() { MyObject myObject = new MyObject(); System.out.println(\"-----gc before: \"+myObject); myObject = null; System.gc(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----gc after: \"+myObject); }}3、弱引用​\t\t弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。class MyObject{ //一般开发中不用调用这个方法，本次只是为了演示 @Override protected void finalize() throws Throwable { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---finalize method invoked....\"); }}public class ReferenceDemo{ public static void main(String[] args) { WeakReference&lt;MyObject&gt; weakReference = new WeakReference&lt;&gt;(new MyObject()); System.out.println(\"-----gc before内存够用: \"+weakReference.get()); System.gc(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----gc after内存够用: \"+weakReference.get()); } public static void softReference() { //当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m SoftReference&lt;MyObject&gt; softReference = new SoftReference&lt;&gt;(new MyObject()); System.gc(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----gc after内存够用: \"+softReference.get()); try { byte[] bytes = new byte[9 * 1024 * 1024]; }catch (Exception e){ e.printStackTrace(); }finally { System.out.println(\"-----gc after内存不够: \"+softReference.get()); } } public static void strongReference() { MyObject myObject = new MyObject(); System.out.println(\"-----gc before: \"+myObject); myObject = null; System.gc(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----gc after: \"+myObject); }}软引用和弱引用的适用场景假如有一个应用需要读取大量的本地图片:如果每次读取图片都从硬盘读取则会严重影响性能,如果一次性全部加载到内存中又可能造成内存溢出。此时使用软引用可以解决这个问题。　　设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。Map&lt;String, SoftReference&gt; imageCache = new HashMap&lt;String, SoftReference&gt;();4、虚引用虚引用需要java.lang.ref.PhantomReference类来实现。​\t\t顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列 (ReferenceQueue)联合使用。​\t\t虚引用的主要作用是跟踪对象被垃圾回收的状态。 仅仅是提供了一种确保对象被 finalize以后，做某些事情的机制。 PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。我被回收前需要被引用队列保存下。class MyObject{ //一般开发中不用调用这个方法，本次只是为了演示 @Override protected void finalize() throws Throwable { System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---finalize method invoked....\"); }}public class ReferenceDemo{ public static void main(String[] args) { ReferenceQueue&lt;MyObject&gt; referenceQueue = new ReferenceQueue(); PhantomReference&lt;MyObject&gt; phantomReference = new PhantomReference&lt;&gt;(new MyObject(),referenceQueue); //System.out.println(phantomReference.get()); List&lt;byte[]&gt; list = new ArrayList&lt;&gt;(); new Thread(() -&gt; { while (true) { list.add(new byte[1 * 1024 * 1024]); try { TimeUnit.MILLISECONDS.sleep(600); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(phantomReference.get()); } },\"t1\").start(); new Thread(() -&gt; { while (true) { Reference&lt;? extends MyObject&gt; reference = referenceQueue.poll(); if (reference != null) { System.out.println(\"***********有虚对象加入队列了\"); } } },\"t2\").start(); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } } public static void weakReference() { WeakReference&lt;MyObject&gt; weakReference = new WeakReference&lt;&gt;(new MyObject()); System.out.println(\"-----gc before内存够用: \"+weakReference.get()); System.gc(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----gc after内存够用: \"+weakReference.get()); } public static void softReference() { //当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m SoftReference&lt;MyObject&gt; softReference = new SoftReference&lt;&gt;(new MyObject()); System.gc(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----gc after内存够用: \"+softReference.get()); try { byte[] bytes = new byte[9 * 1024 * 1024]; }catch (Exception e){ e.printStackTrace(); }finally { System.out.println(\"-----gc after内存不够: \"+softReference.get()); } } public static void strongReference() { MyObject myObject = new MyObject(); System.out.println(\"-----gc before: \"+myObject); myObject = null; System.gc(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-----gc after: \"+myObject); }}5、GCRoots和四大引用小总结4、关系每个Thread对象维护着一个ThreadLocalMap的引用ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值Value是传递进来的对象调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象ThreadLocal本身并不存储值，它只是自己作为一个key来让线程从ThreadLocalMap获取value，正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响～6、为什么要用弱引用?不用如何？public void function01(){ ThreadLocal tl = new ThreadLocal&lt;Integer&gt;(); //line1 tl.set(2021); //line2 tl.get(); //line3}//line1新建了一个ThreadLocal对象，t1 是强引用指向这个对象；//line2调用set()方法后新建一个Entry，通过源码可知Entry对象里的k是弱引用指向这个对象。​\t\t当function01方法执行完毕后，栈帧销毁强引用 tl 也就没有了。但此时线程的ThreadLocalMap里某个entry的key引用还指向这个对象,若这个key引用是强引用，就会导致key指向的ThreadLocal对象及v指向的对象不能被gc回收，造成内存泄漏；若这个key引用是弱引用就大概率会减少内存泄漏的问题(还有一个key为null的雷)。使用弱引用，就可以使ThreadLocal对象在方法执行完毕后顺利被回收且Entry的key引用指向为null。此后我们调用get,set或remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存。1、弱引用就万事大吉了吗？ 当我们为threadLocal变量赋值，实际上就是当前的Entry(threadLocal实例为key，值为value)往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null(tl=null),那么系统 GC 的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。 当然，如果当前thread运行结束，threadLocal，threadLocalMap,Entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。 但在实际使用中我们有时候会用线程池去维护我们的线程，比如在Executors.newFixedThreadPool()时创建线程的时候，为了复用线程是不会结束的，所以threadLocal内存泄漏就值得我们小心 2、key为null的entry，原理解析​\t\tThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话(比如正好用在线程池)，这些key为null的Entry的value就会一直存在一条强引用链。​\t\t虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后，手动调用remoev方法来删除它，尤其是在线程池中，不仅仅是内存泄露的问题，因为线程池中的线程是重复使用的，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取到上个线程遗留下来的value值，造成bug。3、set、get方法会去检查所有键为null的Entry对象set()get()remove()结论​\t\t从前面的set,getEntry,remove方法看出，在threadLocal的生命周期里，针对threadLocal存在的内存泄漏的问题，都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法清理掉key为null的脏entry。4、结论7、最佳实践用完记得手动remove8、小总结 ThreadLocal 并不解决线程间共享数据的问题 ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景 ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题 每个线程持有一个只属于自己的专属Map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题 ThreadLocalMap的Entry对ThreadLocal的引用为弱引用，避免了ThreadLocal对象无法被回收的问题 都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏，属于安全加固的方法 群雄逐鹿起纷争，人各一份天下安9、ThreadLocal和InheritableThreadLocal需要解决的问题 我们还是以解决问题的方式来引出ThreadLocal、InheritableThreadLocal，这样印象会深刻一些。目前java开发web系统一般有3层，controller、service、dao，请求到达controller，controller调用service，service调用dao，然后进行处理。我们写一个简单的例子，有3个方法分别模拟controller、service、dao。代码如下：import java.util.ArrayList;import java.util.List;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class Demo1 { static AtomicInteger threadIndex = new AtomicInteger(1); //创建处理请求的线程池子 static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3, 3, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(), r -&gt; { Thread thread = new Thread(r); thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement()); return thread; }); //记录日志 public static void log(String msg) { StackTraceElement stack[] = (new Throwable()).getStackTrace(); System.out.println(\"****\" + System.currentTimeMillis() + \",[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg); } //模拟controller public static void controller(List&lt;String&gt; dataList) { log(\"接受请求\"); service(dataList); } //模拟service public static void service(List&lt;String&gt; dataList) { log(\"执行业务\"); dao(dataList); } //模拟dao public static void dao(List&lt;String&gt; dataList) { log(\"执行数据库操作\"); //模拟插入数据 for (String s : dataList) { log(\"插入数据\" + s + \"成功\"); } } public static void main(String[] args) { //需要插入的数据 List&lt;String&gt; dataList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { dataList.add(\"数据\" + i); } //模拟5个请求 int requestCount = 5; for (int i = 0; i &lt; requestCount; i++) { disposeRequestExecutor.execute(() -&gt; { controller(dataList); }); } disposeRequestExecutor.shutdown(); }}****1565338891286,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求****1565338891286,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求****1565338891287,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务****1565338891287,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功****1565338891287,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功****1565338891287,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求****1565338891287,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务****1565338891288,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作****1565338891288,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功****1565338891288,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功****1565338891288,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功****1565338891288,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功****1565338891288,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求****1565338891288,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功****1565338891288,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务****1565338891289,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作****1565338891289,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功****1565338891289,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功****1565338891289,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功代码中调用controller、service、dao 3个方法时，来模拟处理一个请求。main方法中循环了5次模拟发起5次请求，然后交给线程池去处理请求，dao中模拟循环插入传入的dataList数据。问题来了：开发者想看一下哪些地方耗时比较多，想通过日志来分析耗时情况，想追踪某个请求的完整日志，怎么搞？上面的请求采用线程池的方式处理的，多个请求可能会被一个线程处理，通过日志很难看出那些日志是同一个请求，我们能不能给请求加一个唯一标志，日志中输出这个唯一标志，当然可以。如果我们的代码就只有上面示例这么简单，我想还是很容易的，上面就3个方法，给每个方法加个traceId参数，log方法也加个traceId参数，就解决了，代码如下：import java.util.ArrayList;import java.util.List;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class Demo2 { static AtomicInteger threadIndex = new AtomicInteger(1); //创建处理请求的线程池子 static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3, 3, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(), r -&gt; { Thread thread = new Thread(r); thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement()); return thread; }); //记录日志 public static void log(String msg, String traceId) { StackTraceElement stack[] = (new Throwable()).getStackTrace(); System.out.println(\"****\" + System.currentTimeMillis() + \"[traceId:\" + traceId + \"],[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg); } //模拟controller public static void controller(List&lt;String&gt; dataList, String traceId) { log(\"接受请求\", traceId); service(dataList, traceId); } //模拟service public static void service(List&lt;String&gt; dataList, String traceId) { log(\"执行业务\", traceId); dao(dataList, traceId); } //模拟dao public static void dao(List&lt;String&gt; dataList, String traceId) { log(\"执行数据库操作\", traceId); //模拟插入数据 for (String s : dataList) { log(\"插入数据\" + s + \"成功\", traceId); } } public static void main(String[] args) { //需要插入的数据 List&lt;String&gt; dataList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { dataList.add(\"数据\" + i); } //模拟5个请求 int requestCount = 5; for (int i = 0; i &lt; requestCount; i++) { String traceId = String.valueOf(i); disposeRequestExecutor.execute(() -&gt; { controller(dataList, traceId); }); } disposeRequestExecutor.shutdown(); }}****1565339559773[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求****1565339559773[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求****1565339559773[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务****1565339559774[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作****1565339559774[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功****1565339559774[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功****1565339559774[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功****1565339559774[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求****1565339559775[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务****1565339559775[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作****1565339559775[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功****1565339559775[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功****1565339559775[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功****1565339559775[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功上面我们通过修改代码的方式，把问题解决了，但前提是你们的系统都像上面这么简单，功能很少，需要改的代码很少，可以这么去改。但事与愿违，我们的系统一般功能都是比较多的，如果我们都一个个去改，岂不是要疯掉，改代码还涉及到重新测试，风险也不可控。那有什么好办法么？ThreadLocal还是拿上面的问题，我们来分析一下，每个请求都是由一个线程处理的，线程就相当于一个人一样，每个请求相当于一个任务，任务来了，人来处理，处理完毕之后，再处理下一个请求任务。人身上是不是有很多口袋，人刚开始准备处理任务的时候，我们把任务的编号放在处理者的口袋中，然后处理中一路携带者，处理过程中如果需要用到这个编号，直接从口袋中获取就可以了。那么刚好java中线程设计的时候也考虑到了这些问题，Thread对象中就有很多口袋，用来放东西。Thread类中有这么一个变量：ThreadLocal.ThreadLocalMap threadLocals = null;如何来操作Thread中的这些口袋呢，java为我们提供了一个类ThreadLocal，ThreadLocal对象用来操作Thread中的某一个口袋，可以向这个口袋中放东西、获取里面的东西、清除里面的东西，这个口袋一次性只能放一个东西，重复放东西会将里面已经存在的东西覆盖掉。常用的3个方法：//向Thread中某个口袋中放东西public void set(T value);//获取这个口袋中目前放的东西public T get();//清空这个口袋中放的东西public void remove()我们使用ThreadLocal来改造一下上面的代码，如下：import java.util.ArrayList;import java.util.List;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class Demo3 { //创建一个操作Thread中存放请求任务追踪id口袋的对象 static ThreadLocal&lt;String&gt; traceIdKD = new ThreadLocal&lt;&gt;(); static AtomicInteger threadIndex = new AtomicInteger(1); //创建处理请求的线程池子 static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3, 3, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(), r -&gt; { Thread thread = new Thread(r); thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement()); return thread; }); //记录日志 public static void log(String msg) { StackTraceElement stack[] = (new Throwable()).getStackTrace(); //获取当前线程存放tranceId口袋中的内容 String traceId = traceIdKD.get(); System.out.println(\"****\" + System.currentTimeMillis() + \"[traceId:\" + traceId + \"],[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg); } //模拟controller public static void controller(List&lt;String&gt; dataList) { log(\"接受请求\"); service(dataList); } //模拟service public static void service(List&lt;String&gt; dataList) { log(\"执行业务\"); dao(dataList); } //模拟dao public static void dao(List&lt;String&gt; dataList) { log(\"执行数据库操作\"); //模拟插入数据 for (String s : dataList) { log(\"插入数据\" + s + \"成功\"); } } public static void main(String[] args) { //需要插入的数据 List&lt;String&gt; dataList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { dataList.add(\"数据\" + i); } //模拟5个请求 int requestCount = 5; for (int i = 0; i &lt; requestCount; i++) { String traceId = String.valueOf(i); disposeRequestExecutor.execute(() -&gt; { //把traceId放入口袋中 traceIdKD.set(traceId); try { controller(dataList); } finally { //将tranceId从口袋中移除 traceIdKD.remove(); } }); } disposeRequestExecutor.shutdown(); }}****1565339644214[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求****1565339644214[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求****1565339644214[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求****1565339644214[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务****1565339644214[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务****1565339644214[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作****1565339644214[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务****1565339644214[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功****1565339644214[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作****1565339644214[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作****1565339644215[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功****1565339644215[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功****1565339644215[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功****1565339644215[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功****1565339644215[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功****1565339644215[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功****1565339644215[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务****1565339644215[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功可以看出输出和刚才使用traceId参数的方式结果一致，但是却简单了很多。不用去修改controller、service、dao代码了，风险也减少了很多。代码中创建了一个ThreadLocal traceIdKD，这个对象用来操作Thread中一个口袋，用这个口袋来存放tranceId。在main方法中通过traceIdKD.set(traceId)方法将traceId放入口袋，log方法中通traceIdKD.get()获取口袋中的traceId，最后任务处理完之后，main中的finally中调用traceIdKD.remove();将口袋中的traceId清除。ThreadLocal的官方API解释为： “该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。”InheritableThreadLocal继续上面的实例，dao中循环处理dataList的内容，假如dataList处理比较耗时，我们想加快处理速度有什么办法么？大家已经想到了，用多线程并行处理dataList，那么我们把代码改一下，如下：import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class Demo4 { //创建一个操作Thread中存放请求任务追踪id口袋的对象 static ThreadLocal&lt;String&gt; traceIdKD = new ThreadLocal&lt;&gt;(); static AtomicInteger threadIndex = new AtomicInteger(1); //创建处理请求的线程池子 static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3, 3, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(), r -&gt; { Thread thread = new Thread(r); thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement()); return thread; }); //记录日志 public static void log(String msg) { StackTraceElement stack[] = (new Throwable()).getStackTrace(); //获取当前线程存放tranceId口袋中的内容 String traceId = traceIdKD.get(); System.out.println(\"****\" + System.currentTimeMillis() + \"[traceId:\" + traceId + \"],[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg); } //模拟controller public static void controller(List&lt;String&gt; dataList) { log(\"接受请求\"); service(dataList); } //模拟service public static void service(List&lt;String&gt; dataList) { log(\"执行业务\"); dao(dataList); } //模拟dao public static void dao(List&lt;String&gt; dataList) { CountDownLatch countDownLatch = new CountDownLatch(dataList.size()); log(\"执行数据库操作\"); String threadName = Thread.currentThread().getName(); //模拟插入数据 for (String s : dataList) { new Thread(() -&gt; { try { //模拟数据库操作耗时100毫秒 TimeUnit.MILLISECONDS.sleep(100); log(\"插入数据\" + s + \"成功,主线程：\" + threadName); } catch (InterruptedException e) { e.printStackTrace(); } finally { countDownLatch.countDown(); } }).start(); } //等待上面的dataList处理完毕 try { countDownLatch.await(); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { //需要插入的数据 List&lt;String&gt; dataList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { dataList.add(\"数据\" + i); } //模拟5个请求 int requestCount = 5; for (int i = 0; i &lt; requestCount; i++) { String traceId = String.valueOf(i); disposeRequestExecutor.execute(() -&gt; { //把traceId放入口袋中 traceIdKD.set(traceId); try { controller(dataList); } finally { //将tranceId从口袋中移除 traceIdKD.remove(); } }); } disposeRequestExecutor.shutdown(); }}看一下上面的输出，有些traceId为null，这是为什么呢？这是因为dao中为了提升处理速度，创建了子线程来并行处理，子线程调用log的时候，去自己的存放traceId的口袋中拿去东西，肯定是空的了。那有什么办法么？可不可以这样？父线程相当于主管，子线程相当于干活的小弟，主管让小弟们干活的时候，将自己兜里面的东西复制一份给小弟们使用，主管兜里面可能有很多牛逼的工具，为了提升小弟们的工作效率，给小弟们都复制一个，丢到小弟们的兜里，然后小弟就可以从自己的兜里拿去这些东西使用了，也可以清空自己兜里面的东西。Thread对象中有个inheritableThreadLocals变量，代码如下：ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;inheritableThreadLocals相当于线程中另外一种兜，这种兜有什么特征呢，当创建子线程的时候，子线程会将父线程这种类型兜的东西全部复制一份放到自己的inheritableThreadLocals兜中，使用InheritableThreadLocal对象可以操作线程中的inheritableThreadLocals兜。InheritableThreadLocal常用的方法也有3个：//向Thread中某个口袋中放东西public void set(T value);//获取这个口袋中目前放的东西public T get();//清空这个口袋中放的东西public void remove()使用InheritableThreadLocal解决上面子线程中无法输出traceId的问题，只需要将上一个示例代码中的ThreadLocal替换成InheritableThreadLocal即可，代码如下：import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;/** * 跟着阿里p7学并发，微信公众号：javacode2018 */public class Demo4 { //创建一个操作Thread中存放请求任务追踪id口袋的对象,子线程可以继承父线程中内容 static InheritableThreadLocal&lt;String&gt; traceIdKD = new InheritableThreadLocal&lt;&gt;(); static AtomicInteger threadIndex = new AtomicInteger(1); //创建处理请求的线程池子 static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3, 3, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(), r -&gt; { Thread thread = new Thread(r); thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement()); return thread; }); //记录日志 public static void log(String msg) { StackTraceElement stack[] = (new Throwable()).getStackTrace(); //获取当前线程存放tranceId口袋中的内容 String traceId = traceIdKD.get(); System.out.println(\"****\" + System.currentTimeMillis() + \"[traceId:\" + traceId + \"],[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg); } //模拟controller public static void controller(List&lt;String&gt; dataList) { log(\"接受请求\"); service(dataList); } //模拟service public static void service(List&lt;String&gt; dataList) { log(\"执行业务\"); dao(dataList); } //模拟dao public static void dao(List&lt;String&gt; dataList) { CountDownLatch countDownLatch = new CountDownLatch(dataList.size()); log(\"执行数据库操作\"); String threadName = Thread.currentThread().getName(); //模拟插入数据 for (String s : dataList) { new Thread(() -&gt; { try { //模拟数据库操作耗时100毫秒 TimeUnit.MILLISECONDS.sleep(100); log(\"插入数据\" + s + \"成功,主线程：\" + threadName); } catch (InterruptedException e) { e.printStackTrace(); } finally { countDownLatch.countDown(); } }).start(); } //等待上面的dataList处理完毕 try { countDownLatch.await(); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { //需要插入的数据 List&lt;String&gt; dataList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { dataList.add(\"数据\" + i); } //模拟5个请求 int requestCount = 5; for (int i = 0; i &lt; requestCount; i++) { String traceId = String.valueOf(i); disposeRequestExecutor.execute(() -&gt; { //把traceId放入口袋中 traceIdKD.set(traceId); try { controller(dataList); } finally { //将tranceId从口袋中移除 traceIdKD.remove(); } }); } disposeRequestExecutor.shutdown(); }}十四、Java对象内存布局和对象头1、对象在堆内存中布局1、对象在堆内存中的存储布局对象内部结构分为：对象头、实例数据、对齐填充（保证8个字节的倍数）。对象头分为对象标记（markOop）和类元信息（klassOop），类元信息存储的是指向该对象类元数据（klass）的首地址。2、对象头1、对象标记Mark Word在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节​\t\t默认存储对象的HashCode、分代年龄和锁标志位等信息。这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。2、类元信息(又叫类型指针)对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。3、对象头多大在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。3、实例数据存放类的属性(Field)数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。4、对齐填充虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐。http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.htmlhttp://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/oop.hpp_mark字段是mark word，_metadata是类指针klass pointer，对象头（object header）即是由这两个字段组成，这些术语可以参考Hotspot术语表，2、MarkWord1、oop.hpp2、markOop.hpphash： 保存对象的哈希码age： 保存对象的分代年龄biased_lock： 偏向锁标识位lock： 锁状态标识位JavaThread* ：保存持有偏向锁的线程IDepoch： 保存偏向时间戳markword(64位)分布图，对象布局、GC回收和后面的锁升级就是对象标记MarkWord里面标志位的变化3、聊聊Object obj = new Object()1、JOL证明http://openjdk.java.net/projects/code-tools/jol/&lt;!--官网：http://openjdk.java.net/projects/code-tools/jol/定位：分析对象在JVM的大小和分布--&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt;public class MyObject{ public static void main(String[] args){ //VM的细节详细情况 System.out.println(VM.current().details()); //所有的对象分配的字节都是8的整数倍。 System.out.println(VM.current().objectAlignment()); }}public class JOLDemo{ public static void main(String[] args) { Object o = new Object(); System.out.println( ClassLayout.parseInstance(o).toPrintable()); }} OFFSET 偏移量，也就是到这个字段位置所占用的byte数 SIZE 后面类型的字节大小 TYPE 是Class中定义的类型 DESCRIPTION DESCRIPTION是类型的描述 VALUE VALUE是TYPE在内存中的值 GC年龄采用4位bit存储，最大为15，例如MaxTenuringThreshold参数默认值就是15-XX:MaxTenuringThreshold=162、默认开启压缩说明java -XX:+PrintCommandLineFlags -version-XX:+UseCompressedClassPointers上述表示开启了类型指针的压缩，以节约空间，假如不加压缩？？？手动关闭压缩再看看-XX:-UseCompressedClassPointers4、换成其他对象试试十五、Synchronized与锁升级1、Synchronized 锁优化的背景用锁能够实现数据的安全性，但是会带来性能下降。无锁能够基于线程并行提升程序性能，但是会带来安全性下降。synchronized锁：由对象头中的Mark Word根据锁标志位的不同而被复用及锁升级策略2、Synchronized的性能变化java5以前，只有Synchronized，这个是操作系统级别的重量级操作，重量级锁，假如锁的竞争比较激烈的话，性能下降1、Java5之前，用户态和内核态之间的切换​\t\tjava的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。​\t\t在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁2、为什么每一个对象都可以成为一个锁？？？？markOop.hpp​\t\tMonitor可以理解为一种同步工具，也可理解为一种同步机制，常常被描述为一个Java对象。Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。Monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。Monitor(监视器锁)Mutex Lock Monitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所以synchronized是Java语言中的一个重量级操作。Monitor与java对象以及线程是如何关联 ？1.如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址2.Monitor的Owner字段会存放拥有相关联对象锁的线程idMutex Lock 的切换需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。3、java6开始，优化SynchronizedJava 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁需要有个逐步升级的过程，别一开始就捅到重量级锁3、Synchronized锁种类及升级步骤1、多线程访问情况，3种 只有一个线程来访问，有且唯一Only One 有2个线程A、B来交替访问 竞争激烈，多个线程来访问2、升级流程synchronized用的锁是存在Java对象头里的Mark Word中锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位3、无锁public class MyObject{ public static void main(String[] args) { Object o = new Object(); System.out.println(\"10进制hash码：\"+o.hashCode()); System.out.println(\"16进制hash码：\"+Integer.toHexString(o.hashCode())); System.out.println(\"2进制hash码：\"+Integer.toBinaryString(o.hashCode())); System.out.println( ClassLayout.parseInstance(o).toPrintable()); }}4、偏向锁 当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁 同一个老顾客来访，直接老规矩行方便 Hotspot 的作者经过研究发现，大多数情况下： 多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况， 偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。通过CAS方式修改markword中的线程ID1、偏向锁的持有理论落地： 在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，也就是说锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。​ 那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁)。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。​ 假如不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。技术实现：\t\t一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向本身的ID，无需再进入 Monitor 去竞争对象了。2、细化案例Account对象举例说明偏向锁的操作不用直接捅到操作系统，不涉及用户到内核转换，不必要直接升级为最高级，我们以一个account对象的“对象头”为例，​\t\t假如有一个线程执行到synchronized代码块的时候，JVM使用CAS操作把线程指针ID记录到Mark Word当中，并修改标偏向标示，标示当前线程就获得该锁。锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并不会主动释放偏向锁。​\t\t这时线程获得了锁，可以执行同步代码块。当该线程第二次到达同步代码块时会判断此时持有锁的线程是否还是自己（持有锁的线程ID也在对象头里），JVM通过account对象的Mark Word判断：当前线程ID还在，说明还持有着这个对象的锁，就可以继续进入临界区工作。由于之前没有释放锁，这里也就不需要重新加锁。 如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。​\t\t结论：JVM不用和操作系统协商设置Mutex(争取内核)，它只需要记录下线程ID就标示自己获得了当前锁，不用操作系统接入。上述就是偏向锁：在没有其他线程竞争的时候，一直偏向偏心当前线程，当前线程可以一直执行。3、偏向锁JVM命令java -XX:+PrintFlagsInitial |grep BiasedLock** 实际上偏向锁在JDK1.6之后是默认开启的，但是启动时间有延迟，* 所以需要添加参数-XX:BiasedLockingStartupDelay=0，让其在程序启动时立刻启动。** 开启偏向锁：* -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0** 关闭偏向锁：关闭之后程序默认会直接进入------------------------------------------&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 轻量级锁状态。* -XX:-UseBiasedLocking4、Code演示 public class MyObject { public static void main(String[] args) { Object o = new Object(); new Thread(() -&gt; { synchronized (o){ System.out.println(ClassLayout.parseInstance(o).toPrintable()); } },\"t1\").start(); } }一切默认，演示无效果,因为参数系统默认开启-XX:+UseBiasedLocking # 开启偏向锁(默认) -XX:-UseBiasedLocking # 关闭偏向锁-XX:BiasedLockingStartupDelay=0 # 关闭延迟(演示偏向锁时需要开启)#参数说明：#偏向锁在JDK1.6以上默认开启，开启后程序启动几秒后才会被激活，可以使用JVM参数来关闭延迟 -XX:BiasedLockingStartupDelay=0 #如果确定锁通常处于竞争状态则可通过JVM参数 -XX:-UseBiasedLocking 关闭偏向锁，那么默认会进入轻量级锁关闭延时参数，启用该功能-XX:BiasedLockingStartupDelay=05、偏向锁的撤销当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。 偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行： ① 第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。② 第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向 。5、轻锁有线程来参与锁的竞争，但是获取锁的冲突时间极短本质就是自旋锁1、轻量级锁的获取轻量级锁是为了在线程近乎交替执行同步块时提高性能。主要目的： 在没有多线程竞争的前提下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗，说白了先自旋再阻塞。升级时机： 当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁假如线程A已经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁已经被线程A拿到，当前该锁已是偏向锁了。而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，那线程B就会进行CAS操作希望能获得锁。此时线程B操作中有两种情况：如果锁获取成功，直接替换Mark Word中的线程ID为B自己的ID(A → B)，重新偏向于其他线程(即将偏向锁交给其他线程，相当于当前线程”被”释放了锁)，该锁会保持偏向锁状态，A线程Over，B线程上位；​\t\t如果锁获取失败，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。2、Code演示如果关闭偏向锁，就可以直接进入轻量级锁-XX:-UseBiasedLocking3、自旋达到一定次数和程度java6之前默认启用，默认情况下自旋的次数是 10 次 -XX:PreBlockSpin=10来修改，或者自旋线程数超过cpu核数一半Java6之后自适应，自适应意味着自旋的次数不是固定不变的而是根据：同一个锁上一次自旋的时间，拥有锁线程的状态来决定。4、轻量锁与偏向锁的区别和不同争夺轻量级锁失败时，自旋尝试抢占锁轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁6、重锁有大量的线程参与锁的竞争，冲突性很高7、各种锁优缺点、synchronized锁升级和实现原理synchronized锁升级过程总结：一句话，就是先自旋，不行再阻塞。实际上是把之前的悲观锁(重量级锁)变成在一定条件下使用偏向锁以及使用轻量级(自旋锁CAS)的形式​\t\tsynchronized在修饰方法和代码块在字节码上实现方式有很大差异，但是内部实现还是基于对象头的MarkWord来实现的。JDK1.6之前synchronized使用的是重量级锁，JDK1.6之后进行了优化，拥有了无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁的升级过程，而不是无论什么情况都使用重量级锁。​\t\t偏向锁:适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法/代码块则使用偏向锁。轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法/代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。​\t\t重量级锁：适用于竞争激烈的情况，如果同步方法/代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。4、JIT编译器对锁的优化Just In Time Compiler，一般翻译为即时编译器1、锁消除/** * 锁消除 * 从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用， * 极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用 */public class LockClearUPDemo{ static Object objectLock = new Object();//正常的 public void m1() { //锁消除,JIT会无视它，synchronized(对象锁)不存在了。不正常的 Object o = new Object(); synchronized (o) { System.out.println(\"-----hello LockClearUPDemo\"+\"\\t\"+o.hashCode()+\"\\t\"+objectLock.hashCode()); } } public static void main(String[] args) { LockClearUPDemo demo = new LockClearUPDemo(); for (int i = 1; i &lt;=10; i++) { new Thread(() -&gt; { demo.m1(); },String.valueOf(i)).start(); } }}2、锁粗化/** * 锁粗化 * 假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块， * 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能 */public class LockBigDemo{ static Object objectLock = new Object(); public static void main(String[] args) { new Thread(() -&gt; { synchronized (objectLock) { System.out.println(\"11111\"); } synchronized (objectLock) { System.out.println(\"22222\"); } synchronized (objectLock) { System.out.println(\"33333\"); } },\"a\").start(); new Thread(() -&gt; { synchronized (objectLock) { System.out.println(\"44444\"); } synchronized (objectLock) { System.out.println(\"55555\"); } synchronized (objectLock) { System.out.println(\"66666\"); } },\"b\").start(); }}十六、AbstractQueuedSynchronizer之AQS1、AQS是什么字面意思:抽象的队列同步器AbstractOwnableSynchronizerAbstractQueuedLongSynchronizerAbstractQueuedSynchronizer 通常地：AbstractQueuedSynchronizer简称为AQS技术解释​\t\t是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石，通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态CLH：Craig、Landin and Hagersten 队列，是一个单向链表，AQS中的队列是CLH变体的虚拟双向队列FIFO2、AQS为什么是JUC内容中最重要的基石1、和AQS有关的2、ReentrantLock3、CountDownLatch4、ReentrantReadWriteLock5、Semaphore6、进一步理解锁和同步器的关系锁，面向锁的使用者定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可。同步器，面向锁的实现者比如Java并发大神DougLee，提出统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。3、AQS能干嘛加锁会导致阻塞，有阻塞就需要排队，实现排队必然需要队列​\t\t抢到资源的线程直接使用处理业务，抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程继续去等待(类似银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候)，但等候线程仍然保留获取锁的可能且获取锁流程仍在继续(候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务)。既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？​\t\t如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的结点（Node），通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的效果。4、AQS初步1、官网解释有阻塞就需要排队，实现排队必然需要队列​\t\tAQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改。2、AQS内部体系架构1、AQS自身 AQS的int变量AQS的同步状态State成员变量银行办理业务的受理窗口状态零就是没人，自由状态可以办理大于等于1，有人占用窗口，等着去 AQS的CLH队列CLH队列(三个大牛的名字组成)，为一个双向队列小总结有阻塞就需要排队，实现排队必然需要队列state变量+CLH双端队列2、内部类Node(Node类在AQS类内部) Node的int变量Node的等待状态waitState成员变量volatile int waitStatus等候区其它顾客(其它线程)的等待状态队列中每个排队的个体就是一个 Node Node此类的讲解3、AQS同步队列的基本结构CLH：Craig、Landin and Hagersten 队列，是个单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO）5、从ReentrantLock开始解读AQSLock接口的实现类，基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的1、ReentrantLock的原理2、从最简单的lock方法开始看看公平和非公平 可以明显看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法3、非公平锁 方法lock()对比公平锁和非公平锁的 tryAcquire()方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少了一个判断 !hasQueuedPredecessors()hasQueuedPredecessors() 中判断了是否需要排队，导致公平锁和非公平锁的差异如下：公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中；非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程在unpark()，之后还是需要竞争锁（存在线程竞争的情况下）4、源码解读1、lock()2、acquire()3、tryAcquire(arg)非公平锁nonfairTryAcquire(acquires)return false; 继续推进条件，走下一个方法return true; 结束4、addWaiter(Node.EXCLUSIVE)addWaiter(Node mode)enq(node);双向链表中，第一个节点为虚节点(也叫哨兵节点)，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是从第二个节点开始的。假如3号ThreadC线程进来prev - compareAndSetTail - next5、acquireQueued(addWaiter(Node.EXCLUSIVE), arg)acquireQueued假如再抢抢失败就会进入shouldParkAfterFailedAcquire 和 parkAndCheckInterrupt 方法中shouldParkAfterFailedAcquire​\t\t如果前驱节点的 waitStatus 是 SIGNAL状态，即 shouldParkAfterFailedAcquire 方法会返回 true 程序会继续向下执行 parkAndCheckInterrupt 方法，用于将当前线程挂起parkAndCheckInterrupt5、unlocksync.release(1);tryRelease(arg)unparkSuccessor十七、ReentrantLock、ReentrantReadWriteLock、StampedLock1、ReentrantReadWriteLock读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。1、读写锁意义和特点​\t\t读写锁ReentrantReadWriteLock并不是真正意义上的读写分离，它只允许读读共存，而读写和写写依然是互斥的，大多实际场景是“读/读”线程间并不存在互斥关系，只有”读/写”线程或”写/写”线程间的操作需要互斥的。因此引入ReentrantReadWriteLock。​\t\t一个ReentrantReadWriteLock同时只能存在一个写锁但是可以存在多个读锁，但不能同时存在写锁和读锁(切菜还是拍蒜选一个)。也即一个资源可以被多个读操作访问或一个写操作访问，但两者不能同时进行。只有在读多写少情境之下，读写锁才具有较高的性能体现。2、特点 可重入 读写分离public class ReentrantReadWriteLockDemo{ public static void main(String[] args) { MyResource myResource = new MyResource(); for (int i = 1; i &lt;=10; i++) { int finalI = i; new Thread(() -&gt; { myResource.write(finalI +\"\", finalI +\"\"); },String.valueOf(i)).start(); } for (int i = 1; i &lt;=10; i++) { int finalI = i; new Thread(() -&gt; { myResource.read(finalI +\"\"); },String.valueOf(i)).start(); } //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } //读全部over才可以继续写 for (int i = 1; i &lt;=3; i++) { int finalI = i; new Thread(() -&gt; { myResource.write(finalI +\"\", finalI +\"\"); },\"newWriteThread===\"+String.valueOf(i)).start(); } }}3、从写锁→读锁，ReentrantReadWriteLock可以降级《Java 并发编程的艺术》中关于锁降级的说明：锁的严苛程度变强叫做升级，反之叫做降级锁降级：将写入锁降级为读锁(类似Linux文件读写权限理解，就像写权限要高于读权限一样)1、读写锁降级演示可以降级锁降级：遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。Java8 官网说明重入还允许通过获取写入锁定，然后读取锁然后释放写锁从写锁到读取锁, 但是，从读锁定升级到写锁是不可能的。锁降级是为了让当前线程感知到数据的变化，目的是保证数据可见性/** * 锁降级：遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。 * * 如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。 */public class LockDownGradingDemo{ public static void main(String[] args) { ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(); ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock(); ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock(); writeLock.lock(); System.out.println(\"-------正在写入\"); readLock.lock(); System.out.println(\"-------正在读取\"); writeLock.unlock(); }}如果有线程在读，那么写线程是无法获取写锁的，是悲观锁的策略不可锁升级线程获取读锁是不能直接升级为写入锁的。在ReentrantReadWriteLock中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会被阻塞。所以，需要释放所有读锁，才可获取写锁，2、写锁和读锁是互斥的​\t\t写锁和读锁是互斥的（这里的互斥是指线程间的互斥，当前线程可以获取到写锁又获取到读锁，但是获取到了读锁不能继续获取写锁），这是因为读写锁要保持写操作的可见性。因为，如果允许读锁在被获取的情况下对写锁的获取，那么正在运行的其他读线程无法感知到当前写线程的操作​\t\t因此，分析读写锁ReentrantReadWriteLock，会发现它有个潜在的问题：读锁全完，写锁有望；写锁独占，读写全堵；如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，见前面Case《code演示LockDownGradingDemo》即ReadWriteLock读的过程中不允许写，只有等待线程都释放了读锁，当前线程才能获取写锁，也就是写入必须等待，这是一种悲观的读锁，o(╥﹏╥)o，人家还在读着那，你先别去写，省的数据乱。​\t\t分析StampedLock(后面详细讲解)，会发现它改进之处在于：读的过程中也允许获取写锁介入(相当牛B，读和写两个操作也让你“共享”(注意引号))，这样会导致我们读的数据就可能不一致！所以，需要额外的方法来判断读的过程中是否有写入，这是一种乐观的读锁，O(∩_∩)O哈哈~。 显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。4、读写锁之读写规矩，再说降级锁降级 下面的示例代码摘自ReentrantWriteReadLock源码中：ReentrantWriteReadLock支持锁降级，遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁，不支持锁升级。解读在最下面: 代码中声明了一个volatile类型的cacheValid变量，保证其可见性。 首先获取读锁，如果cache不可用，则释放读锁，获取写锁，在更改数据之前，再检查一次cacheValid的值，然后修改数据，将cacheValid置为true，然后在释放写锁前获取读锁；此时，cache中数据可用，处理cache中数据，最后释放读锁。这个过程就是一个完整的锁降级的过程，目的是保证数据可见性。 如果违背锁降级的步骤 如果当前的线程C在修改完cache中的数据后，没有获取读锁而是直接释放了写锁，那么假设此时另一个线程D获取了写锁并修改了数据，那么C线程无法感知到数据已被修改，则数据出现错误。 如果遵循锁降级的步骤 线程C在释放写锁之前获取读锁，那么线程D在获取写锁时将被阻塞，直到线程C完成数据处理过程，释放读锁。这样可以保证返回的数据是这次更新的数据，该机制是专门为了缓存设计的。 2、邮戳锁StampedLock无锁→独占锁→读写锁→邮戳锁1、StampedLock是什么StampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5中的读写锁ReentrantReadWriteLock的优化。邮戳锁 - 也叫票据锁 stamp（戳记，long类型） 代表了锁的状态。当stamp返回零时，表示线程获取锁失败。并且，当释放锁或者转换锁的时候，都要传入最初获取的stamp值。2、它是由锁饥饿问题引出​\t\tReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了 因为当前有可能会一直存在读锁，而无法获得写锁，根本没机会写，1、如何缓解锁饥饿问题？使用“公平”策略可以一定程度上缓解这个问题new ReentrantReadWriteLock(true);但是“公平”策略是以牺牲系统吞吐量为代价的StampedLock类的乐观读锁闪亮登场ReentrantReadWriteLock允许多个线程同时读，但是只允许一个线程写，在线程获取到写锁的时候，其他写操作和读操作都会处于阻塞状态，读锁和写锁也是互斥的，所以在读的时候是不允许写的，读写锁比传统的synchronized速度要快很多，原因就是在于ReentrantReadWriteLock支持读并发StampedLock横空出世ReentrantReadWriteLock的读锁被占用的时候，其他线程尝试获取写锁的时候会被阻塞。但是，StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，这其实是对读锁的优化，所以，在获取乐观读锁后，还需要对结果进行校验。3、StampedLock的特点 所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为零表示获取失败，其余都表示成功； 所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致； StampedLock是不可重入的，危险(如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)1、StampedLock有三种访问模式 Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似 Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似 Optimistic reading（乐观读模式）：无锁机制，类似于数据库中的乐观锁，支持读写并发，很乐观认为读取时没人修改，假如被修改再实现升级为悲观读模式 2、乐观读模式code演示public class StampedLockDemo{ static int number = 37; static StampedLock stampedLock = new StampedLock(); public void write() { long stamp = stampedLock.writeLock(); System.out.println(Thread.currentThread().getName()+\"\\t\"+\"=====写线程准备修改\"); try { number = number + 13; }catch (Exception e){ e.printStackTrace(); }finally { stampedLock.unlockWrite(stamp); } System.out.println(Thread.currentThread().getName()+\"\\t\"+\"=====写线程结束修改\"); } //悲观读 public void read() { long stamp = stampedLock.readLock(); System.out.println(Thread.currentThread().getName()+\"\\t come in readlock block,4 seconds continue...\"); //暂停几秒钟线程 for (int i = 0; i &lt;4 ; i++) { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"\\t 正在读取中......\"); } try { int result = number; System.out.println(Thread.currentThread().getName()+\"\\t\"+\" 获得成员变量值result：\" + result); System.out.println(\"写线程没有修改值，因为 stampedLock.readLock()读的时候，不可以写，读写互斥\"); }catch (Exception e){ e.printStackTrace(); }finally { stampedLock.unlockRead(stamp); } } //乐观读 public void tryOptimisticRead() { long stamp = stampedLock.tryOptimisticRead(); int result = number; //间隔4秒钟，我们很乐观的认为没有其他线程修改过number值，实际靠判断。 System.out.println(\"4秒前stampedLock.validate值(true无修改，false有修改)\"+\"\\t\"+stampedLock.validate(stamp)); for (int i = 1; i &lt;=4 ; i++) { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"\\t 正在读取中......\"+i+ \"秒后stampedLock.validate值(true无修改，false有修改)\"+\"\\t\" +stampedLock.validate(stamp)); } if(!stampedLock.validate(stamp)) { System.out.println(\"有人动过--------存在写操作！\"); stamp = stampedLock.readLock(); try { System.out.println(\"从乐观读 升级为 悲观读\"); result = number; System.out.println(\"重新悲观读锁通过获取到的成员变量值result：\" + result); }catch (Exception e){ e.printStackTrace(); }finally { stampedLock.unlockRead(stamp); } } System.out.println(Thread.currentThread().getName()+\"\\t finally value: \"+result); } public static void main(String[] args) { StampedLockDemo resource = new StampedLockDemo(); new Thread(() -&gt; { resource.read(); //resource.tryOptimisticRead(); },\"readThread\").start(); // 2秒钟时乐观读失败，6秒钟乐观读取成功resource.tryOptimisticRead();，修改切换演示 //try { TimeUnit.SECONDS.sleep(6); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { resource.write(); },\"writeThread\").start(); }}读的过程中也允许获取写锁介入4、StampedLock的缺点 StampedLock 不支持重入，没有Re开头 StampedLock 的悲观读锁和写锁都不支持条件变量（Condition），这个也需要注意。 使用 StampedLock一定不要调用中断操作，即不要调用interrupt() 方法 如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly()和写锁writeLockInterruptibly() " }, { "title": "MySQL学习", "url": "/posts/mysql%E5%AD%A6%E4%B9%A0/", "categories": "", "tags": "MySQL, 数据库", "date": "2022-07-28 21:22:00 +0800", "snippet": "基础篇通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限通用语法 SQL语句可以单行或多行书写，以分号结尾。 SQL语句可以使用空格/缩进来增强语句的可读性。 MySQL数据库的...", "content": "基础篇通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限通用语法 SQL语句可以单行或多行书写，以分号结尾。 SQL语句可以使用空格/缩进来增强语句的可读性。 MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。 注释： 单行注释：–注释内容或#注释内容(MySQL特有) 多行注释：/注释内容/ DDL（数据定义语言）数据定义语言数据库操作查询所有数据库：SHOW DATABASES;查询当前处于哪个数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ]; 字符集(character set)：定义了字符以及字符的编码。 字符序(collation)：定义了字符的比较规则。删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名; UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集表操作查询当前数据库所有表(前提是你已经use 数据库名)：SHOW TABLES;查询表结构：DESC 表名;查询指定表的建表语句：SHOW CREATE TABLE 表名;创建表：CREATE TABLE 表名(\t字段1 字段1类型 [COMMENT 字段1注释],\t字段2 字段2类型 [COMMENT 字段2注释],\t字段3 字段3类型 [COMMENT 字段3注释],\t...\t字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ];最后一个字段后面没有逗号数据类型整型 类型名称 取值范围 大小 TINYINT -128〜127 1个字节 SMALLINT -32768〜32767 2个宇节 MEDIUMINT -8388608〜8388607 3个字节 INT (INTEGHR) -2147483648〜2147483647 4个字节 BIGINT -9223372036854775808〜9223372036854775807 8个字节 无符号在数据类型后加 unsigned 关键字。无符号最大值大约是有符号最大值的两倍TINYINT类似Java中的ByteSMALLINT类似Java中的ShortINT类似Java中的IntegerBIGINT类似Java中的Long浮点型 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 日期和时间 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 字符串 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;=M&lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称';修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称';删除字段：ALTER TABLE 表名 DROP 字段名;修改表名：ALTER TABLE 表名 RENAME TO 新表名删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：保留表结构,不保留数据TRUNCATE TABLE 表名;DML（数据操作语言）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...);批量添加数据：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 插入数据时,指定的字段顺序需要与值的顺序是一一对应的 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = 'Jack' WHERE id = 1;删除数据：DELETE FROM 表名 [ WHERE 条件 ];DQL（数据查询语言）语法：SELECT\t字段列表FROM\t表名字段WHERE\t条件列表GROUP BY\t分组字段列表HAVING\t分组后的条件列表ORDER BY\t排序字段列表LIMIT\t分页参数 记忆口诀: 说服我干活哦了基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名;设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;去除重复记录：SELECT DISTINCT 字段列表 FROM 表名;转义：SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/'/ 之后的_不作为通配符条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表;条件： 比较运算符 功能 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 = 等于 &lt;&gt; 或 != 不等于 BETWEEN … AND … 在某个范围内（先最小、后最大值) 替代范围值 and IN(…) 在in之后的列表中的值，多选一,替代多个or情况 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 &amp;&amp; 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子：-- 年龄等于30select * from employee where age = 30;-- 年龄小于30select * from employee where age &lt; 30;-- 小于等于select * from employee where age &lt;= 30;-- 没有身份证select * from employee where idcard is null or idcard = '';-- 有身份证select * from employee where idcard;select * from employee where idcard is not null;-- 不等于select * from employee where age != 30;-- 年龄在20到30之间select * from employee where age between 20 and 30;select * from employee where age &gt;= 20 and age &lt;= 30;-- 下面语句不报错，但查不到任何信息select * from employee where age between 30 and 20;-- 性别为女且年龄小于30select * from employee where age &lt; 30 and gender = '女';-- 年龄等于25或30或35select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);-- 姓名为两个字select * from employee where name like '__';-- 身份证最后为Xselect * from employee where idcard like '%X';聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法：SELECT 聚合函数(字段列表) FROM 表名;例：SELECT count(id) from employee where workaddress = \"广东省\"; 所有NULL不参与所有聚合函数运算分组查询语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子：-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）select count(*) from employee group by gender;-- 根据性别分组，统计男性和女性数量select gender, count(*) from employee group by gender;-- 根据性别分组，统计男性和女性的平均年龄select gender, avg(age) from employee group by gender;-- 年龄小于45，并根据工作地址分组select workaddress, count(*) from employee where age &lt; 45 group by workaddress;-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3; 执行顺序：where &gt; 聚合函数 &gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;排序方式： ASC: 升序（默认） DESC: 降序例子：-- 根据年龄升序排序SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;-- 两字段排序，根据年龄升序排序，入职时间降序排序SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;例子：-- 查询第一页数据，展示10条SELECT * FROM employee LIMIT 0, 10;-- 查询第二页SELECT * FROM employee LIMIT 10, 10; 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10DQL执行顺序FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMITDCL管理用户查询用户：USER mysql;SELECT * FROM user;创建用户:CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';修改用户密码：ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';删除用户：DROP USER '用户名'@'主机名';例子：-- 创建用户test，只能在当前主机localhost访问create user 'test'@'localhost' identified by '123456';-- 创建用户test，能在任意主机访问create user 'test'@'%' identified by '123456';create user 'test' identified by '123456';-- 修改密码alter user 'test'@'localhost' identified with mysql_native_password by '1234';-- 删除用户drop user 'test'@'localhost'; 主机名可以使用 % 通配权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看权限一览表查询权限：SHOW GRANTS FOR '用户名'@'主机名';授予权限：GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 多个权限用逗号分隔授权时，数据库名和表名可以用 * 进行通配，代表所有函数 字符串函数 数值函数 日期函数 流程函数字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 使用示例：-- 拼接SELECT CONCAT('Hello', 'World');-- 小写SELECT LOWER('Hello');-- 大写SELECT UPPER('Hello');-- 左填充SELECT LPAD('01', 5, '-');-- 右填充SELECT RPAD('01', 5, '-');-- 去除空格SELECT TRIM(' Hello World ');-- 切片（起始索引为1）SELECT SUBSTRING('Hello World', 1, 5);数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子：-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子：select\tname,\t(case when age &gt; 30 then '中年' else '青年' end)from employee;select\tname,\t(case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址'from employee;约束分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子：create table user(\tid int primary key auto_increment,\tname varchar(10) not null unique,\tage int check(age &gt; 0 and age &lt; 120),\tstatus char(1) default '1',\tgender char(1));外键约束添加外键：CREATE TABLE 表名(\t字段名 字段类型,\t...\t[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名;删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;多表查询多表关系 一对多（多对一） 多对多 一对一一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id;内连接查询内连接查询的是两张表交集的部分隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;显式性能比隐式高例子：-- 查询员工姓名，及关联的部门的名称-- 隐式select e.name, d.name from employee as e, dept as d where e.dept = d.id;-- 显式select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;例子：-- 左select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样-- 右select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept自连接查询当前表与自身的连接查询，自连接必须使用表别名语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;自连接查询，可以是内连接查询，也可以是外连接查询例子：-- 查询员工及其所属领导的名字select a.name, b.name from employee a, employee b where a.manager = b.id;-- 没有领导的也查询出来select a.name, b.name from employee a left join employee b on a.manager = b.id;联合查询 union, union all把多次查询的结果合并，形成一个新的查询集语法：SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ... UNION ALL 会有重复结果，UNION 不会联合查询比使用or效率高，不会使索引失效子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列）根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=例子：-- 查询销售部所有员工select id from dept where name = '销售部';-- 根据销售部部门ID，查询员工信息select * from employee where dept = 4;-- 合并（子查询）select * from employee where dept = (select id from dept where name = '销售部');-- 查询xxx入职之后的员工信息select * from employee where entrydate &gt; (select entrydate from employee where name = 'xxx');列子查询返回的结果是一列（可以是多行）。常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子：-- 查询销售部和市场部的所有员工信息select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');-- 查询比财务部所有人工资都高的员工信息select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = '财务部'));-- 查询比研发部任意一人工资高的员工信息select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = '研发部'));行子查询返回的结果是一行（可以是多列）。常用操作符：=, &lt;, &gt;, IN, NOT IN例子：-- 查询与xxx的薪资及直属领导相同的员工信息select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx');表子查询返回的结果是多行多列常用操作符：IN例子：-- 查询与xxx1，xxx2的职位和薪资相同的员工select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2');-- 查询入职日期是2006-01-01之后的员工，及其部门信息select e.*, d.* from (select * from employee where entrydate &gt; '2006-01-01') as e left join dept as d on e.dept = d.id;事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。基本操作：-- 1. 查询张三账户余额select * from account where name = '张三';-- 2. 将张三账户余额-1000update account set money = money - 1000 where name = '张三';-- 此语句出错后张三钱减少但是李四钱没有增加模拟sql语句错误-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = '李四';-- 查看事务提交方式SELECT @@AUTOCOMMIT;-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效SET @@AUTOCOMMIT = 0;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;-- 设置手动提交后上面代码改为：select * from account where name = '张三';update account set money = money - 1000 where name = '张三';update account set money = money + 1000 where name = '李四';commit;操作方式二：开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK;操作实例：start transaction;select * from account where name = '张三';update account set money = money - 1000 where name = '张三';update account set money = money + 1000 where name = '李四';commit;四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效进阶篇存储引擎MySQL体系结构：存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。相关操作：-- 查询建表语句show create table account;-- 建表时指定存储引擎CREATE TABLE 表名(\t...) ENGINE=INNODB;-- 查看当前数据库支持的存储引擎show engines;InnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。特点： DML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性文件： xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间知识点：查看 Mysql 变量：show variables like 'innodb_file_per_table';从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibdInnoDB 逻辑存储结构：MyISAMMyISAM 是 MySQL 早期的默认存储引擎。特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快文件： xxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引MemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。特点： 存放在内存中，速度快 hash索引（默认）文件： xxx.sdi: 存储表结构信息存储引擎特点 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N/A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。性能分析查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：SHOW GLOBAL STATUS LIKE 'Com_______'; 或者 SHOW SESSION STATUS LIKE 'Com_______';例：show global status like 'Com_______'慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：\t# 开启慢查询日志开关\tslow_query_log=1\t# 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志\tlong_query_time=2更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log查看慢查询日志开关状态：show variables like 'slow_query_log';profileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：SELECT @@have_profiling;profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：SET profiling = 1;查看所有语句的耗时：show profiles;查看指定query_id的SQL语句各个阶段的耗时：show profile for query query_id;查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id;explainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法：\t# 直接在select语句之前加上关键字 explain / desc\tEXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;EXPLAIN 各字段含义： id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all possible_key：可能应用在这张表上的索引，一个或多个 Key：实际使用的索引，如果为 NULL，则没有使用索引 Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好索引索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。优缺点：优点： 提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗缺点： 索引列也是要占用空间的 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 B-Tree二叉树的缺点可以用红黑树来解决：红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。为了解决上述问题，可以使用 B-Tree 结构。B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.htmlB+Tree结构图： 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html与 B-Tree 的区别： 所有的数据都会出现在叶子节点 叶子节点形成一个单向链表MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个   全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 演示图：聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引思考题1. 以下 SQL 语句，哪个执行效率高？为什么？select * from user where id = 10;select * from user where name = 'Arm';-- 备注：id为主键，name字段创建的有索引答：第一条语句，因为第二条需要回表查询，相当于两个步骤。2. InnoDB 主键索引的 B+Tree 高度为多少？答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引查看索引：SHOW INDEX FROM table_name;删除索引：DROP INDEX index_name ON table_name;案例：-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引create index idx_user_name on tb_user(name);-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引create unique index idx_user_phone on tb_user (phone);-- 为profession, age, status创建联合索引create index idx_user_pro_age_stat on tb_user(profession, age, status);-- 为email建立合适的索引来提升查询效率create index idx_user_email on tb_user(email);-- 删除索引drop index idx_user_email on tb_user;使用规则最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。例如，使用索引：explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\";不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\";必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\";use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。覆盖索引&amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。explain 中 extra 字段含义：using index condition：查找使用了索引，但是需要回表查询数据using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx';所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username='itcast';解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式：select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user;show index 里面的sub_part可以看到接取的长度单列索引&amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。单列索引情况：explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';这句只会用到phone索引字段 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询SQL 优化插入数据普通插入： 采用批量插入（一次插入的数据不建议超过1000条） 手动提交事务 主键顺序插入大批量插入：如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。# 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）mysql --local-infile -u root -p# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关set global local_infile = 1;select @@local_infile;# 执行load指令将准备好的数据，加载到表结构中load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\\n';主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定 文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90主键设计原则： 满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 业务操作时，避免对主键的修改order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高 如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引总结： 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）group by优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则limit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化例如：-- 此语句耗时很长select * from tb_sku limit 9000000, 10;-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询select id from tb_sku order by id limit 9000000, 10;-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;count优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用rediscount的几种用法： 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值 用法：count(*)、count(主键)、count(字段)、count(1) count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0各种用法的性能： count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空） count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加 count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)update优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。如以下两条语句：update student set no = '123' where id = 1;，这句由于id有主键索引，所以只会锁这一行；update student set no = '123' where name = 'test';，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引`权限一览表 具体权限的作用详见官方文档GRANT 和 REVOKE 允许的静态权限 Privilege Grant Table Column Context ALL [PRIVILEGES] Synonym for “all privileges” Server administration ALTER Alter_priv Tables ALTER ROUTINE Alter_routine_priv Stored routines CREATE Create_priv Databases, tables, or indexes CREATE ROLE Create_role_priv Server administration CREATE ROUTINE Create_routine_priv Stored routines CREATE TABLESPACE Create_tablespace_priv Server administration CREATE TEMPORARY TABLES Create_tmp_table_priv Tables CREATE USER Create_user_priv Server administration CREATE VIEW Create_view_priv Views DELETE Delete_priv Tables DROP Drop_priv Databases, tables, or views DROP ROLE Drop_role_priv Server administration EVENT Event_priv Databases EXECUTE Execute_priv Stored routines FILE File_priv File access on server host GRANT OPTION Grant_priv Databases, tables, or stored routines INDEX Index_priv Tables INSERT Insert_priv Tables or columns LOCK TABLES Lock_tables_priv Databases PROCESS Process_priv Server administration PROXY See proxies_priv table Server administration REFERENCES References_priv Databases or tables RELOAD Reload_priv Server administration REPLICATION CLIENT Repl_client_priv Server administration REPLICATION SLAVE Repl_slave_priv Server administration SELECT Select_priv Tables or columns SHOW DATABASES Show_db_priv Server administration SHOW VIEW Show_view_priv Views SHUTDOWN Shutdown_priv Server administration SUPER Super_priv Server administration TRIGGER Trigger_priv Tables UPDATE Update_priv Tables or columns USAGE Synonym for “no privileges” Server administration GRANT 和 REVOKE 允许的动态权限 Privilege Context APPLICATION_PASSWORD_ADMIN Dual password administration AUDIT_ABORT_EXEMPT Allow queries blocked by audit log filter AUDIT_ADMIN Audit log administration AUTHENTICATION_POLICY_ADMIN Authentication administration BACKUP_ADMIN Backup administration BINLOG_ADMIN Backup and Replication administration BINLOG_ENCRYPTION_ADMIN Backup and Replication administration CLONE_ADMIN Clone administration CONNECTION_ADMIN Server administration ENCRYPTION_KEY_ADMIN Server administration FIREWALL_ADMIN Firewall administration FIREWALL_EXEMPT Firewall administration FIREWALL_USER Firewall administration FLUSH_OPTIMIZER_COSTS Server administration FLUSH_STATUS Server administration FLUSH_TABLES Server administration FLUSH_USER_RESOURCES Server administration GROUP_REPLICATION_ADMIN Replication administration GROUP_REPLICATION_STREAM Replication administration INNODB_REDO_LOG_ARCHIVE Redo log archiving administration NDB_STORED_USER NDB Cluster PASSWORDLESS_USER_ADMIN Authentication administration PERSIST_RO_VARIABLES_ADMIN Server administration REPLICATION_APPLIER PRIVILEGE_CHECKS_USER for a replication channel REPLICATION_SLAVE_ADMIN Replication administration RESOURCE_GROUP_ADMIN Resource group administration RESOURCE_GROUP_USER Resource group administration ROLE_ADMIN Server administration SESSION_VARIABLES_ADMIN Server administration SET_USER_ID Server administration SHOW_ROUTINE Server administration SYSTEM_USER Server administration SYSTEM_VARIABLES_ADMIN Server administration TABLE_ENCRYPTION_ADMIN Server administration VERSION_TOKEN_ADMIN Server administration XA_RECOVER_ADMIN Server administration 图形化界面工具 Workbench(免费): http://dev.mysql.com/downloads/workbench/ navicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql Sequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/ HeidiSQL(免费): http://www.heidisql.com/ phpMyAdmin(免费): https://www.phpmyadmin.net/ SQLyog: https://sqlyog.en.softonic.com/安装小技巧 在SQL语句之后加上\\G会将结果的表格形式转换成行文本形式 查看Mysql数据库占用空间： SELECT table_schema \"Database Name\" , SUM(data_length + index_length) / (1024 * 1024) \"Database Size in MB\"FROM information_schema.TABLESGROUP BY table_schema; " }, { "title": "1.句子的形成", "url": "/posts/%E8%AF%AD%E6%B3%95-%E4%B8%80-%E5%8F%A5%E5%AD%90%E7%9A%84%E5%BD%A2%E6%88%90/", "categories": "语法, 赖世雄", "tags": "语法, 赖世雄, 英语", "date": "2022-07-27 20:42:00 +0800", "snippet": "(一)句子的形成概说任何一个句子一定是由什么组成?主语 + 动词忽略掉主语的句子是什么句?祈使句祈使句省略的主语是?You should祈使句句首为?动词原形祈使句变为否定形态?原型动词前加Don’tDon’t be silly.第一节可作主语的词类1.名词作主语2.代词作主语3.动名词或不定式短语作主语动词如何充当主语?变为动名词或不定式短语动名词作主语通常表示?表示已知的事实或曾经做过的...", "content": "(一)句子的形成概说任何一个句子一定是由什么组成?主语 + 动词忽略掉主语的句子是什么句?祈使句祈使句省略的主语是?You should祈使句句首为?动词原形祈使句变为否定形态?原型动词前加Don’tDon’t be silly.第一节可作主语的词类1.名词作主语2.代词作主语3.动名词或不定式短语作主语动词如何充当主语?变为动名词或不定式短语动名词作主语通常表示?表示已知的事实或曾经做过的经验不定时作主语通常表示?表示一种意愿,目的或未完成的事不定时或动名词作主语时,主语太长,要如何处理?用代词it作形式主语,置于句首,真正的主语移至句尾动名词作为主语放于句尾时,通常要?改为不定式短语 例外情况:It is no use + 动名词短语 = It is useless + 不定式短语 = It is of no nse + 不定式短语 = There is no use/sense/point + in + 动名词短语4.名词性从句作主语名词性从句包括哪些? 宾语从句 主语从句 表语从句 同位语从句名词性从句的形式有哪些? that 从句 whether 从句 疑问词所引导的从句什么是that从句?任何一个主语起首的句子前面冠以that, 即成that从句什么是whether从句?由可用yes/no的问句变化而成可用yes/no回答的问句称为一般疑问句问句有be动词时,如何变为whether从句主语与be动词还原,前面冠以whether Is he happy? ↓ whether he is happy问句有一般助动词（Can 、 will 、 may 、 should 、 ought to 、 must 、have）时,如何变为whether从句?主语和助动词还原 Can he do it ? ↓ whether he can do it问句有do、does、did等助动词时,如何变为whether从句?主语与助动词还原将do,does,did去掉,后面的动词依人称和时态变化 Did he come? ↓ whether he did come came did为过去时,故come改为一般过去时came Does he like it? ↓ whether he likes it does为三单一般现在时,故like改为likes什么是疑问词从句由疑问词(when,what,how,where,why)等引导的问句变化而成特殊疑问句中有be动词时,如何变为疑问词从句?主语与be动词还原,前面保留疑问词 What is he doing? ↓ what he is doing特殊疑问句中有一般助动词（Can 、 will 、 may 、 should 、 ought to 、 must 、have）时,如何变为疑问词从句?主语与助动词还原,前面保留疑问词 Where can he find it? ↓ where he can find it特殊疑问句中有do,does,did等助动词时,如何变为疑问词从句?主语与助动词还原,前面保留疑问词,再将do,does,did去掉,动词依人称和时态变化 What did he write? ↓ what he did write wroteWho,What,Which(哪一个)为疑问代词,若在问句中作主语,变为名词性从句时?结构不变 Who came here? ↓ Who came here Which is bought? ↓ Which is bought哪个被买走名词性从句在主语部分太长,故?用形式主语it代替,置于句首,名词性从句置于句尾及物动词在英语中称作?transitive verb, 缩写vt.宾语在英语中称作?object, 简写为o.介词在英语中称作?preposition, 缩写成prep.名词性从句作介词的宾语时?that从句不可作介词的宾语whether从句或疑问词引导的名词性从句作宾语 I am worried about whether he can do it. I’m curious about how he'll cope with the problem. I am sure of that the team has won the game.（×）遇到介词,一定要使用that的方法 介词 + the fact + that 从句 例 I am sure of the fact that the team has won the game. I am worried about the fact that he doesn't study. 保留介词,不加the fact ,that做出如下变化 第一步,去掉that 第二步,that后的主语变成所有格 第三步,动词变成动名词 I am worried about that he plays around all day. I am worried about his playing around all day. a) that 从句中若有助动词do,does,did时,予以去掉 I am worried about that he doesn’t study I am worried about his not studying. b) that 从句若有助动词will或would时,予以去掉即可 I am sure of that the team will win the game. I am sure of the team’s winning the game. c) 从句若有以下助动词时，做下列变化： may → be likely to can → be able to 再将be动词变为being I am happy about that he may come I am happy about his being likely to come. be + adj. + that从句 去掉介词,将that从句放在形容词后面,做其宾语 I am worried about that he plays around all day.I am worried that he plays around all day. I am sure of that the team has won the game.I am sure that the team has won the game 以上三种方法1.3最普遍,2常考 有时介词之后亦可直接接that从句,而不需the fact,形成惯用语 in that = because 因为 He is talented in that he can speak five different languages except that 只可惜;除了 He is nice except that sometimes he lies notwithstanding that 尽管 = despite the fact that = in spite of the fact that Notwithstanding that he is nice,I don’t like him Despite the fact that he is nice,I don’t like him. In spite of the fact that he is nice,I don’t like him5.名词短语作主语名词短语由什么组成疑问词+不定式短语疑问副词有哪些?where to live 住哪里whether to try again 是否再试一次when to talk to him 什么时候和他谈how to do it 如何做那事疑问代词有哪些?what to do 做什么whom to see 看谁which to buy 买哪一个whom to talk to 与谁谈 疑问副词形成的名词短语中，疑问副词因为是副词的性质，故不作不定式短语中及物动词的宾语。 但疑问代词形成的名词短语中，疑问代词因具名词的性质，故一定要作不定式短语中动词或介词的宾语。故what、whom、which在上列名词短语中，分别作do、See、buy、to（介词）的宾语。6.表距离的地方副词短语作主语表距离的地方副词短语,亦可作主语,与什么连用?单数的be动词连用from + 地方名词 + to + 地方名词From Shanghai to Beijing is about 1000 kilometers第二节 动词的种类及其用法概说1.动词(verb)基本上可分为五大类五大类分别是?a. 完全不及物动词 缩写c.vi.b. 不完全不及物动词 缩写i.vi.c. 完全及物动词 缩写c.vt.d. 不完全及物动词 缩写 i.vt.e. 授予动词 缩写d.v.2.如何判断完全不及物动词?我_______他. (主动)他被我_____. (被动)在上列的空格中,我们可以放入一个英文动词,翻成中文后,意思若无毛病,就是及物动词,否则就是不及物动词. kill 杀 我 kill 他 他被我 kill 我杀了他,他被我杀,语意五毛病,得知kill为及物动词 dance 跳舞 我 dance 他 他被我 dance 语意有毛病,所以是不及物动词3.兼作及物与不及物动词之常用动词sing vt. 唱（一首歌） vi.唱歌run vt.经营（工厂） vi,跑步study vt.研究（问题） vi.读书kill vt.杀（某人） vi.杀戮4.不及物动词可作及物动词，用同系名词作其宾语dreamvi.做梦vt.做（梦）dream a terrible dream(做一个可怕的梦)livevi.生活vt. 过（生活）live a happy life（过着快乐的生活）smilevi.微笑vt.露出（微笑）smile a bright smile(露出开朗的微笑)laughvi.笑vt.展开（大笑）laugh a hearty laugh（开怀大笑）sighvi.叹气vt.叹（气）sigh a deep sigh（深深地叹一口气）sleepvi.睡眠vt.睡（觉）sleep a sound sleep(睡了安稳的一觉)5.完全及物动词与完全不及物动词什么是完全及物动词?加了宾语以后,意思才很完全的动词 He kill her什么是完全不及物动词?不需加宾语,意思就很完全的动词he laughed6.完全及物动词出现的形态 主语 + 及物动词 + 宾语 He wrote a book S + vt. + o. 主语 + be动词 + 及物动词的现在分词 + 宾语 用于表示某动作正在进行的主动状态 He was writing a book S + be动词 + 现在分词 + o. 主语 + be动词 + 过去分词(past participle, 简称p.p.) 本句型用以表示被动的概念 The book was written by him S + be动词 + p.p. 主语 + be动词 + being + 过去分词 本句型用以表示某动作正在进行的被动状态 A book was being written by him. S + be动词 + 现在分词 + p.p. 7.完全不及物动词出现的形态 主语 + 不及物动词 Something happened. S + vi. 主语 + be动词 + 不及物动词的现在分词 本句型用以表示某动作正在进行的状态 Something was happening S + be动词 + 现在分词 完全不及物动词，就是意思很完全的不及物动词。这个动词置于主语之后，可单独存在，之后不须加任何词类意思就很完全 完全不以物动词后,可接副词(adv.)或副词对等语(如介词短语,状语动词等),以修饰该动词 8.不完全不及物动词什么是不完全不及物动词?这类动词(简写成i.vi.即连系动词)意思不完全，因而无法单独存在，之后要接名词、形容词或名词对等语（如代词、动名词、不定式、名词性从句、名词短语等），以补充其意思的不足。我们称作表语（subjective complement,简称S.c.)9.不完全不及物动词的判断方法10.不完全不及物动词的种类及其表语的用法11.不完全不及物动词的重要相关短语12.完全及物动词13.完全及物动词的用法14.不完全及物动词15.不完全及物动词的分类及用法16.授与动词17.间接宾语与直接宾语倒置原测18.与0f连用的授与动词19.表“提供”的授与动词20.其他补充要点第三节 结论1.五大句型2.祈使句、感叹句、问句3.结语" }, { "title": "第1节 位运算、算法是什么、简单排序", "url": "/posts/%E7%AE%97%E6%B3%95%E6%96%B0%E6%89%8B%E7%8F%AD%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/", "categories": "算法, 左神新手班", "tags": "左神, 算法, 新手班", "date": "2022-07-26 22:56:00 +0800", "snippet": "位运算 什么是算法 简单排序位运算int类型底层是多少位二进制组成?32位,共四字节如何打印一个数的32位?public static void print(int num) {\tfor (int i = 31; i &gt;= 0; i--) {\t\tSystem.out.print((num &amp; (1 &lt;&lt; i)) == 0 ? \"0\" : \"1\");\t}\tSystem...", "content": "位运算 什么是算法 简单排序位运算int类型底层是多少位二进制组成?32位,共四字节如何打印一个数的32位?public static void print(int num) {\tfor (int i = 31; i &gt;= 0; i--) {\t\tSystem.out.print((num &amp; (1 &lt;&lt; i)) == 0 ? \"0\" : \"1\");\t}\tSystem.out.println();}第一步1 « 31 ,1左移31位从0…1得到10….0,左移后空位用0补齐这串数字和num表示的数字进行与运算01为0,11为1,只需判断结果是否为0 想要对比第31位的数字 0000000000000000000000000000011 1000000000000000000000000000000 0000000000000000000000000000000 假设判断第2位的结果是不是1,只需1 « 1 ,通过与运算可以得到一个非0的值 想要对比第2位的数字 0000000000000000000000000000011 0000000000000000000000000000010 0000000000000000000000000000010 因此原数第二位是1左移和右移哪个带符号,哪个不带符号?左移不带符号,右移带符号32位数字能表示的范围?$0 \\sim 2^{32}-1$∵ 32位最多能表示32位1∴ 1111111111111111111111111111111表示的大小为$2^{31}+2^{30}+\\dots+2^{1}+2^{0}$∵等比数列求和公式为$S_n=a_1×\\frac{1-q^n}{1-q}=\\frac{a_1-a_n×q}{1-q}(q \\ne 1)$∴ 代入可得 $S_n=1 × \\frac{1-2^{32}}{1 - 2}=2^{32} - 1$为什么Java整形最大值为21亿,而不是42亿?因为整形最高位用作符号位表示的范围为$-2^{31} \\sim 2^{31} - 1$为什么表示范围右侧里会-1,左侧不减一?首先看无符号数无符号能表示$ 0 \\sim 2^{32}-1$算上0共$ 2^{32}$个数有符号的范围$-2^{31} \\sim 2^{31} - 1$总共同样是$2^{32}$个数正常情况下,分成一半就是各有$2^{31}$但是有个特殊情况就是0,正数里0占一个,对于负数来说有个-0的情况况,表示负数的最大值0归属到非负区表示范围$-0 = -2^{31} \\sim -1$共 $2^{31}$个数如何计算负数的二进制表示?符号位是1后面的状态为取反+1如何理解负数的二进制表示?-1的表示11111111111111111111111111111111Integer.MIN_VALUE的二进制表示10000000000000000000000000000000其二进制值为取反为11111111111111111111111111111111加110000000000000000000000000000000此时值为$2^{31}$为什么负数的运算要取反+1?因为所有的数字在计算机里都是二进制二进制的计算是通过位运算想用一套运算来处理加减乘除通过定义负数的表现形式,可以让不管正负,都通过加法器得到结果越底层的内容越要简单,如果复杂,系统实现成本高1 + 2 和 1 -2»表示的是?右移,最高位用符号位补齐如何获取一个数的相反数? 前面加个减号 某个数取反码 + 1 补码解决了什么问题? 数字0在计算机中非唯一编码 实现了减法变加法 负数在计算机中的存储是?绝对值的补码形式,即符号位不变,其余部分取反+1计算机中最小值取反+1,为什么还是最小值最小值的表示形式是10000…0000取反结果为01111…1111此时+110000…0000所以还是原来的数什么是算法对一个问题的流程设计计算机解决问题依靠数据结构算法分为两类? 明确知道怎么算 不知道怎么算,但明确知道怎么试计算机和计算器的区别?计算器知道怎么算计算机知道怎么试简单排序什么是选择排序?从全局中找出最小值,最小值和数组首位做交换从除首位外其他未排序部分中找出最小值,最小值和第二位做交换依次进行import java.util.Arrays;public class Code04_SelectionSort {\tpublic static void selectionSort(int[] arr) {\t\t// 先考虑清楚边界条件,为1或者0就不需要排序\t\tif (arr == null || arr.length &lt; 2) {\t\t\treturn;\t\t}\t\tfor (int i = 0; i &lt; arr.length - 1; i++) { \t\t\t// 假设i位置的值为最小值\t\t\tint minIndex = i;\t\t\t// i往后所有位置的值我都看一遍\t\t\tfor (int j = i + 1; j &lt; arr.length; j++) {\t\t\t\tif(arr[j] &lt; arr[minIndex]) {\t\t\t\t\tminIndex = j;\t\t\t\t}// 这个if判断可以换成 minValueIndex = arr[j] &lt; arr[minValueIndex]?j:minValueIndex;\t\t\t}\t\t\tswap(arr, i, minIndex);\t\t}\t}}选择排序剩余代码展开\t// i 与 j 的位置进行交换\tpublic static void swap(int[] arr, int i, int j) {\t\tint tmp = arr[i];\t\tarr[i] = arr[j];\t\tarr[j] = tmp;\t}\t// for test\tpublic static void comparator(int[] arr) {\t\tArrays.sort(arr);\t}\t// for test\tpublic static int[] generateRandomArray(int maxSize, int maxValue) {\t\t// Math.random() [0,1)\t\t// Math.random() * N [0,N)\t\t// (int)(Math.random() * N) [0, N-1]\t\tint[] arr = new int[(int) ((maxSize + 1) * Math.random())];\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\t// [-? , +?]\t\t\tarr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());\t\t}\t\treturn arr;\t}\t// for test\tpublic static int[] copyArray(int[] arr) {\t\tif (arr == null) {\t\t\treturn null;\t\t}\t\tint[] res = new int[arr.length];\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tres[i] = arr[i];\t\t}\t\treturn res;\t}\t// for test\tpublic static boolean isEqual(int[] arr1, int[] arr2) {\t\tif ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) {\t\t\treturn false;\t\t}\t\tif (arr1 == null &amp;&amp; arr2 == null) {\t\t\treturn true;\t\t}\t\tif (arr1.length != arr2.length) {\t\t\treturn false;\t\t}\t\tfor (int i = 0; i &lt; arr1.length; i++) {\t\t\tif (arr1[i] != arr2[i]) {\t\t\t\treturn false;\t\t\t}\t\t}\t\treturn true;\t}\t// for test\tpublic static void printArray(int[] arr) {\t\tif (arr == null) {\t\t\treturn;\t\t}\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tSystem.out.print(arr[i] + \" \");\t\t}\t\tSystem.out.println();\t}\t// for test\tpublic static void main(String[] args) {\t\tint testTime = 500000;\t\tint maxSize = 100;\t\tint maxValue = 100;\t\tboolean succeed = true;\t\tfor (int i = 0; i &lt; testTime; i++) {\t\t\tint[] arr1 = generateRandomArray(maxSize, maxValue);\t\t\tint[] arr2 = copyArray(arr1);\t\t\tselectionSort(arr1);\t\t\tcomparator(arr2);\t\t\tif (!isEqual(arr1, arr2)) {\t\t\t\tsucceed = false;\t\t\t\tprintArray(arr1);\t\t\t\tprintArray(arr2);\t\t\t\tbreak;\t\t\t}\t\t}\t\tSystem.out.println(succeed ? \"Nice!\" : \"Fucking fucked!\");\t\tint[] arr = generateRandomArray(maxSize, maxValue);\t\tprintArray(arr);\t\tselectionSort(arr);\t\tprintArray(arr);\t}什么是冒泡排序首先从1,2位置开始比较,大的数放在后面此时比较2,3位置,大的数放在后面依次进行,直到第一次循环完成,此时,最大值放在最后的位置第二次循环开始,1,2比较,2,3比较最后比较n-2和n-1的值大小,无需比较n-1和n的值,因为第一轮循环已经将最大值放在最后的位置package class01;import java.util.Arrays;public class Code05_BubbleSort {\tpublic static void bubbleSort(int[] arr) {\t\tif (arr == null || arr.length &lt; 2) {\t\t\treturn;\t\t}\t\t// 0 ~ n-1\t\t// 0 ~ n-2\t\t// ...\t\t// 0 ~ 1\t\t// 由上可以看出,结尾是从n-1开始,end的值最小值为1,所以结束条件为end&gt;0\t\tfor (int end = arr.length - 1; end &gt; 0; end--) {\t\t\t// 上一层循环解决的是end值是多少\t\t\t// 接下来要处理 01 12 23 ... end-1 end这些数之间的比较\t\t\tfor (int i = 0; i &lt; end; i++) {\t\t\t\t// 在这层循环里面,i的值实际上是两数中前一个数\t\t\t\t// 前一个数大于后一个数,两个交换\t\t\t\tif (arr[i] &gt; arr[i + 1]) {\t\t\t\t\tswap(arr, i, i + 1);\t\t\t\t}\t\t\t}\t\t}\t}}冒泡排序剩余代码展开\t// 交换arr的i和j位置上的值\tpublic static void swap(int[] arr, int i, int j) {\t\tint tmp = arr[i];\t\tarr[i] = arr[j];\t\tarr[j] = tmp;\t}\t// for test\tpublic static void comparator(int[] arr) {\t\tArrays.sort(arr);\t}\t// for test\tpublic static int[] generateRandomArray(int maxSize, int maxValue) {\t\tint[] arr = new int[(int) ((maxSize + 1) * Math.random())];\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tarr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());\t\t}\t\treturn arr;\t}\t// for test\tpublic static int[] copyArray(int[] arr) {\t\tif (arr == null) {\t\t\treturn null;\t\t}\t\tint[] res = new int[arr.length];\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tres[i] = arr[i];\t\t}\t\treturn res;\t}\t// for test\tpublic static boolean isEqual(int[] arr1, int[] arr2) {\t\tif ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) {\t\t\treturn false;\t\t}\t\tif (arr1 == null &amp;&amp; arr2 == null) {\t\t\treturn true;\t\t}\t\tif (arr1.length != arr2.length) {\t\t\treturn false;\t\t}\t\tfor (int i = 0; i &lt; arr1.length; i++) {\t\t\tif (arr1[i] != arr2[i]) {\t\t\t\treturn false;\t\t\t}\t\t}\t\treturn true;\t}\t// for test\tpublic static void printArray(int[] arr) {\t\tif (arr == null) {\t\t\treturn;\t\t}\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tSystem.out.print(arr[i] + \" \");\t\t}\t\tSystem.out.println();\t}\t// for test\tpublic static void main(String[] args) {\t\tint testTime = 500000;\t\tint maxSize = 100;\t\tint maxValue = 100;\t\tboolean succeed = true;\t\tfor (int i = 0; i &lt; testTime; i++) {\t\t\tint[] arr1 = generateRandomArray(maxSize, maxValue);\t\t\tint[] arr2 = copyArray(arr1);\t\t\tbubbleSort(arr1);\t\t\tcomparator(arr2);\t\t\tif (!isEqual(arr1, arr2)) {\t\t\t\tsucceed = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\tSystem.out.println(succeed ? \"Nice!\" : \"Fucking fucked!\");\t\tint[] arr = generateRandomArray(maxSize, maxValue);\t\tprintArray(arr);\t\tbubbleSort(arr);\t\tprintArray(arr);\t}什么是插入排序 首先看前0个数,是否有序(集合为空) 其次看前1个数,是否有序(只有一个,肯定有序) 看前2个数,是否有序 看第二个数与前一个比较,如果小于前一个数则两个交换 看前3个数,是否有序 看第3个数与第2个数比较,如果小于,则交换 如果交换,再与2的前一个数,即第1个数比较,看是否需要交换 以此类推实现的效果就是0 - 0 有序0 - 1 有序0 - 2 有序最终全部有序插入排序在斗地主里常见,新来一张牌,依次比较,直到相等或大于就插入import java.util.Arrays;public class Code06_InsertionSort {\tpublic static void insertionSort(int[] arr) {\t\tif (arr == null || arr.length &lt; 2) {\t\t\treturn;\t\t}\t\t// 0 - 0 (已完成排序,只有一个值)\t\t// 0 - 1 (变化的值从1开始)\t\t// 0 - 2\t\t// ...\t\t// 0 - n - 1\t\tfor (int i = 1; i &lt; arr.length; i++) { \t\t\t// 本轮循环目的:0 ~ i 做到有序\t\t\t// 已经具有的性质: 0 ~ i - 1已经有序\t\t\tfor (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {\t\t\t\t// j为其前一个下标,前一个值&gt;=0说明数组中存在这个位置的值\t\t\t\t// 并且arr[j] 左边的数比右边的数大,就要进行交换\t\t\t\t// 此时j + 1 表示的是要进行判断的数的下标\t\t\t\tswap(arr, j, j + 1);\t\t\t}\t\t}\t}}插入排序剩余代码展开\t// i和j,数交换\tpublic static void swap(int[] arr, int i, int j) {\t\tint tmp = arr[i];\t\tarr[i] = arr[j];\t\tarr[j] = tmp;\t}\t// for test\tpublic static void comparator(int[] arr) {\t\tArrays.sort(arr);\t}\t// for test\tpublic static int[] generateRandomArray(int maxSize, int maxValue) {\t\t// Math.random() -&gt; [0,1) 所有的小数，等概率返回一个\t\t// Math.random() * N -&gt; [0,N) 所有小数，等概率返回一个\t\t// (int)(Math.random() * N) -&gt; [0,N-1] 所有的整数，等概率返回一个\t\tint[] arr = new int[(int) ((maxSize + 1) * Math.random())]; // 长度随机 \t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tarr[i] = (int) ((maxValue + 1) * Math.random()) \t\t\t\t\t- (int) (maxValue * Math.random());\t\t}\t\treturn arr;\t}\t// for test\tpublic static int[] copyArray(int[] arr) {\t\tif (arr == null) {\t\t\treturn null;\t\t}\t\tint[] res = new int[arr.length];\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tres[i] = arr[i];\t\t}\t\treturn res;\t}\t// for test\tpublic static boolean isEqual(int[] arr1, int[] arr2) {\t\tif ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) {\t\t\treturn false;\t\t}\t\tif (arr1 == null &amp;&amp; arr2 == null) {\t\t\treturn true;\t\t}\t\tif (arr1.length != arr2.length) {\t\t\treturn false;\t\t}\t\tfor (int i = 0; i &lt; arr1.length; i++) {\t\t\tif (arr1[i] != arr2[i]) {\t\t\t\treturn false;\t\t\t}\t\t}\t\treturn true;\t}\t// for test\tpublic static void printArray(int[] arr) {\t\tif (arr == null) {\t\t\treturn;\t\t}\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tSystem.out.print(arr[i] + \" \");\t\t}\t\tSystem.out.println();\t}\t// for test\tpublic static void main(String[] args) {\t\tint testTime = 500000;\t\tint maxSize = 100; // 随机数组的长度0～100\t\tint maxValue = 100;// 值：-100～100\t\tboolean succeed = true;\t\tfor (int i = 0; i &lt; testTime; i++) {\t\t\tint[] arr1 = generateRandomArray(maxSize, maxValue);\t\t\tint[] arr2 = copyArray(arr1);\t\t\tinsertionSort(arr1);\t\t\tcomparator(arr2);\t\t\tif (!isEqual(arr1, arr2)) {\t\t\t\t// 打印arr1\t\t\t\t// 打印arr2\t\t\t\tsucceed = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\tSystem.out.println(succeed ? \"Nice!\" : \"Fucking fucked!\");\t\tint[] arr = generateRandomArray(maxSize, maxValue);\t\tprintArray(arr);\t\tinsertionSort(arr);\t\tprintArray(arr);\t}选择排序没有稳定性插入排序一般比冒泡和选择排序好" }, { "title": "算法体系课整体梳理", "url": "/posts/%E7%AE%97%E6%B3%95%E4%BD%93%E7%B3%BB%E8%AF%BE%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/", "categories": "算法, 左神", "tags": "算法", "date": "2022-07-26 21:57:00 +0800", "snippet": "第一阶段（学习+实战） 算法 位运算 二进制及其基本位运算科普（算法新手班01节） 打印一个数的二进制形式（算法新手班01节） 不用中间变量交换两个数（体系学习班02节） 找到出现次数奇数次的数（体系学习班02节） 找到出现次数K次的数（体系学习班02节） ...", "content": "第一阶段（学习+实战） 算法 位运算 二进制及其基本位运算科普（算法新手班01节） 打印一个数的二进制形式（算法新手班01节） 不用中间变量交换两个数（体系学习班02节） 找到出现次数奇数次的数（体系学习班02节） 找到出现次数K次的数（体系学习班02节） N皇后问题的加速实现（体系学习班23节） 位图（算法新手班05节、体系学习班33节） 位运算实现加、减、乘、除（算法新手班05节） 对数器（贯穿所有课程） 随机行为（算法新手班02节） 对数器原理（体系学习班02节） 比较器 算法新手班06节讲述 体系学习班06节讲述 排序算法 选择排序（体系学习班01节） 冒泡排序（体系学习班01节） 插入排序（体系学习班01节） 归并排序（体系学习班04节） 快速排序（体系学习班05节） 堆排序（体系学习班06节） 计数排序（体系学习班08节） 基数排序（体系学习班08节） 排序大总结&amp;避坑指南（体系学习班09节） 二分及其扩展 有序数组中查找数字（体系学习班01节） 有序数组查&gt;=num最左的位置（体系学习班01节） 局部最小值问题（体系学习班01节） 递归到动态规划 递归行为 Master公式（体系学习班03节） 汉诺塔问题（体系学习班17节） 生成全子序列（体系学习班17节） 生成全排列（体系学习班17节） 很多题目的对数器方法都是递归（贯穿所有课程） 动态规划 从左往右尝试模型 背包类问题（体系学习班19节） 数字字符串转英文字符串（体系学习班19节） 贴纸问题（体系学习班19节） 货币找零方法数的系列问题（体系学习班21节） 货币找零的最小张数问题（体系学习班22节） 累加和对半数组划分系列问题（体系学习班23节） 区间范围尝试模型 纸牌游戏（体系学习班18节） 最长回文子序列（体系学习班20节） 样本对应尝试模型 最长公共子序列（体系学习班19节） 最短路径和（体系学习班21节） Bob生存概率问题（体系学习班21节） 砍死怪兽概率问题（体系学习班22节） 分裂数字问题（体系学习班22节） 业务限制尝试模型 机器人行进问题（体系学习班18节） 象棋跳马问题（体系学习班20节） 喝咖啡问题（体系学习班20节） N皇后问题的加速实现（体系学习班23节） 贪心 字典序最小的字符串连接方案（体系学习班13节） 点灯问题（体系学习班14节） 分金条问题（体系学习班14节） 会议的最多安排（体系学习班14节） IPO问题（体系学习班14节） 数据结构 链表 反转链表（体系学习班03节） 链表中删除指定的数字（体系学习班03节） 取链表的中点（体系学习班09节） K个节点之间逆序（算法新手班04节） 合并两个有序链表（算法新手班04节） 判断链表的回文结构（体系学习班09节） 链表三分（体系学习班09节） 拷贝含有随机指针的链表（体系学习班09节） 链表相交系列问题（体系学习班10节） 队列（体系学习班03节） 栈（体系学习班03节） 哈希表的使用（体系学习班03节） 有序表的使用（体系学习班03节） 堆 堆的原理和实现（体系学习班06节） 最大线段重合问题（体系学习班07节） 合并K个有序链表（算法新手班06节） 加强堆（体系学习班07节） 前缀树（体系学习班08节） 二叉树 先序、中序、后序的递归遍历（体系学习班10节） 先序、中序、后序的非递归遍历（体系学习班10节） 相同树问题（算法新手班06节） 相似树问题（算法新手班06节） 二叉树最大深度问题（算法新手班06节） 根据先序和中序重建二叉树（算法新手班06节） 二叉树路径和问题（算法新手班07节） 二叉树按层遍历（体系学习班11节） 二叉树的序列化和反序列化（体系学习班11节） 后继、前驱节点（体系学习班11节） 判断完全二叉树（体系学习班12节） 判断搜索二叉树（体系学习班12节） 判断平衡二叉树（体系学习班12节） 判断满二叉树（体系学习班12节） 递归套路解树型dp问题（体系学习班12~13节） 并查集 并查集的实现（体系学习班14节） 朋友圈问题（体系学习班15节） 岛问题（体系学习班15节） 图 图结构（体系学习班16节） 图算法 拓扑排序（体系学习班16节） Kruskal算法（体系学习班16节） Prim算法（体系学习班16节） Dijkstra算法（体系学习班16节） Dinic算法（体系学习班47节） 哈夫曼树（体系学习班46节） 第二阶段（学习+实战） 算法 斐波那契数列 矩阵乘法的解法（体系学习班26节） 有效的字符串数量（体系学习班26节） KMP算法 原理和实现讲解（体系学习班27节） 包含子树问题（体系学习班27节） 旋转字符串判断问题（体系学习班27节） Manacher算法 原理和实现讲解（体系学习班28节） 结尾添加字符变回文串（体系学习班28节） 无序数组寻找第K小的值 改写快排算法（体系学习班29节） BFPRT算法（体系学习班29节） 蓄水池算法（体系学习班29节） Morris遍历 原理和实现讲解（体系学习班30节） Morris遍历求二叉树最小高度（体系学习班30节） 资源限制类题目的算法设计（体系学习班34节） 打表找规律 小虎买苹果（体系学习班38节） 吃草问题（体系学习班38节） 连续数累加和判断（体系学习班38节） 根据题目的数据量猜解法技巧 原理（体系学习班38节） 贿赂怪兽问题（体系学习班38节） 分治 分治的原理讲解（体系学习班39节） 累加和%m之后的最大值（体系学习班39节） 零食方法数问题（体系学习班39节） 卡特兰数 原理讲解（体系学习班39节） 原理讲解勘误（体系学习班40节） 1都不少于0的前缀串数量问题（体系学习班39节） 求不同二叉树数量（体系学习班39节） 数组三连问题 窗口技巧 正数数组中累加和为给定值的最长子数组（体系学习班40节） 预处理技巧 普通数组中累加和为给定值的最长子数组（体系学习班40节） 淘汰可能性技巧 普通数组中累加和&lt;=num的最长子数组（体系学习班40节） 平均值&lt;=v的最长子数组（体系学习班40节） 状态压缩的动态规划 CanIWin问题（体系学习班43节） TSP问题（体系学习班43节） 贴瓷砖问题（体系学习班43节） 设计简化外部信息的动态规划 打气球的最大分数（体系学习班46节） 消除箱子问题（体系学习班46节） 泡泡龙游戏（体系学习班46节） 奇怪打印机（体系学习班47节） 数组的恢复方法（体系学习班47节 数据结构 窗口内最大值和最小值的更新结构 原理和实现讲解（体系学习班24节） 特殊标准的子数组数量（体系学习班24节） 良好加油站问题（体系学习班24节） 最少找零张数进一步加速（体系学习班24节） 长度&lt;=M子数组最大累加和（体系学习班46节） 单调栈 原理和实现讲解（体系学习班25节） 累加和*最小值最大问题（体系学习班25节） 直方图内最大矩形（体系学习班25节） 全是1的最大矩形（体系学习班25节） 全是1的矩形数量（体系学习班25节） 所有子数组的最小值累加（体系学习班26节） 线段树 原理和实现讲解（体系学习班31节） 掉落砖块后的最大高度（体系学习班31节） IndexTree（体系学习班32节） AC自动机（体系学习班32节） 和哈希函数有关的数据结构 哈希表原理和实现（体系学习班33节） 布隆过滤器原理和实现（体系学习班33节） 一致性哈希原理和实现（体系学习班33节） 二维数组调整 转圈打印矩阵（体系学习班40节） 翻转矩阵（体系学习班40节） zigzag打印矩阵（体系学习班40节） 转圈打印星号（体系学习班40节） 第三阶段（纯实战） 算法 编辑距离（大厂刷题班05节） Nim博弈（大厂刷题班06节） 括号嵌套求解的递归模型（大厂刷题班08节） 最长递增子序列问题（大厂刷题班09节） 约瑟夫环问题（大厂刷题班16节） 完美洗牌问题（大厂刷题班20节） A*算法（算法周更班2022年1月第3周） Bellman Ford算法（算法周更班2022年2月第3周） 强连通分量（算法周更班2022年3月第1周） KM算法（算法周更班2022年3月第5周） 扫描线算法（算法周更班2022年7月第2周） 数据结构 LRU（大厂刷题班19节） LFU（大厂刷题班19节） 树链剖分（大厂刷题班21节） 动态开点线段树（大厂刷题班47节） RMQ（算法周更班2022年4月第3周） 练习 算法新手班所有原理+coding复习 体系学习班所有原理+coding复习 大厂刷题班（350+实战题目）听课和练习 内容太多不再列出 题目汇总：https://github.com/algorithmzuo/class-notes 算法周更班（每周跟直播课）保持状态 第四阶段（极致内容） 有序表 AVL树的原理和实现（体系学习班35节） SB树的原理和实现（体系学习班36节） 跳表的原理和实现（体系学习班36节） 各种有序表的对比（体系学习班35~37节） 改写有序表的相关题目 RangeSum计数问题（体系学习班37节） 窗口中位数问题（体系学习班37节） 高效插入删除读取的数组（体系学习班37节） 四边形不等式 区间划分问题中的不回退现象（体系学习班第41节） 合并石子问题（体系学习班41节） 画匠问题（体系学习班41节） 邮局选址问题（体系学习班42节） 扔蛋问题（体系学习班42节） 后缀数组DC3算法 DC3算法原理和实现（体系学习班44节） 最大字典序的子串（体系学习班44节） 字符串插入得到最大的字典序（体系学习班45节） 生成最大的数字（体系学习班45节） 最长公共子串问题 动态规划的解（体系学习班45节） DC3算法的解（体系学习班45节） 所有资源 所有代码：https://github.com/algorithmzuo 文字资料:https://cloud.fynote.com/share/s/7615" }, { "title": "Sven_shi微博问答记录", "url": "/posts/sven-shi%E5%BE%AE%E5%8D%9A%E9%97%AE%E7%AD%94%E8%AE%B0%E5%BD%95/", "categories": "", "tags": "经济", "date": "2022-07-25 21:50:00 +0800", "snippet": "1 对中国经济的信心来自哪里?以前你一直说对中国的经济有信心，现在这样的经济和政治环境，你是否依然有信心，底层逻辑和理由是什么?我以前听过一段很有趣的话，讲中高考和公务员考试本质上都是一种训化。虽然我们嘴上宣传的是成功者的幸福，但是最关键的则是让没考上的人能够接受自己的命运。只要他们接受了，社会就稳定。考上的改变命运，考不上的就接受命运。我们国家一直有很大的城乡差距。80年代尤其明显。谁不想...", "content": "1 对中国经济的信心来自哪里?以前你一直说对中国的经济有信心，现在这样的经济和政治环境，你是否依然有信心，底层逻辑和理由是什么?我以前听过一段很有趣的话，讲中高考和公务员考试本质上都是一种训化。虽然我们嘴上宣传的是成功者的幸福，但是最关键的则是让没考上的人能够接受自己的命运。只要他们接受了，社会就稳定。考上的改变命运，考不上的就接受命运。我们国家一直有很大的城乡差距。80年代尤其明显。谁不想进北京生活呢？可是社会容纳不了这么多人的梦想。所以设计的就是一套制度。先划定录取率，大约2%。、考上的，就脱离农村，进入城市，工作都包分配。考不上的呢？就接受命运，继续在农村里面，过农民的生活。要是他们想改变命运给进城，那么等来的结果就是去昌平挖沙子，谁让他们没考上呢？接下去就是一段非常高速的经济发展，整个社会似乎都打开了大门。接下去很明显的，就是我们的社会经济增速大幅度下降。门又重新关上了。那么社会在我眼里又会变成以前这样。就像公务员考试，考上了就加入，改变命运，考不上就接受命运。就像月初有件事，国话院那边想引进易烊千玺，走个流程。本来是个互利互惠的商业事件，我是真没理解那么多自己就学表演出身的人，怎么会不断的在我微博下面刷屏，说做演员要加笔试。虽然我不是影视行业的人，但是我起码的常识是知道的。你去做演员试镜，没人给你考笔试的。但是为什么那么多人都在网上写文章说做演员要笔试呢？后来一位老师就回答我说，你不懂现在的年轻人，他们被训的很好。组织一次考试，哪怕就一万人抢一个名额，考不上，他们就认命了。大家一样经济下行，我们国家的年轻人比欧美要认命的多。所以社会相对会稳定很多。经济下行的时候，稳定就是最重要的东西。能稳定，就会有机遇。相比较起来，我是真心觉得中国在这个长时间的经济危机当中能表现的更好。2 是否需要在3年内在上海买房?是否需要在3年内在上海买房? Sven，你好。 我是去年回国的大学生（硕士），有户口、税前30W、可拿出过200W首付。 最近有身边的朋友选择在九亭买房，400W（两室两厅-90平）左右。 我刚好当时没事跟过去凑个热闹，跟中介和卖房人的聊了聊天，他们的口中房价似乎一直在涨，并劝我尽快上车买房。 我自己比较纠结，是再等等（大概5年后）还是近3年就买了？中介应该是帮助买房的工具，而现实中多数人都会因为知识的缺乏被中介牵着鼻子走。中介告诉你的，往往都是一些挂牌价和成交价，而且你自己在网上搜，搜到的也就是那么个价格。有些地方甚至都是政府因为限跌所以政府干预。你光靠搜索和中介的信息，几乎一定会做出高估房价的选择。那么最简单最直接的数据是什么？是成交量。这个数据最难造假。二手房的成交量全国都在爆减，所以中介的日子也很难过。这里最惨是深圳，哪怕是上海也是大面积的萎缩。也就是说你现在要是手里有钱，其实是个捡漏的时机。但是我并不认为目前是最好的捡漏时机，而是再等半年，国家只要不出大面积的放水政策，我觉得房价会到一个低位。我会选在明年中期要是有好机会的话可能再买一套房子投资。我自己用中介的时候坦白讲可能就是我这张脸有问题。怎么问，似乎都是我价格最高。大家好像都喜欢骗我。每个人有不同的功能和技巧，我就是个不太适合去做谈判的人。但是我自己有个朋友谈判很厉害。我们出去买房子，基本都是我做好预估的价格，他去和中介谈。风险代理的模式，中介能帮助我们压价，我们按照百分比给中介钱。上海目前的市场也是买家市场，但是空间其实并不是很大。如果我是你，我会选择先看先观望。注意卖家情况。这里面以前最好的卖家是离婚的，现在则是失业断贷要回老家的。这些人随着经济的低迷我认为会越来越多。尤其是九亭这些地方。可以多去了解下卖家的情况。晚一点，多跑跑再出手。你想，辛辛苦苦干一年活税前就30万，可是多跑跑多了解下，说不定买套房子就能省掉30万。接着是你个人的情况，买房一定要回去仔细和父母商量。尤其是要确定现金流。意思就是你的工作除非是公务员，不然可能很不稳定。一旦你断贷，很可能你就要变成卖家了。这个时候我就是建议你回去仔细和父母算算月供，算准自己的贷款数额再去谈。但是千万别把自己的底价交给中介，装没钱点没坏处的。可能明年利率还要下调一些，比如深圳已经下调了。毕竟房地产市场需要政府刺激。不要着急，现在就是个买方市场。3 如何投资2020年如何投资呀? 老师，2020年疫情影响很大，想问一下有什么投资的好的建议呀？前几天有人给我发私信问投资的事情，大概意思我没记错的话就是他是在打工，拿到了30万的低息贷款，问我怎么投资。我建议他什么都去做，因为他亏不起这30万。他说要借给老板，我也建议他用抵押的方式借，还是要有房产之类的东西做抵押，才能借。原因很简单，借了的钱是要还的。自己主业做做好，另外的普通人适合投资就是要量力而为。我自己银行里没什么钱，主要就是因为有老可啃。真的出了什么问题，我还可以靠爹妈。所以投资相对比较有底气。但是选择的也都是很稳妥的方式。最近唯一的投资就是在苏州买了套房子，没去看，是我姐选的。苏州这边的房子准备长期持有，五年内不需要花这笔钱，所以我敢那么投。最近股票很好。但是我还是建议不要加杠杆，也不要追加投资。因为目前的市场真的不确定。因为股票这个东西风险太大，真的也是要做好长期投资的准备。因为在目前这个经济下行的时候，普通人往往做什么都是错的。政府不断的往外放低息贷款，鼓励大家去创业，去雇人，去重整经济。对政府这是好事情，但是对大众不是。因为借来的钱除非你能像贾跃亭一样，不然你只要还在中国生活，你就是要还的。而且很多借的钱，都是有抵押的，抵押的东西都是房子。每次经济危机，最后都是贫富差距拉大的时候。普通人能做的最好的事情就是好好拿着自己手里的不动产，不要轻易去冒风险。真的能从里面出来的，都是极少数。稳妥一点，有班上，就好好上班吧。4 男孩子找女朋友要注意什么?男孩子找女朋友要注意什么? 斯文老师，除了遇到了就是遇到了，男孩子找个正常点女朋友要注意什么？正常情况下要从哪些方面考量，避免社会性死亡或者其他不好的情况出现？有什么小技巧之类的…真的不用把特殊事件太放在心上。多数人看罗冠军的事情都会感到后怕。因为这个事情绝大多数人都可能在分手后遇到。而且只要女方把握好尺度，男的被冤枉也没什么办法。可是现实当中真的有这么大舆论影响也是很多偶然凑在一起的。绝大多数人一辈子都不可能上一次热搜第一的。这件事情能够起来也有偶然，这女孩子的控诉信息其实早就写好了，但是一直都没有被关注。她后面编的那些自己买热搜，高价请律师也是胡乱搞得。你看她和罗冠军分手因为彩礼事情谈崩就知道这女孩子家庭条件其实挺一般的。是个普通到不能再普通的人。微博上事情红起来，关键转发点还要主动推的人都是很明确的。你看见那些很多真的自己一点都不极端，就是和几个女权群利益互通。人家让转发造势，就去转发。现在女的故事编不下去出来认错，她们也很尴尬，毕竟这个事情真的追究起来，参照之前的处理，封号都逃不掉的。一个普通人绝对没有这个本事的，你放一万个心就好。真的生活当中有些人脑子秀逗，就是做事情损人不利己。结婚多年的夫妻离婚了都会那样。我自己小时候有件事情印象很深，就是我爸事务所里面有个会计师，和老婆离婚了。都已经离婚了，他升职了，他前妻还跑到我家里，向我父母控诉他人品多坏多不好。做这些事情对这位阿姨完全没有好处，离婚分钱她也分得很满意，但是她就是不依不饶，见人就闹。我当然不可能认识年轻时的她，但是据评价这人年轻时也挺正常的。你说她后来怎么变这么副样子？我不知道啊。有什么办法能预测吗？也没有啊。你怎么知道人会怎么变呢？原来该怎么样就怎么样。我不太喜欢看父母知道小孩的说法，我自己性格就和我爹妈很不一样。但是我更加认为如果以结婚为目标，就是两个家庭的结合。认识认识对方父母没什么坏处。5 怎么看待物业公司对于房产作用?斯文，你好。你怎么看待物业对于房产的作用。国外的物业公司是如何收费运营盈利的，相比较而言，国内的优秀物业服务你觉得和德国这种发达国家的优秀物业差距在哪里?你可能对物业服务有点误解，物业服务绝大多数时候都是国内更加优秀。因为人力成本摆在那里。好的物业服务，都是要人做的。我们国内大多数的小区都是封闭式管理的，有保安24小时值守。你哪怕半夜回家，都可以看到小区门口有保安值夜班。欧洲多数小区都是开放式的管理，人力单位成本比较高，你到周末根本找不到人的。而且还有个问题就是摄像头。现在国内城市的小区多数都是有摄像头覆盖的，真的出了什么事情，摄像头是警方破案的一个关键所在。但是欧洲很多地方都没有摄像头啊。法律上还有很严格的隐私限制，所以整体治安管理，肯定是国内更好。最典型比如收个快递，我住的地方我不在就是给邻居。邻居不在，就是我自己跑去邮局取。国内不是快递柜就是保安帮忙，谁好谁坏一目了然。国内的问题其实是在民众普遍的物业法制意识不强。物业，是业主雇佣的。你作为业主不满意，是可以去选择物业的。可是现实当中这种选择困难重重，经常没有办法得到实施。而且其实你自己也未必知道物业的性价比。一个小区大家的消费能力有时也不一样，所以综合性价比选物业会很难。我对物业的要求就是出事能迅速找到人，迅速解决问题。乱七八糟的杂事一定要少，我不太喜欢动不动就有人来烦我。我自己挑房子也是这个原则。所以我买房往往也会参考物业的平均评价，而且喜欢选相对比较小的小区，人员别太复杂。物业费高点问题不大，但是管理反应迅速就好。我在欧洲住的小区也不大，房子是我姐的。物业就是日常帮忙缴纳各种费用，然后给你一堆电话单，出问题去找单独的公司解决。物业的办公室离我住的地方也挺远，我就没去过，连人我都没见过。房子一共就三层加个地下车库，还是配电梯的。看起来好像电梯的费用比较高，所以整体物业费用比我之前住的房子要贵一些。和国内比起来基本属于无服务。6 北京和上海的差距和差异在哪里？北京和上海的差距和差异在哪里？谁更有潜力更活跃?北京和上海分别适合哪几种人？您比较喜欢看好哪个城市？ 北京官二代，上海富二代，深圳全是靠自己！深圳模式适合其他沿海城市吗？广州就不问了，我一个北方人不适合南方！北京上海本质上都是中国最好的地方，有中国最好的经济教育资源。如果从教育评级上来讲，北京有全中国最好的高等教育资源，但是基础教育评分方面上海要更好一些。但是这些差距对普通人来讲几乎没有意义。因为这两个城市的机会都非常多，生活也都很好。我对北京也很喜欢，一直有个想法就是想在北京买一套好的房子，可是直到现在也没买成。从生活习惯上来讲我个人更加喜欢上海，主要是因为我是浙江人，对上海的生活习惯更加适应。北京上海这两个地方，占据绝对多数的都是普通人。北京2300万，上海2500万，两个城市加起来也不可能有超过100万的精英人群。只是这两个城市金字塔模式特别明显，顶层的人太顶层，导致大家在网上都看不见普通人怎么生活了。有钱人不用说，有钱哪里都过得好。北京上海的普通人生活的都很好。只是户籍把普通人分成了本地人和外地人。注意，这里说的本地人不是说你人才落户放到公安局里，就是本地人了，而是土生土长的本地人。这些人的生活水平整体都很不错，因为北京上海的福利兜底做的很好。而且这两个城市有全中国最好的基础设施和福利水平，不仅治安特比好，养老接下去也能直接对标瑞士。但是这个对标是有代价的，就是不断更替的外来人口。本地人不会被替换，但是外来人口会。他们会不断的涌入北京上海工作，缴纳社保，里面的公共部分会留在北京上海，将来年纪大了他们就会被挤出。带着仅有的一点个人账户的余额回去。所以这些人就是要调整好心态，预计自己大概率40岁不会留在北京上海，按照这个方式去打算。买房之类的也是要尽早给自己留个退路。深圳也和他们慢慢都会变得差不多。全中国现在各大城市购房安家的年龄其实都在越来越小，都是家里有钱留得下，没钱就留不下。7 为什么北方经济不如南方？ 为什么会有环京贫困带？为什么北方经济不如南方？是政治体制还是文化差异?南北差距会增大吗？您看好哪些北方城市？为什么？ 为什么会有环京贫困带？按道理来说离北京近应该近水楼台先得月，发展更应该迅速呀？北京会成为中国的金融中心吗？首先我觉得你有个误解，目前我们国家真正的经济发展问题不是南北，而是除去北京之外，只有，注意是只有长三角珠三角的经济以超过平均速度的方式迅速发展。其他的地方都不好。这点其实你可以从社保看出来。全国统筹社保之后，上面这些地区都是往外输血的。当然你仔细看的时候还有一个人口大省山东，但是山东这几年马上也会转负，需要输血。因为山东之后GDP进行了“调整”，也就是说消除了很多注水，而且山东每年的年轻人口都在外流，速度一直都是全国第一。这方面你看社保缴纳特别的明显。哪个地方有更多更好的工作机会，这个地方的社保就变得很充足。因为社保都是当地缴纳的。北方这几年数据上还算不错的有唐山和郑州，其他都没了。但我也谈不上看好，因为真看好我肯定就跑去想着买房了。这几年甚至连青岛都不怎么好，这点我也是没想到的。各地的差别其实主要还是在产业差别上，长三角和珠三角的各个产业发展都非常快，而且效率很高，集群优势明显。所以工作机会多，工资高，地方也好。差距一直在越来越大，没有缩小的趋势。离北京近的城市我个人感觉是它们这边本来就没有形成一个产业集群，主要还是以重工业为主，这几年的环保整治对它们影响也很大。北京附近没工业没服务业集群，属于整体相当一般的。所以个人也不看好后续发展。至于北京一直是金融中心，只是给人的感觉没那么洋气。其实你看房子的时候很明显，北京集中了全国几乎所有的监管机构核心。它们那边的金融就是通过这些监管者发布出去的，而且集中在西城区。金融是北京非常重要的支柱产业，占比很高。当然那边房价也高，而且坦白讲很多房子因为规划的早，其实整体比较一般。但是就是地位在那里，所有的监管也就是规则是它们定的。肯定是属于最重要的位置。相对而言上海就更加的国际化。而且上海的对外金融要明显比北京有优势。我们谈到上海香港，经常讲的就是港口。而北京就是政策。政策主要集中在西城，也就是说所谓的北京金融中心，你甚至可以直接说是北京西城区金融中心。这个金融中心到底能不能国际化，我肯定是说不好的。但是目前也有这个趋势，就是说从监管机构衍生出一批提供服务的人，他们再分散开来。8 关于写作的建议?关于写作的建议? 想听一下你在写作方面的经验分享，老粉都知道你是媒体人，还想做记者，所以在写作方面，你有没有可以分享的经验呢？比如文章逻辑、技巧、高产这类的。我非常好奇你的高产，想重点听一下高产的技巧。我不是媒体人，也不想做记者。我主业是做核电配套的，目前在做核电相关的机器人项目，但是你绝对不可能在网上看到我去讲这些东西，因为上网对我是个娱乐。我工作压力很大，很多东西都不是我一个人能控制的。而且空闲时间很多，写写东西换换脑子时间长了就成了习惯。但是我最赚钱而且我觉得我最擅长做的最好的，就是买房。坦白讲我觉得我把公司关了好好买买房子做主业可能更好。买房需要信息，所以我自己和很多记者认识都是因为房子。而且非常关注相关的政策。有些信息哪怕我自己用不到，我也会很仔细的去看。身边很多人买房都会问我，我也很乐意分享下我自己的看法。因为确实做的不错。当然我也炒股，但是股票业绩就那么副样子，没底气去讲，就是说说聊聊天。媒体行业上下游非常的明显，你在上游，有第一手的信息，就是怎么写怎么有。而且你其实都不用思考怎么去做信息筛选，因为大家小圈子交流压根就不会有什么去为了舆论效果改编资料。这边看过了再看网上，说法不一样的地方就是有问题，按照这个方法去写东西很简单。自己想到什么就写什么，这种写作就和记录生活一样，随手拍拍照你不会觉得累，但是作为一个摄影师，要定期交稿件成工作就是另外一回事了。，我自己原则很简单，照实写，有广告尤其是硬广，东西没问题就接。有钱赚不管多少也是件好事情。所以不太需要担心出问题，也没什么压力。很多事情累和不累真的就是心态问题，我每天工作都觉得很累，尤其是出差在火车上的时候总是觉得很无聊。我现在就在火车上打字，就是打发时间。我还有个特点就是骨子里面并不尖锐，所以很多人都愿意把材料给我看。因为我不是那种知道了信息感觉到现实问题不符合就一定要怎样的人。很多事情在我眼里过去了就是过去了。就像以前我和别人一起看高招腐败问题，别人就是要全面曝光，像我就比较随意，觉得没什么大不了的。以前觉得这东西“应该”这样，现在发现现实不是这样了，那么就是我以前觉得的东西错了，而不是说我一定要把现在变到和我以前理想的一样。9 定期定投股票指数基金是好的理财方式吗?定期定投股票指数基金是好的理财方式吗? 斯文，你好。房产投资门槛太高，对于普通人来讲有没有其他更好的投资渠道？定期定投股票指数基金是好的理财方式吗？股票投资基金本质上就是一种被动型的基金，根据历史来看业绩比较“稳定”，市场上这样的基金有上百只，你准备投哪一个？你搞得清楚沪深300和中证500的区别吗？知道什么是指数增强型基金吗？如果你都不知道。不要靠搜索引擎去了解，以后别买就好。如果你是个没有办法做买房投资的普通人，千万要注意，你在投资的时候会高估自己的风险承受能力。你买这些基金的时候想法一定是“稳妥的多赚点”，但是你一定要知道，不存在这样的可能。想要多赚，就是要承担相应的风险的。一旦遇到亏，你很可能亏不起。指数基金也只是近期走强，相对来说还是要受大环境的影响。大环境好，指数基金就好。如果是增强型，就等于说请专家帮你选，可能扩大盈利，也可能扩大亏损。那你说我只要判断对形势不就好了？整体形势好的时候就投，形势不好了就赎回把盈利变现。可是问题是你觉得你真的有这个能力吗？你对这个东西感兴趣，想投资，就不存在什么懒人赚钱法。先从自己买股票开始选起，看看大概什么钱自己全亏掉不心疼，不加杠杆进股市自己操作操作。有点基础的操作经验了，再了解了解相应的基金，看看有合适自己投资方式的，选择一点买入。慢慢一步一步去走。指数基金是被动的，但是不是提供给不懂的人去买的。当然，核心还是你要看看清楚，自己这个精力投入合适不合适，合算不合算。多数时候如果本金不多，这个东西最多也就是个兴趣。​10 如何看待南北经济差距越来越大？斯文老师如何看待南北经济差距越来越大？北方现在好像只有北京拿得出手.国家会想办法缩小这种差距吗？ 以前大家都说东北不行，现在也说山东东北化，西安感觉经济发展不错，但对比同时发力的成都还是差一些。在我小时候天津是仅次于北上广深的城市，但近些年明显不如从前。我在南方工作时，公司里好几个天津人，甚至在当地安家。 有人说北方太官僚，注重关系，可我们公司获得一些项目也是需要关系的，也有各种利益捆绑。有人说北方人做生意不如南方人，但我遇到的一些北方人在南方做的生意也很大。你先想明白一个逻辑，如果经济这个东西是国家想弄好就能弄好的，那么我们现在所有的不发达地区，就都可以归咎成国家“没有努力”了。现实当中国家或者说中央真的不是没有努力，反而是在全力的投入和支撑欠发达地区的发展。但是现实当中差距就是在越来越大，不是南北差异大，而是全国目前就只有北京上海长三角珠三角真的好。你真的细化的去比一比引才资金，看看人均寿命这些关键指标，中西部很多的大城市也就是所谓的二线城市，真的是比不过长三角的很多小县城。同样是招募人才，你感兴趣的话可以去搜搜温岭这个你可能听都没听过的小地方的人才引进计划，看看别人是怎么给人才项目钱的。中西部很多都是天坑。开始的时候吸引人才，后面经常出现没钱挪用毁约的事情，为什么？当地政府不是有钱不给，是真的没钱给。最后很多案子特别是抓准院士水平的那几位的案子，我现在想起来都觉得他们冤枉。可是现实中有什么办法呢？就是一点办法都没有。他们的整个体系早就不行了。提到东北，总有人会提起大下岗，觉得是东北给全国做贡献。但是在我讲起来，那就是国企破产。企业破产了，所以工人失业。企业为什么破产？因为造的东西卖不掉了。煤矿里还有煤炭能卖，所以煤炭工人不会失业。但是日用品厂的东西已经卖不掉了，因为江浙广东那边的小商品价廉物美，他们国企竞争不过了。这个竞争不过是什么时候开始的？是改革开放就开始了。一直延续到没办法破产下岗了，才真正爆发出来。企业也不是一天破产的，东北的经济也不是一天崩溃的。我自己之前因为一些社保的案子接触东北方面的体制内专家，他们给我的感觉就是态度非常一致，对东北没有任何信心，聊着聊着就会问到我去长三角周边买房子的事情。他们的话千言万语就是一句，自己肯定搞不定，国家肯定不会放弃东北。至于我自己，肯定也是退休了就走了。没有合适的产业，时间长了，人心都散了。这个时候国家真的就是给政策给资金，到最后说不定也就是一栋一栋的烂尾楼。我们舆论上对这种地狱差距刻意不讲，现实就是北京上海的生活水平在逼近瑞士。就是欧洲那个最发达的瑞士，不管是治安还是人均寿命，都在迅速靠近，而且产业优势集群都非常明显。和瑞士一样，低端产业基本就没几个了。但是东北呢？生育率整个就是崩了，年轻人口大量的流失，产业提振讲的婉转一点就是“效果不如预期”，现在这几年，连山东都开始崩了。站在我个人的角度，这些消息对我来讲就是投资买房的方向，什么地方不能去，什么地方能去。但是站在一个真心实意热爱这个国家的角度，其实真的很忧心。就像看待雄安，我真心希望雄安能够走出滨海新区的阴影，成为一个和北京相对应的经济中心，可是现实真的一点都不乐观。11 理财小白营，靠谱么斯文，我最近学理财 斯文你好，最近加入了一个理财小白营，连续14天早中晚夜宵四次学习，这种某机构举办的线上课程靠谱吗？我一边学一边慎防诈骗😹这类项目都是智商税。建议不需要参与。原因很简单，理财首先需要的是本金。比如你存个余额宝，现在利率2%。你本金10万，一年可以拿到2000块。然后你真的很有本事，去通过各种理财，去买所谓的货币基金，拿到4%的收益了。你自己一年也就多赚2000块钱。你为了这2000块钱，投入了多少精力，又承担了多少你看不见的风险？你走进赌场的时候，你知道开大开小的概率各自一半，你押大，赚钱了，你会觉得自己是运气好。但是所谓的理财，尤其是理财行业推的货币基金，他们采取的往往都是放长线吊大鱼的方式。他刚刚开始给你推荐的，都是一些相对比较低风险的基金。让你投个10万块试试看。这种基金其实可能十个里面有九个赚，只有一个亏。你真的赚到了这点小钱，不会觉得自己是运气好，而是认为自己的眼光好。一旦你认为自己眼光好，有经验的时候，这些导师才开始赚你的钱。高佣金高风险的项目就是那个时候来的。你慢慢提高自己风险阈值的时候，其实就是开始赌博式的投资了。原因其实是这些基金项目坦白讲你上几节理财课，绝对不可能真的懂。最怕就是你不是真懂，但是觉得自己懂，还觉得自己能赚钱，有眼光，就往里面追。普通人是亏不起钱的。所以我真的就是建议你选点利率透明的，普通大众比较适合的，像余额宝之类的项目。别去参加那些理财课了。真的所谓的高利率，也都是团队作业的结果。人家巴菲特一年才赚多少比例啊？他什么团队啊？真要学，好好拿本会计基础，看看明白比什么都靠谱。12 会选女团成员做老婆吗？如果有可能，你会选女团成员做老婆吗？她们的发展轨迹一般是什么样的?我这两天看V+群也觉得很奇怪，怎么会有那么多人关心我愿意不愿意去娶女团成员。这问题在我眼里就是你跑到街上找个男的，给他张林志玲的照片，问他愿意不愿意娶。他愿意没用，是人家林志玲愿意不愿意啊。像我也是这样啊。我就是喜欢漂亮的女孩子啊。我爸娶我妈就是因为他觉得我妈长得漂亮啊。但是喜欢和结婚不一样，结婚了就是家人，对家人态度和喜欢自然也就不一样了。如果你问我愿意不愿意和一个长得很漂亮的女孩子交往，我肯定回答愿意啊。只是我知道结果肯定是人家不愿意，像我这种长相，估计属于这辈子只能靠努力赚钱让人忽略我的脸的那种程度。人贵自知，我这点自知之明还是有的。至于女团成员，各种各样的出路都有。女团的寿命往往都和经纪约相挂钩。一个女孩子可能14岁开始受训，18岁出道。26-28岁结束合约。这个时候有的会继续走演艺圈，有的就退圈转幕后。因为她们本身受过很专业的训练，在工业化程度越来越高的娱乐产业里面往往都能找到自己的位置。而且这些位置很多时候都可以互换。就像EXID里面的许率智，出道前就是个声乐老师。自己唱歌唱得很好，也很会教。换到国内，很多艺人到后期都是会选择走体制内的道路，就是不怎么红了，就往体制走。这里面最好的出路往往是高校。我自己音乐类的高校跑得比较多，有次去看朋友演唱会，看到庞龙就在我前面，才知道他也去了大学当老师。比方说我爱记歌词这些节目组里面很多出来的人都在大学里面当老师，而且婚姻都挺幸福的。还有的就是自己做工作室，做幕后，或者做音教。之前我还有个以前做歌手的朋友从体制内出来，到欧洲读了个MBA，后来她和我讲了才知道她是被她老公的妈妈逼着出来读书，她婆婆死活不让她做家庭主妇，一定要逼着她去工作。还投钱给她做了几个各类的工作室。我认识的演艺圈的，女孩子长得漂亮的，基本没有发展差的，也没有太堕落的。当然可能也是人以类聚，演艺圈里面沾染上毒瘾的案例也不少。还有的就是因为退圈之后收入骤降，所以也不得不用一些特殊的方法去赚钱。像韩国也有女团成员退役后堕入风尘。前几年争议比较大的就是一个女团成员退团后去拍了三级片，还连着拍了好几部。我有个朋友追那个团，还特别伤心。演艺圈真混到边缘了，也是挺不容易的。13 什么是真正的价值投资?什么是真正的价值投资? 以前的留几手，现在的号 木生lau ，前几天发了个视频，谈价值投资，大意是真正的价值投资是“大跌大买，小跌小买”，而且是只买不卖，除非认为这个公司已经到顶了没有成长了。也就是说目标并不在于靠股价上涨挣钱，而是在于持有更多的股份，吃股份的分红。我自己印象中A股的股息好像都不高呀，还不如买银行理财呢。但如果这个思路是可行的话，那其实是非常适合我的。我和父母工作的收入都比较高，房子也满限额了，每年收入的结余其实也找不到什么投资渠道。又没有那个智商去炒股，也并不急着要靠股市提现。可以说还挺符合这种投资思路的前提条件的。诗文如何评价这样的投资方式?上面这张图是我今天的持仓。我是18岁成年开始炒股，本金一共150万，截至到今天是257万市值，平均下来一年赚10来万，回报率每年6%左右。看着似乎不错。但是半个月前我仔细调整仓位的时候，我股票账户总共就200万。就这两周的变化，上下就有20%。你怎么个价值投资？投资理念都是要实践出来的。你看见的所谓股票市场的懒人投资法，现实当中全都是行不通的。你在网上看见个段子，比如一个老太太，某年买入苹果股票，然后一直持有，直到死亡时留下巨额遗产，这些全是极其罕见的例子。因为股票市场是瞬息万变的。像你这样的情况，你问问你自己，你准备买什么样的优质股票？具体买哪一个？然后靠哪个股票去吃股息？你不知道的。而且股票带来的股息平均回报率，是远比理财要少的。这个世界上真的不存在什么懒人理财法的，你看见真这样赚钱的，很多都是运气好。就像你问个亿万富翁，人家怎么发财的，他告诉你他爹给的，家里遇到拆迁了，你能模仿吗？模仿不了。网络上真正靠谱的能靠理财赚钱的办法，就是出理财攻略。因为你真正实际操作的时候，会遇到大量的问题。买什么股票，具体股息是多少，到底什么时候买入，什么时候卖出？就连买房子都是这样的，怎么申请贷款，贷款用什么利率，公积金还是商贷，学区还是非学区，电梯房还是老房子，都是问题。都要自己一步一步去研究，去把握的。而且最关键的，你判断对了大趋势，你还真不一定赚钱。投资就是这样的。我觉得你手里面不缺钱，也可以试着投资下股票。我开始的时候本金就是我妈给了50万，自己做做感觉不错。后来慢慢了解多了，我爸给了我笔钱让我去买房子，我再拿了100万进股市。当然我其实总体业绩一般，有两个股票让我亏了很多钱。但是我整体心态很好，因为股市上钱我都用不到，我也从来不加杠杆。在欧洲还有时差，最多就是一个礼拜调整两次仓位。每次和朋友聊天，就像上面一样直接截图给人看看自己的持仓，和人交流下看法。因为上市公司的财报那么多，你绝对不可能一一看过去的。价值投资这种路对普通人来讲根本就是不可能的。股票那么多，你能靠着看公开信息筛出下一个苹果基本就是天方夜谭。好好停一停，学学基础知识，拿点小钱试一试。接着做一段时间你自己自然就有判断了。14 给95后普通女孩一些工作、生活和投资方面的意见和建议请斯文老师给95后普通女孩一些工作、生活和投资方面的意见和建议~ hi,斯文老师， 我今年26岁，随着年龄的增长加上今年的疫情的，衍生出了一些迷茫和焦虑，希望您能给予我一些职场、生活和投资理财方面的建议^o^ 以下是个人情况简述：1、北京户口独生子女 2、家庭存款100W 目前主要都投资了银行理财 我自己会买一点点基金 3、住的两室一厅老房子在三环边上 是我妈单位分的 房产证上写是（军装海移私 军队房改成本价售房）我对政策不是很敏感 就知道现在不让买卖 也不知道未来会如何4、大兴黄村另有一套七十多平的商品房在出租 房本写的我自己的名字 5、我读的财务专业 现在在一个做人才服务的国企上班 收入不高但是比较轻松稳定 我妈每个月有稳定的退休金房产里面细分有很多大类，其中军产房是一个非常麻烦的话题，有很多的细节需要去确认。简单来说就是你首先要搞清楚你们家最值钱的财产的性质。像军产房是房地产里面相当特殊的一个门类。这类房子经常会出问题。而且细分的规则搞得很复杂，普通人光查规定肯定看不懂。像我自己也从来没有买卖过类似的房子，因为我能力有限，这类房子不是给我这类人赚钱的。你首先要确认的核心就是房屋的产权方是谁？这里面有两个大类，第一类是产权还是属于军方的，那么你妈分到的房子原则上就只有使用权，只要她活着一天，这套房子她就可以住一天。一旦她故去了，那么房子是由军方收回的。另一类，就是你提问当中讲到的那一种。房子开始的时候是属于军方的，后来作为福利，卖给了个人。你讲的那种方案的房子我自己见过两套，都是在北京。这种房子你特别注意，因为卖的时候是成本价而且免税的，所以你妈花钱购买产权的时候出的钱很少，这套房子的产权是你妈的，原则上是可以买卖的。但是，如果你要交易过户把这房子当商品房来卖，就需要补税甚至要补土地出让金。你真要把这样的房子套现，需要很多的税务技巧。而且我根据你的描述来看，我觉得你也不需要。你最好的选择，就是一旦确认这房子产权是你妈个人的，可以传辈的，那么就把这套房子留着。将来通过继承的方式获得房屋的产权。这类房子往往质量很好，而且区位很好。但是小区配套设施比较落后，所以不太适合年轻人自住，你可以把这套房子当作一个出租的资产。也就是说如果你手里就那么一套房，没必要去操作，拿着安安心心当房东就好。北京这种房子不可能租不掉的。接着你就要明确你自己的身份位置，你是北京户口，家庭资产千万，处于中国前千分之一的位置上（资产千万就前千分之一了），并且有着百万现金，稳定工作的年轻女性。不管在社会地位还是经济阶层上，你都很高。事业上你个人有追求，可以去考个会计师，择偶也可以把眼光真的放高一点，因为你经济条件很好，有足够的资本高姿态。接下去你就是好好过日子就行，最麻烦的其实是投资。千万千万要谨慎，像你这个情况，我建议你选择保守型的投资方案，存存理财比较好。原因很简单，你手里的资产短期内没办法套现，100万其实在北京也是个比较尴尬的数字。别告诉别人你手里有这样一笔钱，因为人家朝你借你也麻烦。就是安安心心拿着钱，将来给家人养老。另外我猜你妈的思路应该是给你弄套商品房，将来是希望你找个经济条件差不多的男的，把老房子卖了和人家一起买套新房。这个思路也没什么大问题。但是像你的情况其实也可以考虑原先自己婚前的房子不卖，只要大家门当户对，房子留着收租金，结婚租房也可以。这样还更灵活。将来有了孩子，再考虑以第三代为投资对象去买房。这也是另外一个选择，你可以考虑下。你的身价和社会地位一点都不普通，千万要对自己的社会位置有自信。15 作为一名普通上班族，怎么能够快速挣钱积累财富?作为一名普通上班族，怎么能够快速挣钱积累财富?请结合您的经验分析一下，谢谢！我今天正好看见个很搞笑的热帖，是讲30岁青年才俊标准的。说是要爸妈家庭一般，独自来到大城市打拼，随时能调动500万以上的流动资金。这种一看就知道是编的，而且编的人对钱没概念。在他的眼里500万可能就是日常谈到的可以买半套房的钱。但是对一个月薪5000的人来讲，这就是他几辈子不吃不喝的收入。有些话讲难听点，真就是你让一个普通人去想别人财务自由的样子，都是白日做梦，哪里有什么路去实现财务自由？过日子就是什么年龄段做什么年龄该做的事情。该读书的时候尽力把书读好，该工作的时候好好把自己该做的事情做好，有机会看看跳跳槽，没机会就好好干。该结婚生孩子就结婚生孩子。保障自己未来自己都没能力，只能靠小孩在将来提供一些现金流。普通人随便哪个地方要选的不一样，都会有相应的代价。但是只要他做的不差，整体经济情况好，他也过不太差。你看见个机会想着去发财，说不定进入的就是传销了。当然进传销也能发财，只是现实中多数都是炮灰。真的，好好过过日子吧。人生闲暇之余找几个爱好，哪怕简简单单上上网追追剧也有很多的乐趣。没有必要总是想着那些不切实际的生活状态。16 聊聊天津滨海新区斯文老师好。讲讲天津滨海新区吧！ 前几天的一个统计数据很火，天津掉出了前十，北方城市只剩下北京。关于天津不得不提滨海新区，在网上普遍流传一个说法:滨海新区搞砸了！可是我在网上查到全国范围内区级2019年gdp排名，滨海新区8000多亿(几乎是天津其他15区县的总和了)，仅次于上海的浦东新区，全国排第二。也许有人说它面积大，但浦东新区面积也不小，gdp也和上海其他各区不在一个数量级上，并遥遥领先。这么大的gdp数量为啥普遍说滨海新区搞砸了呢？因为滨海新区的GDP是假的啊。这答案惊喜不惊喜，意外不意外？其实真的就那么简单。我国南北都惯性的GDP造假，但是造假的方式不一样。北方除去北京外都是习惯性的多报，一届政府多报了，后面的只能跟着多报。而南方尤其是江浙，习惯少报，因为报多了要多援外。再到近几年，随着营改增还有社保等等的统筹，才慢慢在国家引导下调整过来。滨海新区的多报是多到疯狂的。也就是说没人认为滨海新区的数据是真的。你今天看8000多亿，看着很多，前几年还要多，滨海新区前几年就破万亿了。因为破万亿太夸张，所以说调整统计口径，一口气砍掉了三分之一。才有了现在的逐年增长到8000亿啊。滨海新区的GDP值就是个玄学，没有参考价值。但是有一点可以确定，要是滨海新区真的发展得好，压根就不会有雄安的事情。滨海新区起点是十一五，开始的时候是80年代深圳，90年代浦东，再是2000年后滨海新区，都是作为经济发展的“极”来带动周边地区发展。开始的时候工业，金融全都花大力气进入，还有自贸区和一大堆的政策扶持，天津本身也是个港口城市，发展算是得天独厚，但是就是没发展起来。可是现实当中又不能说它没发展起来，所以就有了一个数据迅速增长的滨海新区。经济发展，真的不是给规划，就能起来的。天津也不是就一天就衰退的。是之前全国都在前进，天津的问题还不明显，疫情就像一个急刹车，刹车了回头看，才看见天津已经落在了那么后面的地方。整体天津的房地产我也是一直不看好。我一直都是认为我国除去北京上海，长三角珠三角，都是欠发达地区。天津，就是这样的一个欠发达地区。后期它还是很难找到真正的发展方向，所以很可能就是会继续衰退。没什么办法，经济差距不是一天两天形成的。很多事情都是积重难返。17 聊聊北京房产古代的屏风2020-12-03 15:24 提问在北京买房? 斯文你好，我是北京人，目前有一套住房，夫妻二人在银行和体制内工作，手里有一些现金但是没有好的投资方式。想请问你目前在北京买房是否是个好的投资渠道？父母60了，是不是要留一些现金抵抗一下风险，等有了孩子以后再买个学区房啥的。如果要买房的话，在北京选房要注意哪些事情呢，还是看土拍的信息吗？北京的新房和二手房的选择策略应该不一样吧，还请赐教，谢谢北京的房地产是一个让我一想起来就很郁闷的话题。我本来16年的时候都已经在北京找到了一个拿到编制的好朋友帮代持买到一套房子了，无奈遇到连锁违约，导致没买成房子。每每想起心里都觉得可惜。前两天回来和朋友吃饭，说有种感觉，可能就是这辈子都不会在北京有房子了。这不是说笑，是我真实的感受。现在想在北京买到一套合适的房子已经很难了。北京不是没有新房，而是它目前的人口上限规划导致北京整体的房产特别的稀缺。如果你在北京买房，资金不是很足够的情况下，我会推荐你尽可能的去置换大约140平左右的房子。这个面积的房子我个人认为在北京的房地产市场很吃香。随着开放生育，类似的房子溢价会更高。我自己长期买房都是首选90-120,但是北京的情况看起来，140左右特别好。另外就是要特别注意北京的学区房。不到万不得已，投资千万别碰。我以前就北京学区房的算法写过篇文章，我等等去找出来，你可以仔细看看。我自己也因为这个事情遇到过很多麻烦。我自己有个好友，他和他老婆加起来因为拆迁在北京有七套房。所以他老婆特别想置换买套学区房，给两个孩子读书。但是他想法和我比较接近，认为自己花钱给孩子请老师效率更高。就骗他老婆说我有消息，知道他老婆看上的学区房要改划片。结果后来真改了，他老婆逢人就说我很牛，有学区房的消息，把我整的特别惨，因为这事情一出来，没人相信我是真的一点学区房的消息都没有。而我是真的一点消息都没有。北京的学区房划片一直都是个玄学，尤其是多校划片，真的是把不准。从投资角度，尤其是你自己房产不多的情况下，我强烈建议你不要碰。学区房一个划片改革，溢价就没了。千万千万要小心。而且不要花钱买任何学区房的消息，北京这类骗子很多，作为普通人能接触到的，一百个里一百个都是骗子，哪怕他在教育局工作，他愿意告诉你，他也是骗子。二手房市场尤其要小心学区。另外就是老人养老，确实要多留钱，因为北京目前的护工价格特别高，还在涨。目前北京自己都在计划着把老人往北三县转移。北京具体片区我是真的没什么推荐，去年还在看，今年连看都没看过。主要是真的没钱买了。18 谈谈认清现实微博问答 2021-01-21 16:27 提问怎么看待您经常提到的认清现实，是现实不够好需要朝着更理想的方向努力，还是理想太天真是难以实现的虚妄?您文章中提到的房价问题、教育问题等等，给我的直观感受几乎都是我们要接受，认清现实，然后在现实的规则下，寻找最利己的方式来指导自己的行动。似乎很少提及现行规则是否合理，是否需要改变。是您觉得现行规则已经是当前最合理的博弈结果，还是觉得这些太过假大空，普通人没必要考虑。劳资矛盾中，讲“合理”是最低级的东西。因为民众不在一个频道上，你给他们不同的信息，他们就会对同一件事情做出完全不同判断。前几天有个饿了么的外卖员自fen，因为没拿到所谓的“工资”。但是现实中他们其实多数都是没有社保的个体工商户。很多每个月都要工作超过300个小时。但是薪水也确实高。像上海这样的地方一个月工作超过300小时，一个月到手确实是过万的。可是他要是缴纳社保呢？1万月薪，自己缴纳社保，就要支出1万4，到手只剩下8000。所以他们不会缴纳社保。尤其是农村来到上海打工的外卖员，根本没有必要在上海缴纳社保。大病回去农村有医疗险，养老也不可能将来在上海。换你你怎么办？现在让你来制定规则，你怎么办？强制他们都变成合同工，让他们足额缴纳社保？那些外卖员会觉得你才是剥削者。你让他们缴纳社保他们又不合算。收入还要大幅度下降。人家到手钱少了就是来骂你。让饿了么涨价？结果很可能就是它要把涨价的成本提升到配送费用上，让点外卖的客户买单。价格高了，客户少了，单量减少了，外卖员的工作岗位少了，谁负责？所以现实中压根就没人敢去动。像之前拼多多的事件，我从来不同情拼多多的员工，因为我觉得他们就是劳动者中的精英，而且如果完整展现现实，多数民众只会觉得该给这些员工加税。你看到的，是他们每月工作300小时很可怜。可是他们赚多少钱呢？很可能是因为家庭矛盾自杀的那个应届生，刚毕业是两万八月薪，签了15-18薪的合同，还有额外的绩效奖励。你告诉我，在你的同学里，刚毕业能拿到这个薪水的，是不是精英？多多买菜，是拼多多员工自己报名去的。因为绩效高。里面高绩效的员工，哪怕是刚毕业的新人，都能拿到70万的综合收入。我在这边遇到的愿意讲自己收入的，只有一个工作了三年的年轻人，他一年股票加薪水是142万。但是他绩效大概是前10%的。其他拼多多的员工都不愿意说自己的薪水，只是愿意告诉我们，横向比较他们赚得比华为还多。我们国家遍地996月薪5000块的人，他们一辈子不吃不喝都赚不到200万，你告诉我，他们应该同情拼多多的员工吗？要是对拼多多初期的报导就把这个写进去，给你这样的信息，你认为大众是不是可以考虑同样是月工作300小时，有人拼死拼活送外卖一年12万和拼多多的员工赚142万的差距呢？认为不认为我们国家应该调节下大家的收入差，让互联网大厂的高薪者缴纳更高的税收来保障低收入的劳工给他们医保社保呢？这样的诉求“合理”吗？在媒体行业里面，最低级的人是去讲“合理”的，因为这些人试图引导民众去思考。我不愿意我自己那么低级。所以你让我写，我会尽可能把我知道的信息和我的观点整理出来给你读，你怎么思考你怎么想是你的事情。19 谈谈试行以经常居住地登记户口制度莫-多 2021-01-31 22:12 提问斯文，能通俗解释一下：我国将试行以经常居住地登记户口制度？我国的户籍政策都是环套式的。国家定一个大方向，确定每个地方能干什么，然后各个地方再根据自己的地域特性在国家划定的范围内，把政策具体定下来。户籍北京上海是人口上限。上海是到2025年才执行，所以现在还有空间。而各个大城市，比如像杭州之类的城市他们也可以自己制定政策，确定怎样落户。户籍背后其实和提供福利有直接关系。你让落户了，比如小孩的义务教育就成了你的预算范围。所以这些人口大量涌入的城市还是要管的。而其他的城市就没什么限制了。这方面我觉得最值得注意的是长三角和珠三角，那边整体社保相对宽裕，人均寿命也长。所以落户政策一旦放宽很值得考虑。剩下的核心其实是农村户口转城市。简单来说就是我们没办法再去走振兴农村的道路了。接下去要让大量的农村人口就近向城市转移。之前几乎所有的政策都和这个相关。比如之前确定了城市户口的孩子也可以继承农村户口父母的宅基地。对很多地方来讲，一个村集体户口一旦全部外迁，就等于自然荒废了。村集体都没了，哪里来的集体土地呢？加速农村转城市，户籍制度改革扮演了非常重要的角色。剩下的就是养老的户籍迁移。也就是说老年人随迁政策。老人在老家没办法养老，户口跟着子女走是国策。这方面哪怕是北京上海，都一定要同意。其他就没什么了，户籍制度这个东西不可能一下子大变，因为背后其实是各地的社保和经济账目。20 为什么经济水平越高，生育率越低?衣者人从 2021-02-05 08:26 提问请问斯文老师，为什么经济水平越高，生育率越低? 是高房价让大家都不生了吗？还是其他的原因？数学上的论证推荐《家庭论》的第五章，加里贝克尔的作品。结论如下，数学论证全文很详细。推荐这个不是因为他做得最好，而是这本书的出版时间恰好和我国推行计生同期。现实就是我国当时的专家们对生育数量的估计犯了原则性的错误。加里贝克尔后来得了诺贝尔奖。而我国那些专家现在很多都退休了。我们也不去说他们。简单来说就是经济增长对生育率有非常明显的副作用。不是大家变穷了不生，而是经济发展让大家更加倾向于少生精养。像加里贝克尔这些人预测的，现实就是“大大的降低了生育率”。和什么高房价什么生不起一毛钱关系没有。房价低的地方，也不生。中国农民7亿，他们的生育率也在全面降低。农村还是自己建房呢。生育率一旦下滑，我们的做法，其实还是从断退路开始。就像上海妇联之前推的一样，“家庭报税”，让少生孩子的单身和丁克多纳税。另外一个是降低女性生育的机会成本。简单来说就是一个女孩子考虑生育，她如果有工作，就要考虑生育对她未来的影响。如果她没工作呢？怎么让她没工作？保护到她没工作。所以大家近期会看到妇女口推大量的女性权益保障提案，而且很多都是微博上知名的女性博主去跟着一起喊。比如什么企业雇佣女性员工到一定比例就要加育婴室，辅助女性哺乳休息，加强产假保护之类的。就和加强女性产假一个道理。女性产假社保全是企业主出。人家不愿意承担最好的办法就是减少雇佣女性。全面保护，结果就是全面减少，然后女性回归家庭。我最近和人起矛盾也是这些事情。我真的发自内心的看不起网上那些搞女权的家伙。明明体制内，偏偏要装成反体制。我知道这些提案对女性就业根本不利，也知道这些事情是没办法必需要做的。因为生育率关系到我们每个人的退休金。可是我是不会转过头说这是一种“福利”的。这批人底线就是能低到讲让女性延迟退休都是女性福利。里面我唯一能接受的推广是非婚生子女的全面铺开认定。很多保守的女性觉得这是在帮助男性解脱婚姻责任。但是我觉得这东西还真的应该全面推广。女人生不生孩子，自己说了算。不需要男人给她一张结婚证。就是我看了这么多年的女性话题，这些年其实感觉是越来越不乐观。但是客观条件就在那里，我是真的一点办法都没有。21普通人2021年的机会是买房，买股票，还是买基金？猴子来了走了 2021-02-11 21:41 提问关于基金购买? 去年是基金大年好多人都赚到钱了，您有购买基金吗？普通2021年的机会是买房，买股票，还是买基金？每到过年的时候我就会习惯性的清帐。我自己也买基金，但是谈不上做。因为我自己的基金都是买了就不去看的。等到需要钱的时候再去看一眼。这是我最近最后一笔基金交易：12月3号。下面是我股票的持仓，现在整体也就只剩下200万了。钱拿去干嘛了？买房去了。我从11月回到国内之后，就一直沿着太湖沿岸在看房子。从苏州一路过来，到湖州截止。我以前投资的理念是分块的。这笔钱拿来买房，那笔拿来买股票。剩下一些闲钱拿来交学费。因为我自己专业就是学经济和电学的，一边学，就一边买。就是“纸上得来终觉浅”，没做过，根本不可能懂。我调整的方法也很简单，哪个做得好，就哪个多投钱。股票做得坦白讲是属于开始很好，后面因为有两支股票投资错误，所以整体盈利率一般。房产这边特别好，好到我觉得我应该辞职不干活，专心致志去买房子。基金则是鸡肋，食之无味弃之可惜。我不喜欢让别人来管理我的钱，我觉得就我那点钱，我自己就可以掌控。投资基金，纯粹就是玩票。但是整体收益还算不错，所以还加过点仓位。你也可以看见，我买的基金基本也都是蓝筹的。我对基金的感受就是“没意思”。基金也会亏钱，买基金的感受就像你把自己的钱交给一个德州扑克的职业玩家，让他来帮你赢钱。这些职业玩家有时可能因为运气好大赢特赢，有时很可能就是会输的一无所有。都是进场，我为什么不自己来呢？这纯粹就是个心态问题。然后站在我个人角度，我2020年最大的决定就是把尽可能多的钱拿出来买房子。买房是五年锁定，我个人非常看好我们国家的发展，所以买房。但是不觉得房子都会普涨，而是觉得国家很可能在这个国际形势当中，会不得不放开货币政策，大规模的注水。然后北京上海深圳的稀缺房产会水涨船高。经济强势的长三角也会。所以在上海和深圳之后，我选了太湖边上的排屋。以前的钱不够了，所以干脆把基金全抛掉，甚至连长期持有的一些股票都按比例消减掉了一部分，来凑钱。自己用家人的名义买了一套240平的排屋。准备五年后把它卖掉。这是我第一次去买非平层的房产，对我自己个人来说也算是个新的尝试。毕竟我以前基本都是买上海深圳这些地方的好小区，电梯房。整体上就没有尝试过去买排屋。甚至连大平层都没有买过。最大买的房子我印象里似乎也就是160几个平方。我现在手里一分钱基金都没有，股票也很少了，基本全都是房子了。上海，深圳，再加上苏州两套。其他都没了。从投资的方式上来讲可能不是好的选择，因为太过集中。但是整体上我认为放水不可避免，所以就是买房。22 怎么看阶层固化dthh222 2021-02-28 20:18 斯文，请问你怎么看阶层固化的事情?我手头正好有一篇01年时一个程序员写的在北京生活的文章，里面有个很有趣的东西叫“暂住证”。选段你可以先读一下： “说到租房，北京的住房更是许多流浪在北京的IT人的心头之痛。随便一点的两居都是2K左右。并且北京的房屋中介行业收费贵（—— 一般中介收费是房租的一个月租金，但上海广州等一些城市，大多是收月租金的一半，另一半从房东那里收），操作极不规范，与中介发生纠纷是常事。如果图便宜，就得往北京的三环四环之外租了，但路远的话，经常在路上堵车堵得你一点脾气也没有。我不大喜欢把时间浪费在路上，因此一般把房子租在靠近公司的地方，虽然贵点，但很方便。在北京的几年，公司搬过三次家，我们也随之租过三个房子，一般离公司就几分钟的路。 相比气候、饮食与租房，最让很多人受不了的，就是北京的暂住证制度，如果你没有暂住证，那些戴盖帽的，戴红袖章的，甚至连既不戴盖帽也不戴袖标的人也可能来检查你。北京政府也挺搞笑，连暂住证都分为ABC 三等。嘿嘿，我拿的就是C类暂住证了，属于那种最底层的外来人口。检查不合格的结果一般是先把你关到昌平去晒沙子挑砖头什么的，为自己被遣返原籍攒路费，然后遣送回乡。“到昌平拉沙子”对在北京的很多外地人来说，是一个很恐怖的词。 1999 年、2000 年以及 2001 年我在北京的几年里，办个暂住证的花费是 188 元，如果你是 MM (毫米) 的话，还得有什么计划生育管理费之类的东东，加起来两百来块左右吧。根据《北京日报》报道，今年9月就有237万外地人口办了证，新浪上面有报道：” “从这一个“创下了历史新高”的政绩背后，我作为一名在北京按章纳税，规规矩矩地交纳了暂住证管理费用的打工者，我很想知道，这笔钱倒底花在了什么地方？算一算啊：237万 * 188.00 RMB/人 = ？ 天啊，4.5个亿啊！而这仅仅是只是一次“统一换发新证”行动的收入！“尔俸尔禄，民脂民膏”，一年下来是多少？两年下来是多少？不知道这笔钱用在了什么地方？受谁的监督？至少我是很少看到有什么真正为外来人口办实事的项目。 关于北京暂住证，有这么几件真实的故事： 一哥们是Cisco思科的高级工程师，他形容自己是：怀里惴着世界上最牛的IT认证证书，干着世界上科技含量最高的IT工作，走在北京阳光明媚的大街上，却时时担心由于没有暂住证而被抓走…. IT记者猛小蛇作为“北漂一族”中的一员，已经在北京分期付款买了房子。但并没有什么归宿感———他说：“我没有北京户口，所以我只能去附近的派出所办一张暂住证‘暂住’在自己购买的房子里。我想这是一件非常荒唐的事情。” 我朋友的一个公司，他们买了济南一个公司的系统，那边派了一个工程师来北京给他们培训。那哥们说九点到，然而十一点还没到。最后才知在路上给抓到收容所去了… 有篇关于一名IT人在北京80小时的亲身经历文章，想必很多的朋友都看过，曾在网上无数次流转。想想也觉得无奈。详见转载地址: http://lisen.www83.cn4e.com/cgi/view.cgi?forum=3&amp;topic=56(2011年注：此链接是2001年一个论坛上的贴子，现在已经无效) 我离开北京的之前，住在增光路上，八月份那里新开了个办事处，叫做”甘家口外来人口管理站”，大红招牌，亮丽堂皇的。而装修、建设这个管理站的全是一些外地的民工。老虎和我看了当时觉得很搞笑。也许这就是外地人的悲哀吧。 五十年大庆期间，大街上经常有些警察查人。有人把三证齐全给他们看，说”我有暂住证”，谁知警察抓着一撕，往旁边水沟一扔，斯条慢理的问：“你现在还有吗？….” !@#$%^$——不要以为这是讲故事，这是很多人的真实经历！ 还记得我们读初中时学过的那篇马丁路德的“我有一个梦想”的讲演吗？—几十年前，马丁·路德·金在华盛顿发表那篇著名的演讲。国内的媒体经常报道其他国家的种族歧视和贫富不均，我想，还是不要嘲笑别国的白人鄙视黑人，不要嘲笑别国的富人鄙视穷人，因为在我们自己的身边，一纸户口所赋予人的特权和这相比，实是有过之而无不及啊！ 虽然我对户口、暂住证有着深深地痛恨，但对于北京人，或者是我现在面对的上海人，我从来没有特别的看法，相反，我觉得很多的北京朋友很不错，特别是年轻的朋友。我经常在一些论坛上看到许多网友挑起地域之争，骂完北京人骂上海人，骂完上海人骂河南人，骂完河南人骂新疆人……何必呢？其实大家都是中国人啊！这笔帐，应该算在谁的身上，其实稍有点脑子的人都清楚，我们不应该把这笔帐帐算到某个城市的居民身上来，或许有天错个位，把你换成他，他换成你，你又会如何？现在在很多城市，仍是一样，只要你是外地人，你都逃不掉。象我的家乡长沙，对待外来人口的管理也是如此。——我侄女在长沙市区工作，家是是长沙郊县的，没有城市户口，每次搞个什么运动，也得东躲西藏，提心吊胆的。 但不管怎样，我相信总有一天这一切都会打破，毕竟社会是在不断地发展。”也就是2001年，刚过了20年。我们国家的阶层一直分得很清楚。北京上海一直都有最好的就业岗位。可是换到三十年前，哪怕你有能力有学历，你都没有机会去争取这样的劳动岗位。因为你没户口。到了21世纪，你去了，也是被当作外来人口清理掉。你说这些民众没怨气吗？怎么可能没有。只不过是他们都被打散掉了，而且总量小。你觉得从前那么严格限制人口流动的社会更固化还是现在的社会更加固化？从前限制这些精英往上走的，就是一纸户口。拿钱没门路，都很难买到。但是现在呢？2020年起北京又是2300万人口上限。但是现在不是暂住证管理了，是全靠钱在管理。你现在到北京，离开被挤出往往就是因为租不起房子。以前是户籍，现在是钱，你觉得哪个更加“固化”？所谓的不固化，也就是碰到了历史上少有的那每年超过8%的增长。北京当初那个时候每年房价涨幅都超过20%，增长何止8%呢？可是这个大环境肯定没有了。以后也不会再有了。阶层这个东西就是这样，有人要上去，就有人要下来。现在是一个稳定的时候。23 怎么看张雪峰老师离开呆了14年的北京去苏州定居？氟氖钠镁铝 2021-03-13 18:40 斯文，怎么看张雪峰老师离开呆了14年的北京去苏州定居？ 张雪峰这个收入级别在北京还没有办法落户吗？是假的吧？这能不能代表一种风向？斯文怎么看？我自己听过不止一个北京人抱怨，网上民众讲的北京中产生活，或者说简单生活，根本和一般的北京人没什么关系。我觉得任何一个对钱有概念的人，都不会觉得1500万的海淀区学区房是“简单生活”。而能掏出钱来买这种房子的，就是中国的人上人。因为中国最多只有前0.1%的人有这个能力去买这样的房子。如果一个人觉得北京海淀区那样的房子都能是一个“必需品”而自己买不起的话，那么只能说他自我定位太高了。北京大多数普通人，努力几辈子，都买不起这样的房子。至于张雪峰本人我很有印象，因为我几乎次次看见他都是看他被激烈批评成骗子。其中有次我印象很深，大概是他一个带哭腔的一个视频，去鼓励大家考研换个好出身。说什么没名校毕业的学历就会被歧视什么的。我看了没什么感觉，但是几个年纪大的真是看了就骂。因为他们是从社会角度去看他的。学生知道的信息少，不知道现在其实硕士就业特别差，因为我们的教育培养制度和市场脱节。考研特别火的文科类专业，比如法学新闻之类的，其实最好就业就是去考公务员。而公务员考录比现在都超过1：60了。他们认为张雪峰这种用过来人身份去给学生指路的，就是骗子。因为这些本科毕业找不到对口工作迷茫的学生，其实都是教育制度下的牺牲品。再往上追求高学历，很可能就是盲目投入很多，收获极少。但是我不那么看。换我去做考研老师我也会给学生描述一条考研的金光大道啊。这里错又不是他的错，是教育部瞎搞啊。学生考研的路都是自己选的。20几岁的人了，还要像个小孩一样去哄着帮他挑路吗？有本事你自己媒体上发篇文章讲讲我们研究生扩招其实是饮鸩止渴，因为本科教育和社会脱节，就业特别不好，无奈才扩招把问题留给将来。但是张老师本人是很会抓社会共鸣的一个人，说孩子不能在北京高考所以无奈把整个事业搬去苏州那这个我要是真信我智力就有问题了。上海杭州不行吗？深圳广州不行吗？孩子十几年后的高考，谁知道当时的政策呢？而且北京上海必须限制外来人的子女就学。因为涉及到非常敏感的套利问题。北京有严格的人口上限，上海马上也会有。基础教育他们就是全国最好。你觉得如果在北京找到一份工作，就能外地家长带着孩子去北京求学，和北京人的孩子一样读书，北京人口上限还控制得住吗？北京的外来务工人员和新加坡的外劳在政策上定位是一样的。这个任何人看了都会不喜欢，但是现实我国就是一个这样的运转模式。而且短期内看不到任何的改动可能。24 为什么环北京不能朝着江浙沪那样的多城市共同繁荣的目标去发展？摩卡mouse 2021-03-20 10:16 为什么环北京不能朝着江浙沪那样的多城市共同繁荣的目标去发展？ 环北京，是没有什么共同发展的。有的只是贫困带。为什么环北京不能朝着江浙沪那样的多城市共同繁荣的目标去发展，为什么环北京只能有贫困带呢？北京人家里有老人也关心养老的，肯定听说过北京要和河北三县协同养老产业。一些无良的开发商也借此宣传，让这些北京人以为河北会被真正纳入北京的一体化发展，忽悠北京人去北三县买房。可是你作为北京人想一想，你北京住的好好的，干嘛要跑去河北养老？北京的医院会搬到河北去吗？当然不是啊。医生也是人，人家真愿意离开北京，去的也不可能是河北啊。是人力成本。去河北养老的北京人不是富人，是在北京没办法支付北京人力成本的人。河北的人力成本更低，北京政府补贴一点，他们去河北养老，带动那边的第三产业发展。而且要那边的人力成本一直低，这些项目才可能长期稳定。所以你也不可能看见上海政府补贴上海请不起护工的老人去苏州的。哪怕苏州高铁到上海只有半个小时。其实你这样也能看出北三县发展的痛点了。北三县能够做什么？国内搞环保的，全都是说不能走先污染后治理的老路。可是发展起来真的只能走这条路。高端产业都是群聚一起发展的，人家吃饱了撑的跑燕郊发展啊？第一产业农业没条件，二产业不能搞污染，第三产业没旅游。你真的相信北三县是将来的中国硅谷吗？河北人说被限制发展，确实是有道理的。但是北京毕竟特殊啊。很多时候真的就是给河北画画大饼而已。尤其是像承接低端养老产业，讲起来都是要多无奈有多无奈。像江浙产业集群做得那么好，先发优势巨大。现在转出来的也多数是低端的污染产业。比如浙江之前一直的痛点就是电池生产。这种产业欠发达地区也要抢的。因为有产业能自己造血了，将来才可能一步一步发展高端。河北尤其是北三县，这个可能都断掉了。怎么“探索”出一条独立的新路呢？25 买房时需要考虑租售比吗?uyfg55 2021-03-31 22:57sven老师，买房时需要考虑租售比吗?经济学当中有很多模型，你看上去很有道理，但是因为你不知道它的使用原则，所以很容易用正确的模型推导出错误的结果。而房屋价值也就是资产评估更是如此。用租售比去衡量商品房房价的，基本都可以归类到不懂。房屋因为性质不同，所以估价的方法会不一样。比如生产用的厂房，一般可以用成本法。意思就是你花了多少钱建造房子，用了多少成本，去衡量价值。然后租售比一般来说是用来衡量商住的。多少钱买，获得多少租金。用收益法。而商品房用的是比较法。就是比较同类型房产的成交价格。比如你家对门邻居的房子1000万按照市场正常卖掉了，再看看你家楼下楼上的价格，找几个参照物对比一下，评估下你房子差不多是1100万。你买商品房考虑租售比，就是犯了原则性的错误。就是一般你在网上看见讲房产的博主用租售比去衡量商品房的房价，就知道这人基本就是属于东边抄抄，西边弄弄的那种。常识都没有啊，而且肯定自己没怎么投钱买过房子。租售比还有一个是衡量泡沫指数，这是很多喜欢看英文新闻的人经常犯的错误。比如你经常可以看见德国的慕尼黑被拉上泡沫指数的头条，但是现实中它上泡沫指数了，接下去还会涨。原因很简单，这里面衡量的是一个模型。意思就是比如你去北京打工，北京的房价远远超过你的收入。你认为政府应该照顾你，让你未来留在北京。那么北京政府就要干嘛？建造更多的房产，让你将来有地方住。可是现实是北京设立了2300万的人口上限。就2300万人住，不会多建造很多房屋给2400万人住。所以现实就是北京核心区的房子会因为极度稀缺而上涨，来北京的外来务工人员的收入也和当地房价无关，只能影响租房市场。26 法拍房的风险?青豆200006 2021-04-12 14:54斯文，你好，请问法拍房除了可能不好腾房以外还有其他风险吗？是否可以贷款购买？还是必须买方一次性付清全款？竞买成功后是买方拿着法院文书去房管局办理过户吗？是否还需要原业主配合办理什么手续？ 有些城市法拍房不在限购范围内，地段、户型、面积等各方面条件看着也不错，看拍卖公告上写的房屋目前空置（也就是说没有租户），会不会出现原业主在法院/竞买人不知情的情况下在拍卖/过户前自己住进去或者租给其他人、把房屋抵押出去等阻碍房屋交付的情况？从你问问题的方式，我就建议你如果不是真了解，别随便去碰法拍房。你问的问题，很明显就是在网上或者其他人身上杂乱的搜索了一堆东西，然后想找一个人，给你完整的答案，把所有的东西都搞明白，再决定你是不是去法拍房子。如果你只是为了好奇，我建议你以后也就别去关心这个话题了。原因很简单，法拍房是一个地方一个政策。你想问哪里的法拍房？像我接触多的是浙江和上海的法拍。上海法拍以前因为不限购，所以经常会标出高价，而现在开始就要限购了。限购的法拍房和不限购的，就完全不一样。因为这个政策，你就要去搞清楚自己是否有购房资质。接着你还要明确的算清楚拿到这套房子到底要多少钱，自己心里价位又是多少。不是拍卖出价多少钱你就拿到多少。你指望看篇文章就能知道怎么操作法拍，那就是不可能的。法拍在房地产不好房子不值钱的地方就是个鸡肋，因为你能买到干净没问题的二手房，没必要碰法拍。在上海北京这种地方是专家的市场。法院里面专门有执行部门，他们知道什么房子好弄。一般法拍普通人能碰的，就是按揭违约或者司法没收的。就六个钱包买房资金链断了的，银行拍卖房子，或者司法当赃物收起来的。干净没什么问题，收了就收了。这种房子往往和市场价格也差不多。你看看也就看看了，普通人是捡不到漏的。另外民间借贷出问题的房子，最好理都别理。这种房子乱七八糟事情多，法院都难搞定，你去碰就是自己倒霉。房地产市场发展到今天这个程度，已经没有什么捷径了。你在网上看见教你搞定学区的，都是骗子，因为没人知道学区房将来怎么规划。搞法拍的，就更加是骗子了。原因很简单，这类房子大城市里需要的买家往往都是资金实力很强的人。有专门的事务所去对接，搞定房子，最后按成交比例拿佣金。你是个高净值客户，人家签约，搞定你付钱，搞不定他赔你钱。你不是，进去可能真能遇到宝，但是你要是就买一套房，绝对得不偿失。这种东西，当个有趣的事情，大家茶余饭后聊一聊就够了。27 是否在环京如固安买房niuniu8051 2021-04-17 07:59我现在40岁北京工作，以后医保养老无法离开北京，考虑是否在环京如固安买养老房，北京房子以后让给孩子?其实我想问你的问题是你为什么不考虑在固安租房而是买房呢？买房是个投资行为。按你的描述你自己是在北京有房的。医保社保离开不了，可能就是公务人员。那么假设现在国家派你去云南，你要长期在云南生活。你会卖掉北京的房子去云南买房吗？不会的。因为北京的房子肯定比云南的好啊。买房就是个投资行为。如果你是养老，你手里有养老金，在哪里都能租房的。别说固安了，北三县的房子我认为出手都是比较难的。如果考虑现在的政策，你就更加不应该考虑自己去固安这样的地方买房养老了。因为政府准备在北三县给北京人安排养老。“京籍老人到北三县养老，将享有更高补贴据北京日报，9月15日， 2020年北京与河北廊坊北三县项目推介洽谈会召开，北京市民政局与廊坊市政府、通州区民政局与廊坊市民政局分别签订了养老合作协议。未来两地将以养老协同促进人口协同，通过鼓励政策和项目落地，鼓励北京养老项目向廊坊市北三县发展，北京市将按照床位随着京籍老人到北三县养老给予补贴。目前，京籍老人在本市养老会对养老机构给予一定补贴，未来到北三县养老，补贴将更高、力度也更大。相关政策正在研究过程中。”简单来说就是北京之前吹牛吹得太大了，还9064，意思就是4%的老年人可以住养老院养老。但是现实中肯定是很难实现的。因为北京的人力成本很高。北三县，还有像固安也是属于廊坊的，这些地方人力成本比较低，政府就准备集中把北京的老人补贴送到那里去养老。如果自己本来钱就不多，干嘛不等着政府补贴呢？你才40岁，养老也是二十年后的事情，看看项目具体做得怎么样再说也不迟啊。反正你社保医保都在北京，还在北京有房子，肯定没人赶你啊。还有句话可能不太中听，我觉得你就是焦虑过度了。你40岁，孩子才多大呢？他将来比如跑到中科院考考试也进了计算机专业，到深圳腾讯去找到工作了，你怎么办呢？还是要他住在北京？慢慢的医保互通虽然难度很大，可是依旧在做。你目前想规划自己二十年后养老难度很大。没办法规划的事情看着就好。买房是投资行为，我从2017年北京人口上限政策以后就不认为北京周边的房价有投资价值。所以我反而会建议你有机会往南边看看，长三角珠三角都有很多很好的地方。28 关于高层住宅的未来是粽子呀yaho 2021-07-20 03:43 关于高层住宅的未来您如何看待 最近某音博主有个“高层住宅没有未来”的视频热度不小，说“高层小区会沦为贫民窟”…虽说房产看地段，有分化现象，但高层住宅未来都会老化，维护拆除重建成本巨大，难道要留意低密社区？请问sven如何看待？谢谢我不是学建筑的，但是对楼房造价还是有一定了解。一般小高层比较好的造价也就几千块一平米，绝对不会到一万。房价主要贵，就是贵在地价。房屋的核心价值也是区位。假设房产真的出了安全问题，怎么解决？最简单的方法就是原拆原建。就是原地把房子拆了，再建。对核心区位的房子来讲政府怎么搞定都可以。因为审批能建多少房子的权利都在政府手里。和当地民众谈，让他们自己出点钱原拆原建一点压力都没有。类似的案例也不少。我印象里南京就有。问题在哪里？在那些人口净流出的小县城。这些城市不仅是高层连普通的民房都会出现大量的“空置”。像鹤岗这样的地方，一栋楼可能就只有几个住户。这些地方人口流出，土地不值钱，房子出问题了怎么办？炸了怎么补偿？恒大刚在鹤岗拿了块地，地多少钱你可以搜下看看。这些地方理论上是不应该建造高楼的。国家之后肯定也会有明确限制。越到人口少的小县城，越要个人自扫门前雪。就是房子就是自己归自己。你独门独户住着，你房子出问题了，你能找谁？只能找自己。就和农村自建房出问题了，政府给政策，你自己改建就行。 补充信息:“2021年5月29日萝北县恒大房地产开发有限公司以底价竞得鹤岗市1宗住宅用地 楼面价219元/㎡”29 面对45%的个税如何心理平衡?–__ 2021-07-26 20:26面对45%的个税如何心理平衡? 努力工作的边际效益递减，到手钱区别越来越小，压力越来越大，让人如何有动力努力工作？资本利得税这么低，理解国家发展需要资本支持，可是意难平，除了默默买基金投资权益市场，很难说服自己出卖时间和劳动力所得上缴45%，公司也不帮忙合理规划，而旁边的香港人却可以在深圳享受15%的税。我看到你的问题想起一个例子。应该是我看的一本德国人写德国问题的书，里面形容社会就像一艘船，资本家负责出钱造船并且拥有船，底层人民等着船回来分利益，而在船上的都是普通劳动者，他们能够竞争的最好岗位就是船长了。拥有船的人可以和政府讨价还价，而上了船的人就没得选了。学术点讲就是资本利得的实际税率远远低于劳动所得，社会主要还是在靠这些中间层纳税维持运转。站在你的位置，没得选。你不可能不工作，你一走开，有的是人看中你的位置。毕竟船长就那么一个。表面上有份别人很羡慕的工作，但是现实中就像被人用鞭子抽着的驴，根本没办法停下来拉磨。边上那些hk的人就像主人家的马，偶尔还给主人使性子，主人却总是哄着它们，不干活就能吃比你好得多的草料。你是驴，生下的就是驴；他们是马，生下的就是马。所以你的孩子在教育等社会资源的分配上就是没办法和他们的孩子比。驴有没有怨气？有啊。但是它停不下来啊。它有父母，有老婆孩子要养，它没得选。搞清楚自己没得选的时候，就是要认命的时候。30 家庭条件会对孩子以后的生活道路产生多大的影响？mzs乡间少年 2021-09-09 16:57 Sven你好，家庭条件会对孩子以后的生活道路产生多大的影响呢？ 作为一个初为人父的90后青年来说，深刻感受到在我们是小孩子的时候，一个人和一个人可能有家庭条件上有区别，但孩子们本身的差别并没有那么明显，可一旦长大，每个人的生活道路就会有有很大的差别呀！还请Sven您给解惑一下，好在以后的育儿生活中少走弯路，对孩子的未来成长少走岔路。我们国家做过很多教育实验，有面向家境优秀的孩子进行超前教育选拔的少年班，也有面向中底层家庭选拔所谓“天赋优秀”的青云班。这些实验的结果其实都是很有价值的。超前教育是什么？就是原来一个孩子14岁应该学初中数学，我们给他教更多，比如高中甚至大学的数学。这就是典型的超前教育。超前教育当然是需要老师教的，一般不是大城市的知名学校办重点班集中培养就是家长自己出钱。现在重点班全要废掉，就是只剩下家长自己培养。这是中科大少年班的数学试题，网上也可以搜到。虚数这些东西初中肯定不会深入教。这个班的效果是好的。家长有一定经济能力，也能支持子女进一步的求学。另外还有一个针对农村家庭的选拔，叫青云班。也是做测试，但是不是直接考数学物理这些东西，而是给小孩做类似智商测验的题目，选拔智力逻辑比较高的农村贫民子弟，给他们相对优秀的集中教育。现实就是效果非常一般。所以后面没有了。而且连收尾都很难。因为你给这些小孩教再多东西，结果他们都是要面向就业找工作的。不让他们走高考路径，还能去哪里？少数孩子你能出钱送他们去国外。可是一旦数量大了呢？谁来出钱呢？这和你从小接受的那种理想中的教育是完全不同的。孩子是依靠自己本身的智力天赋被选拔进入岗位，科学家就是要聪明就可以了。但是现实是随着学制的延长，父母给子女的支持也起到了非常大的作用。家庭条件好和一般的孩子，一样读博30岁毕业心态是完全不一样的。所以作为普通人最稳妥的就是只做自己能力范围内的事情，孩子读书你有钱当然可以让他们多学点。多读点书没什么坏处。超前教育并不坏。没钱就按部就班走，因为越是没钱你就越需要孩子在未来自己就业赚钱。帮他在成绩范围内看看挑挑就业好一些的专业就可以了。家里有点关系也帮忙找找人，其他真没了。31 普通人，怎么实现财富增长帅锅锅锅1 2021-10-04 23:50普通人，怎么实现财富增长? 作为一个普通的90后，在企业上班，如何下定决心，走出圈子，实现个人财富的增长呢？现在致富的途径有哪一些呢？我上个礼拜在帮以前的一个朋友处理一些破产的事情。她自己是本科毕业后先做传媒行业，当时我们认识，但是交流不多。后来她去了英国一所很顶尖的学校读了个教育学回国创业，做英语培训机构。她家庭条件很好，男朋友虽然家境一般，但是工作很不错。本来预定是明年春节上来2月底结婚的。之前还问过我有没有时间。我是上个月才知道她这边出问题的。疫情期间，她认为线上教育遇到了一个很好的契机，然后想要融资但是价码没谈拢。就用父母给的婚房抵押去借钱投进去了。另外还额外从朋友那边借了不少钱扩张。方向都是对的，但是遇到了双减。我是劝她止损，不要想着再转型做培训了。因为政府这次决心很大，就是一刀切。她没有机会通过文件上所谓的漏洞做素质教育的英语培训。完蛋了就是完蛋了。然后男朋友也谈崩了。原因是男朋友不支持他转型。他们结婚有部分钱是准备在婚后投资房产的。她想先拿出来渡过难关。她男朋友不肯。不是说男人一定靠不住，而是说不定在她男朋友眼里她就像个输急了眼的赌徒，不顾一切想要再搏一把。当然，多数时候男人是靠不住的。走下坡路的时候，没几个人愿意陪着自己的。我也就只能作为朋友帮她梳理梳理问题，事情结束了，也就是重新再去找份稳定的工作。父母也退休的年纪了，也没什么钱再给她造了。创业这个事情，是很容易把人变成赌徒的。成了的，就是成了。但是回过头想，有时也是时运。我认为现在这个时间点出来创业，难度太大。很容易就成社会的肥料。自己死掉了，滋养社会成长。好好过日子。没什么好的机会，就停下来等等。真遇到好机会，也要顾及下止损点。人赚钱还是为了生活的。生活的舒适就真没必要给自己找罪受。32 判断未来房价的趋势是怎样乐把金针度与人 2021-11-23 18:45斯文，以你的判断未来房价的趋势是怎样的?我自己对房地产市场评价很简单，就是两极分化。我从买房开始就根本不相信所谓的一二三线城市分类法，就是坚定的信区域分法。北京上海长三角珠三角是发达地区，其他全是欠发达。投资买房，就是选发达地区。两极分化的结果就是这些发达地区民众的财富会和欠发达地区进一步的拉开。房子就是中国人的命根。大家嘴上说着房价高不好，其实只是抨击贫富差距。现实中没人希望自己家房子不值钱的，而且自己家里最值钱的，往往就是房子。然后发达地区也会出现两极分化。但是这个两极分化是政策带来的。而且我认为就是70平以下的老破小会遭遇严重冲击。因为公租房定位就是上限70平。我认为单纯依靠比较法去衡量房产并不对，还要考虑租金回报。老旧房屋的租金回报会因为保障房的存在而大幅度的下降。进而影响他们的估值，并且导致这些老房子变得不值钱。就是空有一个价格，然后处理起来很困难。因为很难满足现代人的居住需求。这就是我自己投资房地产买房时的概念。我买房一般都是90平起，主要是120-140平之间适合三口之家的户型。选地区就是北京上海。北京当然是因为运气不好，遇到连锁违约没买成。33 北京的房价预测古代的屏风 2021-11-30 12:55北京的房价预测? 斯文你好，能预测一下北京未来5年内各区域的房价走势吗，是全面稳步上涨，还是局部区域暴涨暴跌？感谢，期待你的回答。我现在人就在北京，燕莎这里。今天早晨刚到的。刚刚定了明天去故宫的票。我到了北京那么多次，这是我第一次去故宫。现在还挺激动的。今天要早睡，明天早起去。因为之前几乎每一次来，除去开会之外，都在看房子。但是这段时间真的不去看了。因为整个政策都是处在震荡期。房地产市场和货币还有信贷政策是密切相关的。目前新闻上很明确就是把大众的预期调整到一个常态化。意思就是让你别恐慌，觉得房价不跌也没涨。但是很明显的是各地的房地产市场都在出问题。这种当口一个不好，一些小城市的房地产市场就要崩掉。像沈阳昆明，甚至哈尔滨，纯粹就是因为政府动手及时，直接限制跌幅，才把数据稳住。就连深圳都在出问题。我强烈建议你有空的时候可以去看下深圳的法拍房，搜索下，看看像南山这样的地方有多少法拍房流拍。这个时候就不是买房的时候。就是要定下来，等政策明朗。尤其是货币政策。我相信现在中央都是根据情况要确定是否放水。只要努力印钞，房价一定会涨。但是具体印多少，放多少钱出来呢？没人知道。目前北京和上海的房地产市场也是成交量在大幅度的萎缩，高端市场几乎没有什么成交量，周边所谓的低价盘，也就是500万以下的，还是有成交的。但是受到不明确的保障房政策影响，大家都搞不清会出什么问题。尤其是北京之前的新保障房交易政策，反复更动，我之前的问答里也专门讲过。没人搞得清楚会发生什么。现在讲自己知道会怎么变化的，基本就是在瞎猜。我瞎猜也就是继续看好北京的核心区。尤其是海淀和西城，我尤其喜欢。但是价位有点太高，我很谨慎。我每次到北京看房都是习惯住在燕莎附近，因为觉得这边周边几个小区是真心不错。我没理由看衰。但是我自己现在是不会掏钱去买的。就是等，等着看，看明确一点再动手。我给自己定位就是绝对不可能正好抓到底部。那么就是等明朗了再说。34 什么才是普通人应该追求的生活瞌睡的快睡着了 2021-12-30 21:48斯文，到底什么才是普通人应该追求的生活？ 比如学历还可以，工作收入不算很高，但也在中上，物质生活几本没啥愁的，但远不到财富自由，这时候应该追求啥？每天的生活应该以什么为中心？我觉得人生很多时候就像股票一样。今天正好年末清盘，和人聊聊股票感触也挺深的。我一成年就开始做股票的。父母给我的钱除去买房子之外，我基本都是用来买股票和买基金。而且我股票业绩一直算很好，虽然一般也就小几百万投资买股，但是在我的资金量级里面成绩一直都是不错的。唯一投资失败的就是两个股票：博瑞传播和凤凰传媒。这两个股票吃掉了我炒股以来的大量利润，导致我股票整体收益也就比存钱略高，一直就是很心疼。然后就是我今年的业绩：超过23%的盈利算是很不错了。但是其实我基本没做什么操作。原因只有一个，博瑞传播因为成都文交所设立的利好，最近7个交易日拉了5个涨停板。开始时我甚至都不知道有这件事情。虽然钱不多，但是我挺开心的。这两天正好在我父母家里看他们，向他们炫耀自己运气好。然后我妈给我看了她的业绩：我整个愣住了。我妈资金量比我大很多，退休之后就一直炒股。亏钱了，我爸就补钱给她。我一直认为我妈炒股就是当韭菜送钱，多数时候也真的就是这样。然后我就问我妈她到底是什么原因想到这样操作。我听完之后认为我妈所有的操作都是错的，就是反逻辑的。但是结果看见了，就是这么回事，她盈利70%多。仔细算算比例，她做股票成绩比我好很好。哪怕我认为怎么算都应该是我对，但是市场给结果了，就是她对。这种感觉就像你努力学习，从小一直都排在前列，毕业之后也遇到了不错的机会，自己辛辛苦苦攒钱买了套房子准备还贷款，想跟从小的朋友炫耀一下。人家就回你句：“那里我知道，我们家老房子刚拆迁，在那里分了三套房子。”你愉快赚钱的心情一下子就没有了。而且比较下来你真的会发现人和人的差距有的时候真的不在努力，就是大家根本不在一条起跑线上。人家亏钱了，有个老公天天给自己补钱，一下子赚的比你努力十几年赚的还多。你拼命努力，就那么点本钱，运气好了遇到点喜事想炫耀下，发现自己的好运气，在别人眼里真是不值一提。有什么办法呢？你像我嘴上总说自己过好自己的日子就好，但是做人哪里能不去比较呢？一比较，人的心态就坏。人生中很多事情就是没有道理的。你想去坚持一个价值观，你的价值观甚至知识体系都会被现实碾碎的。回过头来就只能接受现实，在现实的基础上，想着让自己比昨天过的更好一点。35 深圳楼市未来的看法ChiyongYim 01-06 12:13Sven，关注你5年多了，一直觉得很有道理。想问一下你对深圳楼市未来的看法？我一直觉得人在钱面前应该诚实一些，尤其是面对房子，这个普通人最重要的资产，一定要先诚实的搞清楚目前面对的情况。我以前讲过我做股票亏钱就两个股票。博瑞传播和凤凰传媒。前者几乎亏掉了我炒股十多年来大半的利润。这股票这几天极其的变态，先是连着来了差不多7个涨停板，这两天又是连着跌停。但我就是看着，很麻木。因为这股票我成本都要最少15块。而且割肉到现在也就8万股左右了。股票上下我就是看着，什么都不操作，等两个月再说。这个底气我是有的。但是如果是上海的房地产市场遇到和深圳一样的情况，我估计我晚上觉都睡不着。因为我几乎大部分的资产都在上海的房地产里面。钱的比例一多，人就是淡定不了的。就像我刚开始做股票，买进博瑞传播后遇到暴跌，真是反复犹豫，都不知道怎么操作才好。心里特别的折磨。深圳的房地产市场目前非常的不好。关键是没有量了，哪怕成交你看着回升，其实很多也是去年年初因为限制贷款的原因。市场就是出问题了。我自己是19年9月在深圳和人合买的房子。21年年中我需要用钱，所以退了差不多一半。现在想起来真的就是运气。我当然希望深圳的房价涨，但是现实很不理想。我这边盯着福田和南山的几个盘，还有就是润玺和前海一带。我的一个好朋友，去年3月份全款跟了一套别人出的房子，当时我帮他算价格是合适的，还有折扣。他自己以后当婚房肯定可以。但是现在看起来，最少就是跌了15%。哪怕就是自己全款买的房子，想着做婚房的，以后要常住的。跌了也不可能不在意的。因为这是人最重要的资产，更何况他房子不止一套。接下去想要套现周转，就是会出问题。深圳我自己粗看感觉是信心出了问题。拿润玺一期举例，当时周边大概15万（注意18万成交只有一套房，是为了套现做高的，当时就是均价15万左右）。13万1开盘，近万人抢，到了二期，120平中等户型，同样价格都卖不掉。出什么问题了？粗看是觉得房产税之类的产生了信心问题。2020年时51个月社保的无房户暂时都观望。而现实就是基本面出了问题。深圳是个造富的天堂，很多人来这里突然有钱了，就是会大笔投资房产。而且当地就是加杠杆加得很猛。一旦集体现金流出问题的时候，真的不是想把房子卖掉就行的。深圳现在挂的房子很多。相当数量的房产给买家提供的时候，都是因为没有满五唯一，所以用先付款帮助原房主付清房贷，然后原房主获得房屋全部产权，抵押给买家，最后满五唯一交易。这样的房子流出了很多，真的没人接手，下一步就是去拍卖市场看见这些房子的。我这几个月看下来就是感觉深圳真的出问题了。如果国家不放水，那么这批人大概率就是一起倒霉。而真的去集中捡漏的时候，大家其实都怕自己捡在半山腰。我目前这两年估计是不会去深圳房产市场上继续买房子了。就是看看，当个案例。看看如果政府不救，深圳的房地产市场会怎么倒霉。现金流足够，就是可以当案例看。不够的，就是真的会很倒霉。​36 为什么很多人对于自己的流水完全没有概念春风化雨-情思深 02-16 17:15看sven的微博产生一个疑问，为什么很多人对于自己的流水完全没有概念，觉得首付凑够了就能大城市上车， 是因为过去房价涨太快给大家带来的过度自信吗？每月还上万房贷，真的很辛苦的。因为他们没真正买过房子。过去这二十年，多数的中国人也就是买一套或者两套房子。你看到的像房产中介，也就是自己跑跑“帮”别人买房子。自己买房的人，操作多了，而且见得多了，一下子就能看出问题来的。而且人的心态会不一样。相当数量的人由于过去非常良好的房地产市场，是会过度高估自己的房产的。关键是他们核心的资产就是自己的房子，所以有的时候心态上就很不好。像我自己在深圳买房子，19年买，算是很好的时间点。现在这个时间点真正要折现很可能就是亏钱的，所幸就是手里现金流没问题，所以就是扔着那边看。真的要是市场出现踩踏，我会很干脆的认亏离场的。因为心态上就是这里亏了，那里可以赚回来。而且之前赚的确实也不少，所以还算亏得起。预期和现实符合，人就不难过。但是有些事情是一定要算清楚的。我看这几天V+群里有个网友在问和女朋友的购房计划。他们想的就是逐级提升。我遇见过这样的人，知道里面的问题。当时这个男的大概是14年左右30岁买房，买了套40平左右的小房子，区位不错。然后和女方承诺说是五年左右换房，搞个90平的，然后生孩子。在他当时的眼里他是觉得没问题的。因为对人生充满憧憬，也觉得政府会帮助像他这样的人。可是真到那个时候他根本换不起。他就是个普通程序员，在上海一个月2万5，老婆收入可能1万左右。父母看他35了催他生孩子，女方也30多岁了。可是女方就是拿着他当时的承诺要求是换房生孩子，房子小就是不生。到最后就是离婚的。媒体上宣传这种逐级提升，就是吃准了多数人压根没买房经验，不知道怎么算现金流，而且喜欢听逐级提升的故事，成功学也用的很多。但是现实不是这样的。所谓的上车，应该是他当时在上海买套房子，年纪到了就把房子卖掉。上海的房子无论如何也比他老家的房子涨得快，到了一个年龄段，开始走下坡了，就是回老家拿着钱生活的。他40个平方卖掉剩下的钱也有300多万，回湖南到长沙买个大平层都没问题的。剩下50万积蓄日用补充下肯定够的。只是你按照这个流程归化，找到的老婆可能就不一样了。预期和现实偏离，日子就过不好。37 环沪是否有投资价值?环沪是否有投资价值? 请问长三角一体化战略和上海大都市圈规划从长线来看对环沪地区是否真的利好？昆山花桥嘉兴嘉善是否还有增长空间环沪这个概念相比环京其实用的很少。因为上海周边的长三角城市其实都是独立自主的市场。尤其是苏州，你可以拿它的GDP量去和人口3000万的重庆去比较下就知道了。苏州的经济是非常好的，属于自己有很强的产业，闷声发财的地方。无锡嘉兴甚至你可以把高铁一小时到上海的杭州都算进去。这些地方都是有自己独立的产业圈的。不仅不是靠着上海输入，而是和上海本地的相对偏远地区直接竞争，并且有明显优势的。最典型就是苏州和临港，你认为他们的体量差距有多大？你可以自己搜搜数据看看。从长远看这样的地方我认为房地产还是有基础的。我自己也在苏州购房的。而且因为我是湖州人，所以我目前也会看湖州的房子。随着高铁管网的全面贯通，这些地方长期都挺有价值的。但是目前绝对不是一个出手买房的时机。因为短期的政策调控实在太密集而且成交量萎缩的太惨了。全国目前能称得上市场不错的，就上海。上海至少还有成交量。但是成交量也在萎缩。成交量下来，经济又叠加冲击。大家日子都不好过的时候，是肯定维持不住价格的。我们国家所有需要计算的房地产价格在我眼里都是不可信的。因为要维持“预期”。也就是不让大家对房地产市场有太坏的预估。所以一般都是公布均价或者是房地产所谓的指数。这些数据都是不可信的。成交量是最好的数字。然后就是用比较法去搜索比较区域内的成交。给房产做估值。目前是房地产市场非常不好的时候。所以什么都别想，就是空着看。等成交量起来了，再去实地看价格。一定要看成交。接下去各地一手房市场都会受冲击的。这个时候晚点动手。地方政府一定比你先坐不住。哪怕是长三角周边的这些城市，他们也会遇到问题的。最典型就是看土拍。现在没有什么民企买地了。地方政府肯定比你着急。38 请问08年那段时间大家是怎么熬过经济增速放缓、失业等问题的第三方反派 03-01 17:15请问08年那段时间大家是怎么熬过经济增速放缓、失业等问题的? 这两年就业环境太差了，想参考参考过去是怎么渡过的，哪些行业是在度过危机后增长爆发的？哪里有资料可以查吗？这里面最经典的不是08年，而是90年代末的下岗潮。当时最成功的一个政策是扩招。扩招大学，让学生进入学校读书。顺带让他们的家长拿出钱来，拉动投资。读不起就是借债，属于加杠杆。等到进入世贸，就是高增长。大家都愉快。08年所谓的4万亿被大家讲的最多的就是房地产，但是其实相比15年330新政带来的刺激我觉得整体并不是太过明显。15年左右才是真正有所谓的危机。再就是到了现在。方法其实还是差不多，就是扩招，让人读书，解决就业。但是问题是现在房地产真出事了。15年之后开始加杠杆的人很多现在都出了问题，而且加了杠杆后根本走不掉。因为二手房市场卖不掉房子。尤其是在很多欠发达地区的省会城市，受冲击非常严重。地方政府在不断的稳定预期。比较典型的是沈阳昆明这些城市，几乎就是用行政命令在舆论上稳住了房价。当然，现实中二手房市场已经崩掉了，只是我们用“指数”统计，显得房价还很稳。意思就是这些人没有太多的积蓄。开始的时候比如有 30万，他就会拿着30万全力加杠杆借70万入场买房。房子价值100万，他也在还。看着市场上房地产涨起来，他还贷也很开心。但是二手房市场的崩溃会导致他房屋的现实交易价值大幅度的缩水。这个缩水一般都要先打7折起。就等于他之前的积蓄其实已经消失了。要是他工作稳定，这个时候问题是不大的。我们只要在舆论上稳住他，让他觉得他的房子还值钱，只是像指数一样波动了0.1%-0.2%，他心态就没问题。可是他要是断贷了呢？要是一群人集体性的断贷了呢？法院拍卖，7折卖不掉，就是再7折。而且这个时候投资者往往都会选择观望的。等市场稳下来，再入手。像郑州就是这个现象特别严重，之前因为严重的经济问题导致很多人失业。失业背后就是断贷甚至法拍。所以非常需要有新人进入去购房。可是郑州的人口流入多数都是本省经济能力不强的人啊，怎么办？给加杠杆。不断的调高他们的杠杆，希望他们在这一波能够按照原先的房价购房，解决现在的问题。而这样的做法，无非只是继续把问题抛给将来而已。目前是这些人要破产，等着人去接。这次可真的没什么太多办法了。39 普通人求职应该如何选择行业?粉胡椒03号 03-15 21:31普通人求职应该如何选择行业? 我是公司职能部门的，算是个万金油职位，但即便如此也感觉到非常大的生存危机。之前在教培，结果双减了，后来跳到互联网，现在大厂又纷纷裁员，下一步不知道可以往哪跳。很少有哪个行业可以长盛不衰吧，及时应变正确选择真的太重要了。不知道现在去哪个行业比较有发展或者保险，也不知道应该如何做出判断。特来求教，希望斯文可以授我以鱼也授我以渔这些东西就和谈恋爱一样，你搞个理想型没什么意义。因为这种事情永远都是双向选择的。我说我的择偶条件，到最后可能就是只有杨幂一个人符合。我想的再好，再怎么努力，也是没意义的。因为人家不会选我。有个大概方向也是不错的，能帮助自己厘清问题。可是社会的变化一定比你的计划要快。要死今天真的遇到杨幂了，能认识一下肯定也是好的。说不定成了呢？人么，梦想总是要有的。意思其实就是你问什么行业好，想跳到什么行业，我认为意义不大。工作这种东西都是双向选择。我觉得公务员好，因为收入稳定。换我爸可能就觉得没意义，因为体制内限制太多，很容易让人觉得不舒服。你的生活工作状态，只能你自己去调整。就像你想和什么样的过日子，也是要你自己知道。唯一不错的是什么？我认为是搞清楚目前社会上比较新的就业模式。随着年龄增长，自己接受新事物的速度会变慢，这个时候就要逼着自己多去了解点就业上的变化。像你描述里面你之前的工作经验主要都是集中在行政部门，意思就是公司里面需要人干活，你能顶得上。但是你自己缺少一个稳定独有的技术能力，不能保证自己一定有岗位，所以会焦虑。这个年纪了，多去学新技术肯定累。倒不如找找自己喜欢的爱好多去发展下。能靠爱好赚钱是好事，不能赚钱自己起码也轻松点。剩下的，就是要多了解点新业态。假如失业了年纪上去了，公司不要了，不给稳定岗位了怎么办？还有灵活就业啊。里面的规则是怎样的，自己怎样和公司结算。这些东西都是需要学习了解的。多观察观察自己身边同样的人，他们做什么打算，万一失业会怎么办。看看人家的案例，自己心里也肯定会有个底。到了一定年龄再想学习转行去追风口，有的时候就真的是把自己逼得太累了。40 分别以1-3年和3-5年的尺度说一下是否看好咱们国家的经济张志航 03-21 22:42sven老师，分别以1-3年和3-5年的尺度说一下你是否看好咱们国家的经济？我还在买房。我接下去的V+就想用我在今年二月份买的一套房子来做案例，讲件我自己买房思路的一些改变。人嘴上说的可能是假的，但是真金白银的行动肯定是真的。我认为我们国家不可能再有过去那样每年8%的增速了，房地产市场也不可能再出现过去一线城市每年20%的稳定回报率了。所以我自己投资的方式做了很大的转变。比如我最近买的其中一套房子就是太湖边上的别墅，但是不是住宅性质，而是转而做商业运营的。具体案例我这几点V+会仔细介绍。就是我觉得我们国家整体最大的优势是稳定。也就是说在世界因为各种原因动荡的时候，我们国家依旧能整体的维持稳定，并且有很好的社会秩序。这种秩序，加上往正确方向发展的努力，就能带来增长。有增长就有机会。我们国家整体一定是长期向好的。但是我并不觉得我们国家和其他国家比起来会有什么本质的不同。在这场危机当中，我们也会出现很大的贫富分化。这样的分化会直接从房地产市场当中体现出来。意思就是哪怕是同个城市相同区位的房子，也会因为对应人群不同出现很大的房屋价值差距。这也是我自己买房时的一个指导思想。我们不会有什么例外。最近这一年一定会非常困难，政策上我甚至并不认为疫情会是最大的问题。所有的分化问题都会在房地产上爆发出来。不管怎么做数据都没用，越来越多的民众会发现他们根本无法用原先公布的价格把自己手里的房子卖掉。房价指数也没有办法再起到引导舆论的作用。我认为这波浪潮中会有很多普通人在房地产市场吃大亏。因为失业带来断贷，然后不得不低价出房，结果就是遇到房地产市场大量的抛售而导致房价整体根本起不来。断贷会吃掉他们原先的积蓄。“诚实而不幸的破产者”形容的就是这些房地产市场中的普通人。接下去3-5年我希望会是一个盘整向上的过程。所以我会在这个出手买房，而且我的行为已经有点过度激进了。今天和我爸打了一个下午电话，谈了很多东西。真正正确的做法我认为还是等到2023年左右等情况明朗一些在做决策。目前这个时候其实最好的选择是少做事，多留一些现金。等一等，毕竟人是要钱生活的。生活和事业要分开。手里有钱，就是在保证生活的基础上去追求事业。41 为什么最近很少提中等收入陷阱RyanSwim 04-05 23:12为何过去经常探讨的中等收入陷阱，现今很少被提及了？疫情和未富先老的现状，90后中产阶级未来出路在哪里？你可以先想另一个问题。像深圳的教师这些年一直涨薪，现在突然间遇到降薪了。他们的薪水再降低后，还会回到原先的标准吗？这就是一个很典型的中等收入陷阱的问题。这东西其实很简单，就是高速发展到一定程度，增速就下来了。或者干脆停滞不动，甚至有一些倒退。深圳教师十年前的收入是绝对没有现在那么高的。他们的工资水平为什么在这些年有了那么巨大的提高？之前是真正的年薪有30万。为什么？是他们自己工作量变大了吗？就像快递小哥，每天努力跑单，从原先的8小时变到15小时，所以收入变高了？不是的。是整个深圳的财政在随着深圳的高速发展越变越好。深圳政府有钱，所以多给自己人发钱。当然对外讲起来肯定是说更重视教育。没有工作量的提高，还是原先的教育服务，但是教师的收入有了巨大的增长。同时吸引了很多甚至是清华北大的毕业生来深圳当基层教师。这就是高速增长带来的好处。你站在正确的位置，就是水涨船高。现在呢？降薪了。对外不会直接讲原因，核心其实就是财政出问题了。钱少了。所以教师的薪水要减少。这和他们的劳动服务也没有什么关系。平均说至少要减掉6万块。他们什么都没做错，但是财政没钱，他们也受影响。他们会辞职吗？毕竟很多都是清华北大的毕业生啊。不会的。因为整个市场都不好。他们跳出来之后能去哪里？教培行业整个都完蛋了。他们个人很优秀，但是现在社会上真没那么多好的岗位。经济增速下来了，位置就少了。个人是没什么办法的。你遇到的行业下行，哪怕是像深圳教师一样的位置，你也是只能过一天算一天的。你说个人能有什么好的办法？就是接受现实，缩减开支。日子从来不是一定就会越过越好的。42 房地产最终会走向何方，普通人买房吗乐把金针度与人 04-04 18:37斯文，依你看房地产最终会走向何方，普通人买房吗?我的判断就是两极分化。这是一个极端政治不正确的判断。因为我自己是个买家。买房对我来讲不仅是个爱好，更是我最重要的收入来源。我这些赚到的工资和我在房地产上的回报比起来根本不值一提。我是站在一个买家的角度这样去分析的，我也是这样去操作的。我认为疫情会对我国带来一个非常巨大的财富分化。中间层会失去一个稳定上涨的预期，在将来他们的购房行为会像我国90年代末那批下岗潮的人一样，不敢于加高杠杆。因为他们对自己的现金流不会再那样有信心了。甚至是体制内的人都会有所改变。因为这次体制内是真的在降低薪水。哪怕是长三角都这样。同时还有福利住房的普及，也就是我国准备规划大量的公租房。以70平为限，很多区位不那么好的大城市老破小是不会再有从前那样的高增值的。他们会被彻底的甩开。城市间的贫富差距会因此加大，因为普通人最值钱的就是他们的房子。高资产群体对居住的高要求是很难被目前有的住房满足的。所以我觉得这些能够满足他们高要求的房产将来会有更好的前途。所以我目前购房就是盯着这些盘在买。我认为我国外来劳动者进入大城市后逐级置换这条路目前就是断了。要不就是一步到位，要不就是干脆不买，只是租房。经济能力强，父母有钱的，一步到位。经济能力弱势，父母没钱的，对未来收入缺乏信心，所以不会加高杠杆，而是保守的租房。43 杭州法拍房比郑州多,为什么不是杭州问题远大于郑州呢张志航 04-10 11:46杭州法拍房数量全国第一？? 我今天得到的数据是全国法拍房杭州第一，郑州第二，可是sven老师你的微博里头一直提到郑州比较多，难道杭州问题不如郑州大？杭州房子单价要比郑州贵，按理说杭州问题远大于郑州呢二手房市场和法拍是紧密相连的。二手房市场特别好的时候，甚至会出现法拍房的价格比二手房更高的情况。这里面比较典型的是上海。之前因为法拍房不限购，所以就是会出现法拍的房子价格比一般的二手房的评估价更高的情况。后来哪怕法拍房也限购了，只要二手房市场火，法拍房肯定也会火。因为现在规则相对来说透明了很多。那么什么情况下会出问题？一般来说比较常见的方法是你可以先搜索公开的法拍房，然后再搜索同区位的房子的挂牌价直接比较。我刚选了个案例，就是随手点的杭州的案例，房主欠银行钱房子被法拍。2022年3月，房子评估价2万6一个平方，挂牌也是2万6。然后法拍成交价格是1万8。为什么会出现这样的情况？除去一些法拍房本身往往就有租赁合约需要晚一些交付的问题。还是因为二手房市场。 “根据透明网数据，截止到2月28日晚，杭州二手房2月成交量为1981套，是杭州近7年倒数第二名，仅次于2020年3月的467套成交量。当时受疫情影响，二手房网签暂停。” “2月中旬后，杭州各大银行纷纷下调利率，主流银行的房贷利率普遍是首套5.65%、二套5.85%。个别银行首套利率最低可至5.5%，二套最低可至5.6%。个别外资银行给优质客户的利率还可以低至5.1%。相比去年高峰时首套房贷款利率在6%以上来说，房贷利率下降不小。 最近几天，杭州的部分银行开始进一步下调房贷利率，首套利率从5.65%降至5.6%，二套则从5.85%降至5.7%。”房产利率非常重要。房贷利率的减少，其实也是因为购房需求的减少。利率低了，大家还是不愿意去买房。一旦资产丧失了流动性，那么资产价值自然也会缩水。但是我们舆论上要求的写法就是二手房成交量的萎缩并没有影响房屋的价值。房价整体是在温和上涨的。因为多数民众最重要的资产就是他们的房子，他们是亏不起的。比如你最近搜索我们热推的4亿中等收入群体概念，就会发现里面最重要的一个数据就是对中间层来说，他们70%以上的资产都是他们的房子。你说二手房成交量大幅度下降，他们的房子很难折现，资产价值受到影响，他们晚上觉都睡不着的。所以这个时候是比较忌讳用拍卖价格和二手房价格做对比，因为很赤裸直接。但是你一搜，其实遍地都是拍卖的案例。尤其是目前在全面鼓励的始终是低资产者入市加高杠杆买房。对房地产市场的信心目前比黄金都要重要。只是对于那些现金流出现断裂，现在不得不去卖房的普通人来讲，哪怕将来房地产市场回暖，也和他们没有关系了。因为他们撑不到那个时候了。问题，其实都是个人的。你的现金流出问题，遇到房地产市场整个遇冷。你就会遭受很严重的损失。​44 深圳买房问题sunnyli_2022 04-07 13:09深圳买房问题? 斯文，你好！我同意你说的即使是一线城市如深圳，房产市场未来也是两级分化的。但具体到个人，依然有很多困惑，希望能得到一些指点。 我们小家庭的具体情况是，因为工作从二线城市调动到深圳，爱人是人才引进，小孩上学不需要学区房，而且工作单位在深圳远郊，所以上学就近，也不是什么名校，我纠结的是需要就近买房吗？如果买的话，6年或者9年（取决于孩子初中在哪儿读）后肯定要卖，因为就是为了孩子上学才住那里。孩子高中后准备住东莞，因为我单位在临深的东莞塘厦，爱人在深圳龙华观澜。 我自己考虑的点是，买的话，因为不属于深圳核心区域，而且几年后，流动性也不知道怎样，另外所谓的学区，因为不是名校，而且未来人口下行趋势，似乎不具备很好的价值；不买这里的话，其实也有资产配置的需求，虽然不多（500w），而且以投资而不是自住为目的的话，有自知自明并不擅长。还是说那就保守，守住现金，择机买东莞自住？ 希望能被看到，谢谢斯文！500万是很多钱。我们假设你孩子现在长大了，在一所相对普通的大学毕业，那么你觉得他一个月的月薪是多少？按照这个标准，他一辈子能够赚多少钱？你可以搜下《新冠疫情冲击下我国高校应届毕业生就业现状实证研究》看看。500万，是大多数名校大学生一辈子都赚不到的资产。而我们这个年代的人是正好遇到了一个百年难遇的高增长，所以赚钱相对容易。以后这样的日子很可能就是一直没有了。所以我一直建议就是不要把孩子的教育放在最高位置。因为教育的回报率可遇见的，也是越来越低。孩子正常受教育，有钱给他补补课，就够了。他能不能作为人群的前1%进入985，你很难保证。但是把钱留给他，让他未来不要那么辛苦，你是可以保证的。所以买房就是投资，投资的目标就是回报率。但是最近这段时间绝对不要出手去买房。你看我买，是因为我很有经验，而且我不只是买一套。你目前的资本对你来说如果在深圳或者东莞买房，就是那么一套了。这套房子对你非常的重要。而目前整个市场的价格是很难稳定的。因为二手房的交易量太小了。小到完全不正常。如果说国家没有什么实际性的大放水政策，不管是深圳还是东莞，房价都会撑不住。这个时候选时机，一般是看成交。因为你只买一套，往往比较合适的方法就是看成交量下滑后稳定上升再出手。就是说回到一个比较正常的量，房地产市场真正开始恢复正常了再买。这个时候的价格相对是比较明确的。目前的价格是很难说的。我自己最近买的房子我也介绍过，我里面是有很大赌政策的成分在的。没什么人能讲清楚将来会不会再有一次330新政。要是一直不好，那么这些房子拿在手里是很烫手的。唯一正确的，就是这段时间可以先去把楼盘看起来，然后仔仔细细的对比下他们的居住需求。我最近有空再仔细写下我对房屋居住的一些看法，你晚点可以做个参考。目前就是等一等，因为你不太可能买到正好的低点，又是只有一次投资机会。所以一定要谨慎一些。45 如何看待一线城市的老破小marcianfrank 04-06 06:50斯文，请问如何看待一线城市的老破小?这些老房子本来有另外一个称谓叫“上车房”。就是说你把北京上海的房价比做一辆车，这些房子往往价格在之前都是同进同退的。你想在这些大城市长期居住，开始的时候钱不够，那么就买套老破小。面积小单价高，但是会跟着其他房子一起涨。比如你老房子200万，心仪的房子500万。老房子涨到400万了，心仪的房子也就1000万了。你工资增速跟不上，但是你投资回报也是很高的。但是最近两年情况变了。老房子针对的所谓上车客户，也就是经济能力不足的购房者在迅速的变化。他们的收入并没有增长，对现金流的预期也开始萎缩。这是我认为一线城市所谓老破小没有跟着一起涨的原因。注意，上面是我推测的原因。也就是说目前已经出现了老破小房子增速跟不上新房的情况。是已经出现了。我之前举例举北京回龙观就是这样。他们甚至都不能说是“破小”，很多房子还是很大的。你可以算算很简单的，03年是3000块一平，每年增速20%到2018年是4万6左右。现在呢？就是5万上下。也就是说最近两年买这些老房子的买家其实是亏的。只是我们舆论上不告诉他们，税务上也是满五唯一，他们暂时感知不到。其实一线城市房价增速的拉开在北京上海都非常明显。但是深圳广州则不同。因为他们的二手房市场出现了反常的萎缩，现在估价很难。就是说他们的老破小有没有明确拉开，这个暂时说不好。但是北京上海是明确拉开了增速了。房价增速变了，贫富差距其实就是不知不觉在拉开。只是我们舆论上不怎么提而已。46 经济不好的时候，普通人该怎么做乐把金针度与人 05-20 21:14斯文，经济不好的时候，普通人该怎么做?作为一个普通人看见目前的经济情况是应该感到压力，开始变得保守的。我这几天就是在看各地的公务员减薪问题。里面最有名的项目是余杭从清华北大吸纳硕博。当时宣传很好听，说是高学历下基层，其实就是清北这批冷门专业的硕博就业困难，国家帮解决，找到了余杭。余杭区心没那么大，自己基层街道办用几个公职人员都要去清北招聘地球物理的博士。讲穿了就是大家都觉得高学历应该有高收入高地位，我们也需要民众那么相信。可是现实就是哪怕清华北大，你读个冷门专业供大于求，也是没位置的。就是清北地位特殊，国家帮忙解决下就业。现在杭州土拍虽然在全国算不错，但是也出问题啊。杭州吸纳的这些公务员也要减少薪水。但是对外要面子，讲起来就说是正常调整。换到经济差一点的省会城市，那些被吸纳的所谓人才，真是苦。南昌大小也是个省会城市，下面县城里面招聘的高学历人才，一个月该给1000块房补，拖了三年没给。三年。各地郑州还有其他南宁沈阳这些地方简直就无语。我前几天看个体制内的人哭惨，也是真同情。原因他家没钱，是等着政府发房补去买房。借钱利息很高，但是政府的房补拖了他一年多了。所以他很焦虑。这个确实值得同情，但是这钱财政上没有，那就是没有。以前日子过得好，钱多，大家都可以营造出一个和谐气氛。现在钱少了，以前的承诺就成了泡沫。地方政府也被逼着变成渣男。引进人才就像个漂亮女孩，你拿着自己的学历跑去和地方政府结婚，想着好男人会养自己一辈子。真结婚了他手里没钱，马上就变脸说你其实也就那副样子，有本事你去外面重新找一个啊？能找到吗？找不到。心里气。还不敢多声张。被欠了钱都畏畏缩缩，觉得自己连个农民工都不如。毕竟在体制内。可是你想想看，体制内都这样，体制外该怎么样？没被波及，就是运气好。不是能力强，就是运气好。这个时候勒紧点裤腰带，好好多留点现金。真的，等你收入减少的时候你会发现你花钱的地方其实有很多的。47 150万现金该如何科学配置我从来不打喷嚏 05-19 12:25斯文老师，目前阶段，有150万现金该如何科学配置? 我和老婆都是现在居住鄂尔多斯，双公务员，刚结婚没孩子，现在有两套房子，准备卖其中一套不常住的。家人建议卖掉后立马买“未来”要是用的学区房，要不钱就没了，我们不太想买，第一我们这些年也用不着学区。第二我们这边的房子基本没啥设计，房屋的使用率差，同样一百四平，看着就像南方九十平的样子。我觉得花两百万在这里，一平米一万三四买这种房实在不甘心。 我目前计划去珠海斗门买一套房，小区绿化物业设计周边配套领先我们哪里好几个量级，价格也不贵一万二一平，我觉得已经到低了，首付四十万，剩余公积金+商业组合贷。手里剩下一百万存定期，利息加租用来还供。 斯文老师这是我目前的水平能想到的了……您比我聪明，麻烦帮我看看，提提建议。鄂尔多斯这地方特别神奇，它的房地产一直都是个很经典的案例。我这边资料很多。对你有用的简单描述就是这地方15年碰上330新政，通过新区画饼还真的吸引到了一批购买力。但是整个城市房地产有极其严重的问题：“鄂尔多斯房地产现状是，库存量仍较大，但主要是商业用房库存(占库存量的62%)消化慢，2015～2019年1季度末，仅消化存量的38%；住宅库存中大平方米房占比例高，不能迎合中低收入者的刚性购房需求,消化较为困难;大部分旗区住宅库存已经回归至合理的区间；康巴什区、东胜区及伊金霍洛旗房价上涨迅速；房地产不良贷款比率仍处高位，信贷风险需密切关注。”上面这段报告里面有对有错。就是鄂尔多斯存量大，是真的。新增就业和房地产市场不匹配是大问题。意思就是它作为一个资源导向型的城市吸引的就业不高端，民众工资并不高，而它的房子存量又多数是大户型。所以长期起来去化是很难的。这地方的房地产原则上是不应该去碰的。尤其是学区房，出生人口变了，学区就要跟着重新划定。更加不能碰。至于珠海，整体在全国算不错，但是目前这段时间是二手房成交也在大幅度下降。有空可以先去看看，别着急动手。现在全国二手房都在崩。钱拿在手里不用着急。除非国家大规模放水，不然就是安心居家等着就行。多看看，少动手。尤其是只是投资一套的时候，可以再耐心等等。48 年轻人应该怎么应对经济危机?微博问答 06-05 00:11年轻人应该怎么应对经济危机? 斯文，焦虑中：某1.5线城市本地人，21年毕业，无车，无贷款，有商品房一套全款在自己名下，市值350左右但地段一般，板块配套不佳。父母有房，有退休工资，养老完全不用我负担。伪国企财务岗，当前工资不高只够养活自己，每天不知开心为何物。近期没有结婚生子计划。 请问我们年轻人应该怎么应对这一次席卷所有行业的经济寒潮/经济危机 ？ 在什么时间点值得我去贷款置换一套好地段的房产？我能给你的意见就是：“不做事，就不会做错事。”你目前情况就是收入稳定，没有外部压力，在经济下行的过程中就是好好过日子。有爱好，就找点自己喜欢的爱好做做。没有，就去发掘下。像我就是没什么事情喜欢去喂喂鸭子。我现在住在法兰克福我姐家里，那边有个公园，里面很多鸭子，前几天还看见生了一窝小鸭子，怎么看怎么有趣。生活有很多快乐的。当然最后还是回到你核心的房产问题上，我希望你先看看我写的这段：“现在房产新闻里面玩数据的办法讲难听点很幼稚，但是背后也有很多无奈的原因。最近大家在网上看到说所谓最好的房地产市场首推广州，前段时间我V+群里也有很多人讨论，我就拿那些数据分析下，大家一看就明白。给出的数据是这样的：“3月广州全市二手住宅网签较2月增长101.46%。”理由是“受房贷利率下调、贷款审批速度显著加快等利好因素刺激，刚需买家的购房需求陆续释放。”成交量增长了，还翻倍了。政策利好也是真的，利率降低贷款还批得很快，实实在在的大利好。问题在哪里？是它选了一个“环比”，就是找了一个基数很低的月份，来让你觉得数据在迅速增长。如果是去年同比呢？“2021年3月，广州二手房成交是15013套（面积139.84万平方米）；2022年3月，成交8413套（面积82.80万平方米）。”到了2022年四月则是“7274套，同比减少54.6%。”和去年比起来直接腰斩还多，你再配着利率减少，放款加快这些重大利好来看，感觉怎么样？你把数据全列出来，哪怕学过小学数学的人都会得出一个结论就是即使“最好”的房地产市场成交量也在大幅度的缩减。挂牌卖房的人在增加，政策利好不断，但是市场容量在减小。接着我们就要到最关键的核心问题了：房地产市场是“同涨同跌”吗？我们过去讨论房地产市场，给大家的感觉就是一个城市的房产市场是一个整体。老破小，学区房，大户型都是一个整体，他们在同涨同跌。大家是一起变富一起变穷。因为一个城市的本地人住房自有率往往都很高，多数人的房子是属于中低端的。可是现在看数据是这样吗？当然不是啊。最麻烦的是什么？是像这些城市的高端楼盘，总价一般是用千万去计算的，占比在增长，价格也在涨。意思就是这些豪宅盘成交量也减少了，但是整体减少的很少，价格还涨了。具体他们分析的数据是：“今年前4月广州总价1000万以上豪宅共计网签成交775套，与去年同期相比下降14%，但市占率上升至3.4%，同比去年上升1.2%。在价格上，广州千万级别的豪宅成交均价创近5年的新高，达7.2万元/平，同比上涨4.3%。”谁在吃亏啊？这是我们舆论中经常回避的一个问题。就是不同的房产对应不同的购买人群。总价千万以上的房产和一般的打工人是没关系的。而一般外来人口是在对自己未来收入有信心且稳定的情况下，才会背上二十年甚至三十年的贷款买房的。他们没有一个所谓的刚性需求，说到了一线城市打工就要在一线城市买房。而是要他们有钱，并且对自己的收入有信心，才会贷款买房。房子和房子不一样，人和人也不一样，大家遇到的情况更加不一样。一线城市还算不错了，你去抽样看看那些经济欠发达的省会城市，结果是非常惊人的。至于这个趋势会不会持续下去，我当然不知道，也没什么人希望这个趋势持续下去。因为房地产对我们普通人的资产实在是太重要了。越是普通人，家里最值钱的就是他的那套房子。”站在我的角度我可以很明确的告诉你，目前关于房产的新闻就是在瞎搞。看看数据你说房地产市场处在下行周期是绝对没问题的。目前连底在哪里都不知道。两极分化的非常厉害。国内没什么1.5线的说法。就是北京上海整体还趋稳。说广州好，你仔细看看数据心里就知道了。房地产这个东西对于普通人来讲是没有什么回头路的。你现在卖掉老房子，就那么点收入，背上贷款去买套房子，你觉得自己能够抄到底吗？房子看看可以，你也可以试着按照自己心里的价位把房子挂出去试试看。挂出去看看价格是没错的。多看看房子也没问题。就是加杠杆一定要特别谨慎。目前这个行情，就是观望下。就买一套房，肯定要等稳定。49 给普通家庭准大学生一些建议wonetao 06-23 23:57斯文你好，以你的生活阅历，给普通家庭准大学生一些建议吧。 对于普通家庭的孩子来说，读大学本应是一种投资，但很多人却稀里糊涂地将其变成了一种消费。无论是报志愿，还是怎么度过大学，希望你能给出些建议。虽然他们不一定愿意听，但万一有人听了呢。我听过高考最深刻的一段话是位老先生讲的。他说80年代宣传高考是农村孩子改变命运的“唯一”路径，不仅是为了那2%考上的学生“改命”，更是为了让剩下98%没考上的孩子“认命”。这样宣传，其实是为了让跟多数人能够接受自己的命运。你没考上，那就认命。在80年代城乡差距很大。农民的孩子生下来就是拿农村户口，想进城比登天都难。他们的日子是真的很苦。工人生活在城市要有保障的多，而且那个时候还有顶班。也就是子女可以接替父母的工作进入工厂。福利待遇差距极大，城乡剪刀差巨大。农民有很强烈的诉求去改变这样的现状。但是城市中真的没有那么多位置给农民。到2000年时北京还在搞暂住证制度，去昌平挖沙子从来不是笑话。所以那个时候宣传高考是改变命运的唯一路径就很明白了。你考上了，你可以脱离农民的身份，离开农村进入大学，毕业了包分配成为一个“干部”。你考不上呢？就继续认命当农民。科举也是一样的。考上秀才，举人甚至进士的人是少数。多数人就是考不上认命继续当富农小地主。你是多数，还是少数？过去我国经济发展很快，数亿农民进入了城市，成为了城里人。不是靠高考，是靠飞速的经济发展。可是现在我们的增速下来了。也就是说能够提供给普通人改变命运的机会在越来越少。现在的毕业生会发现赚钱比之前的人要难很多。你的命运是什么？你认命不认命？认命，就按部就班的好好过日子。读书是为了将来找份工作，有多少钱，过多少日子。50 怎么看国内的形势，给职场打工人有什么好建议mengdib的秘密花园 07-17 20:40最近经济统计数据出来了，你怎么看国内的形势，给职场打工人有什么好建议?今天出了张很有趣的数据统计图。大家可能都没找到这张图的来源。很多人就质疑这图不存在，是有人自己做的。其实这图真是官网上的。官网上这图的标题配上就异常有趣了。你仔细看看图就知道是真没办法了。基本上就没什么数据是正面的。大家日子是真的都不好过。我问你一个问题：你信不信精英都在体制内，他们肯定有办法？我给你我的建议就是他们没办法。你看全国各地的烂尾楼就知道，是真的没办法。但凡想出办法，都不会让这些楼去烂尾。我今天和人讨论烂尾楼的事情，请了一位领导。讲案例的时候发现这位博士是真的什么都不懂。领导要面子，不能讲。但是现实中我们心里都明白，他一辈子都是学校到机关，其实就没有真正去了解过这些房企的运营，所以碰到这种烂尾楼的问题就是真的不知道怎么办。基层上，讲直白点就是一出问题就瘫痪。以前的问题都是发展掩盖住的。发展的太快，大家不觉得基层不会办事。这话可能你听着傲慢，但是很实在的。但凡这里面真有几个人脑子清楚，都不至于要交那么多“学费”。结果好，一切都好。结果不好，就是一切都不好。你都已经看到结果了。这个时候他们能想出来的，就是项目要死，就要钱。所以你很容易就能理解为什么恒大在某些省会城市的盘，已经停工过了，恒大也是真没钱了，依旧要开盘，还要放出消息说要“保交楼”。原因很简单，如果不让开盘，就没新钱进去，立刻就会出问题。开盘了，说要保交楼，再打个折，以为捡到便宜的民众就会拿着钱去冲。钱来了，楼盘建造要几年，这笔钱进来，问题就能到未来才出。这里面没什么深谋远虑的，就是往下甩，连个愿意出来止血的人都没有。硕士还在扩招也是一个道理。多少年轻人想着的是本科学历不够，要读硕士，而不知道是他们这个专业有问题，本来就没足够工作岗位？不去引导学生正确认识社会。就是不断的扩招。让他们去学校里读书。“将来经济好了就好了。”要是不好呢？站在个人角度就是稳妥一点，手里钱守牢一点。经济真的好转了，是有信号的。普通人，找份工，好好做。这个时候就是最好的选择了。体制内也都是把问题拖着给未来，你也不用想太多的。遇到下行期，就是那么回事。好好守好自己的工作和钱就行。51 对深圳安居房和公租房的看法。osprey_ 2019-07-24 11:54斯文老师您好，想听您谈谈对深圳安居房和公租房的看法。 如果只能拿出100W左右的首付款，家庭年收入只有25W左右，三十出头的中年家庭应该咬牙买商品房（只能买到位置比较偏的小房子）还是排队等深圳安居房和公租房？安居房排名2年了一直没有什么变化，继续等感觉遥遥无期，又怕商品房再涨一轮，这样就永远买不起了。深圳是一个表面上住房自有率不高，但是大多数本地人都有自己房产的地方。所以给外来人口的房子矛盾就非常的剧烈。对小产权房我就一个很简单的态度，不买。因为小产权就是和政府争夺利益，小产权房一旦转正，对房地产市场和地价都很容易造成严重的冲击。我自己9月份正好要去深圳看房子，最近也在帮人看深圳的小产权，里面的村委房、军产房、大红本房、集资房、农民房、拆迁房、福利房等等各类都是小产权，处理起来方法都不一样，唯一共同点就是都不适合买卖。商品房的价格又非常高，深圳同时还对外相对的放松了户口，所以这些户籍人群怎么办？将来定位就是让他们有房子住。那住什么房子？就是你上面说的安居房和廉租房，这些房产的核心非常简单，就是优先无房户籍人口。简单来说就是你作为外来人口到了深圳，如果想长期居留，又估计自己买不起房，那千万别动小产权的念头，先租房想着拿户口，拿到户口之后就是去申请廉租房和安居房，之后再想办法回老家或者周边买套商品房。别多想，小产权别碰。就算排不到，也别去买。至于孩子读书，千万记得深圳也是一线，已经在教育分流了。想孩子读大学的，可以想办法去外地借读。深圳本地的高考质量真不怎么样。这点你看看广东这次高考移民的事情就可以了。外地来的孩子跟着父母拿着学籍户籍来广东高考，就是压本地的高中一头。主要是因为深圳本地的应试训练太少，所以考不过人家。简单说就是户口和户籍留在本地，孩子出去读。广东好学校很多，读书千万别看211，广东本地的普通高校远比一般的西部211甚至985要强得多，比如深圳大学就是个例子。这个规划原则上没什么问题，普通人家按这个路子走就好了，其他真没必要去拼深圳的学区。出不起国要走高考路线的，特别注意下深圳也是广州本地的教育问题，这个地方长期的教育模式和考试脱节。你要读好学校，挂个学籍出去高考严格的地方再回来，花钱更少，孩子成绩还容易更好。52 公租房未来有没有可能让承租人获得产权，并上市销售四十克的爱情 2019-12-14 06:39斯文，公租房未来有没有可能让承租人获得产权，并上市销售? 我司是北京的一所大学，新入职员工都在排队等摇号公租房，但是实话说，很多老教师有公租房，他们也不住，还不退出来。宁可每月交一千多租金，占着2室的大房子。还有以前的校产房，让老师白住的，但不能销售。很多老师拿着校产房的名额，自己也买房了，照样不退出来。要知道，在海淀区2室的校产房能租一万多，这就成为大龄老师的隐形福利。新老师、年轻校工苦死了，但没办法。关于公租房甚至共有产权住房各地的规则都不一样，所以很多人看这些住房政策经常摸不着头脑。但是只要掌握一些简单的分类方法，比如从产权持有的角度去看问题，马上就能这东西梳理清楚。我们日常说的商品房就是完全个人产权的，根据产权的逐步减少，我们有限制产权的经济适用房，还有和政府共有产权的共有产权房，和你上面说的完全政府产权的公租房。接着你再问自己一个问题：政府的产权属于什么？国有资产。政府怎么处理国有资产？谨慎是第一原则，接下去也是预期要亏了就卖，要赚钱增值就留着。接着我再告诉你北京就2300万的人口上限，一共就只有够2300万人住的房子。你认为北京的房产价值怎么样？长期稀缺，能买到就很不容易了。那按照这个道理北京市政府是不是该长期持有北京的房产来控制人口呢？不是的。他可以把国有资产利益最大化。这个最大化的办法就是共有产权。不管是政府持有一套房50%卖50%给你，还是政府持有1%卖99%给你，本质背后都是它有“一票否决权”。它可以否决你的自由交易，让你的共有产权房限制在特定人群当中交易。这个特定人群就是你们这批人。你们有北京户口，一定在这2300万人当中。你们手里又没有很多钱。比如北京你就算4万一个平方，50平的房子也要200万，是普通人一辈子不吃不喝的收入。你们有北京户口，绝对不会在北京因为没房子住流落街头，所以它要给你们公租房。但是共有产权就可以把你们这批人的钱给套出来。政府比如给你们一套房50%的产权，卖给你了，它拿走100万，变成它的收益。但是它还是可以控制住房屋产权，保证它在你们这批人当中流转。等于说它把公租房做了个二次开发，白赚了一笔。这就是共有产权的秘密。所有共有产权放弃购买的人很多。有房子住才是刚需，不尴不尬的拿50%的房屋产权其实就是给政府送钱。真聪明的人怎么做？你拿到北京户口，一定不会在北京流离失所，所以干脆点就是住公租，哪天公租房要给你共有产权你也不要。像我们认识的一个体制内的记者，他非常干脆，反正北京户口在手，就是在北京住廉租。他买房之前和我一个朋友一起看的，在杭州一个地方叫青山湖，他是6800一个平方买的，90平。你看看那边现在房价。像你们这样的人，就是排队在北京等分配。安安心心自己出去投资。去长三角珠三角，买房，出租，等升值。千万别把手里的钱送给共有产权。因为这种房子从头到尾只会在没钱的人手里流转。它就是个公租房的二次开发。53 公租房与商品房的选择?人行横道6 2020-04-30 23:27公租房与商品房的选择? 斯文老师您好： 基本情况：本人男24，大专毕业一年，工作于当地二甲医院，月薪3k，云南省曲靖市农村户口，家里有一个弟弟，最近我们这边可以购买公租房，12万一套，75平米，两室一厅，一厨一卫，已装修好的。ps：当地房租500元一个月左右，房价15年之前3000左右，现在6000左右 我有点购买的欲望，但是老家也准备盖新房子，家里还在住只有一层楼的老砖房，如果家里给我买的话，可能就会影响到老家盖的房子，那样我会很愧疚。虽然父母说让我不要担心这些钱，我还是觉得这样很不合适，现在依然拿不定注意。 对于我来说，假设正好有这12万，用这12万用来买房做首付还是买公租房比较合适，该如何选择，想听听斯文老师的建议，感谢您回复，祝生活愉快！你有没有想过为什么公租房会那么便宜？75平的商品房要45万，为什么公租房12万就能买下来？因为公租房是限制交易的。你花12万买下的公租房产权，并不是像商品房一样将来可以升值卖掉的。你只能卖给政府规定的指定对象。买房是个投资行为，当初花3000块每平米买房的人，现在6000块房价，自然是赚到的。可是买公租房的人不是啊。他只能以指定的价格把公租房卖给特定群体。所以公租房没有投资价值，一个月500块租金不贵，安安心心租房。而且又在云南这些地方坦白讲整体因为棚改项目逐渐结束，房地产市场后续因为没有什么新人进来所以也会非常的乏力。这个时间点云南这边真的没必要去三四线投资房地产。公租房你每个月交房租绝对不会有人赶你出去。有些话你不方便对你父母说，就把我写的直接给他们看。你的父母很爱你，觉得对你有责任，所以想替你购置一套房产，完成自己对你的任务。但是现实当中购买公租房绝对不是好的选择，只是在给政府送钱而已。父母辛苦一辈子，提升下居住需求没有什么太大的问题。在老家好好修套房子，父母有家孩子就有家，父母的家孩子永远可以回去。所以先让他们好好对自己。你自己目前的收入可以先存钱存起来，要买也只去买商品房，将来有合适的对象一起商量着过将来的生活。该不该卖掉省会的房子?您好，我和我老公两地分居，我在县城，他在省会石家庄，县城的房子是全款，省会的房子是贷款，买在了高点，一万七一平，每月还款9000左右，还款22年，该不该卖掉省会的房子租房住呢？站在我的角度我会认赔。但是这对你来讲我觉得会很难。就是目前还处于舆论上能空置的阶段。意思就是宣传上会尽可能告诉你二手房的成交量在“环比”提高或者复苏。然后再用各种各样的指数告诉你房价没跌。现实中这就是个舆论游戏，我会认为目前这个阶段是逃离的好时机，因为市场上还有信息差。你只要去找找石家庄去年同比的二手房销售数据，就能知道问题所在。这个时候有信息差，就是趁早折价卖掉。投资的房子，亏了就是亏了。上去先挂九折，一个月卖不掉就再八折。就那么简单，卖掉拉倒，起码现金流能宽松很多，后续有的是提振政策。但是这对你来讲很痛苦。我们国家多数人都没做好在房地产上亏钱的准备。今天我还拉黑了个网友，主要就是怕麻烦。湖南石门县里的县长鼓励大家买房，我转发了下说那边30万的房子遍地。马上就有个网友估计是顺着搜索转来的，直接贴了一堆图，选的都是大户型，比如150多平的房子要价60万，还说那边房价确实不高，但是绝对不便宜。这类人特别让人害怕。其实我讲房地产是很客气的。那边现在房子报价3000-4000一平，一般我们讲的房子就是70-90平，这类房子成交也最多。算算看就知道普通房子根本到不了30万。挂牌卖不掉，都是虚的，其实早就崩掉了。根本没有量啊。但是当地人是接受不了这个现实的。成交量下去，房子就不值钱，打个七折能卖掉都不错了。石家庄情况好一些，但是对比下成交量就知道根本稳不住。趁着目前媒体上还能骗骗，早点跑路早点好。怎么选择职业?斯文您好，我在一家美资外企做财务分析，工作时间是4年左右。公司内部有个区域的分析岗位是更好的，负责招聘的财务经理很喜欢我，想让我过去她下面。但是她跟财务总监说了三次，都被拒绝了，理由都是我学校背景不够(本人是普通一本大学，领导都是名校北大复旦之类的)。现在外面有个机会是大宗商品的期货分析员，不知道是否应该去？如果去了那么财务分析的职业算是结束了。我对大宗商品研究员这个行业不太了解，据我朋友说，做的很好的，可以达到年薪百万，普通的也挺好的，比较清闲。​你先读一遍：“你从学校走进社会之后，很可能就听不到什么实话了。这两天高考，有个编辑问大家怎么看“学历门槛”的事情。我自己对这件事情还真的挺有感触的。我以前在我老师事务所实习的时候和他一起招过人。我根据他的要求扮演小企业主去向面试的人咨询一些成立公司的事务，基本上几个问题一下来，就知道这人能力怎么样，以后有没有前途值得培养了。面试完把人送走，他也会和我点评一下上一个面试者哪里不好，要我以后注意。这里面有件事给我印象很深，一个来面试的加了我的QQ，他被拒了之后就再QQ上问我是什么原因。我就和他实话实说，他在回答我问题的时候语调不自觉的就会高起来，把一个咨询搞得像辩论一样。做律师毕竟是个服务行业，怎么说话很重要。然后我就遇到了很多的麻烦，他不断的向我辩解说他当时只是有点紧张，平常说话不那样，还给我提了很多要求，希望以后能再见一次我老师，想再有个机会。他后来还去找了推荐他来面试的朋友，想再试试看。一个诚实的回答，就是能搞出那么多的麻烦。我老师的助理一句话就把问题解决了。她先夸赞了一下他的表现，说他非常有风度，气势上就让人信赖。把他的缺点说成他的优点之后马上一个转折，和他讲他要是中南或者西南政法毕业的就好了，学历上差了那么一点点，我们这边还是有很严格的学历要求的，所以真的非常抱歉。问题就解决了。我后来和我老师聊起这件事的时候他给我讲了一个非常有趣的例子。一女孩子现在有个男朋友小明，双方没什么矛盾，日子也很顺利。突然间有个叫小李的开始追求她。她觉得小李更好想和小李过，她怎么和小明分手呢？直接说她要和小李一起所以希望小明这个障碍离开？真那么做的女孩子就蠢了。很多男女间的凶案都是因为类似的原因。所以女孩子最好的拒绝办法是要从这个男孩子“不可变”的地方着手提理由分手。比如“我妈逼我说以后要结婚一定要有房子，我们交往这么久了你都没提过。我觉得我们这方面没有未来，所以只能分手了。”我当时没抓到这里的核心，就和我老师抬杠，说这男的要是去买了套房子呢？或者说这男的条件好的无可挑剔呢？这女孩子一样可以说：“我和你在一起让自己很自卑，觉得我和你不是一个世界的人。”再分手去和小李一起啊。这就和他招人一样，他就是给工资花钱招人来干活，如果他真的是根据学历去招人，那么他最有效率的办法就是把这些人的学历从高到低排列，依次面试，确定了之后后面学历低的他就看都不用看了。这样效率最高。但是他在拒绝人的时候为什么要用学历这个理由呢？因为这个东西不可变。这个人学历低，他可以说我们这有学历要求，你这就是差了一点点。学历高，他就可以说我们这边平台相对比较低，你能力太强，应该找一个更高的舞台。核心是什么？就是一句话就把问题解决。如果这个人我都确定不要了，我何必要和他多废话呢？选一个他不能改变的条件，一句话把他拒绝，彼此都要轻松得多。大家心里未必都有这样的系统的思维方式，可是现实中大家都会顺着经验那么干。就像我犯过一次错误之后，就算我老师不和我直接说，以后我也会像他助理那么做事。我讲这件事情不是说学历不重要，现实当然是好学校更好。而是你走到现实生活当中，学历只是你求职的一个部分，雇主付钱给你，就是要你给他赚钱的，你的学历只是你赚钱能力的一个组成部分。有很多其他关键的，你应该去学去做的事情，你遇到的人就算知道也不会告诉你，因为他们不愿意浪费时间在你的身上。很多很多东西只能靠你自己在生活和工作当中去体会提高。以后的路还很长，不是只有#高考加油#就够了的。”接着你告诉我，你觉得你在公司里面无法获得理想的职位，真是因为你本科学校不够好吗？只是因为这是你不能改变的东西。你领导不想提拔你，哪怕你清华毕业的，也能给你选出一堆理由：资历不够，学习内容不相符，缺少实际经验。你都做了那么多年了，财务经理，也就是用你的人都觉得你可以，你领导都不让你去，真是因为本科毕业院校吗？你们真有说某个岗位必须要某某大学毕业之类的要求吗？你细细想想。领导毕竟是领导，想转岗，他不同意，好好请他吃个饭，送点东西，求他通融，给个机会。他不愿意，就是死卡着不让你晋升，你再想想下一步。新生儿数量暴跌会如何影响教育行业? 今年新生儿登记数量比教资报名人数还低，未来学校会不会批量关闭，中小幼教师会不会大量下岗呢？这些问题背后都是大众的执念。就是过去十多年的经济增长，让他们误以为工资就是会随着经验的增加而提高。比如特岗教师，开始的时候一个月3000块，将来有个编制稳定，自己教学能力和经验积累了，钱会越来越多。其实不是这样的。这里面是整体预测错误。之前根据我国顶尖人口学会专业预测，2015年放开二胎后会有出生的大高峰，要持续8年，所以要多招聘很多老师来应对。比如特岗教师就是每年8万，高峰时候到10万人，都是去中西部地区。现实是这些地方生育率萎缩很厉害。新生儿跌掉一半都是少的。所以很多学校要合并。合并之后就用不到那么多老师了。但是这批老师之前又是承诺他们服务三年，是应该有相应编制的。这个处理起来就很难了。所以接下去的解决方案是一些靠财政转移的地方要开始减少甚至冻结编制招聘，这批特岗教师可能会获得一个基层服务人员的转型机会。就是说饭碗尽可能保住。但是他们积累的所谓教学经验也没什么用了。整体市场萎缩，需要的老师肯定要大幅度减少。教培行业毕竟都没了。至于其他城市中有编制的老师，随着地方政府的收入缩减，可预计的就是他们的收入要大幅度的缩减。这和大众的预期不符合。大家都觉得自己经验积累的越多，教学能力越强，级别越高，收入就会越高。而现实是政府付钱，政府没钱，那就扣工资。卖掉上海市普陀区面积50平米的老破小，去置换松江大学城100平的新房，您觉得合适么？我刚看私信的时候仔细看了下你发的资料，强烈建议你不要用这些房价涨跌幅的数据来判断。因为单个的案例很容易误导你。你目前要做的其实是两件事，第一件是卖市内的老房子。这个行为站在我的角度是目前情况不明确。数据很明显是上海的中低端房产和全国其他地方一样在缩量。站在我的角度我认为上海会和其他城市一样出现两极分化，中低端的房产会跌价。所以看到这样的信号我会毫不犹豫的把房子卖掉。事实上类似这样的房子我以前就有过套70平的，持有到19年就卖掉了。我长期认为上海的楼市会两极分化。但我不建议你去卖。因为你手里就一套房，卖房的目的是为了置换。这也是你要做的第二件事，买松江的房子。我认为上海的规划策略是失败的。上海并没有像预想的那样实现各个区域协同发展。长期来看松江很难有好的涨幅，甚至我会把松江对标嘉兴。如果我站在你的位置上，只有一套房，在目前的情况下就是什么都别做。等市场放量。看成交量提高上去了，再做对比。千万别用那些某个小区的一套两套房子的短期成交来看房子的走势。先看成交量，再看价格。量起来了，市场就相对明确了。为什么靠地铁（交通）选房不行了?为什么靠地铁（交通）选房不行了? 记得之前文章里面提到过你很早就不靠交通来选房了（至少权重下降很多），能再直白点说下理由吗？我在现实中，看到确实很多人就是根据这个来看房的。如果很多人都有这个共识，那不就是一个事实了吗？根据地铁选房其实就是一种买规划。简单说就是地铁修到哪里，就把商圈带到哪里。地铁的规划不是独立的。比如说开始建造地铁的站往往都是连接核心区和交通点。本来地段就重要，通了地铁交通更加方便，自然而然房价就涨。那么其他地方呢？是地铁不是独立的，而是带去规划。地铁修到一个普通地方往往不可能就是顺路带过，而是会带来一系列的规划。这些规划或许是商业区，或许是居住区，更或许是功能性的比如大学或者医院甚至动物园。地铁引导了系列的规划和人流，这个地方的区位改善了，房价怎么可能不涨呢？那现在或者说大概是2019年左右我好像就在文章里面讲我放弃原先跟着地铁买房的思路。更或者说大概15年左右，330新政出来了我就不那么干了。原因有两个，一个是地铁概念带来的想象空间太大，大家都那么跟风，房价预先涨太多，后续其实空间不大。第二个，就是我认为地方政府的规划能力在很明显的下降。这也是我当时听的一个蛮重要的关于规划的讲座。里面是位退休的学术型的官员。他对棚改批评很多。就是一个共识是棚改拉动甚至说拯救的房地产，但是也带来了巨大的风险。也就是说如果后续没有经济的高增长了，地方政府却背上GDP增长和土地财政的巨大压力，它哪怕没办法也要规划新区。这里面他当时就狂批成都。觉得成都在瞎搞。就是不断的炒作概念，市政府搬迁之类的。说这边要规划个区，那边又要拓展。其实经济增速要下滑是个不可逆的现实。但是地方政府要卖地，要赚钱，就要不断的讲故事。一套房拿到手到卖出差不多5年时间。5年一过，是不是真好，还不穿帮吗？当然，我认为他胆子要是在大点，批判的就是滨海新区了。我听完讲座和他吃了个饭。我们两个当时讨论未来科技城。你可以找到我之前对未来科技城在V+里的评价。我认为那会是个坑。他也那么觉得。我是知道有太多人在那里坐庄，所以认为很难有投资价值。他是直接认为杭州市政府都没能力规划好。##北京购房问题斯文你好，感谢你长期以来的分享解惑。我在大连工作，在大连有套房子，媳妇儿目前在北京工作，近期考虑想在北京南四环买个总价300来万的小房子（五十平），大连的房子还留着。希望你从投资角度给点建议，谢谢！我会很真诚的建议你最近这两年别去碰北京的老破小。但是我的理由不是目前的“现象”，也就是因为购买力出现问题，所以北京的中低端房产在和高端房产拉开，所以就会有预测北京的中低端房产出问题。而是另一个理由，北京的房产整体规划出了问题。尤其是共有产权。我建议你特别注意，北京一般的公租房的大小上限是70平米。北京将来会有多少类似的房产出炉？接着我建议你仔细搜索下北京共有产权住房的政策变化。然后你会发现政策推出不过几年，反反复复就有了多种方案。原因很简单，就是最初的方案导致房子卖不动。而北京目前卖地的情况也并不好，所以后期小于70平的户型，尤其是福利房，政策不稳定的情况肯定会很多。你现在要“投资”一套50平的房子，未来可能就会有很多相应的竞品出现。目前政策还不明确，你手里钱我估计也不是很多。这个时候你做这样的投资是不是应该求稳一些？等这几年过去了，看看国家怎么调整对应的廉租公租房政策，再动手。政策不明确的时候买这些房子，就是赌博。所以稳一点比较好。你太太心态很可能是希望在北京有套房，自己有房感觉毕竟不一样。可是目前这个时候政策都不清楚，你就这样贸然入场我觉得风险太高。对于那种房地产不崩才怪的地方，未来未购买的还能购买吗或者说是什么时候购买才是最佳选择?我给你一个很简单而且我觉得最好用的办法：看二手房成交量。因为这个数据政府最难操控。包括备案甚至成交价，政府都能操作，市场不好甚至好的时候政府操作价格放消息的案例我给过很多。尤其是国企和地方政府一起操弄消息会让人很容易跌到坑里。你把过去五年的二手房成交量按月做个折线图。这个时候你会发现全国的二手房交易量都在迅速的萎缩。接着你等。等到二手房交易量回升到之前的均值上下。等个半年，稳一稳，就可以考虑动手买了。这个时候市场是比较稳定的。不要想着买到最低点。买房自持买到稳定点就可以了。我自己买房的时候经常和朋友一起。我有个朋友做数据很厉害。他做的是一个预测的供应量模型，是把新房供应量和二手房的量放在一起看的。意思就是新房供应量要是特别大，二手房市场稳定，其实也可能导致下跌，所以这个时候就不出手。他是要抓二手房火热，新房供应量低，这个时候之前出手。坦白讲我也看不太懂他做的数据模型，就是觉得这个真心挺厉害的。一般我自己买房就是看看二手房成交量。比如现在深圳罗湖中低端的新盘备案价开八折，我就不建议我朋友买，因为二手房成交量萎缩太厉害，挂牌量又大。这个时候价格很难稳住。而且新盘开始跌价卖求生的时候，整个市场都会被带下来。" } ]
