---
layout: post
title: 1.位运算算法是什么简单排序
date: 2022-07-26 22:56 +0800
categories: 算法 左神 
tags: 左神 算法 新手班
---

# 位运算 什么是算法 简单排序
<br/>
## 位运算

### int类型底层是多少位二进制组成?
32位,共四字节

<br/>

### 如何打印一个数的32位?
```java
public static void print(int num) {
	for (int i = 31; i >= 0; i--) {
		System.out.print((num & (1 << i)) == 0 ? "0" : "1");
	}
	System.out.println();
}
```
第一步

1 << 31 ,1左移31位
从0...1得到10....0,左移后空位用0补齐
这串数字和num表示的数字进行**与运算**
01为0,11为1,只需判断结果是否为0

|想要对比第31位的数字|
| ----|
|0000000000000000000000000000011|  
|1000000000000000000000000000000|
|0000000000000000000000000000000|

假设判断第2位的结果是不是1,只需

1 << 1 ,通过与运算可以得到一个非0的值

| 想要对比第2位的数字  |
| ----|
|0000000000000000000000000000011 | 
|0000000000000000000000000000010 |
|0000000000000000000000000000010 |

因此原数第二位是1

### 左移和右移哪个带符号,哪个不带符号?
左移不带符号,右移带符号

### 32位数字能表示的范围?
$0 \sim 2^{32}-1$

∵ 32位最多能表示32位1

∴ 1111111111111111111111111111111表示的大小为$2^{31}+2^{30}+\dots+2^{1}+2^{0}$

∵等比数列求和公式为

$S_n=a_1×\frac{1-q^n}{1-q}=\frac{a_1-a_n×q}{1-q}(q \ne 1)$

∴ 代入可得 $S_n=1 × \frac{1-2^{32}}{1 - 2}=2^{32} - 1$

### 为什么Java整形最大值为21亿,而不是42亿?
因为整形最高位用作符号位

表示的范围为$-2^{31} \sim 2^{31} - 1$

### 为什么表示范围右侧里会-1,左侧不减一?

首先看无符号数

无符号能表示$ 0 \sim 2^{32}-1$算上0共$ 2^{32}$个数

有符号的范围$-2^{31} \sim 2^{31} - 1$总共同样是$2^{32}$个数

正常情况下,分成一半就是各有$2^{31}$

但是有个特殊情况就是0,正数里0占一个,对于负数来说有个-0的情况况,表示负数的最大值

0归属到非负区

表示范围$-0 = -2^{31} \sim -1$共 $2^{31}$个数

### 如何计算负数的二进制表示?
符号位是1
后面的状态为取反+1

### 如何理解负数的二进制表示?
-1的表示

11111111111111111111111111111111

Integer.MIN_VALUE的二进制表示

10000000000000000000000000000000

其二进制值为取反为

11111111111111111111111111111111

加1

10000000000000000000000000000000

此时值为$2^{31}$


### 为什么负数的运算要取反+1?

因为所有的数字在计算机里都是二进制

二进制的计算是通过位运算

想用一套运算来处理加减乘除

通过定义负数的表现形式,可以让不管正负,都通过加法器得到结果

越底层的内容越要简单,如果复杂,系统实现成本高

1 + 2 和 1 -2

### >>表示的是?
右移,最高位用符号位补齐

### 如何获取一个数的相反数?
1. 前面加个减号

2. 某个数取反码 + 1

### 补码解决了什么问题?
1. 数字0在计算机中非唯一编码

2. 实现了减法变加法

### 负数在计算机中的存储是?
绝对值的补码形式,即符号位不变,其余部分取反+1

### 计算机中最小值取反+1,为什么还是最小值
最小值的表示形式是

10000...0000

取反结果为

01111...1111

此时+1 

10000...0000

所以还是原来的数




## 什么是算法

## 简单排序


