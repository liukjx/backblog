---
layout: post
title: "《Java8实战》读书笔记"
date: 2022-08-31 19:13 +0800
tags: 读书笔记 Java
---

## 第一部分 基础知识
### 第1章　为什么要关心Java 8　　
#### 1.1　Java怎么还在变　　
##### 1.1.1　Java在编程语言生态系统中的位置　　
##### 1.1.2　流处理　　
##### 1.1.3　用行为参数化把代码传递给方法　　
##### 1.1.4　并行与共享的可变数据　　
##### 1.1.5　Java需要演变　　
#### 1.2　Java中的函数　　
##### 1.2.1　方法和Lambda作为一等公民　　
##### 1.2.2　传递代码：一个例子　　
##### 1.2.3　从传递方法到Lambda　　
#### 1.3　流　　
#### 1.4　默认方法　　
#### 1.5　来自函数式编程的其他好思想　　
#### 1.6　小结　　
### 第2章　通过行为参数化传递代码　　
#### 2.1　应对不断变化的需求　　
##### 2.1.1　初试牛刀：筛选绿苹果　　
##### 2.1.2　再展身手：把颜色作为参数　　
##### 2.1.3　第三次尝试：对你能想到的每个属性做筛选　　
#### 2.2　行为参数化　　
#### 2.3　对付啰嗦　　
##### 2.3.1　匿名类　　
##### 2.3.2　第五次尝试：使用匿名类　　
##### 2.3.3　第六次尝试：使用Lambda表达式　　
##### 2.3.4　第七次尝试：将List类型抽象化　　
#### 2.4　真实的例子　　
##### 2.4.1　用Comparator来排序　　
##### 2.4.2　用Runnable执行代码块　　
##### 2.4.3　GUI事件处理　　
#### 2.5　小结　　
### 第3章　Lambda表达式　　
#### 3.1　Lambda管中窥豹　　
#### 3.2　在哪里以及如何使用Lambda　　
##### 3.2.1　函数式接口　　
##### 3.2.2　函数描述符　　
#### 3.3　把Lambda付诸实践：环绕执行模式　　
##### 3.3.1　第1步记得行为参数化　　
##### 3.3.2　第2步：使用函数式接口来传递行为　　
##### 3.3.3　第3步：执行一个行为　　
##### 3.3.4　第4步：传递Lambda　　
#### 3.4　使用函数式接口　　
##### 3.4.1　Predicate　　
##### 3.4.2　Consumer　　
##### 3.4.3　Function　　
#### 3.5　类型检查、类型推断以及限制　　
##### 3.5.1　类型检查　　
##### 3.5.2　同样的Lambda，不同的函数式接口　　
##### 3.5.3　类型推断　　
##### 3.5.4　使用局部变量　　
#### 3.6　方法引用　　
##### 3.6.1　管中窥豹　　
##### 3.6.2　构造函数引用　　
#### 3.7　Lambda和方法引用实战　　
##### 3.7.1　第1步：传递代码　　
##### 3.7.2　第2步：使用匿名类　　
##### 3.7.3　第3步：使用Lambda表达式　　
##### 3.7.4　第4步：使用方法引用　　
#### 3.8　复合Lambda表达式的有用方法　　
##### 3.8.1　比较器复合　　
##### 3.8.2　谓词复合　　
##### 3.8.3　函数复合　　
#### 3.9　数学中的类似思想　　
##### 3.9.1　积分　　
##### 3.9.2　与Java 8的Lambda联系起来　　
#### 3.10　小结　　
## 第二部分 函数式数据处理
### 第4章　引入流　　
#### 4.1　流是什么　　
#### 4.2　流简介　　
#### 4.3　流与集合　　
##### 4.3.1　只能遍历一次　　
##### 4.3.2　外部迭代与内部迭代　　
#### 4.4　流操作　　
##### 4.4.1　中间操作　　
##### 4.4.2　终端操作　　
##### 4.4.3　使用流　　
#### 4.5　小结　　
### 第5章　使用流　　
#### 5.1　筛选和切片　　
##### 5.1.1　用谓词筛选　　
##### 5.1.2　筛选各异的元素　　
##### 5.1.3　截短流　　
##### 5.1.4　跳过元素　　
#### 5.2　映射　　
##### 5.2.1　对流中每一个元素应用函数　　
##### 5.2.2　流的扁平化　　
#### 5.3　查找和匹配　　
##### 5.3.1　检查谓词是否至少匹配一个元素　　
##### 5.3.2　检查谓词是否匹配所有元素　　
##### 5.3.3　查找元素　　
##### 5.3.4　查找第一个元素　　
#### 5.4　归约　　
##### 5.4.1　元素求和　　
##### 5.4.2　最大值和最小值　　
#### 5.5　付诸实践　　
##### 5.5.1　领域：交易员和交易　　
##### 5.5.2　解答　　
#### 5.6　数值流　　
##### 5.6.1　原始类型流特化　　
##### 5.6.2　数值范围　　
##### 5.6.3　数值流应用：勾股数　　
#### 5.7　构建流　　
##### 5.7.1　由值创建流　　
##### 5.7.2　由数组创建流　　
##### 5.7.3　由文件生成流　　
##### 5.7.4　由函数生成流：创建无限流　　
#### 5.8　小结　　
### 第6章　用流收集数据　　
#### 6.1　收集器简介　　
##### 6.1.1　收集器用作高级归约　　
##### 6.1.2　预定义收集器　　
#### 6.2　归约和汇总　　
##### 6.2.1　查找流中的最大值和最小值　　
##### 6.2.2　汇总　　
##### 6.2.3　连接字符串　　
##### 6.2.4　广义的归约汇总　　
#### 6.3　分组　　
##### 6.3.1　多级分组　　
##### 6.3.2　按子组收集数据　　
#### 6.4　分区　　
##### 6.4.1　分区的优势　　
##### 6.4.2　将数字按质数和非质数分区　　
#### 6.5　收集器接口　　
##### 6.5.1　理解Collector接口声明的方法　　
##### 6.5.2　全部融合到一起　　
#### 6.6　开发你自己的收集器以获得更好的性能　　
##### 6.6.1　仅用质数做除数　　
##### 6.6.2　比较收集器的性能　　
#### 6.7　小结　　
### 第7章　并行数据处理与性能　　
#### 7.1　并行流　　
##### 7.1.1　将顺序流转换为并行流　　
##### 7.1.2　测量流性能　　
##### 7.1.3　正确使用并行流　　
##### 7.1.4　高效使用并行流　　
#### 7.2　分支/合并框架　　
##### 7.2.1　使用RecursiveTask　　
##### 7.2.2　使用分支/合并框架的最佳做法　　
##### 7.2.3　工作窃取　　
#### 7.3　Spliterator　　
##### 7.3.1　拆分过程　　
##### 7.3.2　实现你自己的Spliterator　　
#### 7.4　小结　　
## 第三部分 高效Java 8编程
### 第8章　重构、测试和调试　　
#### 8.1　为改善可读性和灵活性重构代码　　
##### 8.1.1　改善代码的可读性　　
##### 8.1.2　从匿名类到Lambda表达式的转换　　
##### 8.1.3　从Lambda表达式到方法引用的转换　　
##### 8.1.4　从命令式的数据处理切换到Stream　　
##### 8.1.5　增加代码的灵活性　　
#### 8.2　使用Lambda重构面向对象的设计模式　　
##### 8.2.1　策略模式　　
##### 8.2.2　模板方法　　
##### 8.2.3　观察者模式　　
##### 8.2.4　责任链模式　　
##### 8.2.5　工厂模式　　
#### 8.3　测试Lambda表达式　　
##### 8.3.1　测试可见Lambda函数的行为　　
##### 8.3.2　测试使用Lambda的方法的行为　　
##### 8.3.3　将复杂的Lambda表达式分到不同的方法　　
##### 8.3.4　高阶函数的测试　　
#### 8.4　调试　　
##### 8.4.1　查看栈跟踪　　
##### 8.4.2　使用日志调试　　
#### 8.5　小结　　
### 第9章　默认方法　　 
#### 9.1　不断演进的API　　 
##### 9.1.1　初始版本的API　　
##### 9.1.2　第二版API　　
#### 9.2　概述默认方法　　
#### 9.3　默认方法的使用模式　　
##### 9.3.1　可选方法　　
##### 9.3.2　行为的多继承　　
#### 9.4　解决冲突的规则　　
##### 9.4.1　解决问题的三条规则　　
##### 9.4.2　选择提供了最具体实现的默认方法的接口　　
##### 9.4.3　冲突及如何显式地消除歧义　　
##### 9.4.4　菱形继承问题　　
#### 9.5　小结　　
### 第10章　用Optional取代null　　
#### 10.1　如何为缺失的值建模　　 
##### 10.1.1　采用防御式检查减少Null-PointerException　　
##### 10.1.2　null带来的种种问题　　
##### 10.1.3　其他语言中null的替代品　　
#### 10.2　Optional类入门　　
#### 10.3　应用Optional的几种模式　　 
##### 10.3.1　创建Optional对象　　
##### 10.3.2　使用map从Optional对象中提取和转换值　　
##### 10.3.3　使用flatMap链接Optional对象　　
##### 10.3.4　默认行为及解引用Optional对象　　
##### 10.3.5　两个Optional对象的组合　　
##### 10.3.6　使用filter剔除特定的值　　
#### 10.4　使用Optional的实战示例　　 
##### 10.4.1　用Optional封装可能为null的值　　
##### 10.4.2　异常与Optional的对比　　
##### 10.4.3　把所有内容整合起来　　
#### 10.5　小结　　
### 第11章　CompletableFuture：组合式异步编程　　
#### 11.1　Future接口　　
##### 11.1.1　Future接口的局限性　　
##### 11.1.2　使用CompletableFuture构建异步应用　　
#### 11.2　实现异步API　　 
##### 11.2.1　将同步方法转换为异步方法　　
##### 11.2.2　错误处理　　
#### 11.3　让你的代码免受阻塞之苦　　
##### 11.3.1　使用并行流对请求进行并行操作　　
##### 11.3.2　使用CompletableFuture发起异步请求　　
##### 11.3.3　寻找更好的方案　　
##### 11.3.4　使用定制的执行器　　
#### 11.4　对多个异步任务进行流水线操作　　
##### 11.4.1　实现折扣服务　　
##### 11.4.2　使用Discount服务　　
##### 11.4.3　构造同步和异步操作　　
##### 11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　
##### 11.4.5　对Future和Completable-Future的回顾　　
#### 11.5　响应CompletableFuture的completion事件　　
##### 11.5.1　对最佳价格查询器应用的优化　　
##### 11.5.2　付诸实践　　
#### 11.6　小结　　
### 第12章　新的日期和时间API　　
#### 12.1　LocalDate、LocalTime、Instant、Duration以及Period　　
##### 12.1.1　使用LocalDate和LocalTime　　
##### 12.1.2　合并日期和时间　　
##### 12.1.3　机器的日期和时间格式　　
##### 12.1.4　定义Duration或Period　　
#### 12.2　操纵、解析和格式化日期　　
##### 12.2.1　使用TemporalAdjuster　　
##### 12.2.2　打印输出及解析日期－时间对象　　
#### 12.3　处理不同的时区和历法　　
##### 12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　
##### 12.3.2　使用别的日历系统　　
#### 12.4　小结　　
## 第四部分 超越Java 
### 第13章　函数式的思考　　
#### 13.1　实现和维护系统　　
##### 13.1.1　共享的可变数据　　
##### 13.1.2　声明式编程　　
##### 13.1.3　为什么要采用函数式编程　　
#### 13.2　什么是函数式编程　　
##### 13.2.1　函数式Java编程　　
##### 13.2.2　引用透明性　　
##### 13.2.3　面向对象的编程和函数式编程的对比　　 
##### 13.2.4　函数式编程实战　　
#### 13.3　递归和迭代　　
#### 13.4　小结　　
### 第14章　函数式编程的技巧　　
#### 14.1　无处不在的函数　　
##### 14.1.1　高阶函数　　
##### 14.1.2　科里化　　
#### 14.2　持久化数据结构　　
##### 14.2.1　破坏式更新和函数式更新的比较　　
##### 14.2.2　另一个使用Tree的例子　　
##### 14.2.3　采用函数式的方法　　
#### 14.3　Stream的延迟计算　　
##### 14.3.1　自定义的Stream　　 
##### 14.3.2　创建你自己的延迟列表　　
#### 14.4　模式匹配　　
##### 14.4.1　访问者设计模式　　
##### 14.4.2　用模式匹配力挽狂澜　　
#### 14.5　杂项　　
##### 14.5.1　缓存或记忆表　　
##### 14.5.2　“返回同样的对象”意味着什么　　
##### 14.5.3　结合器　　
#### 14.6　小结　　
### 第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　 
#### 15.1　Scala简介　　
##### 15.1.1　你好，啤酒　　
##### 15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　
#### 15.2　函数　　
##### 15.2.1　Scala中的一等函数　　
##### 15.2.2　匿名函数和闭包　　
##### 15.2.3　科里化　　
#### 15.3　类和trait　　
##### 15.3.1　更加简洁的Scala类　　
##### 15.3.2　Scala的trait与Java 8的接口对比　　
#### 15.4　小结　　
### 第16章　结论以及Java的未来　　
#### 16.1　回顾Java 8的语言特性　　 
##### 16.1.1　行为参数化（Lambda 以及方法引用）　　
##### 16.1.2　流　　
##### 16.1.3　CompletableFuture　　
##### 16.1.4　Optional　　
##### 16.1.5　默认方法　　
#### 16.2　Java 的未来　　
##### 16.2.1　集合　　
##### 16.2.2　类型系统的改进　　
##### 16.2.3　模式匹配　　
##### 16.2.4　更加丰富的泛型形式　　
##### 16.2.5　对不变性的更深层支持　　
##### 16.2.6　值类型　　
#### 16.3　写在最后的话　　
附录A　其他语言特性的更新　　
附录B　类库的更新　　
附录C　如何以并发方式在同一个流上执行多种操作　　
附录D　Lambda表达式和JVM 字节码　　
